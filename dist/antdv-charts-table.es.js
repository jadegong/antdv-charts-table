import { isVNode, Fragment, Comment, Text, defineComponent, reactive, getCurrentInstance, onMounted, onUpdated, onUnmounted, watch, inject, computed, unref, createVNode as createVNode$1, provide, Transition, Teleport, ref, TransitionGroup, render as render$1, h as h$1, nextTick, watchEffect, withDirectives, resolveDirective, onBeforeUnmount, cloneVNode, toRef, withModifiers, vShow, onBeforeMount, createTextVNode, isRef, toRefs, shallowRef, toRaw, camelize as camelize$1, renderSlot, onActivated, openBlock, createElementBlock, normalizeStyle as normalizeStyle$1, createElementVNode, toDisplayString, resolveComponent, createBlock, normalizeClass, withCtx, renderList, createCommentVNode } from "vue";
function _typeof$2(H) {
  return _typeof$2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(C) {
    return typeof C;
  } : function(C) {
    return C && typeof Symbol == "function" && C.constructor === Symbol && C !== Symbol.prototype ? "symbol" : typeof C;
  }, _typeof$2(H);
}
function _toPrimitive(H, C) {
  if (_typeof$2(H) !== "object" || H === null)
    return H;
  var G = H[Symbol.toPrimitive];
  if (G !== void 0) {
    var U = G.call(H, C || "default");
    if (_typeof$2(U) !== "object")
      return U;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (C === "string" ? String : Number)(H);
}
function _toPropertyKey(H) {
  var C = _toPrimitive(H, "string");
  return _typeof$2(C) === "symbol" ? C : String(C);
}
function _defineProperty$A(H, C, G) {
  return C = _toPropertyKey(C), C in H ? Object.defineProperty(H, C, {
    value: G,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : H[C] = G, H;
}
function ownKeys$1(H, C) {
  var G = Object.keys(H);
  if (Object.getOwnPropertySymbols) {
    var U = Object.getOwnPropertySymbols(H);
    C && (U = U.filter(function(K) {
      return Object.getOwnPropertyDescriptor(H, K).enumerable;
    })), G.push.apply(G, U);
  }
  return G;
}
function _objectSpread2$1(H) {
  for (var C = 1; C < arguments.length; C++) {
    var G = arguments[C] != null ? arguments[C] : {};
    C % 2 ? ownKeys$1(Object(G), !0).forEach(function(U) {
      _defineProperty$A(H, U, G[U]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(H, Object.getOwnPropertyDescriptors(G)) : ownKeys$1(Object(G)).forEach(function(U) {
      Object.defineProperty(H, U, Object.getOwnPropertyDescriptor(G, U));
    });
  }
  return H;
}
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(H) {
    for (var C = 1; C < arguments.length; C++) {
      var G = arguments[C];
      for (var U in G)
        Object.prototype.hasOwnProperty.call(G, U) && (H[U] = G[U]);
    }
    return H;
  }, _extends.apply(this, arguments);
}
var isFunction$2 = function(C) {
  return typeof C == "function";
}, isArray$4 = Array.isArray, isString$1 = function(C) {
  return typeof C == "string";
}, isObject$5 = function(C) {
  return C !== null && _typeof$2(C) === "object";
}, onRE = /^on[^a-z]/, isOn = function(C) {
  return onRE.test(C);
}, cacheStringFunction = function(C) {
  var G = /* @__PURE__ */ Object.create(null);
  return function(U) {
    var K = G[U];
    return K || (G[U] = C(U));
  };
}, camelizeRE = /-(\w)/g, camelize = cacheStringFunction(function(H) {
  return H.replace(camelizeRE, function(C, G) {
    return G ? G.toUpperCase() : "";
  });
}), hyphenateRE = /\B([A-Z])/g, hyphenate = cacheStringFunction(function(H) {
  return H.replace(hyphenateRE, "-$1").toLowerCase();
}), hasOwnProperty$a = Object.prototype.hasOwnProperty, hasOwn$1 = function(C, G) {
  return hasOwnProperty$a.call(C, G);
};
function resolvePropValue(H, C, G, U) {
  var K = H[G];
  if (K != null) {
    var W = hasOwn$1(K, "default");
    if (W && U === void 0) {
      var Z = K.default;
      U = K.type !== Function && isFunction$2(Z) ? Z() : Z;
    }
    K.type === Boolean && (!hasOwn$1(C, G) && !W ? U = !1 : U === "" && (U = !0));
  }
  return U;
}
function toPx(H) {
  return typeof H == "number" ? "".concat(H, "px") : H;
}
function renderHelper(H) {
  var C = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, G = arguments.length > 2 ? arguments[2] : void 0;
  return typeof H == "function" ? H(C) : H ?? G;
}
function classNames() {
  for (var H = [], C = 0; C < arguments.length; C++) {
    var G = C < 0 || arguments.length <= C ? void 0 : arguments[C];
    if (G) {
      if (isString$1(G))
        H.push(G);
      else if (isArray$4(G))
        for (var U = 0; U < G.length; U++) {
          var K = classNames(G[U]);
          K && H.push(K);
        }
      else if (isObject$5(G))
        for (var W in G)
          G[W] && H.push(W);
    }
  }
  return H.join(" ");
}
var MapShim = function() {
  if (typeof Map < "u")
    return Map;
  function H(C, G) {
    var U = -1;
    return C.some(function(K, W) {
      return K[0] === G ? (U = W, !0) : !1;
    }), U;
  }
  return function() {
    function C() {
      this.__entries__ = [];
    }
    return Object.defineProperty(C.prototype, "size", {
      /**
       * @returns {boolean}
       */
      get: function() {
        return this.__entries__.length;
      },
      enumerable: !0,
      configurable: !0
    }), C.prototype.get = function(G) {
      var U = H(this.__entries__, G), K = this.__entries__[U];
      return K && K[1];
    }, C.prototype.set = function(G, U) {
      var K = H(this.__entries__, G);
      ~K ? this.__entries__[K][1] = U : this.__entries__.push([G, U]);
    }, C.prototype.delete = function(G) {
      var U = this.__entries__, K = H(U, G);
      ~K && U.splice(K, 1);
    }, C.prototype.has = function(G) {
      return !!~H(this.__entries__, G);
    }, C.prototype.clear = function() {
      this.__entries__.splice(0);
    }, C.prototype.forEach = function(G, U) {
      U === void 0 && (U = null);
      for (var K = 0, W = this.__entries__; K < W.length; K++) {
        var Z = W[K];
        G.call(U, Z[1], Z[0]);
      }
    }, C;
  }();
}(), isBrowser = typeof window < "u" && typeof document < "u" && window.document === document, global$1 = function() {
  return typeof global < "u" && global.Math === Math ? global : typeof self < "u" && self.Math === Math ? self : typeof window < "u" && window.Math === Math ? window : Function("return this")();
}(), requestAnimationFrame$1$1 = function() {
  return typeof requestAnimationFrame == "function" ? requestAnimationFrame.bind(global$1) : function(H) {
    return setTimeout(function() {
      return H(Date.now());
    }, 1e3 / 60);
  };
}(), trailingTimeout = 2;
function throttle$1(H, C) {
  var G = !1, U = !1, K = 0;
  function W() {
    G && (G = !1, H()), U && X();
  }
  function Z() {
    requestAnimationFrame$1$1(W);
  }
  function X() {
    var Q = Date.now();
    if (G) {
      if (Q - K < trailingTimeout)
        return;
      U = !0;
    } else
      G = !0, U = !1, setTimeout(Z, C);
    K = Q;
  }
  return X;
}
var REFRESH_DELAY = 20, transitionKeys = ["top", "right", "bottom", "left", "width", "height", "size", "weight"], mutationObserverSupported = typeof MutationObserver < "u", ResizeObserverController = function() {
  function H() {
    this.connected_ = !1, this.mutationEventsAdded_ = !1, this.mutationsObserver_ = null, this.observers_ = [], this.onTransitionEnd_ = this.onTransitionEnd_.bind(this), this.refresh = throttle$1(this.refresh.bind(this), REFRESH_DELAY);
  }
  return H.prototype.addObserver = function(C) {
    ~this.observers_.indexOf(C) || this.observers_.push(C), this.connected_ || this.connect_();
  }, H.prototype.removeObserver = function(C) {
    var G = this.observers_, U = G.indexOf(C);
    ~U && G.splice(U, 1), !G.length && this.connected_ && this.disconnect_();
  }, H.prototype.refresh = function() {
    var C = this.updateObservers_();
    C && this.refresh();
  }, H.prototype.updateObservers_ = function() {
    var C = this.observers_.filter(function(G) {
      return G.gatherActive(), G.hasActive();
    });
    return C.forEach(function(G) {
      return G.broadcastActive();
    }), C.length > 0;
  }, H.prototype.connect_ = function() {
    !isBrowser || this.connected_ || (document.addEventListener("transitionend", this.onTransitionEnd_), window.addEventListener("resize", this.refresh), mutationObserverSupported ? (this.mutationsObserver_ = new MutationObserver(this.refresh), this.mutationsObserver_.observe(document, {
      attributes: !0,
      childList: !0,
      characterData: !0,
      subtree: !0
    })) : (document.addEventListener("DOMSubtreeModified", this.refresh), this.mutationEventsAdded_ = !0), this.connected_ = !0);
  }, H.prototype.disconnect_ = function() {
    !isBrowser || !this.connected_ || (document.removeEventListener("transitionend", this.onTransitionEnd_), window.removeEventListener("resize", this.refresh), this.mutationsObserver_ && this.mutationsObserver_.disconnect(), this.mutationEventsAdded_ && document.removeEventListener("DOMSubtreeModified", this.refresh), this.mutationsObserver_ = null, this.mutationEventsAdded_ = !1, this.connected_ = !1);
  }, H.prototype.onTransitionEnd_ = function(C) {
    var G = C.propertyName, U = G === void 0 ? "" : G, K = transitionKeys.some(function(W) {
      return !!~U.indexOf(W);
    });
    K && this.refresh();
  }, H.getInstance = function() {
    return this.instance_ || (this.instance_ = new H()), this.instance_;
  }, H.instance_ = null, H;
}(), defineConfigurable = function(H, C) {
  for (var G = 0, U = Object.keys(C); G < U.length; G++) {
    var K = U[G];
    Object.defineProperty(H, K, {
      value: C[K],
      enumerable: !1,
      writable: !1,
      configurable: !0
    });
  }
  return H;
}, getWindowOf = function(H) {
  var C = H && H.ownerDocument && H.ownerDocument.defaultView;
  return C || global$1;
}, emptyRect = createRectInit(0, 0, 0, 0);
function toFloat(H) {
  return parseFloat(H) || 0;
}
function getBordersSize(H) {
  for (var C = [], G = 1; G < arguments.length; G++)
    C[G - 1] = arguments[G];
  return C.reduce(function(U, K) {
    var W = H["border-" + K + "-width"];
    return U + toFloat(W);
  }, 0);
}
function getPaddings(H) {
  for (var C = ["top", "right", "bottom", "left"], G = {}, U = 0, K = C; U < K.length; U++) {
    var W = K[U], Z = H["padding-" + W];
    G[W] = toFloat(Z);
  }
  return G;
}
function getSVGContentRect(H) {
  var C = H.getBBox();
  return createRectInit(0, 0, C.width, C.height);
}
function getHTMLElementContentRect(H) {
  var C = H.clientWidth, G = H.clientHeight;
  if (!C && !G)
    return emptyRect;
  var U = getWindowOf(H).getComputedStyle(H), K = getPaddings(U), W = K.left + K.right, Z = K.top + K.bottom, X = toFloat(U.width), Q = toFloat(U.height);
  if (U.boxSizing === "border-box" && (Math.round(X + W) !== C && (X -= getBordersSize(U, "left", "right") + W), Math.round(Q + Z) !== G && (Q -= getBordersSize(U, "top", "bottom") + Z)), !isDocumentElement(H)) {
    var ee = Math.round(X + W) - C, te = Math.round(Q + Z) - G;
    Math.abs(ee) !== 1 && (X -= ee), Math.abs(te) !== 1 && (Q -= te);
  }
  return createRectInit(K.left, K.top, X, Q);
}
var isSVGGraphicsElement = function() {
  return typeof SVGGraphicsElement < "u" ? function(H) {
    return H instanceof getWindowOf(H).SVGGraphicsElement;
  } : function(H) {
    return H instanceof getWindowOf(H).SVGElement && typeof H.getBBox == "function";
  };
}();
function isDocumentElement(H) {
  return H === getWindowOf(H).document.documentElement;
}
function getContentRect(H) {
  return isBrowser ? isSVGGraphicsElement(H) ? getSVGContentRect(H) : getHTMLElementContentRect(H) : emptyRect;
}
function createReadOnlyRect(H) {
  var C = H.x, G = H.y, U = H.width, K = H.height, W = typeof DOMRectReadOnly < "u" ? DOMRectReadOnly : Object, Z = Object.create(W.prototype);
  return defineConfigurable(Z, {
    x: C,
    y: G,
    width: U,
    height: K,
    top: G,
    right: C + U,
    bottom: K + G,
    left: C
  }), Z;
}
function createRectInit(H, C, G, U) {
  return { x: H, y: C, width: G, height: U };
}
var ResizeObservation = function() {
  function H(C) {
    this.broadcastWidth = 0, this.broadcastHeight = 0, this.contentRect_ = createRectInit(0, 0, 0, 0), this.target = C;
  }
  return H.prototype.isActive = function() {
    var C = getContentRect(this.target);
    return this.contentRect_ = C, C.width !== this.broadcastWidth || C.height !== this.broadcastHeight;
  }, H.prototype.broadcastRect = function() {
    var C = this.contentRect_;
    return this.broadcastWidth = C.width, this.broadcastHeight = C.height, C;
  }, H;
}(), ResizeObserverEntry = function() {
  function H(C, G) {
    var U = createReadOnlyRect(G);
    defineConfigurable(this, { target: C, contentRect: U });
  }
  return H;
}(), ResizeObserverSPI = function() {
  function H(C, G, U) {
    if (this.activeObservations_ = [], this.observations_ = new MapShim(), typeof C != "function")
      throw new TypeError("The callback provided as parameter 1 is not a function.");
    this.callback_ = C, this.controller_ = G, this.callbackCtx_ = U;
  }
  return H.prototype.observe = function(C) {
    if (!arguments.length)
      throw new TypeError("1 argument required, but only 0 present.");
    if (!(typeof Element > "u" || !(Element instanceof Object))) {
      if (!(C instanceof getWindowOf(C).Element))
        throw new TypeError('parameter 1 is not of type "Element".');
      var G = this.observations_;
      G.has(C) || (G.set(C, new ResizeObservation(C)), this.controller_.addObserver(this), this.controller_.refresh());
    }
  }, H.prototype.unobserve = function(C) {
    if (!arguments.length)
      throw new TypeError("1 argument required, but only 0 present.");
    if (!(typeof Element > "u" || !(Element instanceof Object))) {
      if (!(C instanceof getWindowOf(C).Element))
        throw new TypeError('parameter 1 is not of type "Element".');
      var G = this.observations_;
      G.has(C) && (G.delete(C), G.size || this.controller_.removeObserver(this));
    }
  }, H.prototype.disconnect = function() {
    this.clearActive(), this.observations_.clear(), this.controller_.removeObserver(this);
  }, H.prototype.gatherActive = function() {
    var C = this;
    this.clearActive(), this.observations_.forEach(function(G) {
      G.isActive() && C.activeObservations_.push(G);
    });
  }, H.prototype.broadcastActive = function() {
    if (this.hasActive()) {
      var C = this.callbackCtx_, G = this.activeObservations_.map(function(U) {
        return new ResizeObserverEntry(U.target, U.broadcastRect());
      });
      this.callback_.call(C, G, C), this.clearActive();
    }
  }, H.prototype.clearActive = function() {
    this.activeObservations_.splice(0);
  }, H.prototype.hasActive = function() {
    return this.activeObservations_.length > 0;
  }, H;
}(), observers = typeof WeakMap < "u" ? /* @__PURE__ */ new WeakMap() : new MapShim(), ResizeObserver$1 = function() {
  function H(C) {
    if (!(this instanceof H))
      throw new TypeError("Cannot call a class as a function.");
    if (!arguments.length)
      throw new TypeError("1 argument required, but only 0 present.");
    var G = ResizeObserverController.getInstance(), U = new ResizeObserverSPI(C, G, this);
    observers.set(this, U);
  }
  return H;
}();
[
  "observe",
  "unobserve",
  "disconnect"
].forEach(function(H) {
  ResizeObserver$1.prototype[H] = function() {
    var C;
    return (C = observers.get(this))[H].apply(C, arguments);
  };
});
var index$3 = function() {
  return typeof global$1.ResizeObserver < "u" ? global$1.ResizeObserver : ResizeObserver$1;
}();
function _arrayWithHoles$2(H) {
  if (Array.isArray(H))
    return H;
}
function _iterableToArrayLimit$2(H, C) {
  var G = H == null ? null : typeof Symbol < "u" && H[Symbol.iterator] || H["@@iterator"];
  if (G != null) {
    var U, K, W, Z, X = [], Q = !0, ee = !1;
    try {
      if (W = (G = G.call(H)).next, C === 0) {
        if (Object(G) !== G)
          return;
        Q = !1;
      } else
        for (; !(Q = (U = W.call(G)).done) && (X.push(U.value), X.length !== C); Q = !0)
          ;
    } catch (te) {
      ee = !0, K = te;
    } finally {
      try {
        if (!Q && G.return != null && (Z = G.return(), Object(Z) !== Z))
          return;
      } finally {
        if (ee)
          throw K;
      }
    }
    return X;
  }
}
function _arrayLikeToArray$2(H, C) {
  (C == null || C > H.length) && (C = H.length);
  for (var G = 0, U = new Array(C); G < C; G++)
    U[G] = H[G];
  return U;
}
function _unsupportedIterableToArray$2(H, C) {
  if (H) {
    if (typeof H == "string")
      return _arrayLikeToArray$2(H, C);
    var G = Object.prototype.toString.call(H).slice(8, -1);
    if (G === "Object" && H.constructor && (G = H.constructor.name), G === "Map" || G === "Set")
      return Array.from(H);
    if (G === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(G))
      return _arrayLikeToArray$2(H, C);
  }
}
function _nonIterableRest$2() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function _slicedToArray$2(H, C) {
  return _arrayWithHoles$2(H) || _iterableToArrayLimit$2(H, C) || _unsupportedIterableToArray$2(H, C) || _nonIterableRest$2();
}
function _arrayWithoutHoles(H) {
  if (Array.isArray(H))
    return _arrayLikeToArray$2(H);
}
function _iterableToArray(H) {
  if (typeof Symbol < "u" && H[Symbol.iterator] != null || H["@@iterator"] != null)
    return Array.from(H);
}
function _nonIterableSpread() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function _toConsumableArray(H) {
  return _arrayWithoutHoles(H) || _iterableToArray(H) || _unsupportedIterableToArray$2(H) || _nonIterableSpread();
}
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
const freeGlobal$1 = freeGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self, root = freeGlobal$1 || freeSelf || Function("return this")();
const root$1 = root;
var Symbol$2 = root$1.Symbol;
const Symbol$3 = Symbol$2;
var objectProto$c = Object.prototype, hasOwnProperty$9 = objectProto$c.hasOwnProperty, nativeObjectToString$1 = objectProto$c.toString, symToStringTag$1 = Symbol$3 ? Symbol$3.toStringTag : void 0;
function getRawTag(H) {
  var C = hasOwnProperty$9.call(H, symToStringTag$1), G = H[symToStringTag$1];
  try {
    H[symToStringTag$1] = void 0;
    var U = !0;
  } catch {
  }
  var K = nativeObjectToString$1.call(H);
  return U && (C ? H[symToStringTag$1] = G : delete H[symToStringTag$1]), K;
}
var objectProto$b = Object.prototype, nativeObjectToString = objectProto$b.toString;
function objectToString(H) {
  return nativeObjectToString.call(H);
}
var nullTag = "[object Null]", undefinedTag = "[object Undefined]", symToStringTag = Symbol$3 ? Symbol$3.toStringTag : void 0;
function baseGetTag(H) {
  return H == null ? H === void 0 ? undefinedTag : nullTag : symToStringTag && symToStringTag in Object(H) ? getRawTag(H) : objectToString(H);
}
function overArg(H, C) {
  return function(G) {
    return H(C(G));
  };
}
var getPrototype = overArg(Object.getPrototypeOf, Object);
const getPrototype$1 = getPrototype;
function isObjectLike(H) {
  return H != null && typeof H == "object";
}
var objectTag$3 = "[object Object]", funcProto$2 = Function.prototype, objectProto$a = Object.prototype, funcToString$2 = funcProto$2.toString, hasOwnProperty$8 = objectProto$a.hasOwnProperty, objectCtorString = funcToString$2.call(Object);
function isPlainObject(H) {
  if (!isObjectLike(H) || baseGetTag(H) != objectTag$3)
    return !1;
  var C = getPrototype$1(H);
  if (C === null)
    return !0;
  var G = hasOwnProperty$8.call(C, "constructor") && C.constructor;
  return typeof G == "function" && G instanceof G && funcToString$2.call(G) == objectCtorString;
}
var isValid$1 = function(C) {
  return C != null && C !== "";
};
const isValid$2 = isValid$1;
var initDefaultProps = function(C, G) {
  var U = _objectSpread2$1({}, C);
  return Object.keys(G).forEach(function(K) {
    var W = U[K];
    if (W)
      W.type || W.default ? W.default = G[K] : W.def ? W.def(G[K]) : U[K] = {
        type: W,
        default: G[K]
      };
    else
      throw new Error("not have ".concat(K, " prop"));
  }), U;
};
const initDefaultProps$1 = initDefaultProps;
var splitAttrs = function(C) {
  for (var G = Object.keys(C), U = {}, K = {}, W = {}, Z = 0, X = G.length; Z < X; Z++) {
    var Q = G[Z];
    isOn(Q) ? (U[Q[2].toLowerCase() + Q.slice(3)] = C[Q], K[Q] = C[Q]) : W[Q] = C[Q];
  }
  return {
    onEvents: K,
    events: U,
    extraAttrs: W
  };
}, parseStyleText = function() {
  var C = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "", G = arguments.length > 1 ? arguments[1] : void 0, U = {}, K = /;(?![^(]*\))/g, W = /:(.+)/;
  return _typeof$2(C) === "object" ? C : (C.split(K).forEach(function(Z) {
    if (Z) {
      var X = Z.split(W);
      if (X.length > 1) {
        var Q = G ? camelize(X[0].trim()) : X[0].trim();
        U[Q] = X[1].trim();
      }
    }
  }), U);
}, hasProp = function(C, G) {
  return C[G] !== void 0;
}, flattenChildren = function H() {
  var C = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], G = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0, U = Array.isArray(C) ? C : [C], K = [];
  return U.forEach(function(W) {
    Array.isArray(W) ? K.push.apply(K, _toConsumableArray(H(W, G))) : W && W.type === Fragment ? K.push.apply(K, _toConsumableArray(H(W.children, G))) : W && isVNode(W) ? G && !isEmptyElement(W) ? K.push(W) : G || K.push(W) : isValid$2(W) && K.push(W);
  }), K;
}, getSlot = function(C) {
  var G = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "default", U = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  if (isVNode(C))
    return C.type === Fragment ? G === "default" ? flattenChildren(C.children) : [] : C.children && C.children[G] ? flattenChildren(C.children[G](U)) : [];
  var K = C.$slots[G] && C.$slots[G](U);
  return flattenChildren(K);
}, findDOMNode = function(C) {
  for (var G, U = (C == null || (G = C.vnode) === null || G === void 0 ? void 0 : G.el) || C && (C.$el || C); U && !U.tagName; )
    U = U.nextSibling;
  return U;
}, getOptionProps = function(C) {
  var G = {};
  if (C.$ && C.$.vnode) {
    var U = C.$.vnode.props || {};
    Object.keys(C.$props).forEach(function(X) {
      var Q = C.$props[X], ee = hyphenate(X);
      (Q !== void 0 || ee in U) && (G[X] = Q);
    });
  } else if (isVNode(C) && _typeof$2(C.type) === "object") {
    var K = C.props || {}, W = {};
    Object.keys(K).forEach(function(X) {
      W[camelize(X)] = K[X];
    });
    var Z = C.type.props || {};
    Object.keys(Z).forEach(function(X) {
      var Q = resolvePropValue(Z, W, X, W[X]);
      (Q !== void 0 || X in W) && (G[X] = Q);
    });
  }
  return G;
}, getComponent = function(C) {
  var G = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "default", U = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : C, K = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !0, W = void 0;
  if (C.$) {
    var Z = C[G];
    if (Z !== void 0)
      return typeof Z == "function" && K ? Z(U) : Z;
    W = C.$slots[G], W = K && W ? W(U) : W;
  } else if (isVNode(C)) {
    var X = C.props && C.props[G];
    if (X !== void 0 && C.props !== null)
      return typeof X == "function" && K ? X(U) : X;
    C.type === Fragment ? W = C.children : C.children && C.children[G] && (W = C.children[G], W = K && W ? W(U) : W);
  }
  return Array.isArray(W) && (W = flattenChildren(W), W = W.length === 1 ? W[0] : W, W = W.length === 0 ? void 0 : W), W;
};
function getEvents() {
  var H = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, C = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0, G = {};
  return H.$ ? G = _objectSpread2$1(_objectSpread2$1({}, G), H.$attrs) : G = _objectSpread2$1(_objectSpread2$1({}, G), H.props), splitAttrs(G)[C ? "onEvents" : "events"];
}
function getStyle$1(H, C) {
  var G = (isVNode(H) ? H.props : H.$attrs) || {}, U = G.style || {};
  if (typeof U == "string")
    U = parseStyleText(U, C);
  else if (C && U) {
    var K = {};
    return Object.keys(U).forEach(function(W) {
      return K[camelize(W)] = U[W];
    }), K;
  }
  return U;
}
function isEmptyElement(H) {
  return H && (H.type === Comment || H.type === Fragment && H.children.length === 0 || H.type === Text && H.children.trim() === "");
}
function filterEmpty() {
  var H = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], C = [];
  return H.forEach(function(G) {
    Array.isArray(G) ? C.push.apply(C, _toConsumableArray(G)) : (G == null ? void 0 : G.type) === Fragment ? C.push.apply(C, _toConsumableArray(filterEmpty(G.children))) : C.push(G);
  }), C.filter(function(G) {
    return !isEmptyElement(G);
  });
}
function isValidElement(H) {
  return Array.isArray(H) && H.length === 1 && (H = H[0]), H && H.__v_isVNode && _typeof$2(H.type) !== "symbol";
}
function getPropsSlot(H, C) {
  var G, U, K = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "default";
  return (G = C[K]) !== null && G !== void 0 ? G : (U = H[K]) === null || U === void 0 ? void 0 : U.call(H);
}
const ResizeObserver = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ResizeObserver",
  props: {
    disabled: Boolean,
    onResize: Function
  },
  emits: ["resize"],
  setup: function(C, G) {
    var U = G.slots, K = reactive({
      width: 0,
      height: 0,
      offsetHeight: 0,
      offsetWidth: 0
    }), W = null, Z = null, X = function() {
      Z && (Z.disconnect(), Z = null);
    }, Q = function(ne) {
      var ae = C.onResize, ie = ne[0].target, se = ie.getBoundingClientRect(), oe = se.width, le = se.height, ue = ie.offsetWidth, ce = ie.offsetHeight, de = Math.floor(oe), ge = Math.floor(le);
      if (K.width !== de || K.height !== ge || K.offsetWidth !== ue || K.offsetHeight !== ce) {
        var fe = {
          width: de,
          height: ge,
          offsetWidth: ue,
          offsetHeight: ce
        };
        _extends(K, fe), ae && Promise.resolve().then(function() {
          ae(_objectSpread2$1(_objectSpread2$1({}, fe), {}, {
            offsetWidth: ue,
            offsetHeight: ce
          }), ie);
        });
      }
    }, ee = getCurrentInstance(), te = function() {
      var ne = C.disabled;
      if (ne) {
        X();
        return;
      }
      var ae = findDOMNode(ee), ie = ae !== W;
      ie && (X(), W = ae), !Z && ae && (Z = new index$3(Q), Z.observe(ae));
    };
    return onMounted(function() {
      te();
    }), onUpdated(function() {
      te();
    }), onUnmounted(function() {
      X();
    }), watch(function() {
      return C.disabled;
    }, function() {
      te();
    }, {
      flush: "post"
    }), function() {
      var re;
      return (re = U.default) === null || re === void 0 ? void 0 : re.call(U)[0];
    };
  }
});
var raf$1 = function(C) {
  return setTimeout(C, 16);
}, caf = function(C) {
  return clearTimeout(C);
};
typeof window < "u" && "requestAnimationFrame" in window && (raf$1 = function(C) {
  return window.requestAnimationFrame(C);
}, caf = function(C) {
  return window.cancelAnimationFrame(C);
});
var rafUUID = 0, rafIds = /* @__PURE__ */ new Map();
function cleanup(H) {
  rafIds.delete(H);
}
function wrapperRaf(H) {
  var C = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
  rafUUID += 1;
  var G = rafUUID;
  function U(K) {
    if (K === 0)
      cleanup(G), H();
    else {
      var W = raf$1(function() {
        U(K - 1);
      });
      rafIds.set(G, W);
    }
  }
  return U(C), G;
}
wrapperRaf.cancel = function(H) {
  var C = rafIds.get(H);
  return cleanup(C), caf(C);
};
var tuple = function() {
  for (var C = arguments.length, G = new Array(C), U = 0; U < C; U++)
    G[U] = arguments[U];
  return G;
}, withInstall = function(C) {
  var G = C;
  return G.install = function(U) {
    U.component(G.displayName || G.name, C);
  }, C;
}, supportsPassive = !1;
try {
  var opts = Object.defineProperty({}, "passive", {
    get: function() {
      supportsPassive = !0;
    }
  });
  window.addEventListener("testPassive", null, opts), window.removeEventListener("testPassive", null, opts);
} catch {
}
const supportsPassive$1 = supportsPassive;
function addEventListenerWrap(H, C, G, U) {
  if (H && H.addEventListener) {
    var K = U;
    K === void 0 && supportsPassive$1 && (C === "touchstart" || C === "touchmove" || C === "wheel") && (K = {
      passive: !1
    }), H.addEventListener(C, G, K);
  }
  return {
    remove: function() {
      H && H.removeEventListener && H.removeEventListener(C, G);
    }
  };
}
function _objectWithoutPropertiesLoose$2(H, C) {
  if (H == null)
    return {};
  var G = {}, U = Object.keys(H), K, W;
  for (W = 0; W < U.length; W++)
    K = U[W], !(C.indexOf(K) >= 0) && (G[K] = H[K]);
  return G;
}
function _objectWithoutProperties$2(H, C) {
  if (H == null)
    return {};
  var G = _objectWithoutPropertiesLoose$2(H, C), U, K;
  if (Object.getOwnPropertySymbols) {
    var W = Object.getOwnPropertySymbols(H);
    for (K = 0; K < W.length; K++)
      U = W[K], !(C.indexOf(U) >= 0) && Object.prototype.propertyIsEnumerable.call(H, U) && (G[U] = H[U]);
  }
  return G;
}
const enUS$1 = {
  // Options.jsx
  items_per_page: "/ page",
  jump_to: "Go to",
  jump_to_confirm: "confirm",
  page: "",
  // Pagination.jsx
  prev_page: "Previous Page",
  next_page: "Next Page",
  prev_5: "Previous 5 Pages",
  next_5: "Next 5 Pages",
  prev_3: "Previous 3 Pages",
  next_3: "Next 3 Pages"
};
var locale$2 = {
  locale: "en_US",
  today: "Today",
  now: "Now",
  backToToday: "Back to today",
  ok: "Ok",
  clear: "Clear",
  month: "Month",
  year: "Year",
  timeSelect: "select time",
  dateSelect: "select date",
  weekSelect: "Choose a week",
  monthSelect: "Choose a month",
  yearSelect: "Choose a year",
  decadeSelect: "Choose a decade",
  yearFormat: "YYYY",
  dateFormat: "M/D/YYYY",
  dayFormat: "D",
  dateTimeFormat: "M/D/YYYY HH:mm:ss",
  monthBeforeYear: !0,
  previousMonth: "Previous month (PageUp)",
  nextMonth: "Next month (PageDown)",
  previousYear: "Last year (Control + left)",
  nextYear: "Next year (Control + right)",
  previousDecade: "Last decade",
  nextDecade: "Next decade",
  previousCentury: "Last century",
  nextCentury: "Next century"
};
const CalendarLocale = locale$2;
var locale$1 = {
  placeholder: "Select time",
  rangePlaceholder: ["Start time", "End time"]
};
const TimePicker = locale$1;
var locale = {
  lang: _objectSpread2$1({
    placeholder: "Select date",
    yearPlaceholder: "Select year",
    quarterPlaceholder: "Select quarter",
    monthPlaceholder: "Select month",
    weekPlaceholder: "Select week",
    rangePlaceholder: ["Start date", "End date"],
    rangeYearPlaceholder: ["Start year", "End year"],
    rangeQuarterPlaceholder: ["Start quarter", "End quarter"],
    rangeMonthPlaceholder: ["Start month", "End month"],
    rangeWeekPlaceholder: ["Start week", "End week"]
  }, CalendarLocale),
  timePickerLocale: _objectSpread2$1({}, TimePicker)
};
const enUS = locale;
var typeTemplate = "${label} is not a valid ${type}", localeValues = {
  locale: "en",
  Pagination: enUS$1,
  DatePicker: enUS,
  TimePicker,
  Calendar: enUS,
  global: {
    placeholder: "Please select"
  },
  Table: {
    filterTitle: "Filter menu",
    filterConfirm: "OK",
    filterReset: "Reset",
    filterEmptyText: "No filters",
    filterCheckall: "Select all items",
    filterSearchPlaceholder: "Search in filters",
    emptyText: "No data",
    selectAll: "Select current page",
    selectInvert: "Invert current page",
    selectNone: "Clear all data",
    selectionAll: "Select all data",
    sortTitle: "Sort",
    expand: "Expand row",
    collapse: "Collapse row",
    triggerDesc: "Click to sort descending",
    triggerAsc: "Click to sort ascending",
    cancelSort: "Click to cancel sorting"
  },
  Modal: {
    okText: "OK",
    cancelText: "Cancel",
    justOkText: "OK"
  },
  Popconfirm: {
    okText: "OK",
    cancelText: "Cancel"
  },
  Transfer: {
    titles: ["", ""],
    searchPlaceholder: "Search here",
    itemUnit: "item",
    itemsUnit: "items",
    remove: "Remove",
    selectCurrent: "Select current page",
    removeCurrent: "Remove current page",
    selectAll: "Select all data",
    removeAll: "Remove all data",
    selectInvert: "Invert current page"
  },
  Upload: {
    uploading: "Uploading...",
    removeFile: "Remove file",
    uploadError: "Upload error",
    previewFile: "Preview file",
    downloadFile: "Download file"
  },
  Empty: {
    description: "No Data"
  },
  Icon: {
    icon: "icon"
  },
  Text: {
    edit: "Edit",
    copy: "Copy",
    copied: "Copied",
    expand: "Expand"
  },
  PageHeader: {
    back: "Back"
  },
  Form: {
    optional: "(optional)",
    defaultValidateMessages: {
      default: "Field validation error for ${label}",
      required: "Please enter ${label}",
      enum: "${label} must be one of [${enum}]",
      whitespace: "${label} cannot be a blank character",
      date: {
        format: "${label} date format is invalid",
        parse: "${label} cannot be converted to a date",
        invalid: "${label} is an invalid date"
      },
      types: {
        string: typeTemplate,
        method: typeTemplate,
        array: typeTemplate,
        object: typeTemplate,
        number: typeTemplate,
        date: typeTemplate,
        boolean: typeTemplate,
        integer: typeTemplate,
        float: typeTemplate,
        regexp: typeTemplate,
        email: typeTemplate,
        url: typeTemplate,
        hex: typeTemplate
      },
      string: {
        len: "${label} must be ${len} characters",
        min: "${label} must be at least ${min} characters",
        max: "${label} must be up to ${max} characters",
        range: "${label} must be between ${min}-${max} characters"
      },
      number: {
        len: "${label} must be equal to ${len}",
        min: "${label} must be minimum ${min}",
        max: "${label} must be maximum ${max}",
        range: "${label} must be between ${min}-${max}"
      },
      array: {
        len: "Must be ${len} ${label}",
        min: "At least ${min} ${label}",
        max: "At most ${max} ${label}",
        range: "The amount of ${label} must be between ${min}-${max}"
      },
      pattern: {
        mismatch: "${label} does not match the pattern ${pattern}"
      }
    }
  },
  Image: {
    preview: "Preview"
  }
};
const defaultLocale = localeValues, LocaleReceiver = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "LocaleReceiver",
  props: {
    componentName: String,
    defaultLocale: {
      type: [Object, Function]
    },
    children: {
      type: Function
    }
  },
  setup: function(C, G) {
    var U = G.slots, K = inject("localeData", {}), W = computed(function() {
      var X = C.componentName, Q = X === void 0 ? "global" : X, ee = C.defaultLocale, te = ee || defaultLocale[Q || "global"], re = K.antLocale, ne = Q && re ? re[Q] : {};
      return _objectSpread2$1(_objectSpread2$1({}, typeof te == "function" ? te() : te), ne || {});
    }), Z = computed(function() {
      var X = K.antLocale, Q = X && X.locale;
      return X && X.exist && !Q ? defaultLocale.locale : Q;
    });
    return function() {
      var X = C.children || U.default, Q = K.antLocale;
      return X == null ? void 0 : X(W.value, Z.value, Q);
    };
  }
});
function useLocaleReceiver(H, C, G) {
  var U = inject("localeData", {}), K = computed(function() {
    var W = U.antLocale, Z = unref(C) || defaultLocale[H || "global"], X = H && W ? W[H] : {};
    return _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, typeof Z == "function" ? Z() : Z), X || {}), unref(G) || {});
  });
  return [K];
}
var Empty$2 = function() {
  var C = useConfigInject("empty", {}), G = C.getPrefixCls, U = G("empty-img-default");
  return createVNode$1("svg", {
    class: U,
    width: "184",
    height: "152",
    viewBox: "0 0 184 152"
  }, [createVNode$1("g", {
    fill: "none",
    "fill-rule": "evenodd"
  }, [createVNode$1("g", {
    transform: "translate(24 31.67)"
  }, [createVNode$1("ellipse", {
    class: "".concat(U, "-ellipse"),
    cx: "67.797",
    cy: "106.89",
    rx: "67.797",
    ry: "12.668"
  }, null), createVNode$1("path", {
    class: "".concat(U, "-path-1"),
    d: "M122.034 69.674L98.109 40.229c-1.148-1.386-2.826-2.225-4.593-2.225h-51.44c-1.766 0-3.444.839-4.592 2.225L13.56 69.674v15.383h108.475V69.674z"
  }, null), createVNode$1("path", {
    class: "".concat(U, "-path-2"),
    d: "M101.537 86.214L80.63 61.102c-1.001-1.207-2.507-1.867-4.048-1.867H31.724c-1.54 0-3.047.66-4.048 1.867L6.769 86.214v13.792h94.768V86.214z",
    transform: "translate(13.56)"
  }, null), createVNode$1("path", {
    class: "".concat(U, "-path-3"),
    d: "M33.83 0h67.933a4 4 0 0 1 4 4v93.344a4 4 0 0 1-4 4H33.83a4 4 0 0 1-4-4V4a4 4 0 0 1 4-4z"
  }, null), createVNode$1("path", {
    class: "".concat(U, "-path-4"),
    d: "M42.678 9.953h50.237a2 2 0 0 1 2 2V36.91a2 2 0 0 1-2 2H42.678a2 2 0 0 1-2-2V11.953a2 2 0 0 1 2-2zM42.94 49.767h49.713a2.262 2.262 0 1 1 0 4.524H42.94a2.262 2.262 0 0 1 0-4.524zM42.94 61.53h49.713a2.262 2.262 0 1 1 0 4.525H42.94a2.262 2.262 0 0 1 0-4.525zM121.813 105.032c-.775 3.071-3.497 5.36-6.735 5.36H20.515c-3.238 0-5.96-2.29-6.734-5.36a7.309 7.309 0 0 1-.222-1.79V69.675h26.318c2.907 0 5.25 2.448 5.25 5.42v.04c0 2.971 2.37 5.37 5.277 5.37h34.785c2.907 0 5.277-2.421 5.277-5.393V75.1c0-2.972 2.343-5.426 5.25-5.426h26.318v33.569c0 .617-.077 1.216-.221 1.789z"
  }, null)]), createVNode$1("path", {
    class: "".concat(U, "-path-5"),
    d: "M149.121 33.292l-6.83 2.65a1 1 0 0 1-1.317-1.23l1.937-6.207c-2.589-2.944-4.109-6.534-4.109-10.408C138.802 8.102 148.92 0 161.402 0 173.881 0 184 8.102 184 18.097c0 9.995-10.118 18.097-22.599 18.097-4.528 0-8.744-1.066-12.28-2.902z"
  }, null), createVNode$1("g", {
    class: "".concat(U, "-g"),
    transform: "translate(149.65 15.383)"
  }, [createVNode$1("ellipse", {
    cx: "20.654",
    cy: "3.167",
    rx: "2.849",
    ry: "2.815"
  }, null), createVNode$1("path", {
    d: "M5.698 5.63H0L2.898.704zM9.259.704h4.985V5.63H9.259z"
  }, null)])])]);
};
Empty$2.PRESENTED_IMAGE_DEFAULT = !0;
const DefaultEmptyImg = Empty$2;
var Simple = function() {
  var C = useConfigInject("empty", {}), G = C.getPrefixCls, U = G("empty-img-simple");
  return createVNode$1("svg", {
    class: U,
    width: "64",
    height: "41",
    viewBox: "0 0 64 41"
  }, [createVNode$1("g", {
    transform: "translate(0 1)",
    fill: "none",
    "fill-rule": "evenodd"
  }, [createVNode$1("ellipse", {
    class: "".concat(U, "-ellipse"),
    fill: "#F5F5F5",
    cx: "32",
    cy: "33",
    rx: "32",
    ry: "7"
  }, null), createVNode$1("g", {
    class: "".concat(U, "-g"),
    "fill-rule": "nonzero",
    stroke: "#D9D9D9"
  }, [createVNode$1("path", {
    d: "M55 12.76L44.854 1.258C44.367.474 43.656 0 42.907 0H21.093c-.749 0-1.46.474-1.947 1.257L9 12.761V22h46v-9.24z"
  }, null), createVNode$1("path", {
    d: "M41.613 15.931c0-1.605.994-2.93 2.227-2.931H55v18.137C55 33.26 53.68 35 52.05 35h-40.1C10.32 35 9 33.259 9 31.137V13h11.16c1.233 0 2.227 1.323 2.227 2.928v.022c0 1.605 1.005 2.901 2.237 2.901h14.752c1.232 0 2.237-1.308 2.237-2.913v-.007z",
    fill: "#FAFAFA",
    class: "".concat(U, "-path")
  }, null)])])]);
};
Simple.PRESENTED_IMAGE_SIMPLE = !0;
const SimpleEmptyImg = Simple;
function e$1(H, C) {
  for (var G = 0; G < C.length; G++) {
    var U = C[G];
    U.enumerable = U.enumerable || !1, U.configurable = !0, "value" in U && (U.writable = !0), Object.defineProperty(H, U.key, U);
  }
}
function t(H, C, G) {
  return C && e$1(H.prototype, C), G && e$1(H, G), H;
}
function n() {
  return (n = Object.assign || function(H) {
    for (var C = 1; C < arguments.length; C++) {
      var G = arguments[C];
      for (var U in G)
        Object.prototype.hasOwnProperty.call(G, U) && (H[U] = G[U]);
    }
    return H;
  }).apply(this, arguments);
}
function r(H, C) {
  H.prototype = Object.create(C.prototype), H.prototype.constructor = H, H.__proto__ = C;
}
function i$1(H, C) {
  if (H == null)
    return {};
  var G, U, K = {}, W = Object.keys(H);
  for (U = 0; U < W.length; U++)
    C.indexOf(G = W[U]) >= 0 || (K[G] = H[G]);
  return K;
}
function o(H) {
  return ((C = H) != null && typeof C == "object" && Array.isArray(C) === !1) == 1 && Object.prototype.toString.call(H) === "[object Object]";
  var C;
}
var u = Object.prototype, a = u.toString, f = u.hasOwnProperty, c = /^\s*function (\w+)/;
function l(H) {
  var C, G = (C = H == null ? void 0 : H.type) !== null && C !== void 0 ? C : H;
  if (G) {
    var U = G.toString().match(c);
    return U ? U[1] : "";
  }
  return "";
}
var s = function(H) {
  var C, G;
  return o(H) !== !1 && typeof (C = H.constructor) == "function" && o(G = C.prototype) !== !1 && G.hasOwnProperty("isPrototypeOf") !== !1;
}, v = function(H) {
  return H;
}, y = v;
if (process.env.NODE_ENV !== "production") {
  var p = typeof console < "u";
  y = p ? function(H) {
    console.warn("[VueTypes warn]: " + H);
  } : v;
}
var d = function(H, C) {
  return f.call(H, C);
}, h = Number.isInteger || function(H) {
  return typeof H == "number" && isFinite(H) && Math.floor(H) === H;
}, b = Array.isArray || function(H) {
  return a.call(H) === "[object Array]";
}, O = function(H) {
  return a.call(H) === "[object Function]";
}, g = function(H) {
  return s(H) && d(H, "_vueTypes_name");
}, m$1 = function(H) {
  return s(H) && (d(H, "type") || ["_vueTypes_name", "validator", "default", "required"].some(function(C) {
    return d(H, C);
  }));
};
function j(H, C) {
  return Object.defineProperty(H.bind(C), "__original", { value: H });
}
function _(H, C, G) {
  var U;
  G === void 0 && (G = !1);
  var K = !0, W = "";
  U = s(H) ? H : { type: H };
  var Z = g(U) ? U._vueTypes_name + " - " : "";
  if (m$1(U) && U.type !== null) {
    if (U.type === void 0 || U.type === !0 || !U.required && C === void 0)
      return K;
    b(U.type) ? (K = U.type.some(function(re) {
      return _(re, C, !0) === !0;
    }), W = U.type.map(function(re) {
      return l(re);
    }).join(" or ")) : K = (W = l(U)) === "Array" ? b(C) : W === "Object" ? s(C) : W === "String" || W === "Number" || W === "Boolean" || W === "Function" ? function(re) {
      if (re == null)
        return "";
      var ne = re.constructor.toString().match(c);
      return ne ? ne[1] : "";
    }(C) === W : C instanceof U.type;
  }
  if (!K) {
    var X = Z + 'value "' + C + '" should be of type "' + W + '"';
    return G === !1 ? (y(X), !1) : X;
  }
  if (d(U, "validator") && O(U.validator)) {
    var Q = y, ee = [];
    if (y = function(re) {
      ee.push(re);
    }, K = U.validator(C), y = Q, !K) {
      var te = (ee.length > 1 ? "* " : "") + ee.join(`
* `);
      return ee.length = 0, G === !1 ? (y(te), K) : te;
    }
  }
  return K;
}
function T(H, C) {
  var G = Object.defineProperties(C, { _vueTypes_name: { value: H, writable: !0 }, isRequired: { get: function() {
    return this.required = !0, this;
  } }, def: { value: function(K) {
    return K !== void 0 || this.default ? O(K) || _(this, K, !0) === !0 ? (this.default = b(K) ? function() {
      return [].concat(K);
    } : s(K) ? function() {
      return Object.assign({}, K);
    } : K, this) : (y(this._vueTypes_name + ' - invalid default value: "' + K + '"'), this) : this;
  } } }), U = G.validator;
  return O(U) && (G.validator = j(U, G)), G;
}
function w(H, C) {
  var G = T(H, C);
  return Object.defineProperty(G, "validate", { value: function(U) {
    return O(this.validator) && y(this._vueTypes_name + ` - calling .validate() will overwrite the current custom validator function. Validator info:
` + JSON.stringify(this)), this.validator = j(U, this), this;
  } });
}
function k$1(H, C, G) {
  var U, K, W = (U = C, K = {}, Object.getOwnPropertyNames(U).forEach(function(re) {
    K[re] = Object.getOwnPropertyDescriptor(U, re);
  }), Object.defineProperties({}, K));
  if (W._vueTypes_name = H, !s(G))
    return W;
  var Z, X, Q = G.validator, ee = i$1(G, ["validator"]);
  if (O(Q)) {
    var te = W.validator;
    te && (te = (X = (Z = te).__original) !== null && X !== void 0 ? X : Z), W.validator = j(te ? function(re) {
      return te.call(this, re) && Q.call(this, re);
    } : Q, W);
  }
  return Object.assign(W, ee);
}
function P(H) {
  return H.replace(/^(?!\s*$)/gm, "  ");
}
var x = function() {
  return w("any", {});
}, A = function() {
  return w("function", { type: Function });
}, E = function() {
  return w("boolean", { type: Boolean });
}, N = function() {
  return w("string", { type: String });
}, q = function() {
  return w("number", { type: Number });
}, S = function() {
  return w("array", { type: Array });
}, V = function() {
  return w("object", { type: Object });
}, F = function() {
  return T("integer", { type: Number, validator: function(H) {
    return h(H);
  } });
}, D = function() {
  return T("symbol", { validator: function(H) {
    return typeof H == "symbol";
  } });
};
function L(H, C) {
  if (C === void 0 && (C = "custom validation failed"), typeof H != "function")
    throw new TypeError("[VueTypes error]: You must provide a function as argument");
  return T(H.name || "<<anonymous function>>", { validator: function(G) {
    var U = H(G);
    return U || y(this._vueTypes_name + " - " + C), U;
  } });
}
function Y(H) {
  if (!b(H))
    throw new TypeError("[VueTypes error]: You must provide an array as argument.");
  var C = 'oneOf - value should be one of "' + H.join('", "') + '".', G = H.reduce(function(U, K) {
    if (K != null) {
      var W = K.constructor;
      U.indexOf(W) === -1 && U.push(W);
    }
    return U;
  }, []);
  return T("oneOf", { type: G.length > 0 ? G : void 0, validator: function(U) {
    var K = H.indexOf(U) !== -1;
    return K || y(C), K;
  } });
}
function B(H) {
  if (!b(H))
    throw new TypeError("[VueTypes error]: You must provide an array as argument");
  for (var C = !1, G = [], U = 0; U < H.length; U += 1) {
    var K = H[U];
    if (m$1(K)) {
      if (g(K) && K._vueTypes_name === "oneOf") {
        G = G.concat(K.type);
        continue;
      }
      if (O(K.validator) && (C = !0), K.type !== !0 && K.type) {
        G = G.concat(K.type);
        continue;
      }
    }
    G.push(K);
  }
  return G = G.filter(function(W, Z) {
    return G.indexOf(W) === Z;
  }), T("oneOfType", C ? { type: G, validator: function(W) {
    var Z = [], X = H.some(function(Q) {
      var ee = _(g(Q) && Q._vueTypes_name === "oneOf" ? Q.type || null : Q, W, !0);
      return typeof ee == "string" && Z.push(ee), ee === !0;
    });
    return X || y("oneOfType - provided value does not match any of the " + Z.length + ` passed-in validators:
` + P(Z.join(`
`))), X;
  } } : { type: G });
}
function I(H) {
  return T("arrayOf", { type: Array, validator: function(C) {
    var G, U = C.every(function(K) {
      return (G = _(H, K, !0)) === !0;
    });
    return U || y(`arrayOf - value validation error:
` + P(G)), U;
  } });
}
function J(H) {
  return T("instanceOf", { type: H });
}
function M(H) {
  return T("objectOf", { type: Object, validator: function(C) {
    var G, U = Object.keys(C).every(function(K) {
      return (G = _(H, C[K], !0)) === !0;
    });
    return U || y(`objectOf - value validation error:
` + P(G)), U;
  } });
}
function R(H) {
  var C = Object.keys(H), G = C.filter(function(K) {
    var W;
    return !!(!((W = H[K]) === null || W === void 0) && W.required);
  }), U = T("shape", { type: Object, validator: function(K) {
    var W = this;
    if (!s(K))
      return !1;
    var Z = Object.keys(K);
    if (G.length > 0 && G.some(function(Q) {
      return Z.indexOf(Q) === -1;
    })) {
      var X = G.filter(function(Q) {
        return Z.indexOf(Q) === -1;
      });
      return y(X.length === 1 ? 'shape - required property "' + X[0] + '" is not defined.' : 'shape - required properties "' + X.join('", "') + '" are not defined.'), !1;
    }
    return Z.every(function(Q) {
      if (C.indexOf(Q) === -1)
        return W._vueTypes_isLoose === !0 || (y('shape - shape definition does not include a "' + Q + '" property. Allowed keys: "' + C.join('", "') + '".'), !1);
      var ee = _(H[Q], K[Q], !0);
      return typeof ee == "string" && y('shape - "' + Q + `" property validation error:
 ` + P(ee)), ee === !0;
    });
  } });
  return Object.defineProperty(U, "_vueTypes_isLoose", { writable: !0, value: !1 }), Object.defineProperty(U, "loose", { get: function() {
    return this._vueTypes_isLoose = !0, this;
  } }), U;
}
var $ = function() {
  function H() {
  }
  return H.extend = function(C) {
    var G = this;
    if (b(C))
      return C.forEach(function(re) {
        return G.extend(re);
      }), this;
    var U = C.name, K = C.validate, W = K !== void 0 && K, Z = C.getter, X = Z !== void 0 && Z, Q = i$1(C, ["name", "validate", "getter"]);
    if (d(this, U))
      throw new TypeError('[VueTypes error]: Type "' + U + '" already defined');
    var ee, te = Q.type;
    return g(te) ? (delete Q.type, Object.defineProperty(this, U, X ? { get: function() {
      return k$1(U, te, Q);
    } } : { value: function() {
      var re, ne = k$1(U, te, Q);
      return ne.validator && (ne.validator = (re = ne.validator).bind.apply(re, [ne].concat([].slice.call(arguments)))), ne;
    } })) : (ee = X ? { get: function() {
      var re = Object.assign({}, Q);
      return W ? w(U, re) : T(U, re);
    }, enumerable: !0 } : { value: function() {
      var re, ne, ae = Object.assign({}, Q);
      return re = W ? w(U, ae) : T(U, ae), ae.validator && (re.validator = (ne = ae.validator).bind.apply(ne, [re].concat([].slice.call(arguments)))), re;
    }, enumerable: !0 }, Object.defineProperty(this, U, ee));
  }, t(H, null, [{ key: "any", get: function() {
    return x();
  } }, { key: "func", get: function() {
    return A().def(this.defaults.func);
  } }, { key: "bool", get: function() {
    return E().def(this.defaults.bool);
  } }, { key: "string", get: function() {
    return N().def(this.defaults.string);
  } }, { key: "number", get: function() {
    return q().def(this.defaults.number);
  } }, { key: "array", get: function() {
    return S().def(this.defaults.array);
  } }, { key: "object", get: function() {
    return V().def(this.defaults.object);
  } }, { key: "integer", get: function() {
    return F().def(this.defaults.integer);
  } }, { key: "symbol", get: function() {
    return D();
  } }]), H;
}();
function z(H) {
  var C;
  return H === void 0 && (H = { func: function() {
  }, bool: !0, string: "", number: 0, array: function() {
    return [];
  }, object: function() {
    return {};
  }, integer: 0 }), (C = function(G) {
    function U() {
      return G.apply(this, arguments) || this;
    }
    return r(U, G), t(U, null, [{ key: "sensibleDefaults", get: function() {
      return n({}, this.defaults);
    }, set: function(K) {
      this.defaults = K !== !1 ? n({}, K !== !0 ? K : H) : {};
    } }]), U;
  }($)).defaults = n({}, H), C;
}
$.defaults = {}, $.custom = L, $.oneOf = Y, $.instanceOf = J, $.oneOfType = B, $.arrayOf = I, $.objectOf = M, $.shape = R, $.utils = { validate: function(H, C) {
  return _(C, H, !0) === !0;
}, toType: function(H, C, G) {
  return G === void 0 && (G = !1), G ? w(H, C) : T(H, C);
} };
(function(H) {
  function C() {
    return H.apply(this, arguments) || this;
  }
  return r(C, H), C;
})(z());
var PropTypes = z({
  func: void 0,
  bool: void 0,
  string: void 0,
  number: void 0,
  array: void 0,
  object: void 0,
  integer: void 0
});
PropTypes.extend([{
  name: "looseBool",
  getter: !0,
  type: Boolean,
  default: void 0
}, {
  name: "style",
  getter: !0,
  type: [String, Object],
  default: void 0
}, {
  name: "VueNode",
  getter: !0,
  type: null
}]);
const PropTypes$1 = PropTypes;
var _excluded$v = ["image", "description", "imageStyle", "class"], defaultEmptyImg = createVNode$1(DefaultEmptyImg, null, null), simpleEmptyImg = createVNode$1(SimpleEmptyImg, null, null), Empty = function(C, G) {
  var U, K = G.slots, W = K === void 0 ? {} : K, Z = G.attrs, X = useConfigInject("empty", C), Q = X.direction, ee = X.prefixCls, te = ee.value, re = _objectSpread2$1(_objectSpread2$1({}, C), Z), ne = re.image, ae = ne === void 0 ? defaultEmptyImg : ne, ie = re.description, se = ie === void 0 ? ((U = W.description) === null || U === void 0 ? void 0 : U.call(W)) || void 0 : ie, oe = re.imageStyle, le = re.class, ue = le === void 0 ? "" : le, ce = _objectWithoutProperties$2(re, _excluded$v);
  return createVNode$1(LocaleReceiver, {
    componentName: "Empty",
    children: function(ge) {
      var fe, ve = typeof se < "u" ? se : ge.description, pe = typeof ve == "string" ? ve : "empty", he = null;
      return typeof ae == "string" ? he = createVNode$1("img", {
        alt: pe,
        src: ae
      }, null) : he = ae, createVNode$1("div", _objectSpread2$1({
        class: classNames(te, ue, (fe = {}, _defineProperty$A(fe, "".concat(te, "-normal"), ae === simpleEmptyImg), _defineProperty$A(fe, "".concat(te, "-rtl"), Q.value === "rtl"), fe))
      }, ce), [createVNode$1("div", {
        class: "".concat(te, "-image"),
        style: oe
      }, [he]), ve && createVNode$1("p", {
        class: "".concat(te, "-description")
      }, [ve]), W.default && createVNode$1("div", {
        class: "".concat(te, "-footer")
      }, [filterEmpty(W.default())])]);
    }
  }, null);
};
Empty.displayName = "AEmpty";
Empty.PRESENTED_IMAGE_DEFAULT = defaultEmptyImg;
Empty.PRESENTED_IMAGE_SIMPLE = simpleEmptyImg;
Empty.inheritAttrs = !1;
Empty.props = {
  prefixCls: String,
  image: PropTypes$1.any,
  description: PropTypes$1.any,
  imageStyle: {
    type: Object,
    default: void 0
  }
};
const Empty$1 = withInstall(Empty);
var RenderEmpty = function(C) {
  var G = useConfigInject("empty", C), U = G.prefixCls, K = function(Z) {
    switch (Z) {
      case "Table":
      case "List":
        return createVNode$1(Empty$1, {
          image: Empty$1.PRESENTED_IMAGE_SIMPLE
        }, null);
      case "Select":
      case "TreeSelect":
      case "Cascader":
      case "Transfer":
      case "Mentions":
        return createVNode$1(Empty$1, {
          image: Empty$1.PRESENTED_IMAGE_SIMPLE,
          class: "".concat(U.value, "-small")
        }, null);
      default:
        return createVNode$1(Empty$1, null, null);
    }
  };
  return K(C.componentName);
};
function renderEmpty(H) {
  return createVNode$1(RenderEmpty, {
    componentName: H
  }, null);
}
var warned = {};
function warning$2(H, C) {
  process.env.NODE_ENV !== "production" && !H && console !== void 0 && console.error("Warning: ".concat(C));
}
function note(H, C) {
  process.env.NODE_ENV !== "production" && !H && console !== void 0 && console.warn("Note: ".concat(C));
}
function call(H, C, G) {
  !C && !warned[G] && (H(!1, G), warned[G] = !0);
}
function warningOnce(H, C) {
  call(warning$2, H, C);
}
function noteOnce(H, C) {
  call(note, H, C);
}
const warning$1 = function(H, C) {
  var G = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
  warningOnce(H, "[antdv: ".concat(C, "] ").concat(G));
};
var ANT_MARK = "internalMark", LocaleProvider = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ALocaleProvider",
  props: {
    locale: {
      type: Object
    },
    ANT_MARK__: String
  },
  setup: function(C, G) {
    var U = G.slots;
    warning$1(C.ANT_MARK__ === ANT_MARK, "LocaleProvider", "`LocaleProvider` is deprecated. Please use `locale` with `ConfigProvider` instead");
    var K = reactive({
      antLocale: _objectSpread2$1(_objectSpread2$1({}, C.locale), {}, {
        exist: !0
      }),
      ANT_MARK__: ANT_MARK
    });
    return provide("localeData", K), watch(function() {
      return C.locale;
    }, function() {
      K.antLocale = _objectSpread2$1(_objectSpread2$1({}, C.locale), {}, {
        exist: !0
      });
    }, {
      immediate: !0
    }), function() {
      var W;
      return (W = U.default) === null || W === void 0 ? void 0 : W.call(U);
    };
  }
});
LocaleProvider.install = function(H) {
  return H.component(LocaleProvider.name, LocaleProvider), H;
};
const LocaleProvider$1 = withInstall(LocaleProvider);
tuple("bottomLeft", "bottomRight", "topLeft", "topRight");
var getTransitionProps = function(C) {
  var G = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, U = _objectSpread2$1(C ? {
    name: C,
    appear: !0,
    // type: 'animation',
    // appearFromClass: `${transitionName}-appear ${transitionName}-appear-prepare`,
    // appearActiveClass: `antdv-base-transtion`,
    // appearToClass: `${transitionName}-appear ${transitionName}-appear-active`,
    enterFromClass: "".concat(C, "-enter ").concat(C, "-enter-prepare"),
    enterActiveClass: "".concat(C, "-enter ").concat(C, "-enter-prepare"),
    enterToClass: "".concat(C, "-enter ").concat(C, "-enter-active"),
    leaveFromClass: " ".concat(C, "-leave"),
    leaveActiveClass: "".concat(C, "-leave ").concat(C, "-leave-active"),
    leaveToClass: "".concat(C, "-leave ").concat(C, "-leave-active")
  } : {
    css: !1
  }, G);
  return U;
}, getTransitionGroupProps = function(C) {
  var G = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, U = _objectSpread2$1(C ? {
    name: C,
    appear: !0,
    // appearFromClass: `${transitionName}-appear ${transitionName}-appear-prepare`,
    appearActiveClass: "".concat(C),
    appearToClass: "".concat(C, "-appear ").concat(C, "-appear-active"),
    enterFromClass: "".concat(C, "-appear ").concat(C, "-enter ").concat(C, "-appear-prepare ").concat(C, "-enter-prepare"),
    enterActiveClass: "".concat(C),
    enterToClass: "".concat(C, "-enter ").concat(C, "-appear ").concat(C, "-appear-active ").concat(C, "-enter-active"),
    leaveActiveClass: "".concat(C, " ").concat(C, "-leave"),
    leaveToClass: "".concat(C, "-leave-active")
  } : {
    css: !1
  }, G);
  return U;
}, getTransitionName$1 = function(C, G, U) {
  return U !== void 0 ? U : "".concat(C, "-").concat(G);
};
const Notice = defineComponent({
  name: "Notice",
  inheritAttrs: !1,
  props: ["prefixCls", "duration", "updateMark", "noticeKey", "closeIcon", "closable", "props", "onClick", "onClose", "holder", "visible"],
  setup: function(C, G) {
    var U = G.attrs, K = G.slots, W, Z = computed(function() {
      return C.duration === void 0 ? 1.5 : C.duration;
    }), X = function() {
      Z.value && (W = setTimeout(function() {
        ee();
      }, Z.value * 1e3));
    }, Q = function() {
      W && (clearTimeout(W), W = null);
    }, ee = function(ne) {
      ne && ne.stopPropagation(), Q();
      var ae = C.onClose, ie = C.noticeKey;
      ae && ae(ie);
    }, te = function() {
      Q(), X();
    };
    return onMounted(function() {
      X();
    }), onUnmounted(function() {
      Q();
    }), watch([Z, function() {
      return C.updateMark;
    }, function() {
      return C.visible;
    }], function(re, ne) {
      var ae = _slicedToArray$2(re, 3), ie = ae[0], se = ae[1], oe = ae[2], le = _slicedToArray$2(ne, 3), ue = le[0], ce = le[1], de = le[2];
      (ie !== ue || se !== ce || oe !== de && de) && te();
    }, {
      flush: "post"
    }), function() {
      var re, ne, ae = C.prefixCls, ie = C.closable, se = C.closeIcon, oe = se === void 0 ? (re = K.closeIcon) === null || re === void 0 ? void 0 : re.call(K) : se, le = C.onClick, ue = C.holder, ce = U.class, de = U.style, ge = "".concat(ae, "-notice"), fe = Object.keys(U).reduce(function(pe, he) {
        return (he.substr(0, 5) === "data-" || he.substr(0, 5) === "aria-" || he === "role") && (pe[he] = U[he]), pe;
      }, {}), ve = createVNode$1("div", _objectSpread2$1({
        class: classNames(ge, ce, _defineProperty$A({}, "".concat(ge, "-closable"), ie)),
        style: de,
        onMouseenter: Q,
        onMouseleave: X,
        onClick: le
      }, fe), [createVNode$1("div", {
        class: "".concat(ge, "-content")
      }, [(ne = K.default) === null || ne === void 0 ? void 0 : ne.call(K)]), ie ? createVNode$1("a", {
        tabindex: 0,
        onClick: ee,
        class: "".concat(ge, "-close")
      }, [oe || createVNode$1("span", {
        class: "".concat(ge, "-close-x")
      }, null)]) : null]);
      return ue ? createVNode$1(Teleport, {
        to: ue
      }, {
        default: function() {
          return ve;
        }
      }) : ve;
    };
  }
});
var _excluded$u = ["name", "getContainer", "appContext", "prefixCls", "rootPrefixCls", "transitionName", "hasTransitionName"], seed = 0, now$2 = Date.now();
function getUuid() {
  var H = seed;
  return seed += 1, "rcNotification_".concat(now$2, "_").concat(H);
}
var Notification = defineComponent({
  name: "Notification",
  inheritAttrs: !1,
  props: ["prefixCls", "transitionName", "animation", "maxCount", "closeIcon"],
  setup: function(C, G) {
    var U = G.attrs, K = G.expose, W = G.slots, Z = /* @__PURE__ */ new Map(), X = ref([]), Q = computed(function() {
      var re = C.prefixCls, ne = C.animation, ae = ne === void 0 ? "fade" : ne, ie = C.transitionName;
      return !ie && ae && (ie = "".concat(re, "-").concat(ae)), getTransitionGroupProps(ie);
    }), ee = function(ne, ae) {
      var ie = ne.key || getUuid(), se = _objectSpread2$1(_objectSpread2$1({}, ne), {}, {
        key: ie
      }), oe = C.maxCount, le = X.value.map(function(ce) {
        return ce.notice.key;
      }).indexOf(ie), ue = X.value.concat();
      le !== -1 ? ue.splice(le, 1, {
        notice: se,
        holderCallback: ae
      }) : (oe && X.value.length >= oe && (se.key = ue[0].notice.key, se.updateMark = getUuid(), se.userPassKey = ie, ue.shift()), ue.push({
        notice: se,
        holderCallback: ae
      })), X.value = ue;
    }, te = function(ne) {
      X.value = X.value.filter(function(ae) {
        var ie = ae.notice, se = ie.key, oe = ie.userPassKey, le = oe || se;
        return le !== ne;
      });
    };
    return K({
      add: ee,
      remove: te,
      notices: X
    }), function() {
      var re, ne, ae = C.prefixCls, ie = C.closeIcon, se = ie === void 0 ? (re = W.closeIcon) === null || re === void 0 ? void 0 : re.call(W, {
        prefixCls: ae
      }) : ie, oe = X.value.map(function(ue, ce) {
        var de = ue.notice, ge = ue.holderCallback, fe = ce === X.value.length - 1 ? de.updateMark : void 0, ve = de.key, pe = de.userPassKey, he = de.content, me = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
          prefixCls: ae,
          closeIcon: typeof se == "function" ? se({
            prefixCls: ae
          }) : se
        }, de), de.props), {}, {
          key: ve,
          noticeKey: pe || ve,
          updateMark: fe,
          onClose: function(Ce) {
            var Ie;
            te(Ce), (Ie = de.onClose) === null || Ie === void 0 || Ie.call(de);
          },
          onClick: de.onClick
        });
        return ge ? createVNode$1("div", {
          key: ve,
          class: "".concat(ae, "-hook-holder"),
          ref: function(Ce) {
            typeof ve > "u" || (Ce ? (Z.set(ve, Ce), ge(Ce, me)) : Z.delete(ve));
          }
        }, null) : createVNode$1(Notice, me, {
          default: function() {
            return [typeof he == "function" ? he({
              prefixCls: ae
            }) : he];
          }
        });
      }), le = (ne = {}, _defineProperty$A(ne, ae, 1), _defineProperty$A(ne, U.class, !!U.class), ne);
      return createVNode$1("div", {
        class: le,
        style: U.style || {
          top: "65px",
          left: "50%"
        }
      }, [createVNode$1(TransitionGroup, _objectSpread2$1({
        tag: "div"
      }, Q.value), {
        default: function() {
          return [oe];
        }
      })]);
    };
  }
});
Notification.newInstance = function(C, G) {
  var U = C || {}, K = U.name, W = K === void 0 ? "notification" : K, Z = U.getContainer, X = U.appContext, Q = U.prefixCls, ee = U.rootPrefixCls, te = U.transitionName, re = U.hasTransitionName, ne = _objectWithoutProperties$2(U, _excluded$u), ae = document.createElement("div");
  if (Z) {
    var ie = Z();
    ie.appendChild(ae);
  } else
    document.body.appendChild(ae);
  var se = defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "NotificationWrapper",
    setup: function(ue, ce) {
      var de = ce.attrs, ge = ref();
      return onMounted(function() {
        G({
          notice: function(ve) {
            var pe;
            (pe = ge.value) === null || pe === void 0 || pe.add(ve);
          },
          removeNotice: function(ve) {
            var pe;
            (pe = ge.value) === null || pe === void 0 || pe.remove(ve);
          },
          destroy: function() {
            render$1(null, ae), ae.parentNode && ae.parentNode.removeChild(ae);
          },
          component: ge
        });
      }), function() {
        var fe = globalConfigForApi, ve = fe.getPrefixCls(W, Q), pe = fe.getRootPrefixCls(ee, ve), he = re ? te : "".concat(pe, "-").concat(te);
        return createVNode$1(ConfigProvider, _objectSpread2$1(_objectSpread2$1({}, fe), {}, {
          notUpdateGlobalConfig: !0,
          prefixCls: pe
        }), {
          default: function() {
            return [createVNode$1(Notification, _objectSpread2$1(_objectSpread2$1({
              ref: ge
            }, de), {}, {
              prefixCls: ve,
              transitionName: he
            }), null)];
          }
        });
      };
    }
  }), oe = createVNode$1(se, ne);
  oe.appContext = X || oe.appContext, render$1(oe, ae);
};
const Notification$1 = Notification;
var LoadingOutlined$2 = { icon: { tag: "svg", attrs: { viewBox: "0 0 1024 1024", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M988 548c-19.9 0-36-16.1-36-36 0-59.4-11.6-117-34.6-171.3a440.45 440.45 0 00-94.3-139.9 437.71 437.71 0 00-139.9-94.3C629 83.6 571.4 72 512 72c-19.9 0-36-16.1-36-36s16.1-36 36-36c69.1 0 136.2 13.5 199.3 40.3C772.3 66 827 103 874 150c47 47 83.9 101.8 109.7 162.7 26.7 63.1 40.2 130.2 40.2 199.3.1 19.9-16 36-35.9 36z" } }] }, name: "loading", theme: "outlined" };
const LoadingOutlinedSvg = LoadingOutlined$2;
function bound01(H, C) {
  isOnePointZero(H) && (H = "100%");
  var G = isPercentage(H);
  return H = C === 360 ? H : Math.min(C, Math.max(0, parseFloat(H))), G && (H = parseInt(String(H * C), 10) / 100), Math.abs(H - C) < 1e-6 ? 1 : (C === 360 ? H = (H < 0 ? H % C + C : H % C) / parseFloat(String(C)) : H = H % C / parseFloat(String(C)), H);
}
function clamp01(H) {
  return Math.min(1, Math.max(0, H));
}
function isOnePointZero(H) {
  return typeof H == "string" && H.indexOf(".") !== -1 && parseFloat(H) === 1;
}
function isPercentage(H) {
  return typeof H == "string" && H.indexOf("%") !== -1;
}
function boundAlpha(H) {
  return H = parseFloat(H), (isNaN(H) || H < 0 || H > 1) && (H = 1), H;
}
function convertToPercentage(H) {
  return H <= 1 ? "".concat(Number(H) * 100, "%") : H;
}
function pad2(H) {
  return H.length === 1 ? "0" + H : String(H);
}
function rgbToRgb(H, C, G) {
  return {
    r: bound01(H, 255) * 255,
    g: bound01(C, 255) * 255,
    b: bound01(G, 255) * 255
  };
}
function rgbToHsl(H, C, G) {
  H = bound01(H, 255), C = bound01(C, 255), G = bound01(G, 255);
  var U = Math.max(H, C, G), K = Math.min(H, C, G), W = 0, Z = 0, X = (U + K) / 2;
  if (U === K)
    Z = 0, W = 0;
  else {
    var Q = U - K;
    switch (Z = X > 0.5 ? Q / (2 - U - K) : Q / (U + K), U) {
      case H:
        W = (C - G) / Q + (C < G ? 6 : 0);
        break;
      case C:
        W = (G - H) / Q + 2;
        break;
      case G:
        W = (H - C) / Q + 4;
        break;
    }
    W /= 6;
  }
  return { h: W, s: Z, l: X };
}
function hue2rgb(H, C, G) {
  return G < 0 && (G += 1), G > 1 && (G -= 1), G < 1 / 6 ? H + (C - H) * (6 * G) : G < 1 / 2 ? C : G < 2 / 3 ? H + (C - H) * (2 / 3 - G) * 6 : H;
}
function hslToRgb(H, C, G) {
  var U, K, W;
  if (H = bound01(H, 360), C = bound01(C, 100), G = bound01(G, 100), C === 0)
    K = G, W = G, U = G;
  else {
    var Z = G < 0.5 ? G * (1 + C) : G + C - G * C, X = 2 * G - Z;
    U = hue2rgb(X, Z, H + 1 / 3), K = hue2rgb(X, Z, H), W = hue2rgb(X, Z, H - 1 / 3);
  }
  return { r: U * 255, g: K * 255, b: W * 255 };
}
function rgbToHsv(H, C, G) {
  H = bound01(H, 255), C = bound01(C, 255), G = bound01(G, 255);
  var U = Math.max(H, C, G), K = Math.min(H, C, G), W = 0, Z = U, X = U - K, Q = U === 0 ? 0 : X / U;
  if (U === K)
    W = 0;
  else {
    switch (U) {
      case H:
        W = (C - G) / X + (C < G ? 6 : 0);
        break;
      case C:
        W = (G - H) / X + 2;
        break;
      case G:
        W = (H - C) / X + 4;
        break;
    }
    W /= 6;
  }
  return { h: W, s: Q, v: Z };
}
function hsvToRgb(H, C, G) {
  H = bound01(H, 360) * 6, C = bound01(C, 100), G = bound01(G, 100);
  var U = Math.floor(H), K = H - U, W = G * (1 - C), Z = G * (1 - K * C), X = G * (1 - (1 - K) * C), Q = U % 6, ee = [G, Z, W, W, X, G][Q], te = [X, G, G, Z, W, W][Q], re = [W, W, X, G, G, Z][Q];
  return { r: ee * 255, g: te * 255, b: re * 255 };
}
function rgbToHex(H, C, G, U) {
  var K = [
    pad2(Math.round(H).toString(16)),
    pad2(Math.round(C).toString(16)),
    pad2(Math.round(G).toString(16))
  ];
  return U && K[0].startsWith(K[0].charAt(1)) && K[1].startsWith(K[1].charAt(1)) && K[2].startsWith(K[2].charAt(1)) ? K[0].charAt(0) + K[1].charAt(0) + K[2].charAt(0) : K.join("");
}
function rgbaToHex(H, C, G, U, K) {
  var W = [
    pad2(Math.round(H).toString(16)),
    pad2(Math.round(C).toString(16)),
    pad2(Math.round(G).toString(16)),
    pad2(convertDecimalToHex(U))
  ];
  return K && W[0].startsWith(W[0].charAt(1)) && W[1].startsWith(W[1].charAt(1)) && W[2].startsWith(W[2].charAt(1)) && W[3].startsWith(W[3].charAt(1)) ? W[0].charAt(0) + W[1].charAt(0) + W[2].charAt(0) + W[3].charAt(0) : W.join("");
}
function convertDecimalToHex(H) {
  return Math.round(parseFloat(H) * 255).toString(16);
}
function convertHexToDecimal(H) {
  return parseIntFromHex(H) / 255;
}
function parseIntFromHex(H) {
  return parseInt(H, 16);
}
function numberInputToObject(H) {
  return {
    r: H >> 16,
    g: (H & 65280) >> 8,
    b: H & 255
  };
}
var names = {
  aliceblue: "#f0f8ff",
  antiquewhite: "#faebd7",
  aqua: "#00ffff",
  aquamarine: "#7fffd4",
  azure: "#f0ffff",
  beige: "#f5f5dc",
  bisque: "#ffe4c4",
  black: "#000000",
  blanchedalmond: "#ffebcd",
  blue: "#0000ff",
  blueviolet: "#8a2be2",
  brown: "#a52a2a",
  burlywood: "#deb887",
  cadetblue: "#5f9ea0",
  chartreuse: "#7fff00",
  chocolate: "#d2691e",
  coral: "#ff7f50",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cyan: "#00ffff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  darkgreen: "#006400",
  darkgrey: "#a9a9a9",
  darkkhaki: "#bdb76b",
  darkmagenta: "#8b008b",
  darkolivegreen: "#556b2f",
  darkorange: "#ff8c00",
  darkorchid: "#9932cc",
  darkred: "#8b0000",
  darksalmon: "#e9967a",
  darkseagreen: "#8fbc8f",
  darkslateblue: "#483d8b",
  darkslategray: "#2f4f4f",
  darkslategrey: "#2f4f4f",
  darkturquoise: "#00ced1",
  darkviolet: "#9400d3",
  deeppink: "#ff1493",
  deepskyblue: "#00bfff",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1e90ff",
  firebrick: "#b22222",
  floralwhite: "#fffaf0",
  forestgreen: "#228b22",
  fuchsia: "#ff00ff",
  gainsboro: "#dcdcdc",
  ghostwhite: "#f8f8ff",
  goldenrod: "#daa520",
  gold: "#ffd700",
  gray: "#808080",
  green: "#008000",
  greenyellow: "#adff2f",
  grey: "#808080",
  honeydew: "#f0fff0",
  hotpink: "#ff69b4",
  indianred: "#cd5c5c",
  indigo: "#4b0082",
  ivory: "#fffff0",
  khaki: "#f0e68c",
  lavenderblush: "#fff0f5",
  lavender: "#e6e6fa",
  lawngreen: "#7cfc00",
  lemonchiffon: "#fffacd",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lightcyan: "#e0ffff",
  lightgoldenrodyellow: "#fafad2",
  lightgray: "#d3d3d3",
  lightgreen: "#90ee90",
  lightgrey: "#d3d3d3",
  lightpink: "#ffb6c1",
  lightsalmon: "#ffa07a",
  lightseagreen: "#20b2aa",
  lightskyblue: "#87cefa",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#b0c4de",
  lightyellow: "#ffffe0",
  lime: "#00ff00",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  magenta: "#ff00ff",
  maroon: "#800000",
  mediumaquamarine: "#66cdaa",
  mediumblue: "#0000cd",
  mediumorchid: "#ba55d3",
  mediumpurple: "#9370db",
  mediumseagreen: "#3cb371",
  mediumslateblue: "#7b68ee",
  mediumspringgreen: "#00fa9a",
  mediumturquoise: "#48d1cc",
  mediumvioletred: "#c71585",
  midnightblue: "#191970",
  mintcream: "#f5fffa",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  navajowhite: "#ffdead",
  navy: "#000080",
  oldlace: "#fdf5e6",
  olive: "#808000",
  olivedrab: "#6b8e23",
  orange: "#ffa500",
  orangered: "#ff4500",
  orchid: "#da70d6",
  palegoldenrod: "#eee8aa",
  palegreen: "#98fb98",
  paleturquoise: "#afeeee",
  palevioletred: "#db7093",
  papayawhip: "#ffefd5",
  peachpuff: "#ffdab9",
  peru: "#cd853f",
  pink: "#ffc0cb",
  plum: "#dda0dd",
  powderblue: "#b0e0e6",
  purple: "#800080",
  rebeccapurple: "#663399",
  red: "#ff0000",
  rosybrown: "#bc8f8f",
  royalblue: "#4169e1",
  saddlebrown: "#8b4513",
  salmon: "#fa8072",
  sandybrown: "#f4a460",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  skyblue: "#87ceeb",
  slateblue: "#6a5acd",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#fffafa",
  springgreen: "#00ff7f",
  steelblue: "#4682b4",
  tan: "#d2b48c",
  teal: "#008080",
  thistle: "#d8bfd8",
  tomato: "#ff6347",
  turquoise: "#40e0d0",
  violet: "#ee82ee",
  wheat: "#f5deb3",
  white: "#ffffff",
  whitesmoke: "#f5f5f5",
  yellow: "#ffff00",
  yellowgreen: "#9acd32"
};
function inputToRGB(H) {
  var C = { r: 0, g: 0, b: 0 }, G = 1, U = null, K = null, W = null, Z = !1, X = !1;
  return typeof H == "string" && (H = stringInputToObject(H)), typeof H == "object" && (isValidCSSUnit(H.r) && isValidCSSUnit(H.g) && isValidCSSUnit(H.b) ? (C = rgbToRgb(H.r, H.g, H.b), Z = !0, X = String(H.r).substr(-1) === "%" ? "prgb" : "rgb") : isValidCSSUnit(H.h) && isValidCSSUnit(H.s) && isValidCSSUnit(H.v) ? (U = convertToPercentage(H.s), K = convertToPercentage(H.v), C = hsvToRgb(H.h, U, K), Z = !0, X = "hsv") : isValidCSSUnit(H.h) && isValidCSSUnit(H.s) && isValidCSSUnit(H.l) && (U = convertToPercentage(H.s), W = convertToPercentage(H.l), C = hslToRgb(H.h, U, W), Z = !0, X = "hsl"), Object.prototype.hasOwnProperty.call(H, "a") && (G = H.a)), G = boundAlpha(G), {
    ok: Z,
    format: H.format || X,
    r: Math.min(255, Math.max(C.r, 0)),
    g: Math.min(255, Math.max(C.g, 0)),
    b: Math.min(255, Math.max(C.b, 0)),
    a: G
  };
}
var CSS_INTEGER = "[-\\+]?\\d+%?", CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?", CSS_UNIT = "(?:".concat(CSS_NUMBER, ")|(?:").concat(CSS_INTEGER, ")"), PERMISSIVE_MATCH3 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?"), PERMISSIVE_MATCH4 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?"), matchers = {
  CSS_UNIT: new RegExp(CSS_UNIT),
  rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
  rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
  hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
  hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
  hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
  hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
  hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
  hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
};
function stringInputToObject(H) {
  if (H = H.trim().toLowerCase(), H.length === 0)
    return !1;
  var C = !1;
  if (names[H])
    H = names[H], C = !0;
  else if (H === "transparent")
    return { r: 0, g: 0, b: 0, a: 0, format: "name" };
  var G = matchers.rgb.exec(H);
  return G ? { r: G[1], g: G[2], b: G[3] } : (G = matchers.rgba.exec(H), G ? { r: G[1], g: G[2], b: G[3], a: G[4] } : (G = matchers.hsl.exec(H), G ? { h: G[1], s: G[2], l: G[3] } : (G = matchers.hsla.exec(H), G ? { h: G[1], s: G[2], l: G[3], a: G[4] } : (G = matchers.hsv.exec(H), G ? { h: G[1], s: G[2], v: G[3] } : (G = matchers.hsva.exec(H), G ? { h: G[1], s: G[2], v: G[3], a: G[4] } : (G = matchers.hex8.exec(H), G ? {
    r: parseIntFromHex(G[1]),
    g: parseIntFromHex(G[2]),
    b: parseIntFromHex(G[3]),
    a: convertHexToDecimal(G[4]),
    format: C ? "name" : "hex8"
  } : (G = matchers.hex6.exec(H), G ? {
    r: parseIntFromHex(G[1]),
    g: parseIntFromHex(G[2]),
    b: parseIntFromHex(G[3]),
    format: C ? "name" : "hex"
  } : (G = matchers.hex4.exec(H), G ? {
    r: parseIntFromHex(G[1] + G[1]),
    g: parseIntFromHex(G[2] + G[2]),
    b: parseIntFromHex(G[3] + G[3]),
    a: convertHexToDecimal(G[4] + G[4]),
    format: C ? "name" : "hex8"
  } : (G = matchers.hex3.exec(H), G ? {
    r: parseIntFromHex(G[1] + G[1]),
    g: parseIntFromHex(G[2] + G[2]),
    b: parseIntFromHex(G[3] + G[3]),
    format: C ? "name" : "hex"
  } : !1)))))))));
}
function isValidCSSUnit(H) {
  return Boolean(matchers.CSS_UNIT.exec(String(H)));
}
var TinyColor = function() {
  function H(C, G) {
    C === void 0 && (C = ""), G === void 0 && (G = {});
    var U;
    if (C instanceof H)
      return C;
    typeof C == "number" && (C = numberInputToObject(C)), this.originalInput = C;
    var K = inputToRGB(C);
    this.originalInput = C, this.r = K.r, this.g = K.g, this.b = K.b, this.a = K.a, this.roundA = Math.round(100 * this.a) / 100, this.format = (U = G.format) !== null && U !== void 0 ? U : K.format, this.gradientType = G.gradientType, this.r < 1 && (this.r = Math.round(this.r)), this.g < 1 && (this.g = Math.round(this.g)), this.b < 1 && (this.b = Math.round(this.b)), this.isValid = K.ok;
  }
  return H.prototype.isDark = function() {
    return this.getBrightness() < 128;
  }, H.prototype.isLight = function() {
    return !this.isDark();
  }, H.prototype.getBrightness = function() {
    var C = this.toRgb();
    return (C.r * 299 + C.g * 587 + C.b * 114) / 1e3;
  }, H.prototype.getLuminance = function() {
    var C = this.toRgb(), G, U, K, W = C.r / 255, Z = C.g / 255, X = C.b / 255;
    return W <= 0.03928 ? G = W / 12.92 : G = Math.pow((W + 0.055) / 1.055, 2.4), Z <= 0.03928 ? U = Z / 12.92 : U = Math.pow((Z + 0.055) / 1.055, 2.4), X <= 0.03928 ? K = X / 12.92 : K = Math.pow((X + 0.055) / 1.055, 2.4), 0.2126 * G + 0.7152 * U + 0.0722 * K;
  }, H.prototype.getAlpha = function() {
    return this.a;
  }, H.prototype.setAlpha = function(C) {
    return this.a = boundAlpha(C), this.roundA = Math.round(100 * this.a) / 100, this;
  }, H.prototype.isMonochrome = function() {
    var C = this.toHsl().s;
    return C === 0;
  }, H.prototype.toHsv = function() {
    var C = rgbToHsv(this.r, this.g, this.b);
    return { h: C.h * 360, s: C.s, v: C.v, a: this.a };
  }, H.prototype.toHsvString = function() {
    var C = rgbToHsv(this.r, this.g, this.b), G = Math.round(C.h * 360), U = Math.round(C.s * 100), K = Math.round(C.v * 100);
    return this.a === 1 ? "hsv(".concat(G, ", ").concat(U, "%, ").concat(K, "%)") : "hsva(".concat(G, ", ").concat(U, "%, ").concat(K, "%, ").concat(this.roundA, ")");
  }, H.prototype.toHsl = function() {
    var C = rgbToHsl(this.r, this.g, this.b);
    return { h: C.h * 360, s: C.s, l: C.l, a: this.a };
  }, H.prototype.toHslString = function() {
    var C = rgbToHsl(this.r, this.g, this.b), G = Math.round(C.h * 360), U = Math.round(C.s * 100), K = Math.round(C.l * 100);
    return this.a === 1 ? "hsl(".concat(G, ", ").concat(U, "%, ").concat(K, "%)") : "hsla(".concat(G, ", ").concat(U, "%, ").concat(K, "%, ").concat(this.roundA, ")");
  }, H.prototype.toHex = function(C) {
    return C === void 0 && (C = !1), rgbToHex(this.r, this.g, this.b, C);
  }, H.prototype.toHexString = function(C) {
    return C === void 0 && (C = !1), "#" + this.toHex(C);
  }, H.prototype.toHex8 = function(C) {
    return C === void 0 && (C = !1), rgbaToHex(this.r, this.g, this.b, this.a, C);
  }, H.prototype.toHex8String = function(C) {
    return C === void 0 && (C = !1), "#" + this.toHex8(C);
  }, H.prototype.toRgb = function() {
    return {
      r: Math.round(this.r),
      g: Math.round(this.g),
      b: Math.round(this.b),
      a: this.a
    };
  }, H.prototype.toRgbString = function() {
    var C = Math.round(this.r), G = Math.round(this.g), U = Math.round(this.b);
    return this.a === 1 ? "rgb(".concat(C, ", ").concat(G, ", ").concat(U, ")") : "rgba(".concat(C, ", ").concat(G, ", ").concat(U, ", ").concat(this.roundA, ")");
  }, H.prototype.toPercentageRgb = function() {
    var C = function(G) {
      return "".concat(Math.round(bound01(G, 255) * 100), "%");
    };
    return {
      r: C(this.r),
      g: C(this.g),
      b: C(this.b),
      a: this.a
    };
  }, H.prototype.toPercentageRgbString = function() {
    var C = function(G) {
      return Math.round(bound01(G, 255) * 100);
    };
    return this.a === 1 ? "rgb(".concat(C(this.r), "%, ").concat(C(this.g), "%, ").concat(C(this.b), "%)") : "rgba(".concat(C(this.r), "%, ").concat(C(this.g), "%, ").concat(C(this.b), "%, ").concat(this.roundA, ")");
  }, H.prototype.toName = function() {
    if (this.a === 0)
      return "transparent";
    if (this.a < 1)
      return !1;
    for (var C = "#" + rgbToHex(this.r, this.g, this.b, !1), G = 0, U = Object.entries(names); G < U.length; G++) {
      var K = U[G], W = K[0], Z = K[1];
      if (C === Z)
        return W;
    }
    return !1;
  }, H.prototype.toString = function(C) {
    var G = Boolean(C);
    C = C ?? this.format;
    var U = !1, K = this.a < 1 && this.a >= 0, W = !G && K && (C.startsWith("hex") || C === "name");
    return W ? C === "name" && this.a === 0 ? this.toName() : this.toRgbString() : (C === "rgb" && (U = this.toRgbString()), C === "prgb" && (U = this.toPercentageRgbString()), (C === "hex" || C === "hex6") && (U = this.toHexString()), C === "hex3" && (U = this.toHexString(!0)), C === "hex4" && (U = this.toHex8String(!0)), C === "hex8" && (U = this.toHex8String()), C === "name" && (U = this.toName()), C === "hsl" && (U = this.toHslString()), C === "hsv" && (U = this.toHsvString()), U || this.toHexString());
  }, H.prototype.toNumber = function() {
    return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
  }, H.prototype.clone = function() {
    return new H(this.toString());
  }, H.prototype.lighten = function(C) {
    C === void 0 && (C = 10);
    var G = this.toHsl();
    return G.l += C / 100, G.l = clamp01(G.l), new H(G);
  }, H.prototype.brighten = function(C) {
    C === void 0 && (C = 10);
    var G = this.toRgb();
    return G.r = Math.max(0, Math.min(255, G.r - Math.round(255 * -(C / 100)))), G.g = Math.max(0, Math.min(255, G.g - Math.round(255 * -(C / 100)))), G.b = Math.max(0, Math.min(255, G.b - Math.round(255 * -(C / 100)))), new H(G);
  }, H.prototype.darken = function(C) {
    C === void 0 && (C = 10);
    var G = this.toHsl();
    return G.l -= C / 100, G.l = clamp01(G.l), new H(G);
  }, H.prototype.tint = function(C) {
    return C === void 0 && (C = 10), this.mix("white", C);
  }, H.prototype.shade = function(C) {
    return C === void 0 && (C = 10), this.mix("black", C);
  }, H.prototype.desaturate = function(C) {
    C === void 0 && (C = 10);
    var G = this.toHsl();
    return G.s -= C / 100, G.s = clamp01(G.s), new H(G);
  }, H.prototype.saturate = function(C) {
    C === void 0 && (C = 10);
    var G = this.toHsl();
    return G.s += C / 100, G.s = clamp01(G.s), new H(G);
  }, H.prototype.greyscale = function() {
    return this.desaturate(100);
  }, H.prototype.spin = function(C) {
    var G = this.toHsl(), U = (G.h + C) % 360;
    return G.h = U < 0 ? 360 + U : U, new H(G);
  }, H.prototype.mix = function(C, G) {
    G === void 0 && (G = 50);
    var U = this.toRgb(), K = new H(C).toRgb(), W = G / 100, Z = {
      r: (K.r - U.r) * W + U.r,
      g: (K.g - U.g) * W + U.g,
      b: (K.b - U.b) * W + U.b,
      a: (K.a - U.a) * W + U.a
    };
    return new H(Z);
  }, H.prototype.analogous = function(C, G) {
    C === void 0 && (C = 6), G === void 0 && (G = 30);
    var U = this.toHsl(), K = 360 / G, W = [this];
    for (U.h = (U.h - (K * C >> 1) + 720) % 360; --C; )
      U.h = (U.h + K) % 360, W.push(new H(U));
    return W;
  }, H.prototype.complement = function() {
    var C = this.toHsl();
    return C.h = (C.h + 180) % 360, new H(C);
  }, H.prototype.monochromatic = function(C) {
    C === void 0 && (C = 6);
    for (var G = this.toHsv(), U = G.h, K = G.s, W = G.v, Z = [], X = 1 / C; C--; )
      Z.push(new H({ h: U, s: K, v: W })), W = (W + X) % 1;
    return Z;
  }, H.prototype.splitcomplement = function() {
    var C = this.toHsl(), G = C.h;
    return [
      this,
      new H({ h: (G + 72) % 360, s: C.s, l: C.l }),
      new H({ h: (G + 216) % 360, s: C.s, l: C.l })
    ];
  }, H.prototype.onBackground = function(C) {
    var G = this.toRgb(), U = new H(C).toRgb();
    return new H({
      r: U.r + (G.r - U.r) * G.a,
      g: U.g + (G.g - U.g) * G.a,
      b: U.b + (G.b - U.b) * G.a
    });
  }, H.prototype.triad = function() {
    return this.polyad(3);
  }, H.prototype.tetrad = function() {
    return this.polyad(4);
  }, H.prototype.polyad = function(C) {
    for (var G = this.toHsl(), U = G.h, K = [this], W = 360 / C, Z = 1; Z < C; Z++)
      K.push(new H({ h: (U + Z * W) % 360, s: G.s, l: G.l }));
    return K;
  }, H.prototype.equals = function(C) {
    return this.toRgbString() === new H(C).toRgbString();
  }, H;
}(), hueStep = 2, saturationStep = 0.16, saturationStep2 = 0.05, brightnessStep1 = 0.05, brightnessStep2 = 0.15, lightColorCount = 5, darkColorCount = 4, darkColorMap = [{
  index: 7,
  opacity: 0.15
}, {
  index: 6,
  opacity: 0.25
}, {
  index: 5,
  opacity: 0.3
}, {
  index: 5,
  opacity: 0.45
}, {
  index: 5,
  opacity: 0.65
}, {
  index: 5,
  opacity: 0.85
}, {
  index: 4,
  opacity: 0.9
}, {
  index: 3,
  opacity: 0.95
}, {
  index: 2,
  opacity: 0.97
}, {
  index: 1,
  opacity: 0.98
}];
function toHsv(H) {
  var C = H.r, G = H.g, U = H.b, K = rgbToHsv(C, G, U);
  return {
    h: K.h * 360,
    s: K.s,
    v: K.v
  };
}
function toHex(H) {
  var C = H.r, G = H.g, U = H.b;
  return "#".concat(rgbToHex(C, G, U, !1));
}
function mix$1(H, C, G) {
  var U = G / 100, K = {
    r: (C.r - H.r) * U + H.r,
    g: (C.g - H.g) * U + H.g,
    b: (C.b - H.b) * U + H.b
  };
  return K;
}
function getHue(H, C, G) {
  var U;
  return Math.round(H.h) >= 60 && Math.round(H.h) <= 240 ? U = G ? Math.round(H.h) - hueStep * C : Math.round(H.h) + hueStep * C : U = G ? Math.round(H.h) + hueStep * C : Math.round(H.h) - hueStep * C, U < 0 ? U += 360 : U >= 360 && (U -= 360), U;
}
function getSaturation(H, C, G) {
  if (H.h === 0 && H.s === 0)
    return H.s;
  var U;
  return G ? U = H.s - saturationStep * C : C === darkColorCount ? U = H.s + saturationStep : U = H.s + saturationStep2 * C, U > 1 && (U = 1), G && C === lightColorCount && U > 0.1 && (U = 0.1), U < 0.06 && (U = 0.06), Number(U.toFixed(2));
}
function getValue$1(H, C, G) {
  var U;
  return G ? U = H.v + brightnessStep1 * C : U = H.v - brightnessStep2 * C, U > 1 && (U = 1), Number(U.toFixed(2));
}
function generate$1(H) {
  for (var C = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, G = [], U = inputToRGB(H), K = lightColorCount; K > 0; K -= 1) {
    var W = toHsv(U), Z = toHex(inputToRGB({
      h: getHue(W, K, !0),
      s: getSaturation(W, K, !0),
      v: getValue$1(W, K, !0)
    }));
    G.push(Z);
  }
  G.push(toHex(U));
  for (var X = 1; X <= darkColorCount; X += 1) {
    var Q = toHsv(U), ee = toHex(inputToRGB({
      h: getHue(Q, X),
      s: getSaturation(Q, X),
      v: getValue$1(Q, X)
    }));
    G.push(ee);
  }
  return C.theme === "dark" ? darkColorMap.map(function(te) {
    var re = te.index, ne = te.opacity, ae = toHex(mix$1(inputToRGB(C.backgroundColor || "#141414"), inputToRGB(G[re]), ne * 100));
    return ae;
  }) : G;
}
var presetPrimaryColors = {
  red: "#F5222D",
  volcano: "#FA541C",
  orange: "#FA8C16",
  gold: "#FAAD14",
  yellow: "#FADB14",
  lime: "#A0D911",
  green: "#52C41A",
  cyan: "#13C2C2",
  blue: "#1890FF",
  geekblue: "#2F54EB",
  purple: "#722ED1",
  magenta: "#EB2F96",
  grey: "#666666"
}, presetPalettes = {}, presetDarkPalettes = {};
Object.keys(presetPrimaryColors).forEach(function(H) {
  presetPalettes[H] = generate$1(presetPrimaryColors[H]), presetPalettes[H].primary = presetPalettes[H][5], presetDarkPalettes[H] = generate$1(presetPrimaryColors[H], {
    theme: "dark",
    backgroundColor: "#141414"
  }), presetDarkPalettes[H].primary = presetDarkPalettes[H][5];
});
var containers = [], styleElements = [], usage = "insert-css: You need to provide a CSS string. Usage: insertCss(cssString[, options]).";
function createStyleElement() {
  var H = document.createElement("style");
  return H.setAttribute("type", "text/css"), H;
}
function insertCss(H, C) {
  if (C = C || {}, H === void 0)
    throw new Error(usage);
  var G = C.prepend === !0 ? "prepend" : "append", U = C.container !== void 0 ? C.container : document.querySelector("head"), K = containers.indexOf(U);
  K === -1 && (K = containers.push(U) - 1, styleElements[K] = {});
  var W;
  return styleElements[K] !== void 0 && styleElements[K][G] !== void 0 ? W = styleElements[K][G] : (W = styleElements[K][G] = createStyleElement(), G === "prepend" ? U.insertBefore(W, U.childNodes[0]) : U.appendChild(W)), H.charCodeAt(0) === 65279 && (H = H.substr(1, H.length)), W.styleSheet ? W.styleSheet.cssText += H : W.textContent += H, W;
}
function _objectSpread$y(H) {
  for (var C = 1; C < arguments.length; C++) {
    var G = arguments[C] != null ? Object(arguments[C]) : {}, U = Object.keys(G);
    typeof Object.getOwnPropertySymbols == "function" && (U = U.concat(Object.getOwnPropertySymbols(G).filter(function(K) {
      return Object.getOwnPropertyDescriptor(G, K).enumerable;
    }))), U.forEach(function(K) {
      _defineProperty$z(H, K, G[K]);
    });
  }
  return H;
}
function _defineProperty$z(H, C, G) {
  return C in H ? Object.defineProperty(H, C, { value: G, enumerable: !0, configurable: !0, writable: !0 }) : H[C] = G, H;
}
function warn$1(H, C) {
  process.env.NODE_ENV !== "production" && !H && console !== void 0 && console.error("Warning: ".concat(C));
}
function warning(H, C) {
  warn$1(H, "[@ant-design/icons-vue] ".concat(C));
}
function isIconDefinition(H) {
  return typeof H == "object" && typeof H.name == "string" && typeof H.theme == "string" && (typeof H.icon == "object" || typeof H.icon == "function");
}
function generate(H, C, G) {
  return G ? h$1(H.tag, _objectSpread$y({
    key: C
  }, G, H.attrs), (H.children || []).map(function(U, K) {
    return generate(U, "".concat(C, "-").concat(H.tag, "-").concat(K));
  })) : h$1(H.tag, _objectSpread$y({
    key: C
  }, H.attrs), (H.children || []).map(function(U, K) {
    return generate(U, "".concat(C, "-").concat(H.tag, "-").concat(K));
  }));
}
function getSecondaryColor(H) {
  return generate$1(H)[0];
}
function normalizeTwoToneColors(H) {
  return H ? Array.isArray(H) ? H : [H] : [];
}
var iconStyles = `
.anticon {
  display: inline-block;
  color: inherit;
  font-style: normal;
  line-height: 0;
  text-align: center;
  text-transform: none;
  vertical-align: -0.125em;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

.anticon > * {
  line-height: 1;
}

.anticon svg {
  display: inline-block;
}

.anticon::before {
  display: none;
}

.anticon .anticon-icon {
  display: block;
}

.anticon[tabindex] {
  cursor: pointer;
}

.anticon-spin::before,
.anticon-spin {
  display: inline-block;
  -webkit-animation: loadingCircle 1s infinite linear;
  animation: loadingCircle 1s infinite linear;
}

@-webkit-keyframes loadingCircle {
  100% {
    -webkit-transform: rotate(360deg);
    transform: rotate(360deg);
  }
}

@keyframes loadingCircle {
  100% {
    -webkit-transform: rotate(360deg);
    transform: rotate(360deg);
  }
}
`, cssInjectedFlag = !1, useInsertStyles = function() {
  var C = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : iconStyles;
  nextTick(function() {
    cssInjectedFlag || (typeof window < "u" && window.document && window.document.documentElement && insertCss(C, {
      prepend: !0
    }), cssInjectedFlag = !0);
  });
}, _excluded$t = ["icon", "primaryColor", "secondaryColor"];
function _objectWithoutProperties$1(H, C) {
  if (H == null)
    return {};
  var G = _objectWithoutPropertiesLoose$1(H, C), U, K;
  if (Object.getOwnPropertySymbols) {
    var W = Object.getOwnPropertySymbols(H);
    for (K = 0; K < W.length; K++)
      U = W[K], !(C.indexOf(U) >= 0) && Object.prototype.propertyIsEnumerable.call(H, U) && (G[U] = H[U]);
  }
  return G;
}
function _objectWithoutPropertiesLoose$1(H, C) {
  if (H == null)
    return {};
  var G = {}, U = Object.keys(H), K, W;
  for (W = 0; W < U.length; W++)
    K = U[W], !(C.indexOf(K) >= 0) && (G[K] = H[K]);
  return G;
}
function _objectSpread$x(H) {
  for (var C = 1; C < arguments.length; C++) {
    var G = arguments[C] != null ? Object(arguments[C]) : {}, U = Object.keys(G);
    typeof Object.getOwnPropertySymbols == "function" && (U = U.concat(Object.getOwnPropertySymbols(G).filter(function(K) {
      return Object.getOwnPropertyDescriptor(G, K).enumerable;
    }))), U.forEach(function(K) {
      _defineProperty$y(H, K, G[K]);
    });
  }
  return H;
}
function _defineProperty$y(H, C, G) {
  return C in H ? Object.defineProperty(H, C, { value: G, enumerable: !0, configurable: !0, writable: !0 }) : H[C] = G, H;
}
var twoToneColorPalette = {
  primaryColor: "#333",
  secondaryColor: "#E6E6E6",
  calculated: !1
};
function setTwoToneColors(H) {
  var C = H.primaryColor, G = H.secondaryColor;
  twoToneColorPalette.primaryColor = C, twoToneColorPalette.secondaryColor = G || getSecondaryColor(C), twoToneColorPalette.calculated = !!G;
}
function getTwoToneColors() {
  return _objectSpread$x({}, twoToneColorPalette);
}
var IconBase = function(C, G) {
  var U = _objectSpread$x({}, C, G.attrs), K = U.icon, W = U.primaryColor, Z = U.secondaryColor, X = _objectWithoutProperties$1(U, _excluded$t), Q = twoToneColorPalette;
  if (W && (Q = {
    primaryColor: W,
    secondaryColor: Z || getSecondaryColor(W)
  }), useInsertStyles(), warning(isIconDefinition(K), "icon should be icon definiton, but got ".concat(K)), !isIconDefinition(K))
    return null;
  var ee = K;
  return ee && typeof ee.icon == "function" && (ee = _objectSpread$x({}, ee, {
    icon: ee.icon(Q.primaryColor, Q.secondaryColor)
  })), generate(ee.icon, "svg-".concat(ee.name), _objectSpread$x({}, X, {
    "data-icon": ee.name,
    width: "1em",
    height: "1em",
    fill: "currentColor",
    "aria-hidden": "true"
  }));
};
IconBase.props = {
  icon: Object,
  primaryColor: String,
  secondaryColor: String,
  focusable: String
};
IconBase.inheritAttrs = !1;
IconBase.displayName = "IconBase";
IconBase.getTwoToneColors = getTwoToneColors;
IconBase.setTwoToneColors = setTwoToneColors;
const VueIcon = IconBase;
function _slicedToArray$1(H, C) {
  return _arrayWithHoles$1(H) || _iterableToArrayLimit$1(H, C) || _unsupportedIterableToArray$1(H, C) || _nonIterableRest$1();
}
function _nonIterableRest$1() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function _unsupportedIterableToArray$1(H, C) {
  if (H) {
    if (typeof H == "string")
      return _arrayLikeToArray$1(H, C);
    var G = Object.prototype.toString.call(H).slice(8, -1);
    if (G === "Object" && H.constructor && (G = H.constructor.name), G === "Map" || G === "Set")
      return Array.from(H);
    if (G === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(G))
      return _arrayLikeToArray$1(H, C);
  }
}
function _arrayLikeToArray$1(H, C) {
  (C == null || C > H.length) && (C = H.length);
  for (var G = 0, U = new Array(C); G < C; G++)
    U[G] = H[G];
  return U;
}
function _iterableToArrayLimit$1(H, C) {
  var G = H == null ? null : typeof Symbol < "u" && H[Symbol.iterator] || H["@@iterator"];
  if (G != null) {
    var U = [], K = !0, W = !1, Z, X;
    try {
      for (G = G.call(H); !(K = (Z = G.next()).done) && (U.push(Z.value), !(C && U.length === C)); K = !0)
        ;
    } catch (Q) {
      W = !0, X = Q;
    } finally {
      try {
        !K && G.return != null && G.return();
      } finally {
        if (W)
          throw X;
      }
    }
    return U;
  }
}
function _arrayWithHoles$1(H) {
  if (Array.isArray(H))
    return H;
}
function setTwoToneColor(H) {
  var C = normalizeTwoToneColors(H), G = _slicedToArray$1(C, 2), U = G[0], K = G[1];
  return VueIcon.setTwoToneColors({
    primaryColor: U,
    secondaryColor: K
  });
}
function getTwoToneColor() {
  var H = VueIcon.getTwoToneColors();
  return H.calculated ? [H.primaryColor, H.secondaryColor] : H.primaryColor;
}
var _excluded$s = ["class", "icon", "spin", "rotate", "tabindex", "twoToneColor", "onClick"];
function _slicedToArray(H, C) {
  return _arrayWithHoles(H) || _iterableToArrayLimit(H, C) || _unsupportedIterableToArray(H, C) || _nonIterableRest();
}
function _nonIterableRest() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function _unsupportedIterableToArray(H, C) {
  if (H) {
    if (typeof H == "string")
      return _arrayLikeToArray(H, C);
    var G = Object.prototype.toString.call(H).slice(8, -1);
    if (G === "Object" && H.constructor && (G = H.constructor.name), G === "Map" || G === "Set")
      return Array.from(H);
    if (G === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(G))
      return _arrayLikeToArray(H, C);
  }
}
function _arrayLikeToArray(H, C) {
  (C == null || C > H.length) && (C = H.length);
  for (var G = 0, U = new Array(C); G < C; G++)
    U[G] = H[G];
  return U;
}
function _iterableToArrayLimit(H, C) {
  var G = H == null ? null : typeof Symbol < "u" && H[Symbol.iterator] || H["@@iterator"];
  if (G != null) {
    var U = [], K = !0, W = !1, Z, X;
    try {
      for (G = G.call(H); !(K = (Z = G.next()).done) && (U.push(Z.value), !(C && U.length === C)); K = !0)
        ;
    } catch (Q) {
      W = !0, X = Q;
    } finally {
      try {
        !K && G.return != null && G.return();
      } finally {
        if (W)
          throw X;
      }
    }
    return U;
  }
}
function _arrayWithHoles(H) {
  if (Array.isArray(H))
    return H;
}
function _objectSpread$w(H) {
  for (var C = 1; C < arguments.length; C++) {
    var G = arguments[C] != null ? Object(arguments[C]) : {}, U = Object.keys(G);
    typeof Object.getOwnPropertySymbols == "function" && (U = U.concat(Object.getOwnPropertySymbols(G).filter(function(K) {
      return Object.getOwnPropertyDescriptor(G, K).enumerable;
    }))), U.forEach(function(K) {
      _defineProperty$x(H, K, G[K]);
    });
  }
  return H;
}
function _defineProperty$x(H, C, G) {
  return C in H ? Object.defineProperty(H, C, { value: G, enumerable: !0, configurable: !0, writable: !0 }) : H[C] = G, H;
}
function _objectWithoutProperties(H, C) {
  if (H == null)
    return {};
  var G = _objectWithoutPropertiesLoose(H, C), U, K;
  if (Object.getOwnPropertySymbols) {
    var W = Object.getOwnPropertySymbols(H);
    for (K = 0; K < W.length; K++)
      U = W[K], !(C.indexOf(U) >= 0) && Object.prototype.propertyIsEnumerable.call(H, U) && (G[U] = H[U]);
  }
  return G;
}
function _objectWithoutPropertiesLoose(H, C) {
  if (H == null)
    return {};
  var G = {}, U = Object.keys(H), K, W;
  for (W = 0; W < U.length; W++)
    K = U[W], !(C.indexOf(K) >= 0) && (G[K] = H[K]);
  return G;
}
setTwoToneColor("#1890ff");
var Icon = function(C, G) {
  var U, K = _objectSpread$w({}, C, G.attrs), W = K.class, Z = K.icon, X = K.spin, Q = K.rotate, ee = K.tabindex, te = K.twoToneColor, re = K.onClick, ne = _objectWithoutProperties(K, _excluded$s), ae = (U = {
    anticon: !0
  }, _defineProperty$x(U, "anticon-".concat(Z.name), Boolean(Z.name)), _defineProperty$x(U, W, W), U), ie = X === "" || X || Z.name === "loading" ? "anticon-spin" : "", se = ee;
  se === void 0 && re && (se = -1, ne.tabindex = se);
  var oe = Q ? {
    msTransform: "rotate(".concat(Q, "deg)"),
    transform: "rotate(".concat(Q, "deg)")
  } : void 0, le = normalizeTwoToneColors(te), ue = _slicedToArray(le, 2), ce = ue[0], de = ue[1];
  return createVNode$1("span", _objectSpread$w({
    role: "img",
    "aria-label": Z.name
  }, ne, {
    onClick: re,
    class: ae
  }), [createVNode$1(VueIcon, {
    class: ie,
    icon: Z,
    primaryColor: ce,
    secondaryColor: de,
    style: oe
  }, null)]);
};
Icon.props = {
  spin: Boolean,
  rotate: Number,
  icon: Object,
  twoToneColor: String
};
Icon.displayName = "AntdIcon";
Icon.inheritAttrs = !1;
Icon.getTwoToneColor = getTwoToneColor;
Icon.setTwoToneColor = setTwoToneColor;
const AntdIcon = Icon;
function _objectSpread$v(H) {
  for (var C = 1; C < arguments.length; C++) {
    var G = arguments[C] != null ? Object(arguments[C]) : {}, U = Object.keys(G);
    typeof Object.getOwnPropertySymbols == "function" && (U = U.concat(Object.getOwnPropertySymbols(G).filter(function(K) {
      return Object.getOwnPropertyDescriptor(G, K).enumerable;
    }))), U.forEach(function(K) {
      _defineProperty$w(H, K, G[K]);
    });
  }
  return H;
}
function _defineProperty$w(H, C, G) {
  return C in H ? Object.defineProperty(H, C, { value: G, enumerable: !0, configurable: !0, writable: !0 }) : H[C] = G, H;
}
var LoadingOutlined = function(C, G) {
  var U = _objectSpread$v({}, C, G.attrs);
  return createVNode$1(AntdIcon, _objectSpread$v({}, U, {
    icon: LoadingOutlinedSvg
  }), null);
};
LoadingOutlined.displayName = "LoadingOutlined";
LoadingOutlined.inheritAttrs = !1;
const LoadingOutlined$1 = LoadingOutlined;
var ExclamationCircleFilled$2 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm-32 232c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V296zm32 440a48.01 48.01 0 010-96 48.01 48.01 0 010 96z" } }] }, name: "exclamation-circle", theme: "filled" };
const ExclamationCircleFilledSvg = ExclamationCircleFilled$2;
function _objectSpread$u(H) {
  for (var C = 1; C < arguments.length; C++) {
    var G = arguments[C] != null ? Object(arguments[C]) : {}, U = Object.keys(G);
    typeof Object.getOwnPropertySymbols == "function" && (U = U.concat(Object.getOwnPropertySymbols(G).filter(function(K) {
      return Object.getOwnPropertyDescriptor(G, K).enumerable;
    }))), U.forEach(function(K) {
      _defineProperty$v(H, K, G[K]);
    });
  }
  return H;
}
function _defineProperty$v(H, C, G) {
  return C in H ? Object.defineProperty(H, C, { value: G, enumerable: !0, configurable: !0, writable: !0 }) : H[C] = G, H;
}
var ExclamationCircleFilled = function(C, G) {
  var U = _objectSpread$u({}, C, G.attrs);
  return createVNode$1(AntdIcon, _objectSpread$u({}, U, {
    icon: ExclamationCircleFilledSvg
  }), null);
};
ExclamationCircleFilled.displayName = "ExclamationCircleFilled";
ExclamationCircleFilled.inheritAttrs = !1;
const ExclamationCircleFilled$1 = ExclamationCircleFilled;
var CloseCircleFilled$2 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm165.4 618.2l-66-.3L512 563.4l-99.3 118.4-66.1.3c-4.4 0-8-3.5-8-8 0-1.9.7-3.7 1.9-5.2l130.1-155L340.5 359a8.32 8.32 0 01-1.9-5.2c0-4.4 3.6-8 8-8l66.1.3L512 464.6l99.3-118.4 66-.3c4.4 0 8 3.5 8 8 0 1.9-.7 3.7-1.9 5.2L553.5 514l130 155c1.2 1.5 1.9 3.3 1.9 5.2 0 4.4-3.6 8-8 8z" } }] }, name: "close-circle", theme: "filled" };
const CloseCircleFilledSvg = CloseCircleFilled$2;
function _objectSpread$t(H) {
  for (var C = 1; C < arguments.length; C++) {
    var G = arguments[C] != null ? Object(arguments[C]) : {}, U = Object.keys(G);
    typeof Object.getOwnPropertySymbols == "function" && (U = U.concat(Object.getOwnPropertySymbols(G).filter(function(K) {
      return Object.getOwnPropertyDescriptor(G, K).enumerable;
    }))), U.forEach(function(K) {
      _defineProperty$u(H, K, G[K]);
    });
  }
  return H;
}
function _defineProperty$u(H, C, G) {
  return C in H ? Object.defineProperty(H, C, { value: G, enumerable: !0, configurable: !0, writable: !0 }) : H[C] = G, H;
}
var CloseCircleFilled = function(C, G) {
  var U = _objectSpread$t({}, C, G.attrs);
  return createVNode$1(AntdIcon, _objectSpread$t({}, U, {
    icon: CloseCircleFilledSvg
  }), null);
};
CloseCircleFilled.displayName = "CloseCircleFilled";
CloseCircleFilled.inheritAttrs = !1;
const CloseCircleFilled$1 = CloseCircleFilled;
var CheckCircleFilled$2 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm193.5 301.7l-210.6 292a31.8 31.8 0 01-51.7 0L318.5 484.9c-3.8-5.3 0-12.7 6.5-12.7h46.9c10.2 0 19.9 4.9 25.9 13.3l71.2 98.8 157.2-218c6-8.3 15.6-13.3 25.9-13.3H699c6.5 0 10.3 7.4 6.5 12.7z" } }] }, name: "check-circle", theme: "filled" };
const CheckCircleFilledSvg = CheckCircleFilled$2;
function _objectSpread$s(H) {
  for (var C = 1; C < arguments.length; C++) {
    var G = arguments[C] != null ? Object(arguments[C]) : {}, U = Object.keys(G);
    typeof Object.getOwnPropertySymbols == "function" && (U = U.concat(Object.getOwnPropertySymbols(G).filter(function(K) {
      return Object.getOwnPropertyDescriptor(G, K).enumerable;
    }))), U.forEach(function(K) {
      _defineProperty$t(H, K, G[K]);
    });
  }
  return H;
}
function _defineProperty$t(H, C, G) {
  return C in H ? Object.defineProperty(H, C, { value: G, enumerable: !0, configurable: !0, writable: !0 }) : H[C] = G, H;
}
var CheckCircleFilled = function(C, G) {
  var U = _objectSpread$s({}, C, G.attrs);
  return createVNode$1(AntdIcon, _objectSpread$s({}, U, {
    icon: CheckCircleFilledSvg
  }), null);
};
CheckCircleFilled.displayName = "CheckCircleFilled";
CheckCircleFilled.inheritAttrs = !1;
const CheckCircleFilled$1 = CheckCircleFilled;
var InfoCircleFilled$2 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm32 664c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V456c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272zm-32-344a48.01 48.01 0 010-96 48.01 48.01 0 010 96z" } }] }, name: "info-circle", theme: "filled" };
const InfoCircleFilledSvg = InfoCircleFilled$2;
function _objectSpread$r(H) {
  for (var C = 1; C < arguments.length; C++) {
    var G = arguments[C] != null ? Object(arguments[C]) : {}, U = Object.keys(G);
    typeof Object.getOwnPropertySymbols == "function" && (U = U.concat(Object.getOwnPropertySymbols(G).filter(function(K) {
      return Object.getOwnPropertyDescriptor(G, K).enumerable;
    }))), U.forEach(function(K) {
      _defineProperty$s(H, K, G[K]);
    });
  }
  return H;
}
function _defineProperty$s(H, C, G) {
  return C in H ? Object.defineProperty(H, C, { value: G, enumerable: !0, configurable: !0, writable: !0 }) : H[C] = G, H;
}
var InfoCircleFilled = function(C, G) {
  var U = _objectSpread$r({}, C, G.attrs);
  return createVNode$1(AntdIcon, _objectSpread$r({}, U, {
    icon: InfoCircleFilledSvg
  }), null);
};
InfoCircleFilled.displayName = "InfoCircleFilled";
InfoCircleFilled.inheritAttrs = !1;
const InfoCircleFilled$1 = InfoCircleFilled;
var defaultDuration$1 = 3, defaultTop$1, messageInstance, key = 1, localPrefixCls = "", transitionName = "move-up", hasTransitionName = !1, getContainer$1 = function() {
  return document.body;
}, maxCount$1, rtl$1 = !1;
function getKeyThenIncreaseKey() {
  return key++;
}
function setMessageConfig(H) {
  H.top !== void 0 && (defaultTop$1 = H.top, messageInstance = null), H.duration !== void 0 && (defaultDuration$1 = H.duration), H.prefixCls !== void 0 && (localPrefixCls = H.prefixCls), H.getContainer !== void 0 && (getContainer$1 = H.getContainer, messageInstance = null), H.transitionName !== void 0 && (transitionName = H.transitionName, messageInstance = null, hasTransitionName = !0), H.maxCount !== void 0 && (maxCount$1 = H.maxCount, messageInstance = null), H.rtl !== void 0 && (rtl$1 = H.rtl);
}
function getMessageInstance(H, C) {
  if (messageInstance) {
    C(messageInstance);
    return;
  }
  Notification$1.newInstance({
    appContext: H.appContext,
    prefixCls: H.prefixCls || localPrefixCls,
    rootPrefixCls: H.rootPrefixCls,
    transitionName,
    hasTransitionName,
    style: {
      top: defaultTop$1
    },
    getContainer: getContainer$1 || H.getPopupContainer,
    maxCount: maxCount$1,
    name: "message"
  }, function(G) {
    if (messageInstance) {
      C(messageInstance);
      return;
    }
    messageInstance = G, C(G);
  });
}
var typeToIcon$1 = {
  info: InfoCircleFilled$1,
  success: CheckCircleFilled$1,
  error: CloseCircleFilled$1,
  warning: ExclamationCircleFilled$1,
  loading: LoadingOutlined$1
};
function notice$1(H) {
  var C = H.duration !== void 0 ? H.duration : defaultDuration$1, G = H.key || getKeyThenIncreaseKey(), U = new Promise(function(W) {
    var Z = function() {
      return typeof H.onClose == "function" && H.onClose(), W(!0);
    };
    getMessageInstance(H, function(X) {
      X.notice({
        key: G,
        duration: C,
        style: H.style || {},
        class: H.class,
        content: function(ee) {
          var te, re = ee.prefixCls, ne = typeToIcon$1[H.type], ae = ne ? createVNode$1(ne, null, null) : "", ie = classNames("".concat(re, "-custom-content"), (te = {}, _defineProperty$A(te, "".concat(re, "-").concat(H.type), H.type), _defineProperty$A(te, "".concat(re, "-rtl"), rtl$1 === !0), te));
          return createVNode$1("div", {
            class: ie
          }, [typeof H.icon == "function" ? H.icon() : H.icon || ae, createVNode$1("span", null, [typeof H.content == "function" ? H.content() : H.content])]);
        },
        onClose: Z,
        onClick: H.onClick
      });
    });
  }), K = function() {
    messageInstance && messageInstance.removeNotice(G);
  };
  return K.then = function(W, Z) {
    return U.then(W, Z);
  }, K.promise = U, K;
}
function isArgsProps(H) {
  return Object.prototype.toString.call(H) === "[object Object]" && !!H.content;
}
var api$1 = {
  open: notice$1,
  config: setMessageConfig,
  destroy: function(C) {
    if (messageInstance)
      if (C) {
        var G = messageInstance, U = G.removeNotice;
        U(C);
      } else {
        var K = messageInstance, W = K.destroy;
        W(), messageInstance = null;
      }
  }
};
function attachTypeApi(H, C) {
  H[C] = function(G, U, K) {
    return isArgsProps(G) ? H.open(_objectSpread2$1(_objectSpread2$1({}, G), {}, {
      type: C
    })) : (typeof U == "function" && (K = U, U = void 0), H.open({
      content: G,
      duration: U,
      type: C,
      onClose: K
    }));
  };
}
["success", "info", "warning", "error", "loading"].forEach(function(H) {
  return attachTypeApi(api$1, H);
});
api$1.warn = api$1.warning;
const message = api$1;
function asyncGeneratorStep(H, C, G, U, K, W, Z) {
  try {
    var X = H[W](Z), Q = X.value;
  } catch (ee) {
    G(ee);
    return;
  }
  X.done ? C(Q) : Promise.resolve(Q).then(U, K);
}
function _asyncToGenerator(H) {
  return function() {
    var C = this, G = arguments;
    return new Promise(function(U, K) {
      var W = H.apply(C, G);
      function Z(Q) {
        asyncGeneratorStep(W, U, K, Z, X, "next", Q);
      }
      function X(Q) {
        asyncGeneratorStep(W, U, K, Z, X, "throw", Q);
      }
      Z(void 0);
    });
  };
}
var regeneratorRuntimeExports = {}, regeneratorRuntime$1 = {
  get exports() {
    return regeneratorRuntimeExports;
  },
  set exports(H) {
    regeneratorRuntimeExports = H;
  }
}, _typeofExports = {}, _typeof$1 = {
  get exports() {
    return _typeofExports;
  },
  set exports(H) {
    _typeofExports = H;
  }
};
(function(H) {
  function C(G) {
    return H.exports = C = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(U) {
      return typeof U;
    } : function(U) {
      return U && typeof Symbol == "function" && U.constructor === Symbol && U !== Symbol.prototype ? "symbol" : typeof U;
    }, H.exports.__esModule = !0, H.exports.default = H.exports, C(G);
  }
  H.exports = C, H.exports.__esModule = !0, H.exports.default = H.exports;
})(_typeof$1);
(function(H) {
  var C = _typeofExports.default;
  function G() {
    H.exports = G = function() {
      return U;
    }, H.exports.__esModule = !0, H.exports.default = H.exports;
    var U = {}, K = Object.prototype, W = K.hasOwnProperty, Z = Object.defineProperty || function(Se, Ae, _e) {
      Se[Ae] = _e.value;
    }, X = typeof Symbol == "function" ? Symbol : {}, Q = X.iterator || "@@iterator", ee = X.asyncIterator || "@@asyncIterator", te = X.toStringTag || "@@toStringTag";
    function re(Se, Ae, _e) {
      return Object.defineProperty(Se, Ae, {
        value: _e,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }), Se[Ae];
    }
    try {
      re({}, "");
    } catch {
      re = function(_e, xe, Te) {
        return _e[xe] = Te;
      };
    }
    function ne(Se, Ae, _e, xe) {
      var Te = Ae && Ae.prototype instanceof se ? Ae : se, Pe = Object.create(Te.prototype), $e = new Ce(xe || []);
      return Z(Pe, "_invoke", {
        value: pe(Se, _e, $e)
      }), Pe;
    }
    function ae(Se, Ae, _e) {
      try {
        return {
          type: "normal",
          arg: Se.call(Ae, _e)
        };
      } catch (xe) {
        return {
          type: "throw",
          arg: xe
        };
      }
    }
    U.wrap = ne;
    var ie = {};
    function se() {
    }
    function oe() {
    }
    function le() {
    }
    var ue = {};
    re(ue, Q, function() {
      return this;
    });
    var ce = Object.getPrototypeOf, de = ce && ce(ce(Ie([])));
    de && de !== K && W.call(de, Q) && (ue = de);
    var ge = le.prototype = se.prototype = Object.create(ue);
    function fe(Se) {
      ["next", "throw", "return"].forEach(function(Ae) {
        re(Se, Ae, function(_e) {
          return this._invoke(Ae, _e);
        });
      });
    }
    function ve(Se, Ae) {
      function _e(Te, Pe, $e, Me) {
        var Ee = ae(Se[Te], Se, Pe);
        if (Ee.type !== "throw") {
          var we = Ee.arg, Oe = we.value;
          return Oe && C(Oe) == "object" && W.call(Oe, "__await") ? Ae.resolve(Oe.__await).then(function(Ne) {
            _e("next", Ne, $e, Me);
          }, function(Ne) {
            _e("throw", Ne, $e, Me);
          }) : Ae.resolve(Oe).then(function(Ne) {
            we.value = Ne, $e(we);
          }, function(Ne) {
            return _e("throw", Ne, $e, Me);
          });
        }
        Me(Ee.arg);
      }
      var xe;
      Z(this, "_invoke", {
        value: function(Pe, $e) {
          function Me() {
            return new Ae(function(Ee, we) {
              _e(Pe, $e, Ee, we);
            });
          }
          return xe = xe ? xe.then(Me, Me) : Me();
        }
      });
    }
    function pe(Se, Ae, _e) {
      var xe = "suspendedStart";
      return function(Te, Pe) {
        if (xe === "executing")
          throw new Error("Generator is already running");
        if (xe === "completed") {
          if (Te === "throw")
            throw Pe;
          return be();
        }
        for (_e.method = Te, _e.arg = Pe; ; ) {
          var $e = _e.delegate;
          if ($e) {
            var Me = he($e, _e);
            if (Me) {
              if (Me === ie)
                continue;
              return Me;
            }
          }
          if (_e.method === "next")
            _e.sent = _e._sent = _e.arg;
          else if (_e.method === "throw") {
            if (xe === "suspendedStart")
              throw xe = "completed", _e.arg;
            _e.dispatchException(_e.arg);
          } else
            _e.method === "return" && _e.abrupt("return", _e.arg);
          xe = "executing";
          var Ee = ae(Se, Ae, _e);
          if (Ee.type === "normal") {
            if (xe = _e.done ? "completed" : "suspendedYield", Ee.arg === ie)
              continue;
            return {
              value: Ee.arg,
              done: _e.done
            };
          }
          Ee.type === "throw" && (xe = "completed", _e.method = "throw", _e.arg = Ee.arg);
        }
      };
    }
    function he(Se, Ae) {
      var _e = Ae.method, xe = Se.iterator[_e];
      if (xe === void 0)
        return Ae.delegate = null, _e === "throw" && Se.iterator.return && (Ae.method = "return", Ae.arg = void 0, he(Se, Ae), Ae.method === "throw") || _e !== "return" && (Ae.method = "throw", Ae.arg = new TypeError("The iterator does not provide a '" + _e + "' method")), ie;
      var Te = ae(xe, Se.iterator, Ae.arg);
      if (Te.type === "throw")
        return Ae.method = "throw", Ae.arg = Te.arg, Ae.delegate = null, ie;
      var Pe = Te.arg;
      return Pe ? Pe.done ? (Ae[Se.resultName] = Pe.value, Ae.next = Se.nextLoc, Ae.method !== "return" && (Ae.method = "next", Ae.arg = void 0), Ae.delegate = null, ie) : Pe : (Ae.method = "throw", Ae.arg = new TypeError("iterator result is not an object"), Ae.delegate = null, ie);
    }
    function me(Se) {
      var Ae = {
        tryLoc: Se[0]
      };
      1 in Se && (Ae.catchLoc = Se[1]), 2 in Se && (Ae.finallyLoc = Se[2], Ae.afterLoc = Se[3]), this.tryEntries.push(Ae);
    }
    function ye(Se) {
      var Ae = Se.completion || {};
      Ae.type = "normal", delete Ae.arg, Se.completion = Ae;
    }
    function Ce(Se) {
      this.tryEntries = [{
        tryLoc: "root"
      }], Se.forEach(me, this), this.reset(!0);
    }
    function Ie(Se) {
      if (Se) {
        var Ae = Se[Q];
        if (Ae)
          return Ae.call(Se);
        if (typeof Se.next == "function")
          return Se;
        if (!isNaN(Se.length)) {
          var _e = -1, xe = function Te() {
            for (; ++_e < Se.length; )
              if (W.call(Se, _e))
                return Te.value = Se[_e], Te.done = !1, Te;
            return Te.value = void 0, Te.done = !0, Te;
          };
          return xe.next = xe;
        }
      }
      return {
        next: be
      };
    }
    function be() {
      return {
        value: void 0,
        done: !0
      };
    }
    return oe.prototype = le, Z(ge, "constructor", {
      value: le,
      configurable: !0
    }), Z(le, "constructor", {
      value: oe,
      configurable: !0
    }), oe.displayName = re(le, te, "GeneratorFunction"), U.isGeneratorFunction = function(Se) {
      var Ae = typeof Se == "function" && Se.constructor;
      return !!Ae && (Ae === oe || (Ae.displayName || Ae.name) === "GeneratorFunction");
    }, U.mark = function(Se) {
      return Object.setPrototypeOf ? Object.setPrototypeOf(Se, le) : (Se.__proto__ = le, re(Se, te, "GeneratorFunction")), Se.prototype = Object.create(ge), Se;
    }, U.awrap = function(Se) {
      return {
        __await: Se
      };
    }, fe(ve.prototype), re(ve.prototype, ee, function() {
      return this;
    }), U.AsyncIterator = ve, U.async = function(Se, Ae, _e, xe, Te) {
      Te === void 0 && (Te = Promise);
      var Pe = new ve(ne(Se, Ae, _e, xe), Te);
      return U.isGeneratorFunction(Ae) ? Pe : Pe.next().then(function($e) {
        return $e.done ? $e.value : Pe.next();
      });
    }, fe(ge), re(ge, te, "Generator"), re(ge, Q, function() {
      return this;
    }), re(ge, "toString", function() {
      return "[object Generator]";
    }), U.keys = function(Se) {
      var Ae = Object(Se), _e = [];
      for (var xe in Ae)
        _e.push(xe);
      return _e.reverse(), function Te() {
        for (; _e.length; ) {
          var Pe = _e.pop();
          if (Pe in Ae)
            return Te.value = Pe, Te.done = !1, Te;
        }
        return Te.done = !0, Te;
      };
    }, U.values = Ie, Ce.prototype = {
      constructor: Ce,
      reset: function(Ae) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = !1, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(ye), !Ae)
          for (var _e in this)
            _e.charAt(0) === "t" && W.call(this, _e) && !isNaN(+_e.slice(1)) && (this[_e] = void 0);
      },
      stop: function() {
        this.done = !0;
        var Ae = this.tryEntries[0].completion;
        if (Ae.type === "throw")
          throw Ae.arg;
        return this.rval;
      },
      dispatchException: function(Ae) {
        if (this.done)
          throw Ae;
        var _e = this;
        function xe(we, Oe) {
          return $e.type = "throw", $e.arg = Ae, _e.next = we, Oe && (_e.method = "next", _e.arg = void 0), !!Oe;
        }
        for (var Te = this.tryEntries.length - 1; Te >= 0; --Te) {
          var Pe = this.tryEntries[Te], $e = Pe.completion;
          if (Pe.tryLoc === "root")
            return xe("end");
          if (Pe.tryLoc <= this.prev) {
            var Me = W.call(Pe, "catchLoc"), Ee = W.call(Pe, "finallyLoc");
            if (Me && Ee) {
              if (this.prev < Pe.catchLoc)
                return xe(Pe.catchLoc, !0);
              if (this.prev < Pe.finallyLoc)
                return xe(Pe.finallyLoc);
            } else if (Me) {
              if (this.prev < Pe.catchLoc)
                return xe(Pe.catchLoc, !0);
            } else {
              if (!Ee)
                throw new Error("try statement without catch or finally");
              if (this.prev < Pe.finallyLoc)
                return xe(Pe.finallyLoc);
            }
          }
        }
      },
      abrupt: function(Ae, _e) {
        for (var xe = this.tryEntries.length - 1; xe >= 0; --xe) {
          var Te = this.tryEntries[xe];
          if (Te.tryLoc <= this.prev && W.call(Te, "finallyLoc") && this.prev < Te.finallyLoc) {
            var Pe = Te;
            break;
          }
        }
        Pe && (Ae === "break" || Ae === "continue") && Pe.tryLoc <= _e && _e <= Pe.finallyLoc && (Pe = null);
        var $e = Pe ? Pe.completion : {};
        return $e.type = Ae, $e.arg = _e, Pe ? (this.method = "next", this.next = Pe.finallyLoc, ie) : this.complete($e);
      },
      complete: function(Ae, _e) {
        if (Ae.type === "throw")
          throw Ae.arg;
        return Ae.type === "break" || Ae.type === "continue" ? this.next = Ae.arg : Ae.type === "return" ? (this.rval = this.arg = Ae.arg, this.method = "return", this.next = "end") : Ae.type === "normal" && _e && (this.next = _e), ie;
      },
      finish: function(Ae) {
        for (var _e = this.tryEntries.length - 1; _e >= 0; --_e) {
          var xe = this.tryEntries[_e];
          if (xe.finallyLoc === Ae)
            return this.complete(xe.completion, xe.afterLoc), ye(xe), ie;
        }
      },
      catch: function(Ae) {
        for (var _e = this.tryEntries.length - 1; _e >= 0; --_e) {
          var xe = this.tryEntries[_e];
          if (xe.tryLoc === Ae) {
            var Te = xe.completion;
            if (Te.type === "throw") {
              var Pe = Te.arg;
              ye(xe);
            }
            return Pe;
          }
        }
        throw new Error("illegal catch attempt");
      },
      delegateYield: function(Ae, _e, xe) {
        return this.delegate = {
          iterator: Ie(Ae),
          resultName: _e,
          nextLoc: xe
        }, this.method === "next" && (this.arg = void 0), ie;
      }
    }, U;
  }
  H.exports = G, H.exports.__esModule = !0, H.exports.default = H.exports;
})(regeneratorRuntime$1);
var runtime = regeneratorRuntimeExports(), regenerator = runtime;
try {
  regeneratorRuntime = runtime;
} catch {
  typeof globalThis == "object" ? globalThis.regeneratorRuntime = runtime : Function("r", "regeneratorRuntime = r")(runtime);
}
var CheckCircleOutlined$2 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M699 353h-46.9c-10.2 0-19.9 4.9-25.9 13.3L469 584.3l-71.2-98.8c-6-8.3-15.6-13.3-25.9-13.3H325c-6.5 0-10.3 7.4-6.5 12.7l124.6 172.8a31.8 31.8 0 0051.7 0l210.6-292c3.9-5.3.1-12.7-6.4-12.7z" } }, { tag: "path", attrs: { d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" } }] }, name: "check-circle", theme: "outlined" };
const CheckCircleOutlinedSvg = CheckCircleOutlined$2;
function _objectSpread$q(H) {
  for (var C = 1; C < arguments.length; C++) {
    var G = arguments[C] != null ? Object(arguments[C]) : {}, U = Object.keys(G);
    typeof Object.getOwnPropertySymbols == "function" && (U = U.concat(Object.getOwnPropertySymbols(G).filter(function(K) {
      return Object.getOwnPropertyDescriptor(G, K).enumerable;
    }))), U.forEach(function(K) {
      _defineProperty$r(H, K, G[K]);
    });
  }
  return H;
}
function _defineProperty$r(H, C, G) {
  return C in H ? Object.defineProperty(H, C, { value: G, enumerable: !0, configurable: !0, writable: !0 }) : H[C] = G, H;
}
var CheckCircleOutlined = function(C, G) {
  var U = _objectSpread$q({}, C, G.attrs);
  return createVNode$1(AntdIcon, _objectSpread$q({}, U, {
    icon: CheckCircleOutlinedSvg
  }), null);
};
CheckCircleOutlined.displayName = "CheckCircleOutlined";
CheckCircleOutlined.inheritAttrs = !1;
const CheckCircleOutlined$1 = CheckCircleOutlined;
var InfoCircleOutlined$2 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" } }, { tag: "path", attrs: { d: "M464 336a48 48 0 1096 0 48 48 0 10-96 0zm72 112h-48c-4.4 0-8 3.6-8 8v272c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V456c0-4.4-3.6-8-8-8z" } }] }, name: "info-circle", theme: "outlined" };
const InfoCircleOutlinedSvg = InfoCircleOutlined$2;
function _objectSpread$p(H) {
  for (var C = 1; C < arguments.length; C++) {
    var G = arguments[C] != null ? Object(arguments[C]) : {}, U = Object.keys(G);
    typeof Object.getOwnPropertySymbols == "function" && (U = U.concat(Object.getOwnPropertySymbols(G).filter(function(K) {
      return Object.getOwnPropertyDescriptor(G, K).enumerable;
    }))), U.forEach(function(K) {
      _defineProperty$q(H, K, G[K]);
    });
  }
  return H;
}
function _defineProperty$q(H, C, G) {
  return C in H ? Object.defineProperty(H, C, { value: G, enumerable: !0, configurable: !0, writable: !0 }) : H[C] = G, H;
}
var InfoCircleOutlined = function(C, G) {
  var U = _objectSpread$p({}, C, G.attrs);
  return createVNode$1(AntdIcon, _objectSpread$p({}, U, {
    icon: InfoCircleOutlinedSvg
  }), null);
};
InfoCircleOutlined.displayName = "InfoCircleOutlined";
InfoCircleOutlined.inheritAttrs = !1;
const InfoCircleOutlined$1 = InfoCircleOutlined;
var CloseCircleOutlined$2 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M685.4 354.8c0-4.4-3.6-8-8-8l-66 .3L512 465.6l-99.3-118.4-66.1-.3c-4.4 0-8 3.5-8 8 0 1.9.7 3.7 1.9 5.2l130.1 155L340.5 670a8.32 8.32 0 00-1.9 5.2c0 4.4 3.6 8 8 8l66.1-.3L512 564.4l99.3 118.4 66 .3c4.4 0 8-3.5 8-8 0-1.9-.7-3.7-1.9-5.2L553.5 515l130.1-155c1.2-1.4 1.8-3.3 1.8-5.2z" } }, { tag: "path", attrs: { d: "M512 65C264.6 65 64 265.6 64 513s200.6 448 448 448 448-200.6 448-448S759.4 65 512 65zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" } }] }, name: "close-circle", theme: "outlined" };
const CloseCircleOutlinedSvg = CloseCircleOutlined$2;
function _objectSpread$o(H) {
  for (var C = 1; C < arguments.length; C++) {
    var G = arguments[C] != null ? Object(arguments[C]) : {}, U = Object.keys(G);
    typeof Object.getOwnPropertySymbols == "function" && (U = U.concat(Object.getOwnPropertySymbols(G).filter(function(K) {
      return Object.getOwnPropertyDescriptor(G, K).enumerable;
    }))), U.forEach(function(K) {
      _defineProperty$p(H, K, G[K]);
    });
  }
  return H;
}
function _defineProperty$p(H, C, G) {
  return C in H ? Object.defineProperty(H, C, { value: G, enumerable: !0, configurable: !0, writable: !0 }) : H[C] = G, H;
}
var CloseCircleOutlined = function(C, G) {
  var U = _objectSpread$o({}, C, G.attrs);
  return createVNode$1(AntdIcon, _objectSpread$o({}, U, {
    icon: CloseCircleOutlinedSvg
  }), null);
};
CloseCircleOutlined.displayName = "CloseCircleOutlined";
CloseCircleOutlined.inheritAttrs = !1;
const CloseCircleOutlined$1 = CloseCircleOutlined;
var ExclamationCircleOutlined$2 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" } }, { tag: "path", attrs: { d: "M464 688a48 48 0 1096 0 48 48 0 10-96 0zm24-112h48c4.4 0 8-3.6 8-8V296c0-4.4-3.6-8-8-8h-48c-4.4 0-8 3.6-8 8v272c0 4.4 3.6 8 8 8z" } }] }, name: "exclamation-circle", theme: "outlined" };
const ExclamationCircleOutlinedSvg = ExclamationCircleOutlined$2;
function _objectSpread$n(H) {
  for (var C = 1; C < arguments.length; C++) {
    var G = arguments[C] != null ? Object(arguments[C]) : {}, U = Object.keys(G);
    typeof Object.getOwnPropertySymbols == "function" && (U = U.concat(Object.getOwnPropertySymbols(G).filter(function(K) {
      return Object.getOwnPropertyDescriptor(G, K).enumerable;
    }))), U.forEach(function(K) {
      _defineProperty$o(H, K, G[K]);
    });
  }
  return H;
}
function _defineProperty$o(H, C, G) {
  return C in H ? Object.defineProperty(H, C, { value: G, enumerable: !0, configurable: !0, writable: !0 }) : H[C] = G, H;
}
var ExclamationCircleOutlined = function(C, G) {
  var U = _objectSpread$n({}, C, G.attrs);
  return createVNode$1(AntdIcon, _objectSpread$n({}, U, {
    icon: ExclamationCircleOutlinedSvg
  }), null);
};
ExclamationCircleOutlined.displayName = "ExclamationCircleOutlined";
ExclamationCircleOutlined.inheritAttrs = !1;
const ExclamationCircleOutlined$1 = ExclamationCircleOutlined;
var CloseOutlined$2 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M563.8 512l262.5-312.9c4.4-5.2.7-13.1-6.1-13.1h-79.8c-4.7 0-9.2 2.1-12.3 5.7L511.6 449.8 295.1 191.7c-3-3.6-7.5-5.7-12.3-5.7H203c-6.8 0-10.5 7.9-6.1 13.1L459.4 512 196.9 824.9A7.95 7.95 0 00203 838h79.8c4.7 0 9.2-2.1 12.3-5.7l216.5-258.1 216.5 258.1c3 3.6 7.5 5.7 12.3 5.7h79.8c6.8 0 10.5-7.9 6.1-13.1L563.8 512z" } }] }, name: "close", theme: "outlined" };
const CloseOutlinedSvg = CloseOutlined$2;
function _objectSpread$m(H) {
  for (var C = 1; C < arguments.length; C++) {
    var G = arguments[C] != null ? Object(arguments[C]) : {}, U = Object.keys(G);
    typeof Object.getOwnPropertySymbols == "function" && (U = U.concat(Object.getOwnPropertySymbols(G).filter(function(K) {
      return Object.getOwnPropertyDescriptor(G, K).enumerable;
    }))), U.forEach(function(K) {
      _defineProperty$n(H, K, G[K]);
    });
  }
  return H;
}
function _defineProperty$n(H, C, G) {
  return C in H ? Object.defineProperty(H, C, { value: G, enumerable: !0, configurable: !0, writable: !0 }) : H[C] = G, H;
}
var CloseOutlined = function(C, G) {
  var U = _objectSpread$m({}, C, G.attrs);
  return createVNode$1(AntdIcon, _objectSpread$m({}, U, {
    icon: CloseOutlinedSvg
  }), null);
};
CloseOutlined.displayName = "CloseOutlined";
CloseOutlined.inheritAttrs = !1;
const CloseOutlined$1 = CloseOutlined;
var notificationInstance = {}, defaultDuration = 4.5, defaultTop = "24px", defaultBottom = "24px", defaultPrefixCls$1 = "", defaultPlacement = "topRight", defaultGetContainer = function() {
  return document.body;
}, defaultCloseIcon = null, rtl = !1, maxCount;
function setNotificationConfig(H) {
  var C = H.duration, G = H.placement, U = H.bottom, K = H.top, W = H.getContainer, Z = H.closeIcon, X = H.prefixCls;
  X !== void 0 && (defaultPrefixCls$1 = X), C !== void 0 && (defaultDuration = C), G !== void 0 && (defaultPlacement = G), U !== void 0 && (defaultBottom = typeof U == "number" ? "".concat(U, "px") : U), K !== void 0 && (defaultTop = typeof K == "number" ? "".concat(K, "px") : K), W !== void 0 && (defaultGetContainer = W), Z !== void 0 && (defaultCloseIcon = Z), H.rtl !== void 0 && (rtl = H.rtl), H.maxCount !== void 0 && (maxCount = H.maxCount);
}
function getPlacementStyle(H) {
  var C = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : defaultTop, G = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : defaultBottom, U;
  switch (H) {
    case "topLeft":
      U = {
        left: "0px",
        top: C,
        bottom: "auto"
      };
      break;
    case "topRight":
      U = {
        right: "0px",
        top: C,
        bottom: "auto"
      };
      break;
    case "bottomLeft":
      U = {
        left: "0px",
        top: "auto",
        bottom: G
      };
      break;
    default:
      U = {
        right: "0px",
        top: "auto",
        bottom: G
      };
      break;
  }
  return U;
}
function getNotificationInstance(H, C) {
  var G = H.prefixCls, U = H.placement, K = U === void 0 ? defaultPlacement : U, W = H.getContainer, Z = W === void 0 ? defaultGetContainer : W, X = H.top, Q = H.bottom, ee = H.closeIcon, te = ee === void 0 ? defaultCloseIcon : ee, re = H.appContext, ne = globalConfig(), ae = ne.getPrefixCls, ie = ae("notification", G || defaultPrefixCls$1), se = "".concat(ie, "-").concat(K, "-").concat(rtl), oe = notificationInstance[se];
  if (oe) {
    Promise.resolve(oe).then(function(ue) {
      C(ue);
    });
    return;
  }
  var le = classNames("".concat(ie, "-").concat(K), _defineProperty$A({}, "".concat(ie, "-rtl"), rtl === !0));
  Notification$1.newInstance({
    name: "notification",
    prefixCls: G || defaultPrefixCls$1,
    class: le,
    style: getPlacementStyle(K, X, Q),
    appContext: re,
    getContainer: Z,
    closeIcon: function(ce) {
      var de = ce.prefixCls, ge = createVNode$1("span", {
        class: "".concat(de, "-close-x")
      }, [renderHelper(te, {}, createVNode$1(CloseOutlined$1, {
        class: "".concat(de, "-close-icon")
      }, null))]);
      return ge;
    },
    maxCount,
    hasTransitionName: !0
  }, function(ue) {
    notificationInstance[se] = ue, C(ue);
  });
}
var typeToIcon = {
  success: CheckCircleOutlined$1,
  info: InfoCircleOutlined$1,
  error: CloseCircleOutlined$1,
  warning: ExclamationCircleOutlined$1
};
function notice(H) {
  var C = H.icon, G = H.type, U = H.description, K = H.message, W = H.btn, Z = H.duration === void 0 ? defaultDuration : H.duration;
  getNotificationInstance(H, function(X) {
    X.notice({
      content: function(ee) {
        var te = ee.prefixCls, re = "".concat(te, "-notice"), ne = null;
        if (C)
          ne = function() {
            return createVNode$1("span", {
              class: "".concat(re, "-icon")
            }, [renderHelper(C)]);
          };
        else if (G) {
          var ae = typeToIcon[G];
          ne = function() {
            return createVNode$1(ae, {
              class: "".concat(re, "-icon ").concat(re, "-icon-").concat(G)
            }, null);
          };
        }
        return createVNode$1("div", {
          class: ne ? "".concat(re, "-with-icon") : ""
        }, [ne && ne(), createVNode$1("div", {
          class: "".concat(re, "-message")
        }, [!U && ne ? createVNode$1("span", {
          class: "".concat(re, "-message-single-line-auto-margin")
        }, null) : null, renderHelper(K)]), createVNode$1("div", {
          class: "".concat(re, "-description")
        }, [renderHelper(U)]), W ? createVNode$1("span", {
          class: "".concat(re, "-btn")
        }, [renderHelper(W)]) : null]);
      },
      duration: Z,
      closable: !0,
      onClose: H.onClose,
      onClick: H.onClick,
      key: H.key,
      style: H.style || {},
      class: H.class
    });
  });
}
var api = {
  open: notice,
  close: function(C) {
    Object.keys(notificationInstance).forEach(function(G) {
      return Promise.resolve(notificationInstance[G]).then(function(U) {
        U.removeNotice(C);
      });
    });
  },
  config: setNotificationConfig,
  destroy: function() {
    Object.keys(notificationInstance).forEach(function(C) {
      Promise.resolve(notificationInstance[C]).then(function(G) {
        G.destroy();
      }), delete notificationInstance[C];
    });
  }
}, iconTypes = ["success", "info", "warning", "error"];
iconTypes.forEach(function(H) {
  api[H] = function(C) {
    return api.open(_objectSpread2$1(_objectSpread2$1({}, C), {}, {
      type: H
    }));
  };
});
api.warn = api.warning;
const notification = api;
function canUseDom() {
  return !!(typeof window < "u" && window.document && window.document.createElement);
}
var MARK_KEY = "vc-util-key";
function getMark() {
  var H = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, C = H.mark;
  return C ? C.startsWith("data-") ? C : "data-".concat(C) : MARK_KEY;
}
function getContainer(H) {
  if (H.attachTo)
    return H.attachTo;
  var C = document.querySelector("head");
  return C || document.body;
}
function injectCSS(H) {
  var C, G = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (!canUseDom())
    return null;
  var U = document.createElement("style");
  if ((C = G.csp) !== null && C !== void 0 && C.nonce) {
    var K;
    U.nonce = (K = G.csp) === null || K === void 0 ? void 0 : K.nonce;
  }
  U.innerHTML = H;
  var W = getContainer(G), Z = W.firstChild;
  return G.prepend && W.prepend ? W.prepend(U) : G.prepend && Z ? W.insertBefore(U, Z) : W.appendChild(U), U;
}
var containerCache = /* @__PURE__ */ new Map();
function findExistNode(H) {
  var C = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, G = getContainer(C);
  return Array.from(containerCache.get(G).children).find(function(U) {
    return U.tagName === "STYLE" && U.getAttribute(getMark(C)) === H;
  });
}
function updateCSS(H, C) {
  var G = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, U = getContainer(G);
  if (!containerCache.has(U)) {
    var K = injectCSS("", G), W = K.parentNode;
    containerCache.set(U, W), W.removeChild(K);
  }
  var Z = findExistNode(C, G);
  if (Z) {
    var X, Q;
    if ((X = G.csp) !== null && X !== void 0 && X.nonce && Z.nonce !== ((Q = G.csp) === null || Q === void 0 ? void 0 : Q.nonce)) {
      var ee;
      Z.nonce = (ee = G.csp) === null || ee === void 0 ? void 0 : ee.nonce;
    }
    return Z.innerHTML !== H && (Z.innerHTML = H), Z;
  }
  var te = injectCSS(H, G);
  return te.setAttribute(getMark(G), C), te;
}
const devWarning = function(H, C, G) {
  warningOnce(H, "[ant-design-vue: ".concat(C, "] ").concat(G));
};
var dynamicStyleMark = "-ant-".concat(Date.now(), "-").concat(Math.random());
function registerTheme$1(H, C) {
  var G = {}, U = function(te, re) {
    var ne = te.clone();
    return ne = (re == null ? void 0 : re(ne)) || ne, ne.toRgbString();
  }, K = function(te, re) {
    var ne = new TinyColor(te), ae = generate$1(ne.toRgbString());
    G["".concat(re, "-color")] = U(ne), G["".concat(re, "-color-disabled")] = ae[1], G["".concat(re, "-color-hover")] = ae[4], G["".concat(re, "-color-active")] = ae[6], G["".concat(re, "-color-outline")] = ne.clone().setAlpha(0.2).toRgbString(), G["".concat(re, "-color-deprecated-bg")] = ae[1], G["".concat(re, "-color-deprecated-border")] = ae[3];
  };
  if (C.primaryColor) {
    K(C.primaryColor, "primary");
    var W = new TinyColor(C.primaryColor), Z = generate$1(W.toRgbString());
    Z.forEach(function(ee, te) {
      G["primary-".concat(te + 1)] = ee;
    }), G["primary-color-deprecated-l-35"] = U(W, function(ee) {
      return ee.lighten(35);
    }), G["primary-color-deprecated-l-20"] = U(W, function(ee) {
      return ee.lighten(20);
    }), G["primary-color-deprecated-t-20"] = U(W, function(ee) {
      return ee.tint(20);
    }), G["primary-color-deprecated-t-50"] = U(W, function(ee) {
      return ee.tint(50);
    }), G["primary-color-deprecated-f-12"] = U(W, function(ee) {
      return ee.setAlpha(ee.getAlpha() * 0.12);
    });
    var X = new TinyColor(Z[0]);
    G["primary-color-active-deprecated-f-30"] = U(X, function(ee) {
      return ee.setAlpha(ee.getAlpha() * 0.3);
    }), G["primary-color-active-deprecated-d-02"] = U(X, function(ee) {
      return ee.darken(2);
    });
  }
  C.successColor && K(C.successColor, "success"), C.warningColor && K(C.warningColor, "warning"), C.errorColor && K(C.errorColor, "error"), C.infoColor && K(C.infoColor, "info");
  var Q = Object.keys(G).map(function(ee) {
    return "--".concat(H, "-").concat(ee, ": ").concat(G[ee], ";");
  });
  canUseDom() ? updateCSS(`
  :root {
    `.concat(Q.join(`
`), `
  }
  `), "".concat(dynamicStyleMark, "-dynamic-theme")) : devWarning(!1, "ConfigProvider", "SSR do not support dynamic theme with css variables.");
}
var GlobalFormContextKey = Symbol("GlobalFormContextKey"), useProvideGlobalForm = function(C) {
  provide(GlobalFormContextKey, C);
}, configProviderProps = function() {
  return {
    getTargetContainer: {
      type: Function
    },
    getPopupContainer: {
      type: Function
    },
    prefixCls: String,
    getPrefixCls: {
      type: Function
    },
    renderEmpty: {
      type: Function
    },
    transformCellText: {
      type: Function
    },
    csp: {
      type: Object,
      default: void 0
    },
    input: {
      type: Object
    },
    autoInsertSpaceInButton: {
      type: Boolean,
      default: void 0
    },
    locale: {
      type: Object,
      default: void 0
    },
    pageHeader: {
      type: Object
    },
    componentSize: {
      type: String
    },
    direction: {
      type: String
    },
    space: {
      type: Object
    },
    virtual: {
      type: Boolean,
      default: void 0
    },
    dropdownMatchSelectWidth: {
      type: [Number, Boolean],
      default: !0
    },
    form: {
      type: Object,
      default: void 0
    },
    // internal use
    notUpdateGlobalConfig: Boolean
  };
}, defaultPrefixCls = "ant";
function getGlobalPrefixCls() {
  return globalConfigForApi.prefixCls || defaultPrefixCls;
}
var globalConfigByCom = reactive({}), globalConfigBySet = reactive({}), globalConfigForApi = reactive({});
watchEffect(function() {
  _extends(globalConfigForApi, globalConfigByCom, globalConfigBySet), globalConfigForApi.prefixCls = getGlobalPrefixCls(), globalConfigForApi.getPrefixCls = function(H, C) {
    return C || (H ? "".concat(globalConfigForApi.prefixCls, "-").concat(H) : globalConfigForApi.prefixCls);
  }, globalConfigForApi.getRootPrefixCls = function(H, C) {
    return H || (globalConfigForApi.prefixCls ? globalConfigForApi.prefixCls : C && C.includes("-") ? C.replace(/^(.*)-[^-]*$/, "$1") : getGlobalPrefixCls());
  };
});
var stopWatchEffect, setGlobalConfig = function(C) {
  stopWatchEffect && stopWatchEffect(), stopWatchEffect = watchEffect(function() {
    _extends(globalConfigBySet, reactive(C)), _extends(globalConfigForApi, reactive(C));
  }), C.theme && registerTheme$1(getGlobalPrefixCls(), C.theme);
}, globalConfig = function() {
  return {
    getPrefixCls: function(G, U) {
      return U || (G ? "".concat(getGlobalPrefixCls(), "-").concat(G) : getGlobalPrefixCls());
    },
    getRootPrefixCls: function(G, U) {
      return G || (globalConfigForApi.prefixCls ? globalConfigForApi.prefixCls : U && U.includes("-") ? U.replace(/^(.*)-[^-]*$/, "$1") : getGlobalPrefixCls());
    }
  };
}, ConfigProvider = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AConfigProvider",
  inheritAttrs: !1,
  props: configProviderProps(),
  setup: function(C, G) {
    var U = G.slots, K = function(re, ne) {
      var ae = C.prefixCls, ie = ae === void 0 ? "ant" : ae;
      return ne || (re ? "".concat(ie, "-").concat(re) : ie);
    }, W = function(re) {
      var ne = C.renderEmpty || U.renderEmpty || renderEmpty;
      return ne(re);
    }, Z = function(re, ne) {
      var ae = C.prefixCls;
      if (ne)
        return ne;
      var ie = ae || K("");
      return re ? "".concat(ie, "-").concat(re) : ie;
    }, X = reactive(_objectSpread2$1(_objectSpread2$1({}, C), {}, {
      getPrefixCls: Z,
      renderEmpty: W
    }));
    Object.keys(C).forEach(function(te) {
      watch(function() {
        return C[te];
      }, function() {
        X[te] = C[te];
      });
    }), C.notUpdateGlobalConfig || (_extends(globalConfigByCom, X), watch(X, function() {
      _extends(globalConfigByCom, X);
    }));
    var Q = computed(function() {
      var te = {};
      if (C.locale) {
        var re, ne;
        te = ((re = C.locale.Form) === null || re === void 0 ? void 0 : re.defaultValidateMessages) || ((ne = defaultLocale.Form) === null || ne === void 0 ? void 0 : ne.defaultValidateMessages) || {};
      }
      return C.form && C.form.validateMessages && (te = _objectSpread2$1(_objectSpread2$1({}, te), C.form.validateMessages)), te;
    });
    useProvideGlobalForm({
      validateMessages: Q
    }), provide("configProvider", X);
    var ee = function(re) {
      var ne;
      return createVNode$1(LocaleProvider$1, {
        locale: C.locale || re,
        ANT_MARK__: ANT_MARK
      }, {
        default: function() {
          return [(ne = U.default) === null || ne === void 0 ? void 0 : ne.call(U)];
        }
      });
    };
    return watchEffect(function() {
      C.direction && (message.config({
        rtl: C.direction === "rtl"
      }), notification.config({
        rtl: C.direction === "rtl"
      }));
    }), function() {
      return createVNode$1(LocaleReceiver, {
        children: function(re, ne, ae) {
          return ee(ae);
        }
      }, null);
    };
  }
}), defaultConfigProvider = reactive({
  getPrefixCls: function(C, G) {
    return G || (C ? "ant-".concat(C) : "ant");
  },
  renderEmpty,
  direction: "ltr"
});
ConfigProvider.config = setGlobalConfig;
ConfigProvider.install = function(H) {
  H.component(ConfigProvider.name, ConfigProvider);
};
const useConfigInject = function(H, C) {
  var G = inject("configProvider", defaultConfigProvider), U = computed(function() {
    return G.getPrefixCls(H, C.prefixCls);
  }), K = computed(function() {
    var ue;
    return (ue = C.direction) !== null && ue !== void 0 ? ue : G.direction;
  }), W = computed(function() {
    return G.getPrefixCls();
  }), Z = computed(function() {
    return G.autoInsertSpaceInButton;
  }), X = computed(function() {
    return G.renderEmpty;
  }), Q = computed(function() {
    return G.space;
  }), ee = computed(function() {
    return G.pageHeader;
  }), te = computed(function() {
    return G.form;
  }), re = computed(function() {
    return C.getTargetContainer || G.getTargetContainer;
  }), ne = computed(function() {
    return C.getPopupContainer || G.getPopupContainer;
  }), ae = computed(function() {
    var ue;
    return (ue = C.dropdownMatchSelectWidth) !== null && ue !== void 0 ? ue : G.dropdownMatchSelectWidth;
  }), ie = computed(function() {
    return (C.virtual === void 0 ? G.virtual !== !1 : C.virtual !== !1) && ae.value !== !1;
  }), se = computed(function() {
    return C.size || G.componentSize;
  }), oe = computed(function() {
    var ue;
    return C.autocomplete || ((ue = G.input) === null || ue === void 0 ? void 0 : ue.autocomplete);
  }), le = computed(function() {
    return G.csp;
  });
  return {
    configProvider: G,
    prefixCls: U,
    direction: K,
    size: se,
    getTargetContainer: re,
    getPopupContainer: ne,
    space: Q,
    pageHeader: ee,
    form: te,
    autoInsertSpaceInButton: Z,
    renderEmpty: X,
    virtual: ie,
    dropdownMatchSelectWidth: ae,
    rootPrefixCls: W,
    getPrefixCls: G.getPrefixCls,
    autocomplete: oe,
    csp: le
  };
};
function omit(H, C) {
  for (var G = _extends({}, H), U = 0; U < C.length; U += 1) {
    var K = C[U];
    delete G[K];
  }
  return G;
}
function isWindow$1(H) {
  return H != null && H === H.window;
}
function getScroll$1(H, C) {
  if (typeof window > "u")
    return 0;
  var G = C ? "scrollTop" : "scrollLeft", U = 0;
  if (isWindow$1(H) ? U = H[C ? "pageYOffset" : "pageXOffset"] : H instanceof Document ? U = H.documentElement[G] : H && (U = H[G]), H && !isWindow$1(H) && typeof U != "number") {
    var K;
    U = (K = (H.ownerDocument || H).documentElement) === null || K === void 0 ? void 0 : K[G];
  }
  return U;
}
function easeInOutCubic(H, C, G, U) {
  var K = G - C;
  return H /= U / 2, H < 1 ? K / 2 * H * H * H + C : K / 2 * ((H -= 2) * H * H + 2) + C;
}
function scrollTo(H) {
  var C = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, G = C.getContainer, U = G === void 0 ? function() {
    return window;
  } : G, K = C.callback, W = C.duration, Z = W === void 0 ? 450 : W, X = U(), Q = getScroll$1(X, !0), ee = Date.now(), te = function re() {
    var ne = Date.now(), ae = ne - ee, ie = easeInOutCubic(ae > Z ? Z : ae, Q, H, Z);
    isWindow$1(X) ? X.scrollTo(window.pageXOffset, ie) : X instanceof HTMLDocument || X.constructor.name === "HTMLDocument" ? X.documentElement.scrollTop = ie : X.scrollTop = ie, ae < Z ? wrapperRaf(re) : typeof K == "function" && K();
  };
  wrapperRaf(te);
}
function _toArray(H) {
  return _arrayWithHoles$2(H) || _iterableToArray(H) || _unsupportedIterableToArray$2(H) || _nonIterableRest$2();
}
function getKey$2(H, C) {
  var G = H.key, U;
  return "value" in H && (U = H.value), G ?? (U !== void 0 ? U : "rc-index-key-".concat(C));
}
function fillFieldNames$1(H, C) {
  var G = H || {}, U = G.label, K = G.value, W = G.options;
  return {
    label: U || (C ? "children" : "label"),
    value: K || "value",
    options: W || "options"
  };
}
function flattenOptions(H) {
  var C = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, G = C.fieldNames, U = C.childrenAsData, K = [], W = fillFieldNames$1(G, !1), Z = W.label, X = W.value, Q = W.options;
  function ee(te, re) {
    te.forEach(function(ne) {
      var ae = ne[Z];
      if (re || !(Q in ne)) {
        var ie = ne[X];
        K.push({
          key: getKey$2(ne, K.length),
          groupOption: re,
          data: ne,
          label: ae,
          value: ie
        });
      } else {
        var se = ae;
        se === void 0 && U && (se = ne.label), K.push({
          key: getKey$2(ne, K.length),
          group: !0,
          data: ne,
          label: se
        }), ee(ne[Q], !0);
      }
    });
  }
  return ee(H, !1), K;
}
function injectPropsWithOption(H) {
  var C = _objectSpread2$1({}, H);
  return "props" in C || Object.defineProperty(C, "props", {
    get: function() {
      return warning$2(!1, "Return type is option instead of Option instance. Please read value directly instead of reading from `props`."), C;
    }
  }), C;
}
function getSeparatedContent(H, C) {
  if (!C || !C.length)
    return null;
  var G = !1;
  function U(W, Z) {
    var X = _toArray(Z), Q = X[0], ee = X.slice(1);
    if (!Q)
      return [W];
    var te = W.split(Q);
    return G = G || te.length > 1, te.reduce(function(re, ne) {
      return [].concat(_toConsumableArray(re), _toConsumableArray(U(ne, ee)));
    }, []).filter(function(re) {
      return re;
    });
  }
  var K = U(H, C);
  return G ? K : null;
}
function contains(H, C) {
  return H ? H.contains(C) : !1;
}
var availablePrefixs = ["moz", "ms", "webkit"];
function requestAnimationFramePolyfill() {
  var H = 0;
  return function(C) {
    var G = new Date().getTime(), U = Math.max(0, 16 - (G - H)), K = window.setTimeout(function() {
      C(G + U);
    }, U);
    return H = G + U, K;
  };
}
function getRequestAnimationFrame() {
  if (typeof window > "u")
    return function() {
    };
  if (window.requestAnimationFrame)
    return window.requestAnimationFrame.bind(window);
  var H = availablePrefixs.filter(function(C) {
    return "".concat(C, "RequestAnimationFrame") in window;
  })[0];
  return H ? window["".concat(H, "RequestAnimationFrame")] : requestAnimationFramePolyfill();
}
function cancelRequestAnimationFrame(H) {
  if (typeof window > "u")
    return null;
  if (window.cancelAnimationFrame)
    return window.cancelAnimationFrame(H);
  var C = availablePrefixs.filter(function(G) {
    return "".concat(G, "CancelAnimationFrame") in window || "".concat(G, "CancelRequestAnimationFrame") in window;
  })[0];
  return C ? (window["".concat(C, "CancelAnimationFrame")] || window["".concat(C, "CancelRequestAnimationFrame")]).call(this, H) : clearTimeout(H);
}
var raf = getRequestAnimationFrame(), cancelAnimationTimeout = function(C) {
  return cancelRequestAnimationFrame(C.id);
}, requestAnimationTimeout = function(C) {
  var G = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, U = Date.now();
  function K() {
    Date.now() - U >= G ? C.call() : W.id = raf(K);
  }
  var W = {
    id: raf(K)
  };
  return W;
}, innerProps = {
  visible: Boolean,
  prefixCls: String,
  zIndex: Number,
  destroyPopupOnHide: Boolean,
  forceRender: Boolean,
  // Legacy Motion
  animation: [String, Object],
  transitionName: String,
  // Measure
  stretch: {
    type: String
  },
  // Align
  align: {
    type: Object
  },
  point: {
    type: Object
  },
  getRootDomNode: {
    type: Function
  },
  getClassNameFromAlign: {
    type: Function
  },
  onMouseenter: {
    type: Function
  },
  onMouseleave: {
    type: Function
  },
  onMousedown: {
    type: Function
  },
  onTouchstart: {
    type: Function
  }
}, mobileProps = _objectSpread2$1(_objectSpread2$1({}, innerProps), {}, {
  mobile: {
    type: Object
  }
}), popupProps = _objectSpread2$1(_objectSpread2$1({}, innerProps), {}, {
  mask: Boolean,
  mobile: {
    type: Object
  },
  maskAnimation: String,
  maskTransitionName: String
});
function getMotion(H) {
  var C = H.prefixCls, G = H.animation, U = H.transitionName;
  return G ? {
    name: "".concat(C, "-").concat(G)
  } : U ? {
    name: U
  } : {};
}
function Mask(H) {
  var C = H.prefixCls, G = H.visible, U = H.zIndex, K = H.mask, W = H.maskAnimation, Z = H.maskTransitionName;
  if (!K)
    return null;
  var X = {};
  return (Z || W) && (X = getMotion({
    prefixCls: C,
    transitionName: Z,
    animation: W
  })), createVNode$1(Transition, _objectSpread2$1({
    appear: !0
  }, X), {
    default: function() {
      return [withDirectives(createVNode$1("div", {
        style: {
          zIndex: U
        },
        class: "".concat(C, "-mask")
      }, null), [[resolveDirective("if"), G]])];
    }
  });
}
Mask.displayName = "Mask";
const MobilePopupInner = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "MobilePopupInner",
  inheritAttrs: !1,
  props: mobileProps,
  emits: ["mouseenter", "mouseleave", "mousedown", "touchstart", "align"],
  setup: function(C, G) {
    var U = G.expose, K = G.slots, W = ref();
    return U({
      forceAlign: function() {
      },
      getElement: function() {
        return W.value;
      }
    }), function() {
      var Z, X = C.zIndex, Q = C.visible, ee = C.prefixCls, te = C.mobile;
      te = te === void 0 ? {} : te;
      var re = te.popupClassName, ne = te.popupStyle, ae = te.popupMotion, ie = ae === void 0 ? {} : ae, se = te.popupRender, oe = _objectSpread2$1({
        zIndex: X
      }, ne), le = flattenChildren((Z = K.default) === null || Z === void 0 ? void 0 : Z.call(K));
      le.length > 1 && (le = createVNode$1("div", {
        class: "".concat(ee, "-content")
      }, [le])), se && (le = se(le));
      var ue = classNames(ee, re);
      return createVNode$1(Transition, _objectSpread2$1({
        ref: W
      }, ie), {
        default: function() {
          return [Q ? createVNode$1("div", {
            class: ue,
            style: oe
          }, [le]) : null];
        }
      });
    };
  }
});
var StatusQueue = ["measure", "align", null, "motion"];
const useVisibleStatus = function(H, C) {
  var G = ref(null), U = ref(), K = ref(!1);
  function W(Q) {
    K.value || (G.value = Q);
  }
  function Z() {
    wrapperRaf.cancel(U.value);
  }
  function X(Q) {
    Z(), U.value = wrapperRaf(function() {
      var ee = G.value;
      switch (G.value) {
        case "align":
          ee = "motion";
          break;
        case "motion":
          ee = "stable";
          break;
      }
      W(ee), Q == null || Q();
    });
  }
  return watch(H, function() {
    W("measure");
  }, {
    immediate: !0,
    flush: "post"
  }), onMounted(function() {
    watch(G, function() {
      switch (G.value) {
        case "measure":
          C();
          break;
      }
      G.value && (U.value = wrapperRaf(/* @__PURE__ */ _asyncToGenerator(/* @__PURE__ */ regenerator.mark(function Q() {
        var ee, te;
        return regenerator.wrap(function(ne) {
          for (; ; )
            switch (ne.prev = ne.next) {
              case 0:
                ee = StatusQueue.indexOf(G.value), te = StatusQueue[ee + 1], te && ee !== -1 && W(te);
              case 3:
              case "end":
                return ne.stop();
            }
        }, Q);
      }))));
    }, {
      immediate: !0,
      flush: "post"
    });
  }), onBeforeUnmount(function() {
    K.value = !0, Z();
  }), [G, X];
}, useStretchStyle = function(H) {
  var C = ref({
    width: 0,
    height: 0
  });
  function G(K) {
    C.value = {
      width: K.offsetWidth,
      height: K.offsetHeight
    };
  }
  var U = computed(function() {
    var K = {};
    if (H.value) {
      var W = C.value, Z = W.width, X = W.height;
      H.value.indexOf("height") !== -1 && X ? K.height = "".concat(X, "px") : H.value.indexOf("minHeight") !== -1 && X && (K.minHeight = "".concat(X, "px")), H.value.indexOf("width") !== -1 && Z ? K.width = "".concat(Z, "px") : H.value.indexOf("minWidth") !== -1 && Z && (K.minWidth = "".concat(Z, "px"));
    }
    return K;
  });
  return [U, G];
};
function ownKeys(H, C) {
  var G = Object.keys(H);
  if (Object.getOwnPropertySymbols) {
    var U = Object.getOwnPropertySymbols(H);
    C && (U = U.filter(function(K) {
      return Object.getOwnPropertyDescriptor(H, K).enumerable;
    })), G.push.apply(G, U);
  }
  return G;
}
function _objectSpread2(H) {
  for (var C = 1; C < arguments.length; C++) {
    var G = arguments[C] != null ? arguments[C] : {};
    C % 2 ? ownKeys(Object(G), !0).forEach(function(U) {
      _defineProperty$m(H, U, G[U]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(H, Object.getOwnPropertyDescriptors(G)) : ownKeys(Object(G)).forEach(function(U) {
      Object.defineProperty(H, U, Object.getOwnPropertyDescriptor(G, U));
    });
  }
  return H;
}
function _typeof(H) {
  return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(C) {
    return typeof C;
  } : function(C) {
    return C && typeof Symbol == "function" && C.constructor === Symbol && C !== Symbol.prototype ? "symbol" : typeof C;
  }, _typeof(H);
}
function _defineProperty$m(H, C, G) {
  return C in H ? Object.defineProperty(H, C, {
    value: G,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : H[C] = G, H;
}
var vendorPrefix, jsCssMap = {
  Webkit: "-webkit-",
  Moz: "-moz-",
  // IE did it wrong again ...
  ms: "-ms-",
  O: "-o-"
};
function getVendorPrefix() {
  if (vendorPrefix !== void 0)
    return vendorPrefix;
  vendorPrefix = "";
  var H = document.createElement("p").style, C = "Transform";
  for (var G in jsCssMap)
    G + C in H && (vendorPrefix = G);
  return vendorPrefix;
}
function getTransitionName() {
  return getVendorPrefix() ? "".concat(getVendorPrefix(), "TransitionProperty") : "transitionProperty";
}
function getTransformName() {
  return getVendorPrefix() ? "".concat(getVendorPrefix(), "Transform") : "transform";
}
function setTransitionProperty(H, C) {
  var G = getTransitionName();
  G && (H.style[G] = C, G !== "transitionProperty" && (H.style.transitionProperty = C));
}
function setTransform$1(H, C) {
  var G = getTransformName();
  G && (H.style[G] = C, G !== "transform" && (H.style.transform = C));
}
function getTransitionProperty(H) {
  return H.style.transitionProperty || H.style[getTransitionName()];
}
function getTransformXY(H) {
  var C = window.getComputedStyle(H, null), G = C.getPropertyValue("transform") || C.getPropertyValue(getTransformName());
  if (G && G !== "none") {
    var U = G.replace(/[^0-9\-.,]/g, "").split(",");
    return {
      x: parseFloat(U[12] || U[4], 0),
      y: parseFloat(U[13] || U[5], 0)
    };
  }
  return {
    x: 0,
    y: 0
  };
}
var matrix2d = /matrix\((.*)\)/, matrix3d = /matrix3d\((.*)\)/;
function setTransformXY(H, C) {
  var G = window.getComputedStyle(H, null), U = G.getPropertyValue("transform") || G.getPropertyValue(getTransformName());
  if (U && U !== "none") {
    var K, W = U.match(matrix2d);
    if (W)
      W = W[1], K = W.split(",").map(function(X) {
        return parseFloat(X, 10);
      }), K[4] = C.x, K[5] = C.y, setTransform$1(H, "matrix(".concat(K.join(","), ")"));
    else {
      var Z = U.match(matrix3d)[1];
      K = Z.split(",").map(function(X) {
        return parseFloat(X, 10);
      }), K[12] = C.x, K[13] = C.y, setTransform$1(H, "matrix3d(".concat(K.join(","), ")"));
    }
  } else
    setTransform$1(H, "translateX(".concat(C.x, "px) translateY(").concat(C.y, "px) translateZ(0)"));
}
var RE_NUM = /[\-+]?(?:\d*\.|)\d+(?:[eE][\-+]?\d+|)/.source, getComputedStyleX;
function forceRelayout(H) {
  var C = H.style.display;
  H.style.display = "none", H.offsetHeight, H.style.display = C;
}
function css(H, C, G) {
  var U = G;
  if (_typeof(C) === "object") {
    for (var K in C)
      C.hasOwnProperty(K) && css(H, K, C[K]);
    return;
  }
  if (typeof U < "u") {
    typeof U == "number" && (U = "".concat(U, "px")), H.style[C] = U;
    return;
  }
  return getComputedStyleX(H, C);
}
function getClientPosition(H) {
  var C, G, U, K = H.ownerDocument, W = K.body, Z = K && K.documentElement;
  return C = H.getBoundingClientRect(), G = Math.floor(C.left), U = Math.floor(C.top), G -= Z.clientLeft || W.clientLeft || 0, U -= Z.clientTop || W.clientTop || 0, {
    left: G,
    top: U
  };
}
function getScroll(H, C) {
  var G = H["page".concat(C ? "Y" : "X", "Offset")], U = "scroll".concat(C ? "Top" : "Left");
  if (typeof G != "number") {
    var K = H.document;
    G = K.documentElement[U], typeof G != "number" && (G = K.body[U]);
  }
  return G;
}
function getScrollLeft(H) {
  return getScroll(H);
}
function getScrollTop(H) {
  return getScroll(H, !0);
}
function getOffset$1(H) {
  var C = getClientPosition(H), G = H.ownerDocument, U = G.defaultView || G.parentWindow;
  return C.left += getScrollLeft(U), C.top += getScrollTop(U), C;
}
function isWindow(H) {
  return H != null && H == H.window;
}
function getDocument(H) {
  return isWindow(H) ? H.document : H.nodeType === 9 ? H : H.ownerDocument;
}
function _getComputedStyle(H, C, G) {
  var U = G, K = "", W = getDocument(H);
  return U = U || W.defaultView.getComputedStyle(H, null), U && (K = U.getPropertyValue(C) || U[C]), K;
}
var _RE_NUM_NO_PX = new RegExp("^(".concat(RE_NUM, ")(?!px)[a-z%]+$"), "i"), RE_POS = /^(top|right|bottom|left)$/, CURRENT_STYLE = "currentStyle", RUNTIME_STYLE = "runtimeStyle", LEFT = "left", PX = "px";
function _getComputedStyleIE(H, C) {
  var G = H[CURRENT_STYLE] && H[CURRENT_STYLE][C];
  if (_RE_NUM_NO_PX.test(G) && !RE_POS.test(C)) {
    var U = H.style, K = U[LEFT], W = H[RUNTIME_STYLE][LEFT];
    H[RUNTIME_STYLE][LEFT] = H[CURRENT_STYLE][LEFT], U[LEFT] = C === "fontSize" ? "1em" : G || 0, G = U.pixelLeft + PX, U[LEFT] = K, H[RUNTIME_STYLE][LEFT] = W;
  }
  return G === "" ? "auto" : G;
}
typeof window < "u" && (getComputedStyleX = window.getComputedStyle ? _getComputedStyle : _getComputedStyleIE);
function getOffsetDirection(H, C) {
  return H === "left" ? C.useCssRight ? "right" : H : C.useCssBottom ? "bottom" : H;
}
function oppositeOffsetDirection(H) {
  if (H === "left")
    return "right";
  if (H === "right")
    return "left";
  if (H === "top")
    return "bottom";
  if (H === "bottom")
    return "top";
}
function setLeftTop(H, C, G) {
  css(H, "position") === "static" && (H.style.position = "relative");
  var U = -999, K = -999, W = getOffsetDirection("left", G), Z = getOffsetDirection("top", G), X = oppositeOffsetDirection(W), Q = oppositeOffsetDirection(Z);
  W !== "left" && (U = 999), Z !== "top" && (K = 999);
  var ee = "", te = getOffset$1(H);
  ("left" in C || "top" in C) && (ee = getTransitionProperty(H) || "", setTransitionProperty(H, "none")), "left" in C && (H.style[X] = "", H.style[W] = "".concat(U, "px")), "top" in C && (H.style[Q] = "", H.style[Z] = "".concat(K, "px")), forceRelayout(H);
  var re = getOffset$1(H), ne = {};
  for (var ae in C)
    if (C.hasOwnProperty(ae)) {
      var ie = getOffsetDirection(ae, G), se = ae === "left" ? U : K, oe = te[ae] - re[ae];
      ie === ae ? ne[ie] = se + oe : ne[ie] = se - oe;
    }
  css(H, ne), forceRelayout(H), ("left" in C || "top" in C) && setTransitionProperty(H, ee);
  var le = {};
  for (var ue in C)
    if (C.hasOwnProperty(ue)) {
      var ce = getOffsetDirection(ue, G), de = C[ue] - te[ue];
      ue === ce ? le[ce] = ne[ce] + de : le[ce] = ne[ce] - de;
    }
  css(H, le);
}
function setTransform$1$1(H, C) {
  var G = getOffset$1(H), U = getTransformXY(H), K = {
    x: U.x,
    y: U.y
  };
  "left" in C && (K.x = U.x + C.left - G.left), "top" in C && (K.y = U.y + C.top - G.top), setTransformXY(H, K);
}
function setOffset(H, C, G) {
  if (G.ignoreShake) {
    var U = getOffset$1(H), K = U.left.toFixed(0), W = U.top.toFixed(0), Z = C.left.toFixed(0), X = C.top.toFixed(0);
    if (K === Z && W === X)
      return;
  }
  G.useCssRight || G.useCssBottom ? setLeftTop(H, C, G) : G.useCssTransform && getTransformName() in document.body.style ? setTransform$1$1(H, C) : setLeftTop(H, C, G);
}
function each$g(H, C) {
  for (var G = 0; G < H.length; G++)
    C(H[G]);
}
function isBorderBoxFn(H) {
  return getComputedStyleX(H, "boxSizing") === "border-box";
}
var BOX_MODELS = ["margin", "border", "padding"], CONTENT_INDEX = -1, PADDING_INDEX = 2, BORDER_INDEX = 1, MARGIN_INDEX = 0;
function swap(H, C, G) {
  var U = {}, K = H.style, W;
  for (W in C)
    C.hasOwnProperty(W) && (U[W] = K[W], K[W] = C[W]);
  G.call(H);
  for (W in C)
    C.hasOwnProperty(W) && (K[W] = U[W]);
}
function getPBMWidth(H, C, G) {
  var U = 0, K, W, Z;
  for (W = 0; W < C.length; W++)
    if (K = C[W], K)
      for (Z = 0; Z < G.length; Z++) {
        var X = void 0;
        K === "border" ? X = "".concat(K).concat(G[Z], "Width") : X = K + G[Z], U += parseFloat(getComputedStyleX(H, X)) || 0;
      }
  return U;
}
var domUtils = {
  getParent: function(C) {
    var G = C;
    do
      G.nodeType === 11 && G.host ? G = G.host : G = G.parentNode;
    while (G && G.nodeType !== 1 && G.nodeType !== 9);
    return G;
  }
};
each$g(["Width", "Height"], function(H) {
  domUtils["doc".concat(H)] = function(C) {
    var G = C.document;
    return Math.max(
      // firefox chrome documentElement.scrollHeight< body.scrollHeight
      // ie standard mode : documentElement.scrollHeight> body.scrollHeight
      G.documentElement["scroll".concat(H)],
      // quirks : documentElement.scrollHeight 最大等于可视窗口多一点？
      G.body["scroll".concat(H)],
      domUtils["viewport".concat(H)](G)
    );
  }, domUtils["viewport".concat(H)] = function(C) {
    var G = "client".concat(H), U = C.document, K = U.body, W = U.documentElement, Z = W[G];
    return U.compatMode === "CSS1Compat" && Z || K && K[G] || Z;
  };
});
function getWH(H, C, G) {
  var U = G;
  if (isWindow(H))
    return C === "width" ? domUtils.viewportWidth(H) : domUtils.viewportHeight(H);
  if (H.nodeType === 9)
    return C === "width" ? domUtils.docWidth(H) : domUtils.docHeight(H);
  var K = C === "width" ? ["Left", "Right"] : ["Top", "Bottom"], W = Math.floor(C === "width" ? H.getBoundingClientRect().width : H.getBoundingClientRect().height), Z = isBorderBoxFn(H), X = 0;
  (W == null || W <= 0) && (W = void 0, X = getComputedStyleX(H, C), (X == null || Number(X) < 0) && (X = H.style[C] || 0), X = Math.floor(parseFloat(X)) || 0), U === void 0 && (U = Z ? BORDER_INDEX : CONTENT_INDEX);
  var Q = W !== void 0 || Z, ee = W || X;
  return U === CONTENT_INDEX ? Q ? ee - getPBMWidth(H, ["border", "padding"], K) : X : Q ? U === BORDER_INDEX ? ee : ee + (U === PADDING_INDEX ? -getPBMWidth(H, ["border"], K) : getPBMWidth(H, ["margin"], K)) : X + getPBMWidth(H, BOX_MODELS.slice(U), K);
}
var cssShow = {
  position: "absolute",
  visibility: "hidden",
  display: "block"
};
function getWHIgnoreDisplay() {
  for (var H = arguments.length, C = new Array(H), G = 0; G < H; G++)
    C[G] = arguments[G];
  var U, K = C[0];
  return K.offsetWidth !== 0 ? U = getWH.apply(void 0, C) : swap(K, cssShow, function() {
    U = getWH.apply(void 0, C);
  }), U;
}
each$g(["width", "height"], function(H) {
  var C = H.charAt(0).toUpperCase() + H.slice(1);
  domUtils["outer".concat(C)] = function(U, K) {
    return U && getWHIgnoreDisplay(U, H, K ? MARGIN_INDEX : BORDER_INDEX);
  };
  var G = H === "width" ? ["Left", "Right"] : ["Top", "Bottom"];
  domUtils[H] = function(U, K) {
    var W = K;
    if (W !== void 0) {
      if (U) {
        var Z = isBorderBoxFn(U);
        return Z && (W += getPBMWidth(U, ["padding", "border"], G)), css(U, H, W);
      }
      return;
    }
    return U && getWHIgnoreDisplay(U, H, CONTENT_INDEX);
  };
});
function mix(H, C) {
  for (var G in C)
    C.hasOwnProperty(G) && (H[G] = C[G]);
  return H;
}
var utils = {
  getWindow: function(C) {
    if (C && C.document && C.setTimeout)
      return C;
    var G = C.ownerDocument || C;
    return G.defaultView || G.parentWindow;
  },
  getDocument,
  offset: function(C, G, U) {
    if (typeof G < "u")
      setOffset(C, G, U || {});
    else
      return getOffset$1(C);
  },
  isWindow,
  each: each$g,
  css,
  clone: function(C) {
    var G, U = {};
    for (G in C)
      C.hasOwnProperty(G) && (U[G] = C[G]);
    var K = C.overflow;
    if (K)
      for (G in C)
        C.hasOwnProperty(G) && (U.overflow[G] = C.overflow[G]);
    return U;
  },
  mix,
  getWindowScrollLeft: function(C) {
    return getScrollLeft(C);
  },
  getWindowScrollTop: function(C) {
    return getScrollTop(C);
  },
  merge: function() {
    for (var C = {}, G = 0; G < arguments.length; G++)
      utils.mix(C, G < 0 || arguments.length <= G ? void 0 : arguments[G]);
    return C;
  },
  viewportWidth: 0,
  viewportHeight: 0
};
mix(utils, domUtils);
var getParent = utils.getParent;
function getOffsetParent(H) {
  if (utils.isWindow(H) || H.nodeType === 9)
    return null;
  var C = utils.getDocument(H), G = C.body, U, K = utils.css(H, "position"), W = K === "fixed" || K === "absolute";
  if (!W)
    return H.nodeName.toLowerCase() === "html" ? null : getParent(H);
  for (U = getParent(H); U && U !== G && U.nodeType !== 9; U = getParent(U))
    if (K = utils.css(U, "position"), K !== "static")
      return U;
  return null;
}
var getParent$1 = utils.getParent;
function isAncestorFixed(H) {
  if (utils.isWindow(H) || H.nodeType === 9)
    return !1;
  var C = utils.getDocument(H), G = C.body, U = null;
  for (U = getParent$1(H); // 修复元素位于 document.documentElement 下导致崩溃问题
  U && U !== G && U !== C; U = getParent$1(U)) {
    var K = utils.css(U, "position");
    if (K === "fixed")
      return !0;
  }
  return !1;
}
function getVisibleRectForElement(H, C) {
  for (var G = {
    left: 0,
    right: 1 / 0,
    top: 0,
    bottom: 1 / 0
  }, U = getOffsetParent(H), K = utils.getDocument(H), W = K.defaultView || K.parentWindow, Z = K.body, X = K.documentElement; U; ) {
    if ((navigator.userAgent.indexOf("MSIE") === -1 || U.clientWidth !== 0) && // body may have overflow set on it, yet we still get the entire
    // viewport. In some browsers, el.offsetParent may be
    // document.documentElement, so check for that too.
    U !== Z && U !== X && utils.css(U, "overflow") !== "visible") {
      var Q = utils.offset(U);
      Q.left += U.clientLeft, Q.top += U.clientTop, G.top = Math.max(G.top, Q.top), G.right = Math.min(
        G.right,
        // consider area without scrollBar
        Q.left + U.clientWidth
      ), G.bottom = Math.min(G.bottom, Q.top + U.clientHeight), G.left = Math.max(G.left, Q.left);
    } else if (U === Z || U === X)
      break;
    U = getOffsetParent(U);
  }
  var ee = null;
  if (!utils.isWindow(H) && H.nodeType !== 9) {
    ee = H.style.position;
    var te = utils.css(H, "position");
    te === "absolute" && (H.style.position = "fixed");
  }
  var re = utils.getWindowScrollLeft(W), ne = utils.getWindowScrollTop(W), ae = utils.viewportWidth(W), ie = utils.viewportHeight(W), se = X.scrollWidth, oe = X.scrollHeight, le = window.getComputedStyle(Z);
  if (le.overflowX === "hidden" && (se = W.innerWidth), le.overflowY === "hidden" && (oe = W.innerHeight), H.style && (H.style.position = ee), C || isAncestorFixed(H))
    G.left = Math.max(G.left, re), G.top = Math.max(G.top, ne), G.right = Math.min(G.right, re + ae), G.bottom = Math.min(G.bottom, ne + ie);
  else {
    var ue = Math.max(se, re + ae);
    G.right = Math.min(G.right, ue);
    var ce = Math.max(oe, ne + ie);
    G.bottom = Math.min(G.bottom, ce);
  }
  return G.top >= 0 && G.left >= 0 && G.bottom > G.top && G.right > G.left ? G : null;
}
function adjustForViewport(H, C, G, U) {
  var K = utils.clone(H), W = {
    width: C.width,
    height: C.height
  };
  return U.adjustX && K.left < G.left && (K.left = G.left), U.resizeWidth && K.left >= G.left && K.left + W.width > G.right && (W.width -= K.left + W.width - G.right), U.adjustX && K.left + W.width > G.right && (K.left = Math.max(G.right - W.width, G.left)), U.adjustY && K.top < G.top && (K.top = G.top), U.resizeHeight && K.top >= G.top && K.top + W.height > G.bottom && (W.height -= K.top + W.height - G.bottom), U.adjustY && K.top + W.height > G.bottom && (K.top = Math.max(G.bottom - W.height, G.top)), utils.mix(K, W);
}
function getRegion(H) {
  var C, G, U;
  if (!utils.isWindow(H) && H.nodeType !== 9)
    C = utils.offset(H), G = utils.outerWidth(H), U = utils.outerHeight(H);
  else {
    var K = utils.getWindow(H);
    C = {
      left: utils.getWindowScrollLeft(K),
      top: utils.getWindowScrollTop(K)
    }, G = utils.viewportWidth(K), U = utils.viewportHeight(K);
  }
  return C.width = G, C.height = U, C;
}
function getAlignOffset(H, C) {
  var G = C.charAt(0), U = C.charAt(1), K = H.width, W = H.height, Z = H.left, X = H.top;
  return G === "c" ? X += W / 2 : G === "b" && (X += W), U === "c" ? Z += K / 2 : U === "r" && (Z += K), {
    left: Z,
    top: X
  };
}
function getElFuturePos(H, C, G, U, K) {
  var W = getAlignOffset(C, G[1]), Z = getAlignOffset(H, G[0]), X = [Z.left - W.left, Z.top - W.top];
  return {
    left: Math.round(H.left - X[0] + U[0] - K[0]),
    top: Math.round(H.top - X[1] + U[1] - K[1])
  };
}
function isFailX(H, C, G) {
  return H.left < G.left || H.left + C.width > G.right;
}
function isFailY(H, C, G) {
  return H.top < G.top || H.top + C.height > G.bottom;
}
function isCompleteFailX(H, C, G) {
  return H.left > G.right || H.left + C.width < G.left;
}
function isCompleteFailY(H, C, G) {
  return H.top > G.bottom || H.top + C.height < G.top;
}
function flip(H, C, G) {
  var U = [];
  return utils.each(H, function(K) {
    U.push(K.replace(C, function(W) {
      return G[W];
    }));
  }), U;
}
function flipOffset(H, C) {
  return H[C] = -H[C], H;
}
function convertOffset(H, C) {
  var G;
  return /%$/.test(H) ? G = parseInt(H.substring(0, H.length - 1), 10) / 100 * C : G = parseInt(H, 10), G || 0;
}
function normalizeOffset(H, C) {
  H[0] = convertOffset(H[0], C.width), H[1] = convertOffset(H[1], C.height);
}
function doAlign(H, C, G, U) {
  var K = G.points, W = G.offset || [0, 0], Z = G.targetOffset || [0, 0], X = G.overflow, Q = G.source || H;
  W = [].concat(W), Z = [].concat(Z), X = X || {};
  var ee = {}, te = 0, re = !!(X && X.alwaysByViewport), ne = getVisibleRectForElement(Q, re), ae = getRegion(Q);
  normalizeOffset(W, ae), normalizeOffset(Z, C);
  var ie = getElFuturePos(ae, C, K, W, Z), se = utils.merge(ae, ie);
  if (ne && (X.adjustX || X.adjustY) && U) {
    if (X.adjustX && isFailX(ie, ae, ne)) {
      var oe = flip(K, /[lr]/gi, {
        l: "r",
        r: "l"
      }), le = flipOffset(W, 0), ue = flipOffset(Z, 0), ce = getElFuturePos(ae, C, oe, le, ue);
      isCompleteFailX(ce, ae, ne) || (te = 1, K = oe, W = le, Z = ue);
    }
    if (X.adjustY && isFailY(ie, ae, ne)) {
      var de = flip(K, /[tb]/gi, {
        t: "b",
        b: "t"
      }), ge = flipOffset(W, 1), fe = flipOffset(Z, 1), ve = getElFuturePos(ae, C, de, ge, fe);
      isCompleteFailY(ve, ae, ne) || (te = 1, K = de, W = ge, Z = fe);
    }
    te && (ie = getElFuturePos(ae, C, K, W, Z), utils.mix(se, ie));
    var pe = isFailX(ie, ae, ne), he = isFailY(ie, ae, ne);
    if (pe || he) {
      var me = K;
      pe && (me = flip(K, /[lr]/gi, {
        l: "r",
        r: "l"
      })), he && (me = flip(K, /[tb]/gi, {
        t: "b",
        b: "t"
      })), K = me, W = G.offset || [0, 0], Z = G.targetOffset || [0, 0];
    }
    ee.adjustX = X.adjustX && pe, ee.adjustY = X.adjustY && he, (ee.adjustX || ee.adjustY) && (se = adjustForViewport(ie, ae, ne, ee));
  }
  return se.width !== ae.width && utils.css(Q, "width", utils.width(Q) + se.width - ae.width), se.height !== ae.height && utils.css(Q, "height", utils.height(Q) + se.height - ae.height), utils.offset(Q, {
    left: se.left,
    top: se.top
  }, {
    useCssRight: G.useCssRight,
    useCssBottom: G.useCssBottom,
    useCssTransform: G.useCssTransform,
    ignoreShake: G.ignoreShake
  }), {
    points: K,
    offset: W,
    targetOffset: Z,
    overflow: ee
  };
}
function isOutOfVisibleRect(H, C) {
  var G = getVisibleRectForElement(H, C), U = getRegion(H);
  return !G || U.left + U.width <= G.left || U.top + U.height <= G.top || U.left >= G.right || U.top >= G.bottom;
}
function alignElement(H, C, G) {
  var U = G.target || C, K = getRegion(U), W = !isOutOfVisibleRect(U, G.overflow && G.overflow.alwaysByViewport);
  return doAlign(H, K, G, W);
}
alignElement.__getOffsetParent = getOffsetParent;
alignElement.__getVisibleRectForElement = getVisibleRectForElement;
function alignPoint(H, C, G) {
  var U, K, W = utils.getDocument(H), Z = W.defaultView || W.parentWindow, X = utils.getWindowScrollLeft(Z), Q = utils.getWindowScrollTop(Z), ee = utils.viewportWidth(Z), te = utils.viewportHeight(Z);
  "pageX" in C ? U = C.pageX : U = X + C.clientX, "pageY" in C ? K = C.pageY : K = Q + C.clientY;
  var re = {
    left: U,
    top: K,
    width: 0,
    height: 0
  }, ne = U >= 0 && U <= X + ee && K >= 0 && K <= Q + te, ae = [G.points[0], "cc"];
  return doAlign(H, re, _objectSpread2(_objectSpread2({}, G), {}, {
    points: ae
  }), ne);
}
function cloneElement(H) {
  var C = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, G = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0, U = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1, K = H;
  if (Array.isArray(H) && (K = filterEmpty(H)[0]), !K)
    return null;
  var W = cloneVNode(K, C, U);
  return W.props = G ? _objectSpread2$1(_objectSpread2$1({}, W.props), C) : W.props, warning$1(_typeof$2(W.props.class) !== "object", "class must be string"), W;
}
const isVisible = function(H) {
  if (!H)
    return !1;
  if (H.offsetParent)
    return !0;
  if (H.getBBox) {
    var C = H.getBBox();
    if (C.width || C.height)
      return !0;
  }
  if (H.getBoundingClientRect) {
    var G = H.getBoundingClientRect();
    if (G.width || G.height)
      return !0;
  }
  return !1;
};
function isSamePoint(H, C) {
  return H === C ? !0 : !H || !C ? !1 : "pageX" in C && "pageY" in C ? H.pageX === C.pageX && H.pageY === C.pageY : "clientX" in C && "clientY" in C ? H.clientX === C.clientX && H.clientY === C.clientY : !1;
}
function restoreFocus(H, C) {
  H !== document.activeElement && contains(C, H) && typeof H.focus == "function" && H.focus();
}
function monitorResize(H, C) {
  var G = null, U = null;
  function K(Z) {
    var X = _slicedToArray$2(Z, 1), Q = X[0].target;
    if (document.documentElement.contains(Q)) {
      var ee = Q.getBoundingClientRect(), te = ee.width, re = ee.height, ne = Math.floor(te), ae = Math.floor(re);
      (G !== ne || U !== ae) && Promise.resolve().then(function() {
        C({
          width: ne,
          height: ae
        });
      }), G = ne, U = ae;
    }
  }
  var W = new index$3(K);
  return H && W.observe(H), function() {
    W.disconnect();
  };
}
const useBuffer = function(H, C) {
  var G = !1, U = null;
  function K() {
    clearTimeout(U);
  }
  function W(Z) {
    if (!G || Z === !0) {
      if (H() === !1)
        return;
      G = !0, K(), U = setTimeout(function() {
        G = !1;
      }, C.value);
    } else
      K(), U = setTimeout(function() {
        G = !1, W();
      }, C.value);
  }
  return [W, function() {
    G = !1, K();
  }];
};
function listCacheClear() {
  this.__data__ = [], this.size = 0;
}
function eq(H, C) {
  return H === C || H !== H && C !== C;
}
function assocIndexOf(H, C) {
  for (var G = H.length; G--; )
    if (eq(H[G][0], C))
      return G;
  return -1;
}
var arrayProto$1 = Array.prototype, splice = arrayProto$1.splice;
function listCacheDelete(H) {
  var C = this.__data__, G = assocIndexOf(C, H);
  if (G < 0)
    return !1;
  var U = C.length - 1;
  return G == U ? C.pop() : splice.call(C, G, 1), --this.size, !0;
}
function listCacheGet$1(H) {
  var C = this.__data__, G = assocIndexOf(C, H);
  return G < 0 ? void 0 : C[G][1];
}
function listCacheHas(H) {
  return assocIndexOf(this.__data__, H) > -1;
}
function listCacheSet$1(H, C) {
  var G = this.__data__, U = assocIndexOf(G, H);
  return U < 0 ? (++this.size, G.push([H, C])) : G[U][1] = C, this;
}
function ListCache(H) {
  var C = -1, G = H == null ? 0 : H.length;
  for (this.clear(); ++C < G; ) {
    var U = H[C];
    this.set(U[0], U[1]);
  }
}
ListCache.prototype.clear = listCacheClear;
ListCache.prototype.delete = listCacheDelete;
ListCache.prototype.get = listCacheGet$1;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet$1;
function stackClear() {
  this.__data__ = new ListCache(), this.size = 0;
}
function stackDelete(H) {
  var C = this.__data__, G = C.delete(H);
  return this.size = C.size, G;
}
function stackGet(H) {
  return this.__data__.get(H);
}
function stackHas(H) {
  return this.__data__.has(H);
}
function isObject$4(H) {
  var C = typeof H;
  return H != null && (C == "object" || C == "function");
}
var asyncTag = "[object AsyncFunction]", funcTag$1 = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction$1(H) {
  if (!isObject$4(H))
    return !1;
  var C = baseGetTag(H);
  return C == funcTag$1 || C == genTag || C == asyncTag || C == proxyTag;
}
var coreJsData = root$1["__core-js_shared__"];
const coreJsData$1 = coreJsData;
var maskSrcKey = function() {
  var H = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || "");
  return H ? "Symbol(src)_1." + H : "";
}();
function isMasked(H) {
  return !!maskSrcKey && maskSrcKey in H;
}
var funcProto$1 = Function.prototype, funcToString$1 = funcProto$1.toString;
function toSource(H) {
  if (H != null) {
    try {
      return funcToString$1.call(H);
    } catch {
    }
    try {
      return H + "";
    } catch {
    }
  }
  return "";
}
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reIsHostCtor = /^\[object .+?Constructor\]$/, funcProto = Function.prototype, objectProto$9 = Object.prototype, funcToString = funcProto.toString, hasOwnProperty$7 = objectProto$9.hasOwnProperty, reIsNative = RegExp(
  "^" + funcToString.call(hasOwnProperty$7).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative(H) {
  if (!isObject$4(H) || isMasked(H))
    return !1;
  var C = isFunction$1(H) ? reIsNative : reIsHostCtor;
  return C.test(toSource(H));
}
function getValue(H, C) {
  return H == null ? void 0 : H[C];
}
function getNative(H, C) {
  var G = getValue(H, C);
  return baseIsNative(G) ? G : void 0;
}
var Map$1 = getNative(root$1, "Map");
const Map$2 = Map$1;
var nativeCreate = getNative(Object, "create");
const nativeCreate$1 = nativeCreate;
function hashClear() {
  this.__data__ = nativeCreate$1 ? nativeCreate$1(null) : {}, this.size = 0;
}
function hashDelete(H) {
  var C = this.has(H) && delete this.__data__[H];
  return this.size -= C ? 1 : 0, C;
}
var HASH_UNDEFINED$2 = "__lodash_hash_undefined__", objectProto$8 = Object.prototype, hasOwnProperty$6 = objectProto$8.hasOwnProperty;
function hashGet(H) {
  var C = this.__data__;
  if (nativeCreate$1) {
    var G = C[H];
    return G === HASH_UNDEFINED$2 ? void 0 : G;
  }
  return hasOwnProperty$6.call(C, H) ? C[H] : void 0;
}
var objectProto$7 = Object.prototype, hasOwnProperty$5 = objectProto$7.hasOwnProperty;
function hashHas(H) {
  var C = this.__data__;
  return nativeCreate$1 ? C[H] !== void 0 : hasOwnProperty$5.call(C, H);
}
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
function hashSet(H, C) {
  var G = this.__data__;
  return this.size += this.has(H) ? 0 : 1, G[H] = nativeCreate$1 && C === void 0 ? HASH_UNDEFINED$1 : C, this;
}
function Hash(H) {
  var C = -1, G = H == null ? 0 : H.length;
  for (this.clear(); ++C < G; ) {
    var U = H[C];
    this.set(U[0], U[1]);
  }
}
Hash.prototype.clear = hashClear;
Hash.prototype.delete = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
function mapCacheClear() {
  this.size = 0, this.__data__ = {
    hash: new Hash(),
    map: new (Map$2 || ListCache)(),
    string: new Hash()
  };
}
function isKeyable(H) {
  var C = typeof H;
  return C == "string" || C == "number" || C == "symbol" || C == "boolean" ? H !== "__proto__" : H === null;
}
function getMapData(H, C) {
  var G = H.__data__;
  return isKeyable(C) ? G[typeof C == "string" ? "string" : "hash"] : G.map;
}
function mapCacheDelete(H) {
  var C = getMapData(this, H).delete(H);
  return this.size -= C ? 1 : 0, C;
}
function mapCacheGet(H) {
  return getMapData(this, H).get(H);
}
function mapCacheHas(H) {
  return getMapData(this, H).has(H);
}
function mapCacheSet(H, C) {
  var G = getMapData(this, H), U = G.size;
  return G.set(H, C), this.size += G.size == U ? 0 : 1, this;
}
function MapCache(H) {
  var C = -1, G = H == null ? 0 : H.length;
  for (this.clear(); ++C < G; ) {
    var U = H[C];
    this.set(U[0], U[1]);
  }
}
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype.delete = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
var LARGE_ARRAY_SIZE$1 = 200;
function stackSet(H, C) {
  var G = this.__data__;
  if (G instanceof ListCache) {
    var U = G.__data__;
    if (!Map$2 || U.length < LARGE_ARRAY_SIZE$1 - 1)
      return U.push([H, C]), this.size = ++G.size, this;
    G = this.__data__ = new MapCache(U);
  }
  return G.set(H, C), this.size = G.size, this;
}
function Stack(H) {
  var C = this.__data__ = new ListCache(H);
  this.size = C.size;
}
Stack.prototype.clear = stackClear;
Stack.prototype.delete = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function setCacheAdd(H) {
  return this.__data__.set(H, HASH_UNDEFINED), this;
}
function setCacheHas(H) {
  return this.__data__.has(H);
}
function SetCache(H) {
  var C = -1, G = H == null ? 0 : H.length;
  for (this.__data__ = new MapCache(); ++C < G; )
    this.add(H[C]);
}
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;
function arraySome(H, C) {
  for (var G = -1, U = H == null ? 0 : H.length; ++G < U; )
    if (C(H[G], G, H))
      return !0;
  return !1;
}
function cacheHas(H, C) {
  return H.has(C);
}
var COMPARE_PARTIAL_FLAG$3 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
function equalArrays(H, C, G, U, K, W) {
  var Z = G & COMPARE_PARTIAL_FLAG$3, X = H.length, Q = C.length;
  if (X != Q && !(Z && Q > X))
    return !1;
  var ee = W.get(H), te = W.get(C);
  if (ee && te)
    return ee == C && te == H;
  var re = -1, ne = !0, ae = G & COMPARE_UNORDERED_FLAG$1 ? new SetCache() : void 0;
  for (W.set(H, C), W.set(C, H); ++re < X; ) {
    var ie = H[re], se = C[re];
    if (U)
      var oe = Z ? U(se, ie, re, C, H, W) : U(ie, se, re, H, C, W);
    if (oe !== void 0) {
      if (oe)
        continue;
      ne = !1;
      break;
    }
    if (ae) {
      if (!arraySome(C, function(le, ue) {
        if (!cacheHas(ae, ue) && (ie === le || K(ie, le, G, U, W)))
          return ae.push(ue);
      })) {
        ne = !1;
        break;
      }
    } else if (!(ie === se || K(ie, se, G, U, W))) {
      ne = !1;
      break;
    }
  }
  return W.delete(H), W.delete(C), ne;
}
var Uint8Array$1 = root$1.Uint8Array;
const Uint8Array$2 = Uint8Array$1;
function mapToArray(H) {
  var C = -1, G = Array(H.size);
  return H.forEach(function(U, K) {
    G[++C] = [K, U];
  }), G;
}
function setToArray(H) {
  var C = -1, G = Array(H.size);
  return H.forEach(function(U) {
    G[++C] = U;
  }), G;
}
var COMPARE_PARTIAL_FLAG$2 = 1, COMPARE_UNORDERED_FLAG = 2, boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$1 = "[object String]", symbolTag$1 = "[object Symbol]", arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]", symbolProto = Symbol$3 ? Symbol$3.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
function equalByTag(H, C, G, U, K, W, Z) {
  switch (G) {
    case dataViewTag$2:
      if (H.byteLength != C.byteLength || H.byteOffset != C.byteOffset)
        return !1;
      H = H.buffer, C = C.buffer;
    case arrayBufferTag$1:
      return !(H.byteLength != C.byteLength || !W(new Uint8Array$2(H), new Uint8Array$2(C)));
    case boolTag$1:
    case dateTag$1:
    case numberTag$1:
      return eq(+H, +C);
    case errorTag$1:
      return H.name == C.name && H.message == C.message;
    case regexpTag$1:
    case stringTag$1:
      return H == C + "";
    case mapTag$2:
      var X = mapToArray;
    case setTag$2:
      var Q = U & COMPARE_PARTIAL_FLAG$2;
      if (X || (X = setToArray), H.size != C.size && !Q)
        return !1;
      var ee = Z.get(H);
      if (ee)
        return ee == C;
      U |= COMPARE_UNORDERED_FLAG, Z.set(H, C);
      var te = equalArrays(X(H), X(C), U, K, W, Z);
      return Z.delete(H), te;
    case symbolTag$1:
      if (symbolValueOf)
        return symbolValueOf.call(H) == symbolValueOf.call(C);
  }
  return !1;
}
function arrayPush(H, C) {
  for (var G = -1, U = C.length, K = H.length; ++G < U; )
    H[K + G] = C[G];
  return H;
}
var isArray$2 = Array.isArray;
const isArray$3 = isArray$2;
function baseGetAllKeys(H, C, G) {
  var U = C(H);
  return isArray$3(H) ? U : arrayPush(U, G(H));
}
function arrayFilter(H, C) {
  for (var G = -1, U = H == null ? 0 : H.length, K = 0, W = []; ++G < U; ) {
    var Z = H[G];
    C(Z, G, H) && (W[K++] = Z);
  }
  return W;
}
function stubArray() {
  return [];
}
var objectProto$6 = Object.prototype, propertyIsEnumerable$1 = objectProto$6.propertyIsEnumerable, nativeGetSymbols = Object.getOwnPropertySymbols, getSymbols = nativeGetSymbols ? function(H) {
  return H == null ? [] : (H = Object(H), arrayFilter(nativeGetSymbols(H), function(C) {
    return propertyIsEnumerable$1.call(H, C);
  }));
} : stubArray;
const getSymbols$1 = getSymbols;
function baseTimes(H, C) {
  for (var G = -1, U = Array(H); ++G < H; )
    U[G] = C(G);
  return U;
}
var argsTag$2 = "[object Arguments]";
function baseIsArguments(H) {
  return isObjectLike(H) && baseGetTag(H) == argsTag$2;
}
var objectProto$5 = Object.prototype, hasOwnProperty$4 = objectProto$5.hasOwnProperty, propertyIsEnumerable = objectProto$5.propertyIsEnumerable, isArguments = baseIsArguments(function() {
  return arguments;
}()) ? baseIsArguments : function(H) {
  return isObjectLike(H) && hasOwnProperty$4.call(H, "callee") && !propertyIsEnumerable.call(H, "callee");
};
const isArguments$1 = isArguments;
function stubFalse() {
  return !1;
}
var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports, freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module, moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1, Buffer$1 = moduleExports$1 ? root$1.Buffer : void 0, nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : void 0, isBuffer = nativeIsBuffer || stubFalse;
const isBuffer$1 = isBuffer;
var MAX_SAFE_INTEGER$2 = 9007199254740991, reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(H, C) {
  var G = typeof H;
  return C = C ?? MAX_SAFE_INTEGER$2, !!C && (G == "number" || G != "symbol" && reIsUint.test(H)) && H > -1 && H % 1 == 0 && H < C;
}
var MAX_SAFE_INTEGER$1 = 9007199254740991;
function isLength(H) {
  return typeof H == "number" && H > -1 && H % 1 == 0 && H <= MAX_SAFE_INTEGER$1;
}
var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", mapTag$1 = "[object Map]", numberTag = "[object Number]", objectTag$2 = "[object Object]", regexpTag = "[object RegExp]", setTag$1 = "[object Set]", stringTag = "[object String]", weakMapTag$1 = "[object WeakMap]", arrayBufferTag = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]", typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = !0;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag$1] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag$1] = typedArrayTags[numberTag] = typedArrayTags[objectTag$2] = typedArrayTags[regexpTag] = typedArrayTags[setTag$1] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag$1] = !1;
function baseIsTypedArray(H) {
  return isObjectLike(H) && isLength(H.length) && !!typedArrayTags[baseGetTag(H)];
}
function baseUnary(H) {
  return function(C) {
    return H(C);
  };
}
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports, freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module, moduleExports = freeModule && freeModule.exports === freeExports, freeProcess = moduleExports && freeGlobal$1.process, nodeUtil = function() {
  try {
    var H = freeModule && freeModule.require && freeModule.require("util").types;
    return H || freeProcess && freeProcess.binding && freeProcess.binding("util");
  } catch {
  }
}();
const nodeUtil$1 = nodeUtil;
var nodeIsTypedArray = nodeUtil$1 && nodeUtil$1.isTypedArray, isTypedArray$1 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
const isTypedArray$2 = isTypedArray$1;
var objectProto$4 = Object.prototype, hasOwnProperty$3 = objectProto$4.hasOwnProperty;
function arrayLikeKeys(H, C) {
  var G = isArray$3(H), U = !G && isArguments$1(H), K = !G && !U && isBuffer$1(H), W = !G && !U && !K && isTypedArray$2(H), Z = G || U || K || W, X = Z ? baseTimes(H.length, String) : [], Q = X.length;
  for (var ee in H)
    (C || hasOwnProperty$3.call(H, ee)) && !(Z && // Safari 9 has enumerable `arguments.length` in strict mode.
    (ee == "length" || K && (ee == "offset" || ee == "parent") || W && (ee == "buffer" || ee == "byteLength" || ee == "byteOffset") || // Skip index properties.
    isIndex(ee, Q))) && X.push(ee);
  return X;
}
var objectProto$3 = Object.prototype;
function isPrototype(H) {
  var C = H && H.constructor, G = typeof C == "function" && C.prototype || objectProto$3;
  return H === G;
}
var nativeKeys = overArg(Object.keys, Object);
const nativeKeys$1 = nativeKeys;
var objectProto$2 = Object.prototype, hasOwnProperty$2 = objectProto$2.hasOwnProperty;
function baseKeys(H) {
  if (!isPrototype(H))
    return nativeKeys$1(H);
  var C = [];
  for (var G in Object(H))
    hasOwnProperty$2.call(H, G) && G != "constructor" && C.push(G);
  return C;
}
function isArrayLike$1(H) {
  return H != null && isLength(H.length) && !isFunction$1(H);
}
function keys$1(H) {
  return isArrayLike$1(H) ? arrayLikeKeys(H) : baseKeys(H);
}
function getAllKeys(H) {
  return baseGetAllKeys(H, keys$1, getSymbols$1);
}
var COMPARE_PARTIAL_FLAG$1 = 1, objectProto$1 = Object.prototype, hasOwnProperty$1 = objectProto$1.hasOwnProperty;
function equalObjects(H, C, G, U, K, W) {
  var Z = G & COMPARE_PARTIAL_FLAG$1, X = getAllKeys(H), Q = X.length, ee = getAllKeys(C), te = ee.length;
  if (Q != te && !Z)
    return !1;
  for (var re = Q; re--; ) {
    var ne = X[re];
    if (!(Z ? ne in C : hasOwnProperty$1.call(C, ne)))
      return !1;
  }
  var ae = W.get(H), ie = W.get(C);
  if (ae && ie)
    return ae == C && ie == H;
  var se = !0;
  W.set(H, C), W.set(C, H);
  for (var oe = Z; ++re < Q; ) {
    ne = X[re];
    var le = H[ne], ue = C[ne];
    if (U)
      var ce = Z ? U(ue, le, ne, C, H, W) : U(le, ue, ne, H, C, W);
    if (!(ce === void 0 ? le === ue || K(le, ue, G, U, W) : ce)) {
      se = !1;
      break;
    }
    oe || (oe = ne == "constructor");
  }
  if (se && !oe) {
    var de = H.constructor, ge = C.constructor;
    de != ge && "constructor" in H && "constructor" in C && !(typeof de == "function" && de instanceof de && typeof ge == "function" && ge instanceof ge) && (se = !1);
  }
  return W.delete(H), W.delete(C), se;
}
var DataView$2 = getNative(root$1, "DataView");
const DataView$3 = DataView$2;
var Promise$1 = getNative(root$1, "Promise");
const Promise$2 = Promise$1;
var Set$1 = getNative(root$1, "Set");
const Set$2 = Set$1;
var WeakMap$3 = getNative(root$1, "WeakMap");
const WeakMap$4 = WeakMap$3;
var mapTag = "[object Map]", objectTag$1 = "[object Object]", promiseTag = "[object Promise]", setTag = "[object Set]", weakMapTag = "[object WeakMap]", dataViewTag = "[object DataView]", dataViewCtorString = toSource(DataView$3), mapCtorString = toSource(Map$2), promiseCtorString = toSource(Promise$2), setCtorString = toSource(Set$2), weakMapCtorString = toSource(WeakMap$4), getTag = baseGetTag;
(DataView$3 && getTag(new DataView$3(new ArrayBuffer(1))) != dataViewTag || Map$2 && getTag(new Map$2()) != mapTag || Promise$2 && getTag(Promise$2.resolve()) != promiseTag || Set$2 && getTag(new Set$2()) != setTag || WeakMap$4 && getTag(new WeakMap$4()) != weakMapTag) && (getTag = function(H) {
  var C = baseGetTag(H), G = C == objectTag$1 ? H.constructor : void 0, U = G ? toSource(G) : "";
  if (U)
    switch (U) {
      case dataViewCtorString:
        return dataViewTag;
      case mapCtorString:
        return mapTag;
      case promiseCtorString:
        return promiseTag;
      case setCtorString:
        return setTag;
      case weakMapCtorString:
        return weakMapTag;
    }
  return C;
});
const getTag$1 = getTag;
var COMPARE_PARTIAL_FLAG = 1, argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]", objectProto = Object.prototype, hasOwnProperty = objectProto.hasOwnProperty;
function baseIsEqualDeep(H, C, G, U, K, W) {
  var Z = isArray$3(H), X = isArray$3(C), Q = Z ? arrayTag : getTag$1(H), ee = X ? arrayTag : getTag$1(C);
  Q = Q == argsTag ? objectTag : Q, ee = ee == argsTag ? objectTag : ee;
  var te = Q == objectTag, re = ee == objectTag, ne = Q == ee;
  if (ne && isBuffer$1(H)) {
    if (!isBuffer$1(C))
      return !1;
    Z = !0, te = !1;
  }
  if (ne && !te)
    return W || (W = new Stack()), Z || isTypedArray$2(H) ? equalArrays(H, C, G, U, K, W) : equalByTag(H, C, Q, G, U, K, W);
  if (!(G & COMPARE_PARTIAL_FLAG)) {
    var ae = te && hasOwnProperty.call(H, "__wrapped__"), ie = re && hasOwnProperty.call(C, "__wrapped__");
    if (ae || ie) {
      var se = ae ? H.value() : H, oe = ie ? C.value() : C;
      return W || (W = new Stack()), K(se, oe, G, U, W);
    }
  }
  return ne ? (W || (W = new Stack()), equalObjects(H, C, G, U, K, W)) : !1;
}
function baseIsEqual(H, C, G, U, K) {
  return H === C ? !0 : H == null || C == null || !isObjectLike(H) && !isObjectLike(C) ? H !== H && C !== C : baseIsEqualDeep(H, C, G, U, baseIsEqual, K);
}
function isEqual(H, C) {
  return baseIsEqual(H, C);
}
var alignProps = {
  align: Object,
  target: [Object, Function],
  onAlign: Function,
  monitorBufferTime: Number,
  monitorWindowResize: Boolean,
  disabled: Boolean
};
function getElement(H) {
  return typeof H != "function" ? null : H();
}
function getPoint(H) {
  return _typeof$2(H) !== "object" || !H ? null : H;
}
const Align = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Align",
  props: alignProps,
  emits: ["align"],
  setup: function(C, G) {
    var U = G.expose, K = G.slots, W = ref({}), Z = ref(), X = useBuffer(function() {
      var se = C.disabled, oe = C.target, le = C.align, ue = C.onAlign;
      if (!se && oe && Z.value) {
        var ce = Z.value, de, ge = getElement(oe), fe = getPoint(oe);
        W.value.element = ge, W.value.point = fe, W.value.align = le;
        var ve = document, pe = ve.activeElement;
        return ge && isVisible(ge) ? de = alignElement(ce, ge, le) : fe && (de = alignPoint(ce, fe, le)), restoreFocus(pe, ce), ue && de && ue(ce, de), !0;
      }
      return !1;
    }, computed(function() {
      return C.monitorBufferTime;
    })), Q = _slicedToArray$2(X, 2), ee = Q[0], te = Q[1], re = ref({
      cancel: function() {
      }
    }), ne = ref({
      cancel: function() {
      }
    }), ae = function() {
      var oe = C.target, le = getElement(oe), ue = getPoint(oe);
      Z.value !== ne.value.element && (ne.value.cancel(), ne.value.element = Z.value, ne.value.cancel = monitorResize(Z.value, ee)), (W.value.element !== le || !isSamePoint(W.value.point, ue) || !isEqual(W.value.align, C.align)) && (ee(), re.value.element !== le && (re.value.cancel(), re.value.element = le, re.value.cancel = monitorResize(le, ee)));
    };
    onMounted(function() {
      nextTick(function() {
        ae();
      });
    }), onUpdated(function() {
      nextTick(function() {
        ae();
      });
    }), watch(function() {
      return C.disabled;
    }, function(se) {
      se ? te() : ee();
    }, {
      immediate: !0,
      flush: "post"
    });
    var ie = ref(null);
    return watch(function() {
      return C.monitorWindowResize;
    }, function(se) {
      se ? ie.value || (ie.value = addEventListenerWrap(window, "resize", ee)) : ie.value && (ie.value.remove(), ie.value = null);
    }, {
      flush: "post"
    }), onUnmounted(function() {
      re.value.cancel(), ne.value.cancel(), ie.value && ie.value.remove(), te();
    }), U({
      forceAlign: function() {
        return ee(!0);
      }
    }), function() {
      var se = K == null ? void 0 : K.default();
      return se ? cloneElement(se[0], {
        ref: Z
      }, !0, !0) : null;
    };
  }
}), PopupInner = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "PopupInner",
  inheritAttrs: !1,
  props: innerProps,
  emits: ["mouseenter", "mouseleave", "mousedown", "touchstart", "align"],
  setup: function(C, G) {
    var U = G.expose, K = G.attrs, W = G.slots, Z = ref(), X = ref(), Q = ref(), ee = useStretchStyle(toRef(C, "stretch")), te = _slicedToArray$2(ee, 2), re = te[0], ne = te[1], ae = function() {
      C.stretch && ne(C.getRootDomNode());
    }, ie = ref(!1), se;
    watch(function() {
      return C.visible;
    }, function(ye) {
      clearTimeout(se), ye ? se = setTimeout(function() {
        ie.value = C.visible;
      }) : ie.value = !1;
    }, {
      immediate: !0
    });
    var oe = useVisibleStatus(ie, ae), le = _slicedToArray$2(oe, 2), ue = le[0], ce = le[1], de = ref(), ge = function() {
      return C.point ? C.point : C.getRootDomNode;
    }, fe = function() {
      var Ce;
      (Ce = Z.value) === null || Ce === void 0 || Ce.forceAlign();
    }, ve = function(Ce, Ie) {
      var be = C.getClassNameFromAlign(Ie), Se = Q.value;
      if (Q.value !== be && (Q.value = be), ue.value === "align") {
        var Ae;
        Se !== be ? Promise.resolve().then(function() {
          fe();
        }) : ce(function() {
          var _e;
          (_e = de.value) === null || _e === void 0 || _e.call(de);
        }), (Ae = C.onAlign) === null || Ae === void 0 || Ae.call(C, Ce, Ie);
      }
    }, pe = computed(function() {
      var ye = _typeof$2(C.animation) === "object" ? C.animation : getMotion(C);
      return ["onAfterEnter", "onAfterLeave"].forEach(function(Ce) {
        var Ie = ye[Ce];
        ye[Ce] = function(be) {
          ce(), ue.value = "stable", Ie == null || Ie(be);
        };
      }), ye;
    }), he = function() {
      return new Promise(function(Ce) {
        de.value = Ce;
      });
    };
    watch([pe, ue], function() {
      !pe.value && ue.value === "motion" && ce();
    }, {
      immediate: !0
    }), U({
      forceAlign: fe,
      getElement: function() {
        return X.value.$el || X.value;
      }
    });
    var me = computed(function() {
      var ye;
      return !((ye = C.align) !== null && ye !== void 0 && ye.points && (ue.value === "align" || ue.value === "stable"));
    });
    return function() {
      var ye, Ce = C.zIndex, Ie = C.align, be = C.prefixCls, Se = C.destroyPopupOnHide, Ae = C.onMouseenter, _e = C.onMouseleave, xe = C.onTouchstart, Te = xe === void 0 ? function() {
      } : xe, Pe = C.onMousedown, $e = ue.value, Me = [_objectSpread2$1(_objectSpread2$1({}, re.value), {}, {
        zIndex: Ce,
        opacity: $e === "motion" || $e === "stable" || !ie.value ? null : 0,
        // pointerEvents: statusValue === 'stable' ? null : 'none',
        pointerEvents: !ie.value && $e !== "stable" ? "none" : null
      }), K.style], Ee = flattenChildren((ye = W.default) === null || ye === void 0 ? void 0 : ye.call(W, {
        visible: C.visible
      }));
      Ee.length > 1 && (Ee = createVNode$1("div", {
        class: "".concat(be, "-content")
      }, [Ee]));
      var we = classNames(be, K.class, Q.value), Oe = ie.value || !C.visible, Ne = Oe ? getTransitionProps(pe.value.name, pe.value) : {};
      return createVNode$1(Transition, _objectSpread2$1(_objectSpread2$1({
        ref: X
      }, Ne), {}, {
        onBeforeEnter: he
      }), {
        default: function() {
          return !Se || C.visible ? withDirectives(createVNode$1(Align, {
            target: ge(),
            key: "popup",
            ref: Z,
            monitorWindowResize: !0,
            disabled: me.value,
            align: Ie,
            onAlign: ve
          }, {
            default: function() {
              return createVNode$1("div", _objectSpread2$1(_objectSpread2$1({
                class: we,
                onMouseenter: Ae,
                onMouseleave: _e,
                onMousedown: withModifiers(Pe, ["capture"])
              }, _defineProperty$A({}, supportsPassive$1 ? "onTouchstartPassive" : "onTouchstart", withModifiers(Te, ["capture"]))), {}, {
                style: Me
              }), [Ee]);
            }
          }), [[vShow, ie.value]]) : null;
        }
      });
    };
  }
}), Popup = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Popup",
  inheritAttrs: !1,
  props: popupProps,
  setup: function(C, G) {
    var U = G.attrs, K = G.slots, W = G.expose, Z = ref(!1), X = ref(!1), Q = ref();
    return watch([function() {
      return C.visible;
    }, function() {
      return C.mobile;
    }], function() {
      Z.value = C.visible, C.visible && C.mobile && (X.value = !0);
    }, {
      immediate: !0,
      flush: "post"
    }), W({
      forceAlign: function() {
        var te;
        (te = Q.value) === null || te === void 0 || te.forceAlign();
      },
      getElement: function() {
        var te;
        return (te = Q.value) === null || te === void 0 ? void 0 : te.getElement();
      }
    }), function() {
      var ee = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, C), U), {}, {
        visible: Z.value
      }), te = X.value ? createVNode$1(MobilePopupInner, _objectSpread2$1(_objectSpread2$1({}, ee), {}, {
        mobile: C.mobile,
        ref: Q
      }), {
        default: K.default
      }) : createVNode$1(PopupInner, _objectSpread2$1(_objectSpread2$1({}, ee), {}, {
        ref: Q
      }), {
        default: K.default
      });
      return createVNode$1("div", null, [createVNode$1(Mask, ee, null), te]);
    };
  }
});
function isPointsEq(H, C, G) {
  return G ? H[0] === C[0] : H[0] === C[0] && H[1] === C[1];
}
function getAlignFromPlacement(H, C, G) {
  var U = H[C] || {};
  return _objectSpread2$1(_objectSpread2$1({}, U), G);
}
function getAlignPopupClassName(H, C, G, U) {
  for (var K = G.points, W = Object.keys(H), Z = 0; Z < W.length; Z += 1) {
    var X = W[Z];
    if (isPointsEq(H[X].points, K, U))
      return "".concat(C, "-placement-").concat(X);
  }
  return "";
}
const BaseMixin = {
  methods: {
    setState: function() {
      var C = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, G = arguments.length > 1 ? arguments[1] : void 0, U = typeof C == "function" ? C(this.$data, this.$props) : C;
      if (this.getDerivedStateFromProps) {
        var K = this.getDerivedStateFromProps(getOptionProps(this), _objectSpread2$1(_objectSpread2$1({}, this.$data), U));
        if (K === null)
          return;
        U = _objectSpread2$1(_objectSpread2$1({}, U), K || {});
      }
      _extends(this.$data, U), this._.isMounted && this.$forceUpdate(), nextTick(function() {
        G && G();
      });
    },
    __emit: function() {
      var C = [].slice.call(arguments, 0), G = C[0];
      G = "on".concat(G[0].toUpperCase()).concat(G.substring(1));
      var U = this.$props[G] || this.$attrs[G];
      if (C.length && U)
        if (Array.isArray(U))
          for (var K = 0, W = U.length; K < W; K++)
            U[K].apply(U, _toConsumableArray(C.slice(1)));
        else
          U.apply(void 0, _toConsumableArray(C.slice(1)));
    }
  }
};
var TriggerContextKey = Symbol("TriggerContextKey"), useInjectTrigger = function(C) {
  return C ? inject(TriggerContextKey, {
    setPortal: function() {
    },
    popPortal: !1
  }) : {
    setPortal: function() {
    },
    popPortal: !1
  };
}, PortalContextKey = Symbol("PortalContextKey"), useProvidePortal = function(C) {
  var G = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    inTriggerContext: !0
  };
  provide(PortalContextKey, {
    inTriggerContext: G.inTriggerContext,
    shouldRender: computed(function() {
      var U = C || {}, K = U.sPopupVisible, W = U.popupRef, Z = U.forceRender, X = U.autoDestroy, Q = !1;
      return (K || W || Z) && (Q = !0), !K && X && (Q = !1), Q;
    })
  });
}, useInjectPortal = function() {
  useProvidePortal({}, {
    inTriggerContext: !1
  });
  var C = inject(PortalContextKey, {
    shouldRender: computed(function() {
      return !1;
    }),
    inTriggerContext: !1
  });
  return {
    shouldRender: computed(function() {
      return C.shouldRender.value || C.inTriggerContext === !1;
    })
  };
};
const Portal = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Portal",
  inheritAttrs: !1,
  props: {
    getContainer: PropTypes$1.func.isRequired,
    didUpdate: Function
  },
  setup: function(C, G) {
    var U = G.slots, K = !0, W, Z = useInjectPortal(), X = Z.shouldRender;
    onBeforeMount(function() {
      K = !1, X.value && (W = C.getContainer());
    });
    var Q = watch(X, function() {
      X.value && !W && (W = C.getContainer()), W && Q();
    });
    return onUpdated(function() {
      nextTick(function() {
        if (X.value) {
          var ee;
          (ee = C.didUpdate) === null || ee === void 0 || ee.call(C, C);
        }
      });
    }), onBeforeUnmount(function() {
      W && W.parentNode && W.parentNode.removeChild(W);
    }), function() {
      if (!X.value)
        return null;
      if (K) {
        var ee;
        return (ee = U.default) === null || ee === void 0 ? void 0 : ee.call(U);
      }
      return W ? createVNode$1(Teleport, {
        to: W
      }, U) : null;
    };
  }
});
function noop$4() {
}
function returnEmptyString() {
  return "";
}
function returnDocument(H) {
  return H ? H.ownerDocument : window.document;
}
var ALL_HANDLERS = ["onClick", "onMousedown", "onTouchstart", "onMouseenter", "onMouseleave", "onFocus", "onBlur", "onContextmenu"];
const Trigger = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Trigger",
  mixins: [BaseMixin],
  inheritAttrs: !1,
  props: {
    action: PropTypes$1.oneOfType([PropTypes$1.string, PropTypes$1.arrayOf(PropTypes$1.string)]).def([]),
    showAction: PropTypes$1.any.def([]),
    hideAction: PropTypes$1.any.def([]),
    getPopupClassNameFromAlign: PropTypes$1.any.def(returnEmptyString),
    onPopupVisibleChange: Function,
    afterPopupVisibleChange: PropTypes$1.func.def(noop$4),
    popup: PropTypes$1.any,
    popupStyle: {
      type: Object,
      default: void 0
    },
    prefixCls: PropTypes$1.string.def("rc-trigger-popup"),
    popupClassName: PropTypes$1.string.def(""),
    popupPlacement: String,
    builtinPlacements: PropTypes$1.object,
    popupTransitionName: String,
    popupAnimation: PropTypes$1.any,
    mouseEnterDelay: PropTypes$1.number.def(0),
    mouseLeaveDelay: PropTypes$1.number.def(0.1),
    zIndex: Number,
    focusDelay: PropTypes$1.number.def(0),
    blurDelay: PropTypes$1.number.def(0.15),
    getPopupContainer: Function,
    getDocument: PropTypes$1.func.def(returnDocument),
    forceRender: {
      type: Boolean,
      default: void 0
    },
    destroyPopupOnHide: {
      type: Boolean,
      default: !1
    },
    mask: {
      type: Boolean,
      default: !1
    },
    maskClosable: {
      type: Boolean,
      default: !0
    },
    // onPopupAlign: PropTypes.func.def(noop),
    popupAlign: PropTypes$1.object.def(function() {
      return {};
    }),
    popupVisible: {
      type: Boolean,
      default: void 0
    },
    defaultPopupVisible: {
      type: Boolean,
      default: !1
    },
    maskTransitionName: String,
    maskAnimation: String,
    stretch: String,
    alignPoint: {
      type: Boolean,
      default: void 0
    },
    autoDestroy: {
      type: Boolean,
      default: !1
    },
    mobile: Object,
    getTriggerDOMNode: Function,
    // portal context will change
    tryPopPortal: Boolean
    // no need reactive
  },
  setup: function(C) {
    var G = computed(function() {
      var Q = C.popupPlacement, ee = C.popupAlign, te = C.builtinPlacements;
      return Q && te ? getAlignFromPlacement(te, Q, ee) : ee;
    }), U = useInjectTrigger(C.tryPopPortal), K = U.setPortal, W = U.popPortal, Z = ref(null), X = function(ee) {
      Z.value = ee;
    };
    return {
      popPortal: W,
      setPortal: K,
      vcTriggerContext: inject("vcTriggerContext", {}),
      popupRef: Z,
      setPopupRef: X,
      triggerRef: ref(null),
      align: G,
      focusTime: null,
      clickOutsideHandler: null,
      contextmenuOutsideHandler1: null,
      contextmenuOutsideHandler2: null,
      touchOutsideHandler: null,
      attachId: null,
      delayTimer: null,
      hasPopupMouseDown: !1,
      preClickTime: null,
      preTouchTime: null,
      mouseDownTimeout: null,
      childOriginEvents: {}
    };
  },
  data: function() {
    var C = this, G, U = this.$props, K;
    return this.popupVisible !== void 0 ? K = !!U.popupVisible : K = !!U.defaultPopupVisible, ALL_HANDLERS.forEach(function(W) {
      C["fire".concat(W)] = function(Z) {
        C.fireEvents(W, Z);
      };
    }), (G = this.setPortal) === null || G === void 0 || G.call(this, createVNode$1(Portal, {
      key: "portal",
      getContainer: this.getContainer,
      didUpdate: this.handlePortalUpdate
    }, {
      default: this.getComponent
    })), {
      prevPopupVisible: K,
      sPopupVisible: K,
      point: null
    };
  },
  watch: {
    popupVisible: function(C) {
      C !== void 0 && (this.prevPopupVisible = this.sPopupVisible, this.sPopupVisible = C);
    }
  },
  created: function() {
    provide("vcTriggerContext", {
      onPopupMouseDown: this.onPopupMouseDown
    }), useProvidePortal(this);
  },
  deactivated: function() {
    this.setPopupVisible(!1);
  },
  mounted: function() {
    var C = this;
    this.$nextTick(function() {
      C.updatedCal();
    });
  },
  updated: function() {
    var C = this;
    this.$nextTick(function() {
      C.updatedCal();
    });
  },
  beforeUnmount: function() {
    this.clearDelayTimer(), this.clearOutsideHandler(), clearTimeout(this.mouseDownTimeout), wrapperRaf.cancel(this.attachId);
  },
  methods: {
    updatedCal: function() {
      var C = this.$props, G = this.$data;
      if (G.sPopupVisible) {
        var U;
        !this.clickOutsideHandler && (this.isClickToHide() || this.isContextmenuToShow()) && (U = C.getDocument(this.getRootDomNode()), this.clickOutsideHandler = addEventListenerWrap(U, "mousedown", this.onDocumentClick)), this.touchOutsideHandler || (U = U || C.getDocument(this.getRootDomNode()), this.touchOutsideHandler = addEventListenerWrap(U, "touchstart", this.onDocumentClick, supportsPassive$1 ? {
          passive: !1
        } : !1)), !this.contextmenuOutsideHandler1 && this.isContextmenuToShow() && (U = U || C.getDocument(this.getRootDomNode()), this.contextmenuOutsideHandler1 = addEventListenerWrap(U, "scroll", this.onContextmenuClose)), !this.contextmenuOutsideHandler2 && this.isContextmenuToShow() && (this.contextmenuOutsideHandler2 = addEventListenerWrap(window, "blur", this.onContextmenuClose));
      } else
        this.clearOutsideHandler();
    },
    onMouseenter: function(C) {
      var G = this.$props.mouseEnterDelay;
      this.fireEvents("onMouseenter", C), this.delaySetPopupVisible(!0, G, G ? null : C);
    },
    onMouseMove: function(C) {
      this.fireEvents("onMousemove", C), this.setPoint(C);
    },
    onMouseleave: function(C) {
      this.fireEvents("onMouseleave", C), this.delaySetPopupVisible(!1, this.$props.mouseLeaveDelay);
    },
    onPopupMouseenter: function() {
      this.clearDelayTimer();
    },
    onPopupMouseleave: function(C) {
      var G;
      C && C.relatedTarget && !C.relatedTarget.setTimeout && contains((G = this.popupRef) === null || G === void 0 ? void 0 : G.getElement(), C.relatedTarget) || this.delaySetPopupVisible(!1, this.$props.mouseLeaveDelay);
    },
    onFocus: function(C) {
      this.fireEvents("onFocus", C), this.clearDelayTimer(), this.isFocusToShow() && (this.focusTime = Date.now(), this.delaySetPopupVisible(!0, this.$props.focusDelay));
    },
    onMousedown: function(C) {
      this.fireEvents("onMousedown", C), this.preClickTime = Date.now();
    },
    onTouchstart: function(C) {
      this.fireEvents("onTouchstart", C), this.preTouchTime = Date.now();
    },
    onBlur: function(C) {
      contains(C.target, C.relatedTarget || document.activeElement) || (this.fireEvents("onBlur", C), this.clearDelayTimer(), this.isBlurToHide() && this.delaySetPopupVisible(!1, this.$props.blurDelay));
    },
    onContextmenu: function(C) {
      C.preventDefault(), this.fireEvents("onContextmenu", C), this.setPopupVisible(!0, C);
    },
    onContextmenuClose: function() {
      this.isContextmenuToShow() && this.close();
    },
    onClick: function(C) {
      if (this.fireEvents("onClick", C), this.focusTime) {
        var G;
        if (this.preClickTime && this.preTouchTime ? G = Math.min(this.preClickTime, this.preTouchTime) : this.preClickTime ? G = this.preClickTime : this.preTouchTime && (G = this.preTouchTime), Math.abs(G - this.focusTime) < 20)
          return;
        this.focusTime = 0;
      }
      this.preClickTime = 0, this.preTouchTime = 0, this.isClickToShow() && (this.isClickToHide() || this.isBlurToHide()) && C && C.preventDefault && C.preventDefault(), C && C.domEvent && C.domEvent.preventDefault();
      var U = !this.$data.sPopupVisible;
      (this.isClickToHide() && !U || U && this.isClickToShow()) && this.setPopupVisible(!this.$data.sPopupVisible, C);
    },
    onPopupMouseDown: function() {
      var C = this, G = this.vcTriggerContext, U = G === void 0 ? {} : G;
      this.hasPopupMouseDown = !0, clearTimeout(this.mouseDownTimeout), this.mouseDownTimeout = setTimeout(function() {
        C.hasPopupMouseDown = !1;
      }, 0), U.onPopupMouseDown && U.onPopupMouseDown.apply(U, arguments);
    },
    onDocumentClick: function(C) {
      if (!(this.$props.mask && !this.$props.maskClosable)) {
        var G = C.target, U = this.getRootDomNode(), K = this.getPopupDomNode();
        (!contains(U, G) || this.isContextMenuOnly()) && !contains(K, G) && !this.hasPopupMouseDown && this.delaySetPopupVisible(!1, 0.1);
      }
    },
    getPopupDomNode: function() {
      var C;
      return ((C = this.popupRef) === null || C === void 0 ? void 0 : C.getElement()) || null;
    },
    getRootDomNode: function() {
      var C = this.$props.getTriggerDOMNode;
      if (C) {
        var G = findDOMNode(this.triggerRef);
        return findDOMNode(C(G));
      }
      try {
        var U = findDOMNode(this.triggerRef);
        if (U)
          return U;
      } catch {
      }
      return findDOMNode(this);
    },
    handleGetPopupClassFromAlign: function(C) {
      var G = [], U = this.$props, K = U.popupPlacement, W = U.builtinPlacements, Z = U.prefixCls, X = U.alignPoint, Q = U.getPopupClassNameFromAlign;
      return K && W && G.push(getAlignPopupClassName(W, Z, C, X)), Q && G.push(Q(C)), G.join(" ");
    },
    getPopupAlign: function() {
      var C = this.$props, G = C.popupPlacement, U = C.popupAlign, K = C.builtinPlacements;
      return G && K ? getAlignFromPlacement(K, G, U) : U;
    },
    getComponent: function() {
      var C = this, G = {};
      this.isMouseEnterToShow() && (G.onMouseenter = this.onPopupMouseenter), this.isMouseLeaveToHide() && (G.onMouseleave = this.onPopupMouseleave), G.onMousedown = this.onPopupMouseDown, G[supportsPassive$1 ? "onTouchstartPassive" : "onTouchstart"] = this.onPopupMouseDown;
      var U = this.handleGetPopupClassFromAlign, K = this.getRootDomNode, W = this.getContainer, Z = this.$attrs, X = this.$props, Q = X.prefixCls, ee = X.destroyPopupOnHide, te = X.popupClassName, re = X.popupAnimation, ne = X.popupTransitionName, ae = X.popupStyle, ie = X.mask, se = X.maskAnimation, oe = X.maskTransitionName, le = X.zIndex, ue = X.stretch, ce = X.alignPoint, de = X.mobile, ge = X.forceRender, fe = this.$data, ve = fe.sPopupVisible, pe = fe.point, he = _objectSpread2$1(_objectSpread2$1({
        prefixCls: Q,
        destroyPopupOnHide: ee,
        visible: ve,
        point: ce ? pe : null,
        align: this.align,
        animation: re,
        getClassNameFromAlign: U,
        stretch: ue,
        getRootDomNode: K,
        mask: ie,
        zIndex: le,
        transitionName: ne,
        maskAnimation: se,
        maskTransitionName: oe,
        getContainer: W,
        class: te,
        style: ae,
        onAlign: Z.onPopupAlign || noop$4
      }, G), {}, {
        ref: this.setPopupRef,
        mobile: de,
        forceRender: ge
      });
      return createVNode$1(Popup, he, {
        default: this.$slots.popup || function() {
          return getComponent(C, "popup");
        }
      });
    },
    attachParent: function(C) {
      var G = this;
      wrapperRaf.cancel(this.attachId);
      var U = this.$props, K = U.getPopupContainer, W = U.getDocument, Z = this.getRootDomNode(), X;
      K ? (Z || K.length === 0) && (X = K(Z)) : X = W(this.getRootDomNode()).body, X ? X.appendChild(C) : this.attachId = wrapperRaf(function() {
        G.attachParent(C);
      });
    },
    getContainer: function() {
      var C = this.$props, G = C.getDocument, U = G(this.getRootDomNode()).createElement("div");
      return U.style.position = "absolute", U.style.top = "0", U.style.left = "0", U.style.width = "100%", this.attachParent(U), U;
    },
    setPopupVisible: function(C, G) {
      var U = this.alignPoint, K = this.sPopupVisible, W = this.onPopupVisibleChange;
      this.clearDelayTimer(), K !== C && (hasProp(this, "popupVisible") || this.setState({
        sPopupVisible: C,
        prevPopupVisible: K
      }), W && W(C)), U && G && C && this.setPoint(G);
    },
    setPoint: function(C) {
      var G = this.$props.alignPoint;
      !G || !C || this.setState({
        point: {
          pageX: C.pageX,
          pageY: C.pageY
        }
      });
    },
    handlePortalUpdate: function() {
      this.prevPopupVisible !== this.sPopupVisible && this.afterPopupVisibleChange(this.sPopupVisible);
    },
    delaySetPopupVisible: function(C, G, U) {
      var K = this, W = G * 1e3;
      if (this.clearDelayTimer(), W) {
        var Z = U ? {
          pageX: U.pageX,
          pageY: U.pageY
        } : null;
        this.delayTimer = requestAnimationTimeout(function() {
          K.setPopupVisible(C, Z), K.clearDelayTimer();
        }, W);
      } else
        this.setPopupVisible(C, U);
    },
    clearDelayTimer: function() {
      this.delayTimer && (cancelAnimationTimeout(this.delayTimer), this.delayTimer = null);
    },
    clearOutsideHandler: function() {
      this.clickOutsideHandler && (this.clickOutsideHandler.remove(), this.clickOutsideHandler = null), this.contextmenuOutsideHandler1 && (this.contextmenuOutsideHandler1.remove(), this.contextmenuOutsideHandler1 = null), this.contextmenuOutsideHandler2 && (this.contextmenuOutsideHandler2.remove(), this.contextmenuOutsideHandler2 = null), this.touchOutsideHandler && (this.touchOutsideHandler.remove(), this.touchOutsideHandler = null);
    },
    createTwoChains: function(C) {
      var G = function() {
      }, U = getEvents(this);
      return this.childOriginEvents[C] && U[C] ? this["fire".concat(C)] : (G = this.childOriginEvents[C] || U[C] || G, G);
    },
    isClickToShow: function() {
      var C = this.$props, G = C.action, U = C.showAction;
      return G.indexOf("click") !== -1 || U.indexOf("click") !== -1;
    },
    isContextMenuOnly: function() {
      var C = this.$props.action;
      return C === "contextmenu" || C.length === 1 && C[0] === "contextmenu";
    },
    isContextmenuToShow: function() {
      var C = this.$props, G = C.action, U = C.showAction;
      return G.indexOf("contextmenu") !== -1 || U.indexOf("contextmenu") !== -1;
    },
    isClickToHide: function() {
      var C = this.$props, G = C.action, U = C.hideAction;
      return G.indexOf("click") !== -1 || U.indexOf("click") !== -1;
    },
    isMouseEnterToShow: function() {
      var C = this.$props, G = C.action, U = C.showAction;
      return G.indexOf("hover") !== -1 || U.indexOf("mouseenter") !== -1;
    },
    isMouseLeaveToHide: function() {
      var C = this.$props, G = C.action, U = C.hideAction;
      return G.indexOf("hover") !== -1 || U.indexOf("mouseleave") !== -1;
    },
    isFocusToShow: function() {
      var C = this.$props, G = C.action, U = C.showAction;
      return G.indexOf("focus") !== -1 || U.indexOf("focus") !== -1;
    },
    isBlurToHide: function() {
      var C = this.$props, G = C.action, U = C.hideAction;
      return G.indexOf("focus") !== -1 || U.indexOf("blur") !== -1;
    },
    forcePopupAlign: function() {
      if (this.$data.sPopupVisible) {
        var C;
        (C = this.popupRef) === null || C === void 0 || C.forceAlign();
      }
    },
    fireEvents: function(C, G) {
      this.childOriginEvents[C] && this.childOriginEvents[C](G);
      var U = this.$props[C] || this.$attrs[C];
      U && U(G);
    },
    close: function() {
      this.setPopupVisible(!1);
    }
  },
  render: function() {
    var C = this, G = this.$attrs, U = filterEmpty(getSlot(this)), K = this.$props.alignPoint, W = U[0];
    this.childOriginEvents = getEvents(W);
    var Z = {
      key: "trigger"
    };
    this.isContextmenuToShow() ? Z.onContextmenu = this.onContextmenu : Z.onContextmenu = this.createTwoChains("onContextmenu"), this.isClickToHide() || this.isClickToShow() ? (Z.onClick = this.onClick, Z.onMousedown = this.onMousedown, Z[supportsPassive$1 ? "onTouchstartPassive" : "onTouchstart"] = this.onTouchstart) : (Z.onClick = this.createTwoChains("onClick"), Z.onMousedown = this.createTwoChains("onMousedown"), Z[supportsPassive$1 ? "onTouchstartPassive" : "onTouchstart"] = this.createTwoChains("onTouchstart")), this.isMouseEnterToShow() ? (Z.onMouseenter = this.onMouseenter, K && (Z.onMousemove = this.onMouseMove)) : Z.onMouseenter = this.createTwoChains("onMouseenter"), this.isMouseLeaveToHide() ? Z.onMouseleave = this.onMouseleave : Z.onMouseleave = this.createTwoChains("onMouseleave"), this.isFocusToShow() || this.isBlurToHide() ? (Z.onFocus = this.onFocus, Z.onBlur = this.onBlur) : (Z.onFocus = this.createTwoChains("onFocus"), Z.onBlur = function(te) {
      te && (!te.relatedTarget || !contains(te.target, te.relatedTarget)) && C.createTwoChains("onBlur")(te);
    });
    var X = classNames(W && W.props && W.props.class, G.class);
    X && (Z.class = X);
    var Q = cloneElement(W, _objectSpread2$1(_objectSpread2$1({}, Z), {}, {
      ref: "triggerRef"
    }), !0, !0);
    if (this.popPortal)
      return Q;
    var ee = createVNode$1(Portal, {
      key: "portal",
      getContainer: this.getContainer,
      didUpdate: this.handlePortalUpdate
    }, {
      default: this.getComponent
    });
    return createVNode$1(Fragment, null, [ee, Q]);
  }
});
var _excluded$r = ["empty"], getBuiltInPlacements = function(C) {
  var G = C === !0 ? 0 : 1;
  return {
    bottomLeft: {
      points: ["tl", "bl"],
      offset: [0, 4],
      overflow: {
        adjustX: G,
        adjustY: 1
      }
    },
    bottomRight: {
      points: ["tr", "br"],
      offset: [0, 4],
      overflow: {
        adjustX: G,
        adjustY: 1
      }
    },
    topLeft: {
      points: ["bl", "tl"],
      offset: [0, -4],
      overflow: {
        adjustX: G,
        adjustY: 1
      }
    },
    topRight: {
      points: ["br", "tr"],
      offset: [0, -4],
      overflow: {
        adjustX: G,
        adjustY: 1
      }
    }
  };
}, SelectTrigger = defineComponent({
  name: "SelectTrigger",
  inheritAttrs: !1,
  props: {
    dropdownAlign: Object,
    visible: {
      type: Boolean,
      default: void 0
    },
    disabled: {
      type: Boolean,
      default: void 0
    },
    dropdownClassName: String,
    dropdownStyle: PropTypes$1.object,
    placement: String,
    empty: {
      type: Boolean,
      default: void 0
    },
    prefixCls: String,
    popupClassName: String,
    animation: String,
    transitionName: String,
    getPopupContainer: Function,
    dropdownRender: Function,
    containerWidth: Number,
    dropdownMatchSelectWidth: PropTypes$1.oneOfType([Number, Boolean]).def(!0),
    popupElement: PropTypes$1.any,
    direction: String,
    getTriggerDOMNode: Function,
    onPopupVisibleChange: Function,
    onPopupMouseEnter: Function
  },
  setup: function(C, G) {
    var U = G.slots, K = G.attrs, W = G.expose, Z = computed(function() {
      var Q = C.dropdownMatchSelectWidth;
      return getBuiltInPlacements(Q);
    }), X = ref();
    return W({
      getPopupElement: function() {
        return X.value;
      }
    }), function() {
      var Q = _objectSpread2$1(_objectSpread2$1({}, C), K), ee = Q.empty, te = ee === void 0 ? !1 : ee, re = _objectWithoutProperties$2(Q, _excluded$r), ne = re.visible, ae = re.dropdownAlign, ie = re.prefixCls, se = re.popupElement, oe = re.dropdownClassName, le = re.dropdownStyle, ue = re.direction, ce = ue === void 0 ? "ltr" : ue, de = re.placement, ge = re.dropdownMatchSelectWidth, fe = re.containerWidth, ve = re.dropdownRender, pe = re.animation, he = re.transitionName, me = re.getPopupContainer, ye = re.getTriggerDOMNode, Ce = re.onPopupVisibleChange, Ie = re.onPopupMouseEnter, be = "".concat(ie, "-dropdown"), Se = se;
      ve && (Se = ve({
        menuNode: se,
        props: C
      }));
      var Ae = pe ? "".concat(be, "-").concat(pe) : he, _e = _objectSpread2$1({
        minWidth: "".concat(fe, "px")
      }, le);
      return typeof ge == "number" ? _e.width = "".concat(ge, "px") : ge && (_e.width = "".concat(fe, "px")), createVNode$1(Trigger, _objectSpread2$1(_objectSpread2$1({}, C), {}, {
        showAction: Ce ? ["click"] : [],
        hideAction: Ce ? ["click"] : [],
        popupPlacement: de || (ce === "rtl" ? "bottomRight" : "bottomLeft"),
        builtinPlacements: Z.value,
        prefixCls: be,
        popupTransitionName: Ae,
        popupAlign: ae,
        popupVisible: ne,
        getPopupContainer: me,
        popupClassName: classNames(oe, _defineProperty$A({}, "".concat(be, "-empty"), te)),
        popupStyle: _e,
        getTriggerDOMNode: ye,
        onPopupVisibleChange: Ce
      }), {
        default: U.default,
        popup: function() {
          return createVNode$1("div", {
            ref: X,
            onMouseenter: Ie
          }, [Se]);
        }
      });
    };
  }
});
const SelectTrigger$1 = SelectTrigger;
var KeyCode = {
  /**
   * MAC_ENTER
   */
  MAC_ENTER: 3,
  /**
   * BACKSPACE
   */
  BACKSPACE: 8,
  /**
   * TAB
   */
  TAB: 9,
  /**
   * NUMLOCK on FF/Safari Mac
   */
  NUM_CENTER: 12,
  /**
   * ENTER
   */
  ENTER: 13,
  /**
   * SHIFT
   */
  SHIFT: 16,
  /**
   * CTRL
   */
  CTRL: 17,
  /**
   * ALT
   */
  ALT: 18,
  /**
   * PAUSE
   */
  PAUSE: 19,
  /**
   * CAPS_LOCK
   */
  CAPS_LOCK: 20,
  /**
   * ESC
   */
  ESC: 27,
  /**
   * SPACE
   */
  SPACE: 32,
  /**
   * PAGE_UP
   */
  PAGE_UP: 33,
  /**
   * PAGE_DOWN
   */
  PAGE_DOWN: 34,
  /**
   * END
   */
  END: 35,
  /**
   * HOME
   */
  HOME: 36,
  /**
   * LEFT
   */
  LEFT: 37,
  /**
   * UP
   */
  UP: 38,
  /**
   * RIGHT
   */
  RIGHT: 39,
  /**
   * DOWN
   */
  DOWN: 40,
  /**
   * PRINT_SCREEN
   */
  PRINT_SCREEN: 44,
  /**
   * INSERT
   */
  INSERT: 45,
  /**
   * DELETE
   */
  DELETE: 46,
  /**
   * ZERO
   */
  ZERO: 48,
  /**
   * ONE
   */
  ONE: 49,
  /**
   * TWO
   */
  TWO: 50,
  /**
   * THREE
   */
  THREE: 51,
  /**
   * FOUR
   */
  FOUR: 52,
  /**
   * FIVE
   */
  FIVE: 53,
  /**
   * SIX
   */
  SIX: 54,
  /**
   * SEVEN
   */
  SEVEN: 55,
  /**
   * EIGHT
   */
  EIGHT: 56,
  /**
   * NINE
   */
  NINE: 57,
  /**
   * QUESTION_MARK
   */
  QUESTION_MARK: 63,
  /**
   * A
   */
  A: 65,
  /**
   * B
   */
  B: 66,
  /**
   * C
   */
  C: 67,
  /**
   * D
   */
  D: 68,
  /**
   * E
   */
  E: 69,
  /**
   * F
   */
  F: 70,
  /**
   * G
   */
  G: 71,
  /**
   * H
   */
  H: 72,
  /**
   * I
   */
  I: 73,
  /**
   * J
   */
  J: 74,
  /**
   * K
   */
  K: 75,
  /**
   * L
   */
  L: 76,
  /**
   * M
   */
  M: 77,
  /**
   * N
   */
  N: 78,
  /**
   * O
   */
  O: 79,
  /**
   * P
   */
  P: 80,
  /**
   * Q
   */
  Q: 81,
  /**
   * R
   */
  R: 82,
  /**
   * S
   */
  S: 83,
  /**
   * T
   */
  T: 84,
  /**
   * U
   */
  U: 85,
  /**
   * V
   */
  V: 86,
  /**
   * W
   */
  W: 87,
  /**
   * X
   */
  X: 88,
  /**
   * Y
   */
  Y: 89,
  /**
   * Z
   */
  Z: 90,
  /**
   * META
   */
  META: 91,
  /**
   * WIN_KEY_RIGHT
   */
  WIN_KEY_RIGHT: 92,
  /**
   * CONTEXT_MENU
   */
  CONTEXT_MENU: 93,
  /**
   * NUM_ZERO
   */
  NUM_ZERO: 96,
  /**
   * NUM_ONE
   */
  NUM_ONE: 97,
  /**
   * NUM_TWO
   */
  NUM_TWO: 98,
  /**
   * NUM_THREE
   */
  NUM_THREE: 99,
  /**
   * NUM_FOUR
   */
  NUM_FOUR: 100,
  /**
   * NUM_FIVE
   */
  NUM_FIVE: 101,
  /**
   * NUM_SIX
   */
  NUM_SIX: 102,
  /**
   * NUM_SEVEN
   */
  NUM_SEVEN: 103,
  /**
   * NUM_EIGHT
   */
  NUM_EIGHT: 104,
  /**
   * NUM_NINE
   */
  NUM_NINE: 105,
  /**
   * NUM_MULTIPLY
   */
  NUM_MULTIPLY: 106,
  /**
   * NUM_PLUS
   */
  NUM_PLUS: 107,
  /**
   * NUM_MINUS
   */
  NUM_MINUS: 109,
  /**
   * NUM_PERIOD
   */
  NUM_PERIOD: 110,
  /**
   * NUM_DIVISION
   */
  NUM_DIVISION: 111,
  /**
   * F1
   */
  F1: 112,
  /**
   * F2
   */
  F2: 113,
  /**
   * F3
   */
  F3: 114,
  /**
   * F4
   */
  F4: 115,
  /**
   * F5
   */
  F5: 116,
  /**
   * F6
   */
  F6: 117,
  /**
   * F7
   */
  F7: 118,
  /**
   * F8
   */
  F8: 119,
  /**
   * F9
   */
  F9: 120,
  /**
   * F10
   */
  F10: 121,
  /**
   * F11
   */
  F11: 122,
  /**
   * F12
   */
  F12: 123,
  /**
   * NUMLOCK
   */
  NUMLOCK: 144,
  /**
   * SEMICOLON
   */
  SEMICOLON: 186,
  /**
   * DASH
   */
  DASH: 189,
  /**
   * EQUALS
   */
  EQUALS: 187,
  /**
   * COMMA
   */
  COMMA: 188,
  /**
   * PERIOD
   */
  PERIOD: 190,
  /**
   * SLASH
   */
  SLASH: 191,
  /**
   * APOSTROPHE
   */
  APOSTROPHE: 192,
  /**
   * SINGLE_QUOTE
   */
  SINGLE_QUOTE: 222,
  /**
   * OPEN_SQUARE_BRACKET
   */
  OPEN_SQUARE_BRACKET: 219,
  /**
   * BACKSLASH
   */
  BACKSLASH: 220,
  /**
   * CLOSE_SQUARE_BRACKET
   */
  CLOSE_SQUARE_BRACKET: 221,
  /**
   * WIN_KEY
   */
  WIN_KEY: 224,
  /**
   * MAC_FF_META
   */
  MAC_FF_META: 224,
  /**
   * WIN_IME
   */
  WIN_IME: 229,
  // ======================== Function ========================
  /**
   * whether text and modified key is entered at the same time.
   */
  isTextModifyingKeyEvent: function(C) {
    var G = C.keyCode;
    if (C.altKey && !C.ctrlKey || C.metaKey || // Function keys don't generate text
    G >= KeyCode.F1 && G <= KeyCode.F12)
      return !1;
    switch (G) {
      case KeyCode.ALT:
      case KeyCode.CAPS_LOCK:
      case KeyCode.CONTEXT_MENU:
      case KeyCode.CTRL:
      case KeyCode.DOWN:
      case KeyCode.END:
      case KeyCode.ESC:
      case KeyCode.HOME:
      case KeyCode.INSERT:
      case KeyCode.LEFT:
      case KeyCode.MAC_FF_META:
      case KeyCode.META:
      case KeyCode.NUMLOCK:
      case KeyCode.NUM_CENTER:
      case KeyCode.PAGE_DOWN:
      case KeyCode.PAGE_UP:
      case KeyCode.PAUSE:
      case KeyCode.PRINT_SCREEN:
      case KeyCode.RIGHT:
      case KeyCode.SHIFT:
      case KeyCode.UP:
      case KeyCode.WIN_KEY:
      case KeyCode.WIN_KEY_RIGHT:
        return !1;
      default:
        return !0;
    }
  },
  /**
   * whether character is entered.
   */
  isCharacterKey: function(C) {
    if (C >= KeyCode.ZERO && C <= KeyCode.NINE || C >= KeyCode.NUM_ZERO && C <= KeyCode.NUM_MULTIPLY || C >= KeyCode.A && C <= KeyCode.Z || window.navigator.userAgent.indexOf("WebKit") !== -1 && C === 0)
      return !0;
    switch (C) {
      case KeyCode.SPACE:
      case KeyCode.QUESTION_MARK:
      case KeyCode.NUM_PLUS:
      case KeyCode.NUM_MINUS:
      case KeyCode.NUM_PERIOD:
      case KeyCode.NUM_DIVISION:
      case KeyCode.SEMICOLON:
      case KeyCode.DASH:
      case KeyCode.EQUALS:
      case KeyCode.COMMA:
      case KeyCode.PERIOD:
      case KeyCode.SLASH:
      case KeyCode.APOSTROPHE:
      case KeyCode.SINGLE_QUOTE:
      case KeyCode.OPEN_SQUARE_BRACKET:
      case KeyCode.BACKSLASH:
      case KeyCode.CLOSE_SQUARE_BRACKET:
        return !0;
      default:
        return !1;
    }
  }
};
const KeyCode$1 = KeyCode;
var TransBtn = function(C, G) {
  var U, K = G.slots, W = C.class, Z = C.customizeIcon, X = C.customizeIconProps, Q = C.onMousedown, ee = C.onClick, te;
  return typeof Z == "function" ? te = Z(X) : te = Z, createVNode$1("span", {
    class: W,
    onMousedown: function(ne) {
      ne.preventDefault(), Q && Q(ne);
    },
    style: {
      userSelect: "none",
      WebkitUserSelect: "none"
    },
    unselectable: "on",
    onClick: ee,
    "aria-hidden": !0
  }, [te !== void 0 ? te : createVNode$1("span", {
    class: W.split(/\s+/).map(function(re) {
      return "".concat(re, "-icon");
    })
  }, [(U = K.default) === null || U === void 0 ? void 0 : U.call(K)])]);
};
TransBtn.inheritAttrs = !1;
TransBtn.displayName = "TransBtn";
TransBtn.props = {
  class: String,
  customizeIcon: PropTypes$1.any,
  customizeIconProps: PropTypes$1.any,
  onMousedown: Function,
  onClick: Function
};
const TransBtn$1 = TransBtn;
function onCompositionStart(H) {
  H.target.composing = !0;
}
function onCompositionEnd(H) {
  H.target.composing && (H.target.composing = !1, trigger$2(H.target, "input"));
}
function trigger$2(H, C) {
  var G = document.createEvent("HTMLEvents");
  G.initEvent(C, !0, !0), H.dispatchEvent(G);
}
function addEventListener$2(H, C, G, U) {
  H.addEventListener(C, G, U);
}
var antInput = {
  created: function(C, G) {
    (!G.modifiers || !G.modifiers.lazy) && (addEventListener$2(C, "compositionstart", onCompositionStart), addEventListener$2(C, "compositionend", onCompositionEnd), addEventListener$2(C, "change", onCompositionEnd));
  }
};
const antInputDirective = antInput;
var inputProps$2 = {
  inputRef: PropTypes$1.any,
  prefixCls: String,
  id: String,
  inputElement: PropTypes$1.VueNode,
  disabled: {
    type: Boolean,
    default: void 0
  },
  autofocus: {
    type: Boolean,
    default: void 0
  },
  autocomplete: String,
  editable: {
    type: Boolean,
    default: void 0
  },
  activeDescendantId: String,
  value: String,
  open: {
    type: Boolean,
    default: void 0
  },
  tabindex: PropTypes$1.oneOfType([PropTypes$1.number, PropTypes$1.string]),
  /** Pass accessibility props to input */
  attrs: PropTypes$1.object,
  onKeydown: {
    type: Function
  },
  onMousedown: {
    type: Function
  },
  onChange: {
    type: Function
  },
  onPaste: {
    type: Function
  },
  onCompositionstart: {
    type: Function
  },
  onCompositionend: {
    type: Function
  },
  onFocus: {
    type: Function
  },
  onBlur: {
    type: Function
  }
}, Input$1 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Input",
  inheritAttrs: !1,
  props: inputProps$2,
  setup: function(C) {
    var G = null, U = inject("VCSelectContainerEvent");
    return function() {
      var K, W, Z = C.prefixCls, X = C.id, Q = C.inputElement, ee = C.disabled, te = C.tabindex, re = C.autofocus, ne = C.autocomplete, ae = C.editable, ie = C.activeDescendantId, se = C.value, oe = C.onKeydown, le = C.onMousedown, ue = C.onChange, ce = C.onPaste, de = C.onCompositionstart, ge = C.onCompositionend, fe = C.onFocus, ve = C.onBlur, pe = C.open, he = C.inputRef, me = C.attrs, ye = Q || withDirectives(createVNode$1("input", null, null), [[antInputDirective]]), Ce = ye.props || {}, Ie = Ce.onKeydown, be = Ce.onInput, Se = Ce.onFocus, Ae = Ce.onBlur, _e = Ce.onMousedown, xe = Ce.onCompositionstart, Te = Ce.onCompositionend, Pe = Ce.style;
      return ye = cloneElement(ye, _extends(_objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
        type: "search"
      }, Ce), {}, {
        id: X,
        ref: he,
        disabled: ee,
        tabindex: te,
        autocomplete: ne || "off",
        autofocus: re,
        class: classNames("".concat(Z, "-selection-search-input"), (K = ye) === null || K === void 0 || (W = K.props) === null || W === void 0 ? void 0 : W.class),
        role: "combobox",
        "aria-expanded": pe,
        "aria-haspopup": "listbox",
        "aria-owns": "".concat(X, "_list"),
        "aria-autocomplete": "list",
        "aria-controls": "".concat(X, "_list"),
        "aria-activedescendant": ie
      }, me), {}, {
        value: ae ? se : "",
        readonly: !ae,
        unselectable: ae ? null : "on",
        style: _objectSpread2$1(_objectSpread2$1({}, Pe), {}, {
          opacity: ae ? null : 0
        }),
        onKeydown: function(Me) {
          oe(Me), Ie && Ie(Me);
        },
        onMousedown: function(Me) {
          le(Me), _e && _e(Me);
        },
        onInput: function(Me) {
          ue(Me), be && be(Me);
        },
        onCompositionstart: function(Me) {
          de(Me), xe && xe(Me);
        },
        onCompositionend: function(Me) {
          ge(Me), Te && Te(Me);
        },
        onPaste: ce,
        onFocus: function() {
          clearTimeout(G), Se && Se(arguments.length <= 0 ? void 0 : arguments[0]), fe && fe(arguments.length <= 0 ? void 0 : arguments[0]), U == null || U.focus(arguments.length <= 0 ? void 0 : arguments[0]);
        },
        onBlur: function() {
          for (var Me = arguments.length, Ee = new Array(Me), we = 0; we < Me; we++)
            Ee[we] = arguments[we];
          G = setTimeout(function() {
            Ae && Ae(Ee[0]), ve && ve(Ee[0]), U == null || U.blur(Ee[0]);
          }, 100);
        }
      }), ye.type === "textarea" ? {} : {
        type: "search"
      }), !0, !0), ye;
    };
  }
});
const Input$2 = Input$1;
var attributes = `accept acceptcharset accesskey action allowfullscreen allowtransparency
alt async autocomplete autofocus autoplay capture cellpadding cellspacing challenge
charset checked classid classname colspan cols content contenteditable contextmenu
controls coords crossorigin data datetime default defer dir disabled download draggable
enctype form formaction formenctype formmethod formnovalidate formtarget frameborder
headers height hidden high href hreflang htmlfor for httpequiv icon id inputmode integrity
is keyparams keytype kind label lang list loop low manifest marginheight marginwidth max maxlength media
mediagroup method min minlength multiple muted name novalidate nonce open
optimum pattern placeholder poster preload radiogroup readonly rel required
reversed role rowspan rows sandbox scope scoped scrolling seamless selected
shape size sizes span spellcheck src srcdoc srclang srcset start step style
summary tabindex target title type usemap value width wmode wrap`, eventsName = `onCopy onCut onPaste onCompositionend onCompositionstart onCompositionupdate onKeydown
    onKeypress onKeyup onFocus onBlur onChange onInput onSubmit onClick onContextmenu onDoubleclick onDblclick
    onDrag onDragend onDragenter onDragexit onDragleave onDragover onDragstart onDrop onMousedown
    onMouseenter onMouseleave onMousemove onMouseout onMouseover onMouseup onSelect onTouchcancel
    onTouchend onTouchmove onTouchstart onTouchstartPassive onTouchmovePassive onScroll onWheel onAbort onCanplay onCanplaythrough
    onDurationchange onEmptied onEncrypted onEnded onError onLoadeddata onLoadedmetadata
    onLoadstart onPause onPlay onPlaying onProgress onRatechange onSeeked onSeeking onStalled onSuspend onTimeupdate onVolumechange onWaiting onLoad onError`, propList = "".concat(attributes, " ").concat(eventsName).split(/[\s\n]+/), ariaPrefix = "aria-", dataPrefix = "data-";
function match$1(H, C) {
  return H.indexOf(C) === 0;
}
function pickAttrs(H) {
  var C = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, G;
  C === !1 ? G = {
    aria: !0,
    data: !0,
    attr: !0
  } : C === !0 ? G = {
    aria: !0
  } : G = _objectSpread2$1({}, C);
  var U = {};
  return Object.keys(H).forEach(function(K) {
    // Aria
    (G.aria && (K === "role" || match$1(K, ariaPrefix)) || // Data
    G.data && match$1(K, dataPrefix) || // Attr
    G.attr && (propList.includes(K) || propList.includes(K.toLowerCase()))) && (U[K] = H[K]);
  }), U;
}
var OverflowContextProviderKey = Symbol("OverflowContextProviderKey"), OverflowContextProvider = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "OverflowContextProvider",
  inheritAttrs: !1,
  props: {
    value: {
      type: Object
    }
  },
  setup: function(C, G) {
    var U = G.slots;
    return provide(OverflowContextProviderKey, computed(function() {
      return C.value;
    })), function() {
      var K;
      return (K = U.default) === null || K === void 0 ? void 0 : K.call(U);
    };
  }
}), useInjectOverflowContext = function() {
  return inject(OverflowContextProviderKey, computed(function() {
    return null;
  }));
}, _excluded$q = ["prefixCls", "invalidate", "item", "renderItem", "responsive", "registerSize", "itemKey", "display", "order", "component"], UNDEFINED$1 = void 0;
const Item$2 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Item",
  props: {
    prefixCls: String,
    item: PropTypes$1.any,
    renderItem: Function,
    responsive: Boolean,
    itemKey: {
      type: [String, Number]
    },
    registerSize: Function,
    display: Boolean,
    order: Number,
    component: PropTypes$1.any,
    invalidate: Boolean
  },
  setup: function(C, G) {
    var U = G.slots, K = G.expose, W = computed(function() {
      return C.responsive && !C.display;
    }), Z = ref();
    K({
      itemNodeRef: Z
    });
    function X(Q) {
      C.registerSize(C.itemKey, Q);
    }
    return onUnmounted(function() {
      X(null);
    }), function() {
      var Q, ee = C.prefixCls, te = C.invalidate, re = C.item, ne = C.renderItem, ae = C.responsive;
      C.registerSize, C.itemKey, C.display;
      var ie = C.order, se = C.component, oe = se === void 0 ? "div" : se, le = _objectWithoutProperties$2(C, _excluded$q), ue = (Q = U.default) === null || Q === void 0 ? void 0 : Q.call(U), ce = ne && re !== UNDEFINED$1 ? ne(re) : ue, de;
      te || (de = {
        opacity: W.value ? 0 : 1,
        height: W.value ? 0 : UNDEFINED$1,
        overflowY: W.value ? "hidden" : UNDEFINED$1,
        order: ae ? ie : UNDEFINED$1,
        pointerEvents: W.value ? "none" : UNDEFINED$1,
        position: W.value ? "absolute" : UNDEFINED$1
      });
      var ge = {};
      return W.value && (ge["aria-hidden"] = !0), createVNode$1(ResizeObserver, {
        disabled: !ae,
        onResize: function(ve) {
          var pe = ve.offsetWidth;
          X(pe);
        }
      }, {
        default: function() {
          return createVNode$1(oe, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
            class: classNames(!te && ee),
            style: de
          }, ge), le), {}, {
            ref: Z
          }), {
            default: function() {
              return [ce];
            }
          });
        }
      });
    };
  }
});
var _excluded$p = ["component"], _excluded2$1 = ["className"], _excluded3 = ["class"];
const RawItem = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "RawItem",
  inheritAttrs: !1,
  props: {
    component: PropTypes$1.any,
    title: PropTypes$1.any,
    id: String,
    onMouseenter: {
      type: Function
    },
    onMouseleave: {
      type: Function
    },
    onClick: {
      type: Function
    },
    onKeydown: {
      type: Function
    },
    onFocus: {
      type: Function
    }
  },
  setup: function(C, G) {
    var U = G.slots, K = G.attrs, W = useInjectOverflowContext();
    return function() {
      if (!W.value) {
        var Z, X = C.component, Q = X === void 0 ? "div" : X, ee = _objectWithoutProperties$2(C, _excluded$p);
        return createVNode$1(Q, _objectSpread2$1(_objectSpread2$1({}, ee), K), {
          default: function() {
            return [(Z = U.default) === null || Z === void 0 ? void 0 : Z.call(U)];
          }
        });
      }
      var te = W.value, re = te.className, ne = _objectWithoutProperties$2(te, _excluded2$1), ae = K.class, ie = _objectWithoutProperties$2(K, _excluded3);
      return createVNode$1(OverflowContextProvider, {
        value: null
      }, {
        default: function() {
          return [createVNode$1(Item$2, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
            class: classNames(re, ae)
          }, ne), ie), C), U)];
        }
      });
    };
  }
});
var _excluded$o = ["class", "style"], RESPONSIVE = "responsive", INVALIDATE = "invalidate";
function defaultRenderRest(H) {
  return "+ ".concat(H.length, " ...");
}
var overflowProps = function() {
  return {
    id: String,
    prefixCls: String,
    data: Array,
    itemKey: [String, Number, Function],
    /** Used for `responsive`. It will limit render node to avoid perf issue */
    itemWidth: {
      type: Number,
      default: 10
    },
    renderItem: Function,
    /** @private Do not use in your production. Render raw node that need wrap Item by developer self */
    renderRawItem: Function,
    maxCount: [Number, String],
    renderRest: Function,
    /** @private Do not use in your production. Render raw node that need wrap Item by developer self */
    renderRawRest: Function,
    suffix: PropTypes$1.any,
    component: String,
    itemComponent: PropTypes$1.any,
    /** @private This API may be refactor since not well design */
    onVisibleChange: Function,
    /** When set to `full`, ssr will render full items by default and remove at client side */
    ssr: String,
    onMousedown: Function
  };
}, Overflow = defineComponent({
  name: "Overflow",
  inheritAttrs: !1,
  props: overflowProps(),
  emits: ["visibleChange"],
  setup: function(C, G) {
    var U = G.attrs, K = G.emit, W = G.slots, Z = computed(function() {
      return C.ssr === "full";
    }), X = ref(null), Q = computed(function() {
      return X.value || 0;
    }), ee = ref(/* @__PURE__ */ new Map()), te = ref(0), re = ref(0), ne = ref(0), ae = ref(null), ie = ref(null), se = computed(function() {
      return ie.value === null && Z.value ? Number.MAX_SAFE_INTEGER : ie.value || 0;
    }), oe = ref(!1), le = computed(function() {
      return "".concat(C.prefixCls, "-item");
    }), ue = computed(function() {
      return Math.max(te.value, re.value);
    }), ce = computed(function() {
      return !!(C.data.length && C.maxCount === RESPONSIVE);
    }), de = computed(function() {
      return C.maxCount === INVALIDATE;
    }), ge = computed(function() {
      return ce.value || typeof C.maxCount == "number" && C.data.length > C.maxCount;
    }), fe = computed(function() {
      var Ae = C.data;
      return ce.value ? X.value === null && Z.value ? Ae = C.data : Ae = C.data.slice(0, Math.min(C.data.length, Q.value / C.itemWidth)) : typeof C.maxCount == "number" && (Ae = C.data.slice(0, C.maxCount)), Ae;
    }), ve = computed(function() {
      return ce.value ? C.data.slice(se.value + 1) : C.data.slice(fe.value.length);
    }), pe = function(_e, xe) {
      var Te;
      return typeof C.itemKey == "function" ? C.itemKey(_e) : (Te = C.itemKey && (_e == null ? void 0 : _e[C.itemKey])) !== null && Te !== void 0 ? Te : xe;
    }, he = computed(function() {
      return C.renderItem || function(Ae) {
        return Ae;
      };
    }), me = function(_e, xe) {
      ie.value = _e, xe || (oe.value = _e < C.data.length - 1, K("visibleChange", _e));
    }, ye = function(_e, xe) {
      X.value = xe.clientWidth;
    }, Ce = function(_e, xe) {
      var Te = new Map(ee.value);
      xe === null ? Te.delete(_e) : Te.set(_e, xe), ee.value = Te;
    }, Ie = function(_e, xe) {
      te.value = re.value, re.value = xe;
    }, be = function(_e, xe) {
      ne.value = xe;
    }, Se = function(_e) {
      return ee.value.get(pe(fe.value[_e], _e));
    };
    return watch([Q, ee, re, ne, function() {
      return C.itemKey;
    }, fe], function() {
      if (Q.value && ue.value && fe.value) {
        var Ae = ne.value, _e = fe.value.length, xe = _e - 1;
        if (!_e) {
          me(0), ae.value = null;
          return;
        }
        for (var Te = 0; Te < _e; Te += 1) {
          var Pe = Se(Te);
          if (Pe === void 0) {
            me(Te - 1, !0);
            break;
          }
          if (Ae += Pe, // Only one means `totalWidth` is the final width
          xe === 0 && Ae <= Q.value || // Last two width will be the final width
          Te === xe - 1 && Ae + Se(xe) <= Q.value) {
            me(xe), ae.value = null;
            break;
          } else if (Ae + ue.value > Q.value) {
            me(Te - 1), ae.value = Ae - Pe - ne.value + re.value;
            break;
          }
        }
        C.suffix && Se(0) + ne.value > Q.value && (ae.value = null);
      }
    }), function() {
      var Ae = oe.value && !!ve.value.length, _e = C.itemComponent, xe = C.renderRawItem, Te = C.renderRawRest, Pe = C.renderRest, $e = C.prefixCls, Me = $e === void 0 ? "rc-overflow" : $e, Ee = C.suffix, we = C.component, Oe = we === void 0 ? "div" : we, Ne = C.id, ke = C.onMousedown, ze = U.class, He = U.style, We = _objectWithoutProperties$2(U, _excluded$o), Re = {};
      ae.value !== null && ce.value && (Re = {
        position: "absolute",
        left: "".concat(ae.value, "px"),
        top: 0
      });
      var Le = {
        prefixCls: le.value,
        responsive: ce.value,
        component: _e,
        invalidate: de.value
      }, De = xe ? function(vt, ut) {
        var at = pe(vt, ut);
        return createVNode$1(OverflowContextProvider, {
          key: at,
          value: _objectSpread2$1(_objectSpread2$1({}, Le), {}, {
            order: ut,
            item: vt,
            itemKey: at,
            registerSize: Ce,
            display: ut <= se.value
          })
        }, {
          default: function() {
            return [xe(vt, ut)];
          }
        });
      } : function(vt, ut) {
        var at = pe(vt, ut);
        return createVNode$1(Item$2, _objectSpread2$1(_objectSpread2$1({}, Le), {}, {
          order: ut,
          key: at,
          item: vt,
          renderItem: he.value,
          itemKey: at,
          registerSize: Ce,
          display: ut <= se.value
        }), null);
      }, Ue = function() {
        return null;
      }, st = {
        order: Ae ? se.value : Number.MAX_SAFE_INTEGER,
        className: "".concat(le.value, " ").concat(le.value, "-rest"),
        registerSize: Ie,
        display: Ae
      };
      if (Te)
        Te && (Ue = function() {
          return createVNode$1(OverflowContextProvider, {
            value: _objectSpread2$1(_objectSpread2$1({}, Le), st)
          }, {
            default: function() {
              return [Te(ve.value)];
            }
          });
        });
      else {
        var ot = Pe || defaultRenderRest;
        Ue = function() {
          return createVNode$1(Item$2, _objectSpread2$1(_objectSpread2$1({}, Le), st), {
            default: function() {
              return typeof ot == "function" ? ot(ve.value) : ot;
            }
          });
        };
      }
      var ct = function() {
        var ut;
        return createVNode$1(Oe, _objectSpread2$1({
          id: Ne,
          class: classNames(!de.value && Me, ze),
          style: He,
          onMousedown: ke
        }, We), {
          default: function() {
            return [fe.value.map(De), ge.value ? Ue() : null, Ee && createVNode$1(Item$2, _objectSpread2$1(_objectSpread2$1({}, Le), {}, {
              order: se.value,
              class: "".concat(le.value, "-suffix"),
              registerSize: be,
              display: !0,
              style: Re
            }), {
              default: function() {
                return Ee;
              }
            }), (ut = W.default) === null || ut === void 0 ? void 0 : ut.call(W)];
          }
        });
      };
      return createVNode$1(ResizeObserver, {
        disabled: !ce.value,
        onResize: ye
      }, {
        default: ct
      });
    };
  }
});
Overflow.Item = RawItem;
Overflow.RESPONSIVE = RESPONSIVE;
Overflow.INVALIDATE = INVALIDATE;
const Overflow$1 = Overflow;
var TreeSelectLegacyContextPropsKey = Symbol("TreeSelectLegacyContextPropsKey");
function useInjectLegacySelectContext() {
  return inject(TreeSelectLegacyContextPropsKey, {});
}
var props$1 = {
  id: String,
  prefixCls: String,
  values: PropTypes$1.array,
  open: {
    type: Boolean,
    default: void 0
  },
  searchValue: String,
  inputRef: PropTypes$1.any,
  placeholder: PropTypes$1.any,
  disabled: {
    type: Boolean,
    default: void 0
  },
  mode: String,
  showSearch: {
    type: Boolean,
    default: void 0
  },
  autofocus: {
    type: Boolean,
    default: void 0
  },
  autocomplete: String,
  activeDescendantId: String,
  tabindex: PropTypes$1.oneOfType([PropTypes$1.number, PropTypes$1.string]),
  removeIcon: PropTypes$1.any,
  choiceTransitionName: String,
  maxTagCount: PropTypes$1.oneOfType([PropTypes$1.number, PropTypes$1.string]),
  maxTagTextLength: Number,
  maxTagPlaceholder: PropTypes$1.any.def(function() {
    return function(H) {
      return "+ ".concat(H.length, " ...");
    };
  }),
  tagRender: Function,
  onToggleOpen: {
    type: Function
  },
  onRemove: Function,
  onInputChange: Function,
  onInputPaste: Function,
  onInputKeyDown: Function,
  onInputMouseDown: Function,
  onInputCompositionStart: Function,
  onInputCompositionEnd: Function
}, onPreventMouseDown = function(C) {
  C.preventDefault(), C.stopPropagation();
}, SelectSelector = defineComponent({
  name: "MultipleSelectSelector",
  inheritAttrs: !1,
  props: props$1,
  setup: function(C) {
    var G = ref(), U = ref(0), K = ref(!1), W = useInjectLegacySelectContext(), Z = computed(function() {
      return "".concat(C.prefixCls, "-selection");
    }), X = computed(function() {
      return C.open || C.mode === "tags" ? C.searchValue : "";
    }), Q = computed(function() {
      return C.mode === "tags" || C.showSearch && (C.open || K.value);
    });
    onMounted(function() {
      watch(X, function() {
        U.value = G.value.scrollWidth;
      }, {
        flush: "post",
        immediate: !0
      });
    });
    function ee(ae, ie, se, oe, le) {
      return createVNode$1("span", {
        class: classNames("".concat(Z.value, "-item"), _defineProperty$A({}, "".concat(Z.value, "-item-disabled"), se)),
        title: typeof ae == "string" || typeof ae == "number" ? ae.toString() : void 0
      }, [createVNode$1("span", {
        class: "".concat(Z.value, "-item-content")
      }, [ie]), oe && createVNode$1(TransBtn$1, {
        class: "".concat(Z.value, "-item-remove"),
        onMousedown: onPreventMouseDown,
        onClick: le,
        customizeIcon: C.removeIcon
      }, {
        default: function() {
          return [createTextVNode("×")];
        }
      })]);
    }
    function te(ae, ie, se, oe, le, ue) {
      var ce = function(ve) {
        onPreventMouseDown(ve), C.onToggleOpen(!open);
      }, de = ue;
      if (W.keyEntities) {
        var ge;
        de = ((ge = W.keyEntities[ae]) === null || ge === void 0 ? void 0 : ge.node) || {};
      }
      return createVNode$1("span", {
        key: ae,
        onMousedown: ce
      }, [C.tagRender({
        label: ie,
        value: ae,
        disabled: se,
        closable: oe,
        onClose: le,
        option: de
      })]);
    }
    function re(ae) {
      var ie = ae.disabled, se = ae.label, oe = ae.value, le = ae.option, ue = !C.disabled && !ie, ce = se;
      if (typeof C.maxTagTextLength == "number" && (typeof se == "string" || typeof se == "number")) {
        var de = String(ce);
        de.length > C.maxTagTextLength && (ce = "".concat(de.slice(0, C.maxTagTextLength), "..."));
      }
      var ge = function(ve) {
        var pe;
        ve && ve.stopPropagation(), (pe = C.onRemove) === null || pe === void 0 || pe.call(C, ae);
      };
      return typeof C.tagRender == "function" ? te(oe, ce, ie, ue, ge, le) : ee(se, ce, ie, ue, ge);
    }
    function ne(ae) {
      var ie = C.maxTagPlaceholder, se = ie === void 0 ? function(le) {
        return "+ ".concat(le.length, " ...");
      } : ie, oe = typeof se == "function" ? se(ae) : se;
      return ee(oe, oe, !1);
    }
    return function() {
      var ae = C.id, ie = C.prefixCls, se = C.values, oe = C.open, le = C.inputRef, ue = C.placeholder, ce = C.disabled, de = C.autofocus, ge = C.autocomplete, fe = C.activeDescendantId, ve = C.tabindex, pe = C.onInputChange, he = C.onInputPaste, me = C.onInputKeyDown, ye = C.onInputMouseDown, Ce = C.onInputCompositionStart, Ie = C.onInputCompositionEnd, be = createVNode$1("div", {
        class: "".concat(Z.value, "-search"),
        style: {
          width: U.value + "px"
        },
        key: "input"
      }, [createVNode$1(Input$2, {
        inputRef: le,
        open: oe,
        prefixCls: ie,
        id: ae,
        inputElement: null,
        disabled: ce,
        autofocus: de,
        autocomplete: ge,
        editable: Q.value,
        activeDescendantId: fe,
        value: X.value,
        onKeydown: me,
        onMousedown: ye,
        onChange: pe,
        onPaste: he,
        onCompositionstart: Ce,
        onCompositionend: Ie,
        tabindex: ve,
        attrs: pickAttrs(C, !0),
        onFocus: function() {
          return K.value = !0;
        },
        onBlur: function() {
          return K.value = !1;
        }
      }, null), createVNode$1("span", {
        ref: G,
        class: "".concat(Z.value, "-search-mirror"),
        "aria-hidden": !0
      }, [X.value, createTextVNode(" ")])]), Se = createVNode$1(Overflow$1, {
        prefixCls: "".concat(Z.value, "-overflow"),
        data: se,
        renderItem: re,
        renderRest: ne,
        suffix: be,
        itemKey: "key",
        maxCount: C.maxTagCount,
        key: "overflow"
      }, null);
      return createVNode$1(Fragment, null, [Se, !se.length && !X.value && createVNode$1("span", {
        class: "".concat(Z.value, "-placeholder")
      }, [ue])]);
    };
  }
});
const MultipleSelector = SelectSelector;
var props = {
  inputElement: PropTypes$1.any,
  id: String,
  prefixCls: String,
  values: PropTypes$1.array,
  open: {
    type: Boolean,
    default: void 0
  },
  searchValue: String,
  inputRef: PropTypes$1.any,
  placeholder: PropTypes$1.any,
  disabled: {
    type: Boolean,
    default: void 0
  },
  mode: String,
  showSearch: {
    type: Boolean,
    default: void 0
  },
  autofocus: {
    type: Boolean,
    default: void 0
  },
  autocomplete: String,
  activeDescendantId: String,
  tabindex: PropTypes$1.oneOfType([PropTypes$1.number, PropTypes$1.string]),
  activeValue: String,
  backfill: {
    type: Boolean,
    default: void 0
  },
  optionLabelRender: Function,
  onInputChange: Function,
  onInputPaste: Function,
  onInputKeyDown: Function,
  onInputMouseDown: Function,
  onInputCompositionStart: Function,
  onInputCompositionEnd: Function
}, SingleSelector = defineComponent({
  name: "SingleSelector",
  setup: function(C) {
    var G = ref(!1), U = computed(function() {
      return C.mode === "combobox";
    }), K = computed(function() {
      return U.value || C.showSearch;
    }), W = computed(function() {
      var te = C.searchValue || "";
      return U.value && C.activeValue && !G.value && (te = C.activeValue), te;
    }), Z = useInjectLegacySelectContext();
    watch([U, function() {
      return C.activeValue;
    }], function() {
      U.value && (G.value = !1);
    }, {
      immediate: !0
    });
    var X = computed(function() {
      return C.mode !== "combobox" && !C.open && !C.showSearch ? !1 : !!W.value;
    }), Q = computed(function() {
      var te = C.values[0];
      return te && (typeof te.label == "string" || typeof te.label == "number") ? te.label.toString() : void 0;
    }), ee = function() {
      if (C.values[0])
        return null;
      var re = X.value ? {
        visibility: "hidden"
      } : void 0;
      return createVNode$1("span", {
        class: "".concat(C.prefixCls, "-selection-placeholder"),
        style: re
      }, [C.placeholder]);
    };
    return function() {
      var te, re = C.inputElement, ne = C.prefixCls, ae = C.id, ie = C.values, se = C.inputRef, oe = C.disabled, le = C.autofocus, ue = C.autocomplete, ce = C.activeDescendantId, de = C.open, ge = C.tabindex, fe = C.optionLabelRender, ve = C.onInputKeyDown, pe = C.onInputMouseDown, he = C.onInputChange, me = C.onInputPaste, ye = C.onInputCompositionStart, Ce = C.onInputCompositionEnd, Ie = ie[0], be = null;
      if (Ie && Z.customSlots) {
        var Se, Ae, _e, xe = (Se = Ie.key) !== null && Se !== void 0 ? Se : Ie.value, Te = ((Ae = Z.keyEntities[xe]) === null || Ae === void 0 ? void 0 : Ae.node) || {};
        be = Z.customSlots[(_e = Te.slots) === null || _e === void 0 ? void 0 : _e.title] || Z.customSlots.title || Ie.label, typeof be == "function" && (be = be(Te));
      } else
        be = fe && Ie ? fe(Ie.option) : Ie == null ? void 0 : Ie.label;
      return createVNode$1(Fragment, null, [createVNode$1("span", {
        class: "".concat(ne, "-selection-search")
      }, [createVNode$1(Input$2, {
        inputRef: se,
        prefixCls: ne,
        id: ae,
        open: de,
        inputElement: re,
        disabled: oe,
        autofocus: le,
        autocomplete: ue,
        editable: K.value,
        activeDescendantId: ce,
        value: W.value,
        onKeydown: ve,
        onMousedown: pe,
        onChange: function($e) {
          G.value = !0, he($e);
        },
        onPaste: me,
        onCompositionstart: ye,
        onCompositionend: Ce,
        tabindex: ge,
        attrs: pickAttrs(C, !0)
      }, null)]), !U.value && Ie && !X.value && createVNode$1("span", {
        class: "".concat(ne, "-selection-item"),
        title: Q.value
      }, [createVNode$1(Fragment, {
        key: (te = Ie.key) !== null && te !== void 0 ? te : Ie.value
      }, [be])]), ee()]);
    };
  }
});
SingleSelector.props = props;
SingleSelector.inheritAttrs = !1;
const SingleSelector$1 = SingleSelector;
function isValidateOpenKey(H) {
  return ![
    // System function button
    KeyCode$1.ESC,
    KeyCode$1.SHIFT,
    KeyCode$1.BACKSPACE,
    KeyCode$1.TAB,
    KeyCode$1.WIN_KEY,
    KeyCode$1.ALT,
    KeyCode$1.META,
    KeyCode$1.WIN_KEY_RIGHT,
    KeyCode$1.CTRL,
    KeyCode$1.SEMICOLON,
    KeyCode$1.EQUALS,
    KeyCode$1.CAPS_LOCK,
    KeyCode$1.CONTEXT_MENU,
    // F1-F12
    KeyCode$1.F1,
    KeyCode$1.F2,
    KeyCode$1.F3,
    KeyCode$1.F4,
    KeyCode$1.F5,
    KeyCode$1.F6,
    KeyCode$1.F7,
    KeyCode$1.F8,
    KeyCode$1.F9,
    KeyCode$1.F10,
    KeyCode$1.F11,
    KeyCode$1.F12
  ].includes(H);
}
function useLock() {
  var H = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 250, C = null, G;
  onBeforeUnmount(function() {
    clearTimeout(G);
  });
  function U(K) {
    (K || C === null) && (C = K), clearTimeout(G), G = setTimeout(function() {
      C = null;
    }, H);
  }
  return [function() {
    return C;
  }, U];
}
function createRef() {
  var H = function C(G) {
    C.current = G;
  };
  return H;
}
var Selector = defineComponent({
  name: "Selector",
  inheritAttrs: !1,
  props: {
    id: String,
    prefixCls: String,
    showSearch: {
      type: Boolean,
      default: void 0
    },
    open: {
      type: Boolean,
      default: void 0
    },
    /** Display in the Selector value, it's not same as `value` prop */
    values: PropTypes$1.array,
    multiple: {
      type: Boolean,
      default: void 0
    },
    mode: String,
    searchValue: String,
    activeValue: String,
    inputElement: PropTypes$1.any,
    autofocus: {
      type: Boolean,
      default: void 0
    },
    activeDescendantId: String,
    tabindex: PropTypes$1.oneOfType([PropTypes$1.number, PropTypes$1.string]),
    disabled: {
      type: Boolean,
      default: void 0
    },
    placeholder: PropTypes$1.any,
    removeIcon: PropTypes$1.any,
    // Tags
    maxTagCount: PropTypes$1.oneOfType([PropTypes$1.number, PropTypes$1.string]),
    maxTagTextLength: Number,
    maxTagPlaceholder: PropTypes$1.any,
    tagRender: Function,
    optionLabelRender: Function,
    /** Check if `tokenSeparators` contains `\n` or `\r\n` */
    tokenWithEnter: {
      type: Boolean,
      default: void 0
    },
    // Motion
    choiceTransitionName: String,
    onToggleOpen: {
      type: Function
    },
    /** `onSearch` returns go next step boolean to check if need do toggle open */
    onSearch: Function,
    onSearchSubmit: Function,
    onRemove: Function,
    onInputKeyDown: {
      type: Function
    },
    /**
     * @private get real dom for trigger align.
     * This may be removed after React provides replacement of `findDOMNode`
     */
    domRef: Function
  },
  setup: function(C, G) {
    var U = G.expose, K = createRef(), W = !1, Z = useLock(0), X = _slicedToArray$2(Z, 2), Q = X[0], ee = X[1], te = function(ge) {
      var fe = ge.which;
      (fe === KeyCode$1.UP || fe === KeyCode$1.DOWN) && ge.preventDefault(), C.onInputKeyDown && C.onInputKeyDown(ge), fe === KeyCode$1.ENTER && C.mode === "tags" && !W && !C.open && C.onSearchSubmit(ge.target.value), isValidateOpenKey(fe) && C.onToggleOpen(!0);
    }, re = function() {
      ee(!0);
    }, ne = null, ae = function(ge) {
      C.onSearch(ge, !0, W) !== !1 && C.onToggleOpen(!0);
    }, ie = function() {
      W = !0;
    }, se = function(ge) {
      W = !1, C.mode !== "combobox" && ae(ge.target.value);
    }, oe = function(ge) {
      var fe = ge.target.value;
      if (C.tokenWithEnter && ne && /[\r\n]/.test(ne)) {
        var ve = ne.replace(/[\r\n]+$/, "").replace(/\r\n/g, " ").replace(/[\r\n]/g, " ");
        fe = fe.replace(ve, ne);
      }
      ne = null, ae(fe);
    }, le = function(ge) {
      var fe = ge.clipboardData, ve = fe.getData("text");
      ne = ve;
    }, ue = function(ge) {
      var fe = ge.target;
      if (fe !== K.current) {
        var ve = document.body.style.msTouchAction !== void 0;
        ve ? setTimeout(function() {
          K.current.focus();
        }) : K.current.focus();
      }
    }, ce = function(ge) {
      var fe = Q();
      ge.target !== K.current && !fe && ge.preventDefault(), (C.mode !== "combobox" && (!C.showSearch || !fe) || !C.open) && (C.open && C.onSearch("", !0, !1), C.onToggleOpen());
    };
    return U({
      focus: function() {
        K.current.focus();
      },
      blur: function() {
        K.current.blur();
      }
    }), function() {
      var de = C.prefixCls, ge = C.domRef, fe = C.mode, ve = {
        inputRef: K,
        onInputKeyDown: te,
        onInputMouseDown: re,
        onInputChange: oe,
        onInputPaste: le,
        onInputCompositionStart: ie,
        onInputCompositionEnd: se
      }, pe = fe === "multiple" || fe === "tags" ? createVNode$1(MultipleSelector, _objectSpread2$1(_objectSpread2$1({}, C), ve), null) : createVNode$1(SingleSelector$1, _objectSpread2$1(_objectSpread2$1({}, C), ve), null);
      return createVNode$1("div", {
        ref: ge,
        class: "".concat(de, "-selector"),
        onClick: ue,
        onMousedown: ce
      }, [pe]);
    };
  }
});
const Selector$1 = Selector;
function useSelectTriggerControl(H, C, G) {
  function U(K) {
    var W, Z, X, Q = K.target;
    Q.shadowRoot && K.composed && (Q = K.composedPath()[0] || Q);
    var ee = [(W = H[0]) === null || W === void 0 ? void 0 : W.value, (Z = H[1]) === null || Z === void 0 || (X = Z.value) === null || X === void 0 ? void 0 : X.getPopupElement()];
    C.value && ee.every(function(te) {
      return te && !te.contains(Q) && te !== Q;
    }) && G(!1);
  }
  onMounted(function() {
    window.addEventListener("mousedown", U);
  }), onBeforeUnmount(function() {
    window.removeEventListener("mousedown", U);
  });
}
function useDelayReset() {
  var H = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 10, C = ref(!1), G, U = function() {
    clearTimeout(G);
  };
  onMounted(function() {
    U();
  });
  var K = function(Z, X) {
    U(), G = setTimeout(function() {
      C.value = Z, X && X();
    }, H);
  };
  return [C, K, U];
}
var BaseSelectContextKey = Symbol("BaseSelectContextKey");
function useProvideBaseSelectProps(H) {
  return provide(BaseSelectContextKey, H);
}
function useBaseProps() {
  return inject(BaseSelectContextKey, {});
}
const isMobile$2 = function() {
  if (typeof navigator > "u" || typeof window > "u")
    return !1;
  var H = navigator.userAgent || navigator.vendor || window.opera;
  return !!(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(H) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(H == null ? void 0 : H.substr(0, 4)));
};
function toReactive(H) {
  if (!isRef(H))
    return reactive(H);
  var C = new Proxy({}, {
    get: function(U, K, W) {
      return Reflect.get(H.value, K, W);
    },
    set: function(U, K, W) {
      return H.value[K] = W, !0;
    },
    deleteProperty: function(U, K) {
      return Reflect.deleteProperty(H.value, K);
    },
    has: function(U, K) {
      return Reflect.has(H.value, K);
    },
    ownKeys: function() {
      return Object.keys(H.value);
    },
    getOwnPropertyDescriptor: function() {
      return {
        enumerable: !0,
        configurable: !0
      };
    }
  });
  return reactive(C);
}
var _excluded$n = ["prefixCls", "id", "open", "defaultOpen", "mode", "showSearch", "searchValue", "onSearch", "allowClear", "clearIcon", "showArrow", "inputIcon", "disabled", "loading", "getInputElement", "getPopupContainer", "placement", "animation", "transitionName", "dropdownStyle", "dropdownClassName", "dropdownMatchSelectWidth", "dropdownRender", "dropdownAlign", "showAction", "direction", "tokenSeparators", "tagRender", "optionLabelRender", "onPopupScroll", "onDropdownVisibleChange", "onFocus", "onBlur", "onKeyup", "onKeydown", "onMousedown", "onClear", "omitDomProps", "getRawInputElement", "displayValues", "onDisplayValuesChange", "emptyOptions", "activeDescendantId", "activeValue", "OptionList"], DEFAULT_OMIT_PROPS = ["value", "onChange", "removeIcon", "placeholder", "autofocus", "maxTagCount", "maxTagTextLength", "maxTagPlaceholder", "choiceTransitionName", "onInputKeyDown", "onPopupScroll", "tabindex", "OptionList", "notFoundContent"], baseSelectPrivateProps = function() {
  return {
    prefixCls: String,
    id: String,
    omitDomProps: Array,
    // >>> Value
    displayValues: Array,
    onDisplayValuesChange: Function,
    // >>> Active
    /** Current dropdown list active item string value */
    activeValue: String,
    /** Link search input with target element */
    activeDescendantId: String,
    onActiveValueChange: Function,
    // >>> Search
    searchValue: String,
    /** Trigger onSearch, return false to prevent trigger open event */
    onSearch: Function,
    /** Trigger when search text match the `tokenSeparators`. Will provide split content */
    onSearchSplit: Function,
    maxLength: Number,
    OptionList: PropTypes$1.any,
    /** Tell if provided `options` is empty */
    emptyOptions: Boolean
  };
}, baseSelectPropsWithoutPrivate = function() {
  return {
    showSearch: {
      type: Boolean,
      default: void 0
    },
    tagRender: {
      type: Function
    },
    optionLabelRender: {
      type: Function
    },
    direction: {
      type: String
    },
    // MISC
    tabindex: Number,
    autofocus: Boolean,
    notFoundContent: PropTypes$1.any,
    placeholder: PropTypes$1.any,
    onClear: Function,
    choiceTransitionName: String,
    // >>> Mode
    mode: String,
    // >>> Status
    disabled: {
      type: Boolean,
      default: void 0
    },
    loading: {
      type: Boolean,
      default: void 0
    },
    // >>> Open
    open: {
      type: Boolean,
      default: void 0
    },
    defaultOpen: {
      type: Boolean,
      default: void 0
    },
    onDropdownVisibleChange: {
      type: Function
    },
    // >>> Customize Input
    /** @private Internal usage. Do not use in your production. */
    getInputElement: {
      type: Function
    },
    /** @private Internal usage. Do not use in your production. */
    getRawInputElement: {
      type: Function
    },
    // >>> Selector
    maxTagTextLength: Number,
    maxTagCount: {
      type: [String, Number]
    },
    maxTagPlaceholder: PropTypes$1.any,
    // >>> Search
    tokenSeparators: {
      type: Array
    },
    // >>> Icons
    allowClear: {
      type: Boolean,
      default: void 0
    },
    showArrow: {
      type: Boolean,
      default: void 0
    },
    inputIcon: PropTypes$1.any,
    /** Clear all icon */
    clearIcon: PropTypes$1.any,
    /** Selector remove icon */
    removeIcon: PropTypes$1.any,
    // >>> Dropdown
    animation: String,
    transitionName: String,
    dropdownStyle: {
      type: Object
    },
    dropdownClassName: String,
    dropdownMatchSelectWidth: {
      type: [Boolean, Number],
      default: void 0
    },
    dropdownRender: {
      type: Function
    },
    dropdownAlign: Object,
    placement: {
      type: String
    },
    getPopupContainer: {
      type: Function
    },
    // >>> Focus
    showAction: {
      type: Array
    },
    onBlur: {
      type: Function
    },
    onFocus: {
      type: Function
    },
    // >>> Rest Events
    onKeyup: Function,
    onKeydown: Function,
    onMousedown: Function,
    onPopupScroll: Function,
    onInputKeyDown: Function,
    onMouseenter: Function,
    onMouseleave: Function,
    onClick: Function
  };
}, baseSelectProps = function() {
  return _objectSpread2$1(_objectSpread2$1({}, baseSelectPrivateProps()), baseSelectPropsWithoutPrivate());
};
function isMultiple$1(H) {
  return H === "tags" || H === "multiple";
}
const BaseSelect = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "BaseSelect",
  inheritAttrs: !1,
  props: initDefaultProps$1(baseSelectProps(), {
    showAction: [],
    notFoundContent: "Not Found"
  }),
  setup: function(C, G) {
    var U = G.attrs, K = G.expose, W = G.slots, Z = computed(function() {
      return isMultiple$1(C.mode);
    }), X = computed(function() {
      return C.showSearch !== void 0 ? C.showSearch : Z.value || C.mode === "combobox";
    }), Q = ref(!1);
    onMounted(function() {
      Q.value = isMobile$2();
    });
    var ee = useInjectLegacySelectContext(), te = ref(null), re = createRef(), ne = ref(null), ae = ref(null), ie = ref(null), se = useDelayReset(), oe = _slicedToArray$2(se, 3), le = oe[0], ue = oe[1], ce = oe[2], de = function() {
      var De;
      (De = ae.value) === null || De === void 0 || De.focus();
    }, ge = function() {
      var De;
      (De = ae.value) === null || De === void 0 || De.blur();
    };
    K({
      focus: de,
      blur: ge,
      scrollTo: function(De) {
        var Ue;
        return (Ue = ie.value) === null || Ue === void 0 ? void 0 : Ue.scrollTo(De);
      }
    });
    var fe = computed(function() {
      var Le;
      if (C.mode !== "combobox")
        return C.searchValue;
      var De = (Le = C.displayValues[0]) === null || Le === void 0 ? void 0 : Le.value;
      return typeof De == "string" || typeof De == "number" ? String(De) : "";
    }), ve = C.open !== void 0 ? C.open : C.defaultOpen, pe = ref(ve), he = ref(ve), me = function(De) {
      pe.value = C.open !== void 0 ? C.open : De, he.value = pe.value;
    };
    watch(function() {
      return C.open;
    }, function() {
      me(C.open);
    });
    var ye = computed(function() {
      return !C.notFoundContent && C.emptyOptions;
    });
    watchEffect(function() {
      he.value = pe.value, (C.disabled || ye.value && he.value && C.mode === "combobox") && (he.value = !1);
    });
    var Ce = computed(function() {
      return ye.value ? !1 : he.value;
    }), Ie = function(De) {
      var Ue = De !== void 0 ? De : !he.value;
      pe.value !== Ue && !C.disabled && (me(Ue), C.onDropdownVisibleChange && C.onDropdownVisibleChange(Ue));
    }, be = computed(function() {
      return (C.tokenSeparators || []).some(function(Le) {
        return [`
`, `\r
`].includes(Le);
      });
    }), Se = function(De, Ue, st) {
      var ot, ct = !0, vt = De;
      (ot = C.onActiveValueChange) === null || ot === void 0 || ot.call(C, null);
      var ut = st ? null : getSeparatedContent(De, C.tokenSeparators);
      if (C.mode !== "combobox" && ut) {
        var at;
        vt = "", (at = C.onSearchSplit) === null || at === void 0 || at.call(C, ut), Ie(!1), ct = !1;
      }
      return C.onSearch && fe.value !== vt && C.onSearch(vt, {
        source: Ue ? "typing" : "effect"
      }), ct;
    }, Ae = function(De) {
      var Ue;
      !De || !De.trim() || (Ue = C.onSearch) === null || Ue === void 0 || Ue.call(C, De, {
        source: "submit"
      });
    };
    watch(he, function() {
      !he.value && !Z.value && C.mode !== "combobox" && Se("", !1, !1);
    }, {
      immediate: !0,
      flush: "post"
    }), watch(function() {
      return C.disabled;
    }, function() {
      pe.value && C.disabled && me(!1);
    }, {
      immediate: !0
    });
    var _e = useLock(), xe = _slicedToArray$2(_e, 2), Te = xe[0], Pe = xe[1], $e = function(De) {
      var Ue, st = Te(), ot = De.which;
      if (ot === KeyCode$1.ENTER && (C.mode !== "combobox" && De.preventDefault(), he.value || Ie(!0)), Pe(!!fe.value), ot === KeyCode$1.BACKSPACE && !st && Z.value && !fe.value && C.displayValues.length) {
        for (var ct = _toConsumableArray(C.displayValues), vt = null, ut = ct.length - 1; ut >= 0; ut -= 1) {
          var at = ct[ut];
          if (!at.disabled) {
            ct.splice(ut, 1), vt = at;
            break;
          }
        }
        vt && C.onDisplayValuesChange(ct, {
          type: "remove",
          values: [vt]
        });
      }
      for (var Ze = arguments.length, Xe = new Array(Ze > 1 ? Ze - 1 : 0), qe = 1; qe < Ze; qe++)
        Xe[qe - 1] = arguments[qe];
      if (he.value && ie.value) {
        var dt;
        (dt = ie.value).onKeydown.apply(dt, [De].concat(Xe));
      }
      (Ue = C.onKeydown) === null || Ue === void 0 || Ue.call.apply(Ue, [C, De].concat(Xe));
    }, Me = function(De) {
      for (var Ue = arguments.length, st = new Array(Ue > 1 ? Ue - 1 : 0), ot = 1; ot < Ue; ot++)
        st[ot - 1] = arguments[ot];
      if (he.value && ie.value) {
        var ct;
        (ct = ie.value).onKeyup.apply(ct, [De].concat(st));
      }
      C.onKeyup && C.onKeyup.apply(C, [De].concat(st));
    }, Ee = function(De) {
      var Ue = C.displayValues.filter(function(st) {
        return st !== De;
      });
      C.onDisplayValuesChange(Ue, {
        type: "remove",
        values: [De]
      });
    }, we = ref(!1), Oe = function() {
      ue(!0), C.disabled || (C.onFocus && !we.value && C.onFocus.apply(C, arguments), C.showAction && C.showAction.includes("focus") && Ie(!0)), we.value = !0;
    }, Ne = function() {
      if (ue(!1, function() {
        we.value = !1, Ie(!1);
      }), !C.disabled) {
        var De = fe.value;
        De && (C.mode === "tags" ? C.onSearch(De, {
          source: "submit"
        }) : C.mode === "multiple" && C.onSearch("", {
          source: "blur"
        })), C.onBlur && C.onBlur.apply(C, arguments);
      }
    };
    provide("VCSelectContainerEvent", {
      focus: Oe,
      blur: Ne
    });
    var ke = [];
    onMounted(function() {
      ke.forEach(function(Le) {
        return clearTimeout(Le);
      }), ke.splice(0, ke.length);
    }), onBeforeUnmount(function() {
      ke.forEach(function(Le) {
        return clearTimeout(Le);
      }), ke.splice(0, ke.length);
    });
    var ze = function(De) {
      var Ue, st, ot = De.target, ct = (Ue = ne.value) === null || Ue === void 0 ? void 0 : Ue.getPopupElement();
      if (ct && ct.contains(ot)) {
        var vt = setTimeout(function() {
          var Xe = ke.indexOf(vt);
          if (Xe !== -1 && ke.splice(Xe, 1), ce(), !Q.value && !ct.contains(document.activeElement)) {
            var qe;
            (qe = ae.value) === null || qe === void 0 || qe.focus();
          }
        });
        ke.push(vt);
      }
      for (var ut = arguments.length, at = new Array(ut > 1 ? ut - 1 : 0), Ze = 1; Ze < ut; Ze++)
        at[Ze - 1] = arguments[Ze];
      (st = C.onMousedown) === null || st === void 0 || st.call.apply(st, [C, De].concat(at));
    }, He = ref(null), We = getCurrentInstance(), Re = function() {
      We.update();
    };
    return onMounted(function() {
      watch(Ce, function() {
        if (Ce.value) {
          var Le, De = Math.ceil((Le = te.value) === null || Le === void 0 ? void 0 : Le.offsetWidth);
          He.value !== De && !Number.isNaN(De) && (He.value = De);
        }
      }, {
        immediate: !0,
        flush: "post"
      });
    }), useSelectTriggerControl([te, ne], Ce, Ie), useProvideBaseSelectProps(toReactive(_objectSpread2$1(_objectSpread2$1({}, toRefs(C)), {}, {
      open: he,
      triggerOpen: Ce,
      showSearch: X,
      multiple: Z,
      toggleOpen: Ie
    }))), function() {
      var Le, De = _objectSpread2$1(_objectSpread2$1({}, C), U), Ue = De.prefixCls, st = De.id;
      De.open, De.defaultOpen;
      var ot = De.mode;
      De.showSearch, De.searchValue, De.onSearch;
      var ct = De.allowClear, vt = De.clearIcon, ut = De.showArrow, at = De.inputIcon, Ze = De.disabled, Xe = De.loading, qe = De.getInputElement, dt = De.getPopupContainer, gt = De.placement, yt = De.animation, At = De.transitionName, nt = De.dropdownStyle, Ke = De.dropdownClassName, Qe = De.dropdownMatchSelectWidth, pt = De.dropdownRender, Ye = De.dropdownAlign;
      De.showAction;
      var Fe = De.direction;
      De.tokenSeparators;
      var Be = De.tagRender, je = De.optionLabelRender;
      De.onPopupScroll, De.onDropdownVisibleChange, De.onFocus, De.onBlur, De.onKeyup, De.onKeydown, De.onMousedown;
      var Je = De.onClear, it = De.omitDomProps, et = De.getRawInputElement, Ve = De.displayValues, Ge = De.onDisplayValuesChange, tt = De.emptyOptions, ft = De.activeDescendantId, mt = De.activeValue, ht = De.OptionList, St = _objectWithoutProperties$2(De, _excluded$n), Ct = ot === "combobox" && qe && qe() || null, bt = typeof et == "function" && et(), xt = _objectSpread2$1({}, St), It;
      bt && (It = function(Nt) {
        Ie(Nt);
      }), DEFAULT_OMIT_PROPS.forEach(function($t) {
        delete xt[$t];
      }), it == null || it.forEach(function($t) {
        delete xt[$t];
      });
      var Tt = ut !== void 0 ? ut : Xe || !Z.value && ot !== "combobox", _t;
      Tt && (_t = createVNode$1(TransBtn$1, {
        class: classNames("".concat(Ue, "-arrow"), _defineProperty$A({}, "".concat(Ue, "-arrow-loading"), Xe)),
        customizeIcon: at,
        customizeIconProps: {
          loading: Xe,
          searchValue: fe.value,
          open: he.value,
          focused: le.value,
          showSearch: X.value
        }
      }, null));
      var wt, Mt = function() {
        Je == null || Je(), Ge([], {
          type: "clear",
          values: Ve
        }), Se("", !1, !1);
      };
      !Ze && ct && (Ve.length || fe.value) && (wt = createVNode$1(TransBtn$1, {
        class: "".concat(Ue, "-clear"),
        onMousedown: Mt,
        customizeIcon: vt
      }, {
        default: function() {
          return [createTextVNode("×")];
        }
      }));
      var Ot = createVNode$1(ht, {
        ref: ie
      }, _objectSpread2$1(_objectSpread2$1({}, ee.customSlots), {}, {
        option: W.option
      })), kt = classNames(Ue, U.class, (Le = {}, _defineProperty$A(Le, "".concat(Ue, "-focused"), le.value), _defineProperty$A(Le, "".concat(Ue, "-multiple"), Z.value), _defineProperty$A(Le, "".concat(Ue, "-single"), !Z.value), _defineProperty$A(Le, "".concat(Ue, "-allow-clear"), ct), _defineProperty$A(Le, "".concat(Ue, "-show-arrow"), Tt), _defineProperty$A(Le, "".concat(Ue, "-disabled"), Ze), _defineProperty$A(Le, "".concat(Ue, "-loading"), Xe), _defineProperty$A(Le, "".concat(Ue, "-open"), he.value), _defineProperty$A(Le, "".concat(Ue, "-customize-input"), Ct), _defineProperty$A(Le, "".concat(Ue, "-show-search"), X.value), Le)), Ft = createVNode$1(SelectTrigger$1, {
        ref: ne,
        disabled: Ze,
        prefixCls: Ue,
        visible: Ce.value,
        popupElement: Ot,
        containerWidth: He.value,
        animation: yt,
        transitionName: At,
        dropdownStyle: nt,
        dropdownClassName: Ke,
        direction: Fe,
        dropdownMatchSelectWidth: Qe,
        dropdownRender: pt,
        dropdownAlign: Ye,
        placement: gt,
        getPopupContainer: dt,
        empty: tt,
        getTriggerDOMNode: function() {
          return re.current;
        },
        onPopupVisibleChange: It,
        onPopupMouseEnter: Re
      }, {
        default: function() {
          return bt ? isValidElement(bt) && cloneElement(bt, {
            ref: re
          }, !1, !0) : createVNode$1(Selector$1, _objectSpread2$1(_objectSpread2$1({}, C), {}, {
            domRef: re,
            prefixCls: Ue,
            inputElement: Ct,
            ref: ae,
            id: st,
            showSearch: X.value,
            mode: ot,
            activeDescendantId: ft,
            tagRender: Be,
            optionLabelRender: je,
            values: Ve,
            open: he.value,
            onToggleOpen: Ie,
            activeValue: mt,
            searchValue: fe.value,
            onSearch: Se,
            onSearchSubmit: Ae,
            onRemove: Ee,
            tokenWithEnter: be.value
          }), null);
        }
      }), Rt;
      return bt ? Rt = Ft : Rt = createVNode$1("div", _objectSpread2$1(_objectSpread2$1({}, xt), {}, {
        class: kt,
        ref: te,
        onMousedown: ze,
        onKeydown: $e,
        onKeyup: Me
      }), [le.value && !he.value && createVNode$1("span", {
        style: {
          width: 0,
          height: 0,
          display: "flex",
          overflow: "hidden",
          opacity: 0
        },
        "aria-live": "polite"
      }, ["".concat(Ve.map(function($t) {
        var Nt = $t.label, Dt = $t.value;
        return ["number", "string"].includes(_typeof$2(Nt)) ? Nt : Dt;
      }).join(", "))]), Ft, _t, wt]), Rt;
    };
  }
});
var Filter = function(C, G) {
  var U, K = C.height, W = C.offset, Z = C.prefixCls, X = C.onInnerResize, Q = G.slots, ee = {}, te = {
    display: "flex",
    flexDirection: "column"
  };
  return W !== void 0 && (ee = {
    height: "".concat(K, "px"),
    position: "relative",
    overflow: "hidden"
  }, te = _objectSpread2$1(_objectSpread2$1({}, te), {}, {
    transform: "translateY(".concat(W, "px)"),
    position: "absolute",
    left: 0,
    right: 0,
    top: 0
  })), createVNode$1("div", {
    style: ee
  }, [createVNode$1(ResizeObserver, {
    onResize: function(ne) {
      var ae = ne.offsetHeight;
      ae && X && X();
    }
  }, {
    default: function() {
      return [createVNode$1("div", {
        style: te,
        class: classNames(_defineProperty$A({}, "".concat(Z, "-holder-inner"), Z))
      }, [(U = Q.default) === null || U === void 0 ? void 0 : U.call(Q)])];
    }
  })]);
};
Filter.displayName = "Filter";
Filter.inheritAttrs = !1;
Filter.props = {
  prefixCls: String,
  /** Virtual filler height. Should be `count * itemMinHeight` */
  height: Number,
  /** Set offset of visible items. Should be the top of start item position */
  offset: Number,
  onInnerResize: Function
};
const Filler = Filter;
var Item = function(C, G) {
  var U, K = C.setRef, W = G.slots, Z = flattenChildren((U = W.default) === null || U === void 0 ? void 0 : U.call(W));
  return Z && Z.length ? cloneVNode(Z[0], {
    ref: K
  }) : Z;
};
Item.props = {
  setRef: {
    type: Function,
    default: function() {
    }
  }
};
const Item$1 = Item;
var MIN_SIZE = 20;
function getPageY(H) {
  return "touches" in H ? H.touches[0].pageY : H.pageY;
}
const ScrollBar = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ScrollBar",
  inheritAttrs: !1,
  props: {
    prefixCls: String,
    scrollTop: Number,
    scrollHeight: Number,
    height: Number,
    count: Number,
    onScroll: {
      type: Function
    },
    onStartMove: {
      type: Function
    },
    onStopMove: {
      type: Function
    }
  },
  setup: function() {
    return {
      moveRaf: null,
      scrollbarRef: createRef(),
      thumbRef: createRef(),
      visibleTimeout: null,
      state: reactive({
        dragging: !1,
        pageY: null,
        startTop: null,
        visible: !1
      })
    };
  },
  watch: {
    scrollTop: {
      handler: function() {
        this.delayHidden();
      },
      flush: "post"
    }
  },
  mounted: function() {
    var C, G;
    (C = this.scrollbarRef.current) === null || C === void 0 || C.addEventListener("touchstart", this.onScrollbarTouchStart, supportsPassive$1 ? {
      passive: !1
    } : !1), (G = this.thumbRef.current) === null || G === void 0 || G.addEventListener("touchstart", this.onMouseDown, supportsPassive$1 ? {
      passive: !1
    } : !1);
  },
  beforeUnmount: function() {
    this.removeEvents(), clearTimeout(this.visibleTimeout);
  },
  methods: {
    delayHidden: function() {
      var C = this;
      clearTimeout(this.visibleTimeout), this.state.visible = !0, this.visibleTimeout = setTimeout(function() {
        C.state.visible = !1;
      }, 2e3);
    },
    onScrollbarTouchStart: function(C) {
      C.preventDefault();
    },
    onContainerMouseDown: function(C) {
      C.stopPropagation(), C.preventDefault();
    },
    // ======================= Clean =======================
    patchEvents: function() {
      window.addEventListener("mousemove", this.onMouseMove), window.addEventListener("mouseup", this.onMouseUp), this.thumbRef.current.addEventListener("touchmove", this.onMouseMove, supportsPassive$1 ? {
        passive: !1
      } : !1), this.thumbRef.current.addEventListener("touchend", this.onMouseUp);
    },
    removeEvents: function() {
      window.removeEventListener("mousemove", this.onMouseMove), window.removeEventListener("mouseup", this.onMouseUp), this.scrollbarRef.current.removeEventListener("touchstart", this.onScrollbarTouchStart, supportsPassive$1 ? {
        passive: !1
      } : !1), this.thumbRef.current.removeEventListener("touchstart", this.onMouseDown, supportsPassive$1 ? {
        passive: !1
      } : !1), this.thumbRef.current.removeEventListener("touchmove", this.onMouseMove, supportsPassive$1 ? {
        passive: !1
      } : !1), this.thumbRef.current.removeEventListener("touchend", this.onMouseUp), wrapperRaf.cancel(this.moveRaf);
    },
    // ======================= Thumb =======================
    onMouseDown: function(C) {
      var G = this.$props.onStartMove;
      _extends(this.state, {
        dragging: !0,
        pageY: getPageY(C),
        startTop: this.getTop()
      }), G(), this.patchEvents(), C.stopPropagation(), C.preventDefault();
    },
    onMouseMove: function(C) {
      var G = this.state, U = G.dragging, K = G.pageY, W = G.startTop, Z = this.$props.onScroll;
      if (wrapperRaf.cancel(this.moveRaf), U) {
        var X = getPageY(C) - K, Q = W + X, ee = this.getEnableScrollRange(), te = this.getEnableHeightRange(), re = te ? Q / te : 0, ne = Math.ceil(re * ee);
        this.moveRaf = wrapperRaf(function() {
          Z(ne);
        });
      }
    },
    onMouseUp: function() {
      var C = this.$props.onStopMove;
      this.state.dragging = !1, C(), this.removeEvents();
    },
    // ===================== Calculate =====================
    getSpinHeight: function() {
      var C = this.$props, G = C.height, U = C.count, K = G / U * 10;
      return K = Math.max(K, MIN_SIZE), K = Math.min(K, G / 2), Math.floor(K);
    },
    getEnableScrollRange: function() {
      var C = this.$props, G = C.scrollHeight, U = C.height;
      return G - U || 0;
    },
    getEnableHeightRange: function() {
      var C = this.$props.height, G = this.getSpinHeight();
      return C - G || 0;
    },
    getTop: function() {
      var C = this.$props.scrollTop, G = this.getEnableScrollRange(), U = this.getEnableHeightRange();
      if (C === 0 || G === 0)
        return 0;
      var K = C / G;
      return K * U;
    },
    // Not show scrollbar when height is large than scrollHeight
    showScroll: function() {
      var C = this.$props, G = C.height, U = C.scrollHeight;
      return U > G;
    }
  },
  render: function() {
    var C = this.state, G = C.dragging, U = C.visible, K = this.$props.prefixCls, W = this.getSpinHeight() + "px", Z = this.getTop() + "px", X = this.showScroll(), Q = X && U;
    return createVNode$1("div", {
      ref: this.scrollbarRef,
      class: classNames("".concat(K, "-scrollbar"), _defineProperty$A({}, "".concat(K, "-scrollbar-show"), X)),
      style: {
        width: "8px",
        top: 0,
        bottom: 0,
        right: 0,
        position: "absolute",
        display: Q ? void 0 : "none"
      },
      onMousedown: this.onContainerMouseDown,
      onMousemove: this.delayHidden
    }, [createVNode$1("div", {
      ref: this.thumbRef,
      class: classNames("".concat(K, "-scrollbar-thumb"), _defineProperty$A({}, "".concat(K, "-scrollbar-thumb-moving"), G)),
      style: {
        width: "100%",
        height: W,
        top: Z,
        left: 0,
        position: "absolute",
        background: "rgba(0, 0, 0, 0.5)",
        borderRadius: "99px",
        cursor: "pointer",
        userSelect: "none"
      },
      onMousedown: this.onMouseDown
    }, null)]);
  }
});
function useHeights(H, C, G, U) {
  var K = /* @__PURE__ */ new Map(), W = /* @__PURE__ */ new Map(), Z = ref(Symbol("update"));
  watch(H, function() {
    Z.value = Symbol("update");
  });
  var X = 0;
  function Q() {
    X += 1;
    var te = X;
    Promise.resolve().then(function() {
      te === X && K.forEach(function(re, ne) {
        if (re && re.offsetParent) {
          var ae = re.offsetHeight;
          W.get(ne) !== ae && (Z.value = Symbol("update"), W.set(ne, re.offsetHeight));
        }
      });
    });
  }
  function ee(te, re) {
    var ne = C(te), ae = K.get(ne);
    re ? (K.set(ne, re.$el || re), Q()) : K.delete(ne), !ae != !re && (re ? G == null || G(te) : U == null || U(te));
  }
  return [ee, Q, W, Z];
}
function useScrollTo(H, C, G, U, K, W, Z, X) {
  var Q;
  return function(ee) {
    if (ee == null) {
      X();
      return;
    }
    wrapperRaf.cancel(Q);
    var te = C.value, re = U.itemHeight;
    if (typeof ee == "number")
      Z(ee);
    else if (ee && _typeof$2(ee) === "object") {
      var ne, ae = ee.align;
      "index" in ee ? ne = ee.index : ne = te.findIndex(function(le) {
        return K(le) === ee.key;
      });
      var ie = ee.offset, se = ie === void 0 ? 0 : ie, oe = function le(ue, ce) {
        if (!(ue < 0 || !H.value)) {
          var de = H.value.clientHeight, ge = !1, fe = ce;
          if (de) {
            for (var ve = ce || ae, pe = 0, he = 0, me = 0, ye = Math.min(te.length, ne), Ce = 0; Ce <= ye; Ce += 1) {
              var Ie = K(te[Ce]);
              he = pe;
              var be = G.get(Ie);
              me = he + (be === void 0 ? re : be), pe = me, Ce === ne && be === void 0 && (ge = !0);
            }
            var Se = H.value.scrollTop, Ae = null;
            switch (ve) {
              case "top":
                Ae = he - se;
                break;
              case "bottom":
                Ae = me - de + se;
                break;
              default: {
                var _e = Se + de;
                he < Se ? fe = "top" : me > _e && (fe = "bottom");
              }
            }
            Ae !== null && Ae !== Se && Z(Ae);
          }
          Q = wrapperRaf(function() {
            ge && W(), le(ue - 1, fe);
          });
        }
      };
      oe(5);
    }
  };
}
var isFF = (typeof navigator > "u" ? "undefined" : _typeof$2(navigator)) === "object" && /Firefox/i.test(navigator.userAgent);
const isFF$1 = isFF, useOriginScroll = function(H, C) {
  var G = !1, U = null;
  function K() {
    clearTimeout(U), G = !0, U = setTimeout(function() {
      G = !1;
    }, 50);
  }
  return function(W) {
    var Z = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, X = (
      // Pass origin wheel when on the top
      W < 0 && H.value || // Pass origin wheel when on the bottom
      W > 0 && C.value
    );
    return Z && X ? (clearTimeout(U), G = !1) : (!X || G) && K(), !G && X;
  };
};
function useFrameWheel(H, C, G, U) {
  var K = 0, W = null, Z = null, X = !1, Q = useOriginScroll(C, G);
  function ee(re) {
    if (H.value) {
      wrapperRaf.cancel(W);
      var ne = re.deltaY;
      K += ne, Z = ne, !Q(ne) && (isFF$1 || re.preventDefault(), W = wrapperRaf(function() {
        var ae = X ? 10 : 1;
        U(K * ae), K = 0;
      }));
    }
  }
  function te(re) {
    H.value && (X = re.detail === Z);
  }
  return [ee, te];
}
var SMOOTH_PTG = 14 / 15;
function useMobileTouchMove(H, C, G) {
  var U = !1, K = 0, W = null, Z = null, X = function() {
    W && (W.removeEventListener("touchmove", Q), W.removeEventListener("touchend", ee));
  }, Q = function(ae) {
    if (U) {
      var ie = Math.ceil(ae.touches[0].pageY), se = K - ie;
      K = ie, G(se) && ae.preventDefault(), clearInterval(Z), Z = setInterval(function() {
        se *= SMOOTH_PTG, (!G(se, !0) || Math.abs(se) <= 0.1) && clearInterval(Z);
      }, 16);
    }
  }, ee = function() {
    U = !1, X();
  }, te = function(ae) {
    X(), ae.touches.length === 1 && !U && (U = !0, K = Math.ceil(ae.touches[0].pageY), W = ae.target, W.addEventListener("touchmove", Q, {
      passive: !1
    }), W.addEventListener("touchend", ee));
  }, re = function() {
  };
  onMounted(function() {
    document.addEventListener("touchmove", re, {
      passive: !1
    }), watch(H, function(ne) {
      C.value.removeEventListener("touchstart", te), X(), clearInterval(Z), ne && C.value.addEventListener("touchstart", te, {
        passive: !1
      });
    }, {
      immediate: !0
    });
  }), onBeforeUnmount(function() {
    document.removeEventListener("touchmove", re);
  });
}
var _excluded$m = ["prefixCls", "height", "itemHeight", "fullHeight", "data", "itemKey", "virtual", "component", "onScroll", "children", "style", "class"], EMPTY_DATA$1 = [], ScrollStyle = {
  overflowY: "auto",
  overflowAnchor: "none"
};
function renderChildren(H, C, G, U, K, W) {
  var Z = W.getKey;
  return H.slice(C, G + 1).map(function(X, Q) {
    var ee = C + Q, te = K(X, ee, {
      // style: status === 'MEASURE_START' ? { visibility: 'hidden' } : {},
    }), re = Z(X);
    return createVNode$1(Item$1, {
      key: re,
      setRef: function(ae) {
        return U(X, ae);
      }
    }, {
      default: function() {
        return [te];
      }
    });
  });
}
var List = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "List",
  inheritAttrs: !1,
  props: {
    prefixCls: String,
    data: PropTypes$1.array,
    height: Number,
    itemHeight: Number,
    /** If not match virtual scroll condition, Set List still use height of container. */
    fullHeight: {
      type: Boolean,
      default: void 0
    },
    itemKey: {
      type: [String, Number, Function],
      required: !0
    },
    component: {
      type: [String, Object]
    },
    /** Set `false` will always use real scroll instead of virtual one */
    virtual: {
      type: Boolean,
      default: void 0
    },
    children: Function,
    onScroll: Function,
    onMousedown: Function,
    onMouseenter: Function,
    onVisibleChange: Function
  },
  setup: function(C, G) {
    var U = G.expose, K = computed(function() {
      var Ee = C.height, we = C.itemHeight, Oe = C.virtual;
      return !!(Oe !== !1 && Ee && we);
    }), W = computed(function() {
      var Ee = C.height, we = C.itemHeight, Oe = C.data;
      return K.value && Oe && we * Oe.length > Ee;
    }), Z = reactive({
      scrollTop: 0,
      scrollMoving: !1
    }), X = computed(function() {
      return C.data || EMPTY_DATA$1;
    }), Q = shallowRef([]);
    watch(X, function() {
      Q.value = toRaw(X.value).slice();
    }, {
      immediate: !0
    });
    var ee = shallowRef(function(Ee) {
    });
    watch(function() {
      return C.itemKey;
    }, function(Ee) {
      typeof Ee == "function" ? ee.value = Ee : ee.value = function(we) {
        return we == null ? void 0 : we[Ee];
      };
    }, {
      immediate: !0
    });
    var te = ref(), re = ref(), ne = ref(), ae = function(we) {
      return ee.value(we);
    }, ie = {
      getKey: ae
    };
    function se(Ee) {
      var we;
      typeof Ee == "function" ? we = Ee(Z.scrollTop) : we = Ee;
      var Oe = he(we);
      te.value && (te.value.scrollTop = Oe), Z.scrollTop = Oe;
    }
    var oe = useHeights(Q, ae, null, null), le = _slicedToArray$2(oe, 4), ue = le[0], ce = le[1], de = le[2], ge = le[3], fe = reactive({
      scrollHeight: void 0,
      start: 0,
      end: 0,
      offset: void 0
    }), ve = ref(0);
    onMounted(function() {
      nextTick(function() {
        var Ee;
        ve.value = ((Ee = re.value) === null || Ee === void 0 ? void 0 : Ee.offsetHeight) || 0;
      });
    }), onUpdated(function() {
      nextTick(function() {
        var Ee;
        ve.value = ((Ee = re.value) === null || Ee === void 0 ? void 0 : Ee.offsetHeight) || 0;
      });
    }), watch([K, Q], function() {
      K.value || _extends(fe, {
        scrollHeight: void 0,
        start: 0,
        end: Q.value.length - 1,
        offset: void 0
      });
    }, {
      immediate: !0
    }), watch([K, Q, ve, W], function() {
      K.value && !W.value && _extends(fe, {
        scrollHeight: ve.value,
        start: 0,
        end: Q.value.length - 1,
        offset: void 0
      });
    }, {
      immediate: !0
    }), watch([W, K, function() {
      return Z.scrollTop;
    }, Q, ge, function() {
      return C.height;
    }, ve], function() {
      if (!(!K.value || !W.value)) {
        for (var Ee = 0, we, Oe, Ne, ke = Q.value.length, ze = Q.value, He = Z.scrollTop, We = C.itemHeight, Re = C.height, Le = He + Re, De = 0; De < ke; De += 1) {
          var Ue = ze[De], st = ae(Ue), ot = de.get(st);
          ot === void 0 && (ot = We);
          var ct = Ee + ot;
          we === void 0 && ct >= He && (we = De, Oe = Ee), Ne === void 0 && ct > Le && (Ne = De), Ee = ct;
        }
        we === void 0 && (we = 0, Oe = 0), Ne === void 0 && (Ne = ke - 1), Ne = Math.min(Ne + 1, ke), _extends(fe, {
          scrollHeight: Ee,
          start: we,
          end: Ne,
          offset: Oe
        });
      }
    }, {
      immediate: !0
    });
    var pe = computed(function() {
      return fe.scrollHeight - C.height;
    });
    function he(Ee) {
      var we = Ee;
      return Number.isNaN(pe.value) || (we = Math.min(we, pe.value)), we = Math.max(we, 0), we;
    }
    var me = computed(function() {
      return Z.scrollTop <= 0;
    }), ye = computed(function() {
      return Z.scrollTop >= pe.value;
    }), Ce = useOriginScroll(me, ye);
    function Ie(Ee) {
      var we = Ee;
      se(we);
    }
    function be(Ee) {
      var we, Oe = Ee.currentTarget.scrollTop;
      Math.abs(Oe - Z.scrollTop) >= 1 && se(Oe), (we = C.onScroll) === null || we === void 0 || we.call(C, Ee);
    }
    var Se = useFrameWheel(K, me, ye, function(Ee) {
      se(function(we) {
        var Oe = we + Ee;
        return Oe;
      });
    }), Ae = _slicedToArray$2(Se, 2), _e = Ae[0], xe = Ae[1];
    useMobileTouchMove(K, te, function(Ee, we) {
      return Ce(Ee, we) ? !1 : (_e({
        preventDefault: function() {
        },
        deltaY: Ee
      }), !0);
    });
    function Te(Ee) {
      K.value && Ee.preventDefault();
    }
    var Pe = function() {
      te.value && (te.value.removeEventListener("wheel", _e, supportsPassive$1 ? {
        passive: !1
      } : !1), te.value.removeEventListener("DOMMouseScroll", xe), te.value.removeEventListener("MozMousePixelScroll", Te));
    };
    watchEffect(function() {
      nextTick(function() {
        te.value && (Pe(), te.value.addEventListener("wheel", _e, supportsPassive$1 ? {
          passive: !1
        } : !1), te.value.addEventListener("DOMMouseScroll", xe), te.value.addEventListener("MozMousePixelScroll", Te));
      });
    }), onBeforeUnmount(function() {
      Pe();
    });
    var $e = useScrollTo(te, Q, de, C, ae, ce, se, function() {
      var Ee;
      (Ee = ne.value) === null || Ee === void 0 || Ee.delayHidden();
    });
    U({
      scrollTo: $e
    });
    var Me = computed(function() {
      var Ee = null;
      return C.height && (Ee = _objectSpread2$1(_defineProperty$A({}, C.fullHeight ? "height" : "maxHeight", C.height + "px"), ScrollStyle), K.value && (Ee.overflowY = "hidden", Z.scrollMoving && (Ee.pointerEvents = "none"))), Ee;
    });
    return watch([function() {
      return fe.start;
    }, function() {
      return fe.end;
    }, Q], function() {
      if (C.onVisibleChange) {
        var Ee = Q.value.slice(fe.start, fe.end + 1);
        C.onVisibleChange(Ee, Q.value);
      }
    }, {
      flush: "post"
    }), {
      state: Z,
      mergedData: Q,
      componentStyle: Me,
      onFallbackScroll: be,
      onScrollBar: Ie,
      componentRef: te,
      useVirtual: K,
      calRes: fe,
      collectHeight: ce,
      setInstance: ue,
      sharedConfig: ie,
      scrollBarRef: ne,
      fillerInnerRef: re
    };
  },
  render: function() {
    var C = this, G = _objectSpread2$1(_objectSpread2$1({}, this.$props), this.$attrs), U = G.prefixCls, K = U === void 0 ? "rc-virtual-list" : U, W = G.height;
    G.itemHeight, G.fullHeight, G.data, G.itemKey, G.virtual;
    var Z = G.component, X = Z === void 0 ? "div" : Z;
    G.onScroll;
    var Q = G.children, ee = Q === void 0 ? this.$slots.default : Q, te = G.style, re = G.class, ne = _objectWithoutProperties$2(G, _excluded$m), ae = classNames(K, re), ie = this.state.scrollTop, se = this.calRes, oe = se.scrollHeight, le = se.offset, ue = se.start, ce = se.end, de = this.componentStyle, ge = this.onFallbackScroll, fe = this.onScrollBar, ve = this.useVirtual, pe = this.collectHeight, he = this.sharedConfig, me = this.setInstance, ye = this.mergedData;
    return createVNode$1("div", _objectSpread2$1({
      style: _objectSpread2$1(_objectSpread2$1({}, te), {}, {
        position: "relative"
      }),
      class: ae
    }, ne), [createVNode$1(X, {
      class: "".concat(K, "-holder"),
      style: de,
      ref: "componentRef",
      onScroll: ge
    }, {
      default: function() {
        return [createVNode$1(Filler, {
          prefixCls: K,
          height: oe,
          offset: le,
          onInnerResize: pe,
          ref: "fillerInnerRef"
        }, {
          default: function() {
            return renderChildren(ye, ue, ce, me, ee, he);
          }
        })];
      }
    }), ve && createVNode$1(ScrollBar, {
      ref: "scrollBarRef",
      prefixCls: K,
      scrollTop: ie,
      height: W,
      scrollHeight: oe,
      count: ye.length,
      onScroll: fe,
      onStartMove: function() {
        C.state.scrollMoving = !0;
      },
      onStopMove: function() {
        C.state.scrollMoving = !1;
      }
    }, null)]);
  }
});
const List$1 = List;
function useMemo(H, C, G) {
  var U = ref(H());
  return watch(C, function(K, W) {
    G ? G(K, W) && (U.value = H()) : U.value = H();
  }), U;
}
function isPlatformMac() {
  return /(mac\sos|macintosh)/i.test(navigator.appVersion);
}
var SelectContextKey = Symbol("SelectContextKey");
function useProvideSelectProps(H) {
  return provide(SelectContextKey, H);
}
function useSelectProps() {
  return inject(SelectContextKey, {});
}
var _excluded$l = ["disabled", "title", "children", "style", "class", "className"];
function isTitleType(H) {
  return typeof H == "string" || typeof H == "number";
}
var OptionList = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "OptionList",
  inheritAttrs: !1,
  slots: ["option"],
  setup: function(C, G) {
    var U = G.expose, K = G.slots, W = useBaseProps(), Z = useSelectProps(), X = computed(function() {
      return "".concat(W.prefixCls, "-item");
    }), Q = useMemo(function() {
      return Z.flattenOptions;
    }, [function() {
      return W.open;
    }, function() {
      return Z.flattenOptions;
    }], function(fe) {
      return fe[0];
    }), ee = createRef(), te = function(ve) {
      ve.preventDefault();
    }, re = function(ve) {
      ee.current && ee.current.scrollTo(typeof ve == "number" ? {
        index: ve
      } : ve);
    }, ne = function(ve) {
      for (var pe = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1, he = Q.value.length, me = 0; me < he; me += 1) {
        var ye = (ve + me * pe + he) % he, Ce = Q.value[ye], Ie = Ce.group, be = Ce.data;
        if (!Ie && !be.disabled)
          return ye;
      }
      return -1;
    }, ae = reactive({
      activeIndex: ne(0)
    }), ie = function(ve) {
      var pe = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
      ae.activeIndex = ve;
      var he = {
        source: pe ? "keyboard" : "mouse"
      }, me = Q.value[ve];
      if (!me) {
        Z.onActiveValue(null, -1, he);
        return;
      }
      Z.onActiveValue(me.value, ve, he);
    };
    watch([function() {
      return Q.value.length;
    }, function() {
      return W.searchValue;
    }], function() {
      ie(Z.defaultActiveFirstOption !== !1 ? ne(0) : -1);
    }, {
      immediate: !0
    });
    var se = function(ve) {
      return Z.rawValues.has(ve) && W.mode !== "combobox";
    };
    watch([function() {
      return W.open;
    }, function() {
      return W.searchValue;
    }], function() {
      if (!W.multiple && W.open && Z.rawValues.size === 1) {
        var fe = Array.from(Z.rawValues)[0], ve = toRaw(Q.value).findIndex(function(pe) {
          var he = pe.data;
          return he[Z.fieldNames.value] === fe;
        });
        ve !== -1 && (ie(ve), nextTick(function() {
          re(ve);
        }));
      }
      W.open && nextTick(function() {
        var pe;
        (pe = ee.current) === null || pe === void 0 || pe.scrollTo(void 0);
      });
    }, {
      immediate: !0,
      flush: "post"
    });
    var oe = function(ve) {
      ve !== void 0 && Z.onSelect(ve, {
        selected: !Z.rawValues.has(ve)
      }), W.multiple || W.toggleOpen(!1);
    }, le = function(ve) {
      return typeof ve.label == "function" ? ve.label() : ve.label;
    };
    function ue(fe) {
      var ve = Q.value[fe];
      if (!ve)
        return null;
      var pe = ve.data || {}, he = pe.value, me = ve.group, ye = pickAttrs(pe, !0), Ce = le(ve);
      return ve ? createVNode$1("div", _objectSpread2$1(_objectSpread2$1({
        "aria-label": typeof Ce == "string" && !me ? Ce : null
      }, ye), {}, {
        key: fe,
        role: me ? "presentation" : "option",
        id: "".concat(W.id, "_list_").concat(fe),
        "aria-selected": se(he)
      }), [he]) : null;
    }
    var ce = function(ve) {
      var pe = ve.which, he = ve.ctrlKey;
      switch (pe) {
        case KeyCode$1.N:
        case KeyCode$1.P:
        case KeyCode$1.UP:
        case KeyCode$1.DOWN: {
          var me = 0;
          if (pe === KeyCode$1.UP ? me = -1 : pe === KeyCode$1.DOWN ? me = 1 : isPlatformMac() && he && (pe === KeyCode$1.N ? me = 1 : pe === KeyCode$1.P && (me = -1)), me !== 0) {
            var ye = ne(ae.activeIndex + me, me);
            re(ye), ie(ye, !0);
          }
          break;
        }
        case KeyCode$1.ENTER: {
          var Ce = Q.value[ae.activeIndex];
          Ce && !Ce.data.disabled ? oe(Ce.value) : oe(void 0), W.open && ve.preventDefault();
          break;
        }
        case KeyCode$1.ESC:
          W.toggleOpen(!1), W.open && ve.stopPropagation();
      }
    }, de = function() {
    }, ge = function(ve) {
      re(ve);
    };
    return U({
      onKeydown: ce,
      onKeyup: de,
      scrollTo: ge
    }), function() {
      var fe = W.id, ve = W.notFoundContent, pe = W.onPopupScroll, he = Z.menuItemSelectedIcon, me = Z.fieldNames, ye = Z.virtual, Ce = Z.listHeight, Ie = Z.listItemHeight, be = K.option, Se = ae.activeIndex, Ae = Object.keys(me).map(function(_e) {
        return me[_e];
      });
      return Q.value.length === 0 ? createVNode$1("div", {
        role: "listbox",
        id: "".concat(fe, "_list"),
        class: "".concat(X.value, "-empty"),
        onMousedown: te
      }, [ve]) : createVNode$1(Fragment, null, [createVNode$1("div", {
        role: "listbox",
        id: "".concat(fe, "_list"),
        style: {
          height: 0,
          width: 0,
          overflow: "hidden"
        }
      }, [ue(Se - 1), ue(Se), ue(Se + 1)]), createVNode$1(List$1, {
        itemKey: "key",
        ref: ee,
        data: Q.value,
        height: Ce,
        itemHeight: Ie,
        fullHeight: !1,
        onMousedown: te,
        onScroll: pe,
        virtual: ye
      }, {
        default: function(xe, Te) {
          var Pe, $e = xe.group, Me = xe.groupOption, Ee = xe.data, we = xe.value, Oe = Ee.key, Ne = typeof xe.label == "function" ? xe.label() : xe.label;
          if ($e) {
            var ke, ze = (ke = Ee.title) !== null && ke !== void 0 ? ke : isTitleType(Ne) && Ne;
            return createVNode$1("div", {
              class: classNames(X.value, "".concat(X.value, "-group")),
              title: ze
            }, [be ? be(Ee) : Ne !== void 0 ? Ne : Oe]);
          }
          var He = Ee.disabled, We = Ee.title;
          Ee.children;
          var Re = Ee.style, Le = Ee.class, De = Ee.className, Ue = _objectWithoutProperties$2(Ee, _excluded$l), st = omit(Ue, Ae), ot = se(we), ct = "".concat(X.value, "-option"), vt = classNames(X.value, ct, Le, De, (Pe = {}, _defineProperty$A(Pe, "".concat(ct, "-grouped"), Me), _defineProperty$A(Pe, "".concat(ct, "-active"), Se === Te && !He), _defineProperty$A(Pe, "".concat(ct, "-disabled"), He), _defineProperty$A(Pe, "".concat(ct, "-selected"), ot), Pe)), ut = le(xe), at = !he || typeof he == "function" || ot, Ze = typeof ut == "number" ? ut : ut || we, Xe = isTitleType(Ze) ? Ze.toString() : void 0;
          return We !== void 0 && (Xe = We), createVNode$1("div", _objectSpread2$1(_objectSpread2$1({}, st), {}, {
            "aria-selected": ot,
            class: vt,
            title: Xe,
            onMousemove: function(dt) {
              Ue.onMousemove && Ue.onMousemove(dt), !(Se === Te || He) && ie(Te);
            },
            onClick: function(dt) {
              He || oe(we), Ue.onClick && Ue.onClick(dt);
            },
            style: Re
          }), [createVNode$1("div", {
            class: "".concat(ct, "-content")
          }, [be ? be(Ee) : Ze]), isValidElement(he) || ot, at && createVNode$1(TransBtn$1, {
            class: "".concat(X.value, "-option-state"),
            customizeIcon: he,
            customizeIconProps: {
              isSelected: ot
            }
          }, {
            default: function() {
              return [ot ? "✓" : null];
            }
          })]);
        }
      })]);
    };
  }
});
const OptionList$1 = OptionList;
var _excluded$k = ["value", "disabled"];
function convertNodeToOption(H) {
  var C = H.key, G = H.children, U = H.props, K = U.value, W = U.disabled, Z = _objectWithoutProperties$2(U, _excluded$k), X = G == null ? void 0 : G.default;
  return _objectSpread2$1({
    key: C,
    value: K !== void 0 ? K : C,
    children: X,
    disabled: W || W === ""
  }, Z);
}
function convertChildrenToData(H) {
  var C = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, G = flattenChildren(H).map(function(U, K) {
    var W;
    if (!isValidElement(U) || !U.type)
      return null;
    var Z = U.type.isSelectOptGroup, X = U.key, Q = U.children, ee = U.props;
    if (C || !Z)
      return convertNodeToOption(U);
    var te = Q && Q.default ? Q.default() : void 0, re = (ee == null ? void 0 : ee.label) || ((W = Q.label) === null || W === void 0 ? void 0 : W.call(Q)) || X;
    return _objectSpread2$1(_objectSpread2$1({
      key: "__RC_SELECT_GRP__".concat(X === null ? K : String(X), "__")
    }, ee), {}, {
      label: re,
      options: convertChildrenToData(te || [])
    });
  }).filter(function(U) {
    return U;
  });
  return G;
}
function useOptions(H, C, G) {
  var U = shallowRef(), K = shallowRef(), W = shallowRef(), Z = shallowRef([]);
  return watch([H, C], function() {
    H.value ? Z.value = toRaw(H.value).slice() : Z.value = convertChildrenToData(C.value);
  }, {
    immediate: !0,
    deep: !0
  }), watchEffect(function() {
    var X = Z.value, Q = /* @__PURE__ */ new Map(), ee = /* @__PURE__ */ new Map(), te = G.value;
    function re(ne) {
      for (var ae = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, ie = 0; ie < ne.length; ie += 1) {
        var se = ne[ie];
        !se[te.options] || ae ? (Q.set(se[te.value], se), ee.set(se[te.label], se)) : re(se[te.options], !0);
      }
    }
    re(X), U.value = X, K.value = Q, W.value = ee;
  }), {
    options: U,
    valueOptions: K,
    labelOptions: W
  };
}
var uuid = 0, isBrowserClient = process.env.NODE_ENV !== "test" && canUseDom();
function getUUID() {
  var H;
  return isBrowserClient ? (H = uuid, uuid += 1) : H = "TEST_OR_SSR", H;
}
function useId() {
  var H = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ref(""), C = "rc_select_".concat(getUUID());
  return H.value || C;
}
function toArray$1(H) {
  return Array.isArray(H) ? H : H !== void 0 ? [H] : [];
}
var isClient = typeof window < "u" && window.document && window.document.documentElement;
process.env.NODE_ENV;
function warningProps(H) {
  var C = H.mode, G = H.options, U = H.children, K = H.backfill, W = H.allowClear, Z = H.placeholder, X = H.getInputElement, Q = H.showSearch, ee = H.onSearch, te = H.defaultOpen, re = H.autofocus, ne = H.labelInValue, ae = H.value, ie = H.inputValue, se = H.optionLabelProp, oe = isMultiple$1(C), le = Q !== void 0 ? Q : oe || C === "combobox", ue = G || convertChildrenToData(U);
  if (warningOnce(C !== "tags" || ue.every(function(ge) {
    return !ge.disabled;
  }), "Please avoid setting option to disabled in tags mode since user can always type text as tag."), warningOnce(C !== "combobox" || !se, "`combobox` mode not support `optionLabelProp`. Please set `value` on Option directly."), warningOnce(C === "combobox" || !K, "`backfill` only works with `combobox` mode."), warningOnce(C === "combobox" || !X, "`getInputElement` only work with `combobox` mode."), noteOnce(C !== "combobox" || !X || !W || !Z, "Customize `getInputElement` should customize clear and placeholder logic instead of configuring `allowClear` and `placeholder`."), ee && !le && C !== "combobox" && C !== "tags" && warningOnce(!1, "`onSearch` should work with `showSearch` instead of use alone."), noteOnce(!te || re, "`defaultOpen` makes Select open without focus which means it will not close by click outside. You can set `autofocus` if needed."), ae != null) {
    var ce = toArray$1(ae);
    warningOnce(!ne || ce.every(function(ge) {
      return _typeof$2(ge) === "object" && ("key" in ge || "value" in ge);
    }), "`value` should in shape of `{ value: string | number, label?: any }` when you set `labelInValue` to `true`"), warningOnce(!oe || Array.isArray(ae), "`value` should be array when `mode` is `multiple` or `tags`");
  }
  if (U) {
    var de = null;
    U.some(function(ge) {
      if (!isValidElement(ge) || !ge.type)
        return !1;
      var fe = ge.type;
      if (fe.isSelectOption)
        return !1;
      if (fe.isSelectOptGroup) {
        var ve, pe = ((ve = ge.children) === null || ve === void 0 ? void 0 : ve.default()) || [], he = pe.every(function(me) {
          return !isValidElement(me) || !ge.type || me.type.isSelectOption ? !0 : (de = me.type, !1);
        });
        return !he;
      }
      return de = fe, !0;
    }), de && warningOnce(!1, "`children` should be `Select.Option` or `Select.OptGroup` instead of `".concat(de.displayName || de.name || de, "`.")), warningOnce(ie === void 0, "`inputValue` is deprecated, please use `searchValue` instead.");
  }
}
function includes(H, C) {
  return toArray$1(H).join("").toUpperCase().includes(C);
}
const useFilterOptions = function(H, C, G, U, K) {
  return computed(function() {
    var W = G.value, Z = K == null ? void 0 : K.value, X = U == null ? void 0 : U.value;
    if (!W || X === !1)
      return H.value;
    var Q = C.value, ee = Q.options, te = Q.label, re = Q.value, ne = [], ae = typeof X == "function", ie = W.toUpperCase(), se = ae ? X : function(le, ue) {
      return Z ? includes(ue[Z], ie) : ue[ee] ? includes(ue[te !== "children" ? te : "label"], ie) : includes(ue[re], ie);
    }, oe = ae ? function(le) {
      return injectPropsWithOption(le);
    } : function(le) {
      return le;
    };
    return H.value.forEach(function(le) {
      if (le[ee]) {
        var ue = se(W, oe(le));
        if (ue)
          ne.push(le);
        else {
          var ce = le[ee].filter(function(de) {
            return se(W, oe(de));
          });
          ce.length && ne.push(_objectSpread2$1(_objectSpread2$1({}, le), {}, _defineProperty$A({}, ee, ce)));
        }
        return;
      }
      se(W, oe(le)) && ne.push(le);
    }), ne;
  });
}, useCache = function(H, C) {
  var G = shallowRef({
    values: /* @__PURE__ */ new Map(),
    options: /* @__PURE__ */ new Map()
  }), U = computed(function() {
    var W = G.value, Z = W.values, X = W.options, Q = H.value.map(function(re) {
      if (re.label === void 0) {
        var ne;
        return _objectSpread2$1(_objectSpread2$1({}, re), {}, {
          label: (ne = Z.get(re.value)) === null || ne === void 0 ? void 0 : ne.label
        });
      }
      return re;
    }), ee = /* @__PURE__ */ new Map(), te = /* @__PURE__ */ new Map();
    return Q.forEach(function(re) {
      ee.set(re.value, re), te.set(re.value, C.value.get(re.value) || X.get(re.value));
    }), G.value.values = ee, G.value.options = te, Q;
  }), K = function(Z) {
    return C.value.get(Z) || G.value.options.get(Z);
  };
  return [U, K];
};
function useMergedState(H, C) {
  var G = C || {}, U = G.defaultValue, K = G.value, W = K === void 0 ? ref() : K, Z = typeof H == "function" ? H() : H;
  W.value !== void 0 && (Z = unref(W)), U !== void 0 && (Z = typeof U == "function" ? U() : U);
  var X = ref(Z), Q = ref(Z);
  watchEffect(function() {
    var te = W.value !== void 0 ? W.value : X.value;
    C.postState && (te = C.postState(te)), Q.value = te;
  });
  function ee(te) {
    var re = Q.value;
    X.value = te, toRaw(Q.value) !== te && C.onChange && C.onChange(te, re);
  }
  return watch(W, function() {
    X.value = W.value;
  }), [Q, ee];
}
function useState(H) {
  var C = typeof H == "function" ? H() : H, G = ref(C);
  function U(K) {
    G.value = K;
  }
  return [G, U];
}
var OMIT_DOM_PROPS = ["inputValue"];
function selectProps$1() {
  return _objectSpread2$1(_objectSpread2$1({}, baseSelectPropsWithoutPrivate()), {}, {
    prefixCls: String,
    id: String,
    backfill: {
      type: Boolean,
      default: void 0
    },
    // >>> Field Names
    fieldNames: Object,
    // >>> Search
    /** @deprecated Use `searchValue` instead */
    inputValue: String,
    searchValue: String,
    onSearch: Function,
    autoClearSearchValue: {
      type: Boolean,
      default: void 0
    },
    // >>> Select
    onSelect: Function,
    onDeselect: Function,
    // >>> Options
    /**
     * In Select, `false` means do nothing.
     * In TreeSelect, `false` will highlight match item.
     * It's by design.
     */
    filterOption: {
      type: [Boolean, Function],
      default: void 0
    },
    filterSort: Function,
    optionFilterProp: String,
    optionLabelProp: String,
    options: Array,
    defaultActiveFirstOption: {
      type: Boolean,
      default: void 0
    },
    virtual: {
      type: Boolean,
      default: void 0
    },
    listHeight: Number,
    listItemHeight: Number,
    // >>> Icon
    menuItemSelectedIcon: PropTypes$1.any,
    mode: String,
    labelInValue: {
      type: Boolean,
      default: void 0
    },
    value: PropTypes$1.any,
    defaultValue: PropTypes$1.any,
    onChange: Function,
    children: Array
  });
}
function isRawValue(H) {
  return !H || _typeof$2(H) !== "object";
}
const Select$1 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Select",
  inheritAttrs: !1,
  props: initDefaultProps$1(selectProps$1(), {
    prefixCls: "vc-select",
    autoClearSearchValue: !0,
    listHeight: 200,
    listItemHeight: 20,
    dropdownMatchSelectWidth: !0
  }),
  setup: function(C, G) {
    var U = G.expose, K = G.attrs, W = G.slots, Z = useId(toRef(C, "id")), X = computed(function() {
      return isMultiple$1(C.mode);
    }), Q = computed(function() {
      return !!(!C.options && C.children);
    }), ee = computed(function() {
      return C.filterOption === void 0 && C.mode === "combobox" ? !1 : C.filterOption;
    }), te = computed(function() {
      return fillFieldNames$1(C.fieldNames, Q.value);
    }), re = useMergedState("", {
      value: computed(function() {
        return C.searchValue !== void 0 ? C.searchValue : C.inputValue;
      }),
      postState: function(Ze) {
        return Ze || "";
      }
    }), ne = _slicedToArray$2(re, 2), ae = ne[0], ie = ne[1], se = useOptions(toRef(C, "options"), toRef(C, "children"), te), oe = se.valueOptions, le = se.labelOptions, ue = se.options, ce = function(Ze) {
      var Xe = toArray$1(Ze);
      return Xe.map(function(qe) {
        var dt, gt, yt, At;
        if (isRawValue(qe))
          dt = qe;
        else {
          var nt;
          yt = qe.key, gt = qe.label, dt = (nt = qe.value) !== null && nt !== void 0 ? nt : yt;
        }
        var Ke = oe.value.get(dt);
        if (Ke) {
          var Qe;
          gt === void 0 && (gt = Ke == null ? void 0 : Ke[C.optionLabelProp || te.value.label]), yt === void 0 && (yt = (Qe = Ke == null ? void 0 : Ke.key) !== null && Qe !== void 0 ? Qe : dt), At = Ke == null ? void 0 : Ke.disabled;
        }
        return {
          label: gt,
          value: dt,
          key: yt,
          disabled: At,
          option: Ke
        };
      });
    }, de = useMergedState(C.defaultValue, {
      value: toRef(C, "value")
    }), ge = _slicedToArray$2(de, 2), fe = ge[0], ve = ge[1], pe = computed(function() {
      var at, Ze = ce(fe.value);
      return C.mode === "combobox" && !((at = Ze[0]) !== null && at !== void 0 && at.value) ? [] : Ze;
    }), he = useCache(pe, oe), me = _slicedToArray$2(he, 2), ye = me[0], Ce = me[1], Ie = computed(function() {
      if (!C.mode && ye.value.length === 1) {
        var at = ye.value[0];
        if (at.value === null && (at.label === null || at.label === void 0))
          return [];
      }
      return ye.value.map(function(Ze) {
        var Xe;
        return _objectSpread2$1(_objectSpread2$1({}, Ze), {}, {
          label: (Xe = typeof Ze.label == "function" ? Ze.label() : Ze.label) !== null && Xe !== void 0 ? Xe : Ze.value
        });
      });
    }), be = computed(function() {
      return new Set(ye.value.map(function(at) {
        return at.value;
      }));
    });
    watchEffect(function() {
      if (C.mode === "combobox") {
        var at, Ze = (at = ye.value[0]) === null || at === void 0 ? void 0 : at.value;
        Ze != null && ie(String(Ze));
      }
    }, {
      flush: "post"
    });
    var Se = function(Ze, Xe) {
      var qe, dt = Xe ?? Ze;
      return qe = {}, _defineProperty$A(qe, te.value.value, Ze), _defineProperty$A(qe, te.value.label, dt), qe;
    }, Ae = shallowRef();
    watchEffect(function() {
      if (C.mode !== "tags") {
        Ae.value = ue.value;
        return;
      }
      var at = ue.value.slice(), Ze = function(qe) {
        return oe.value.has(qe);
      };
      _toConsumableArray(ye.value).sort(function(Xe, qe) {
        return Xe.value < qe.value ? -1 : 1;
      }).forEach(function(Xe) {
        var qe = Xe.value;
        Ze(qe) || at.push(Se(qe, Xe.label));
      }), Ae.value = at;
    });
    var _e = useFilterOptions(Ae, te, ae, ee, toRef(C, "optionFilterProp")), xe = computed(function() {
      return C.mode !== "tags" || !ae.value || _e.value.some(function(at) {
        return at[C.optionFilterProp || "value"] === ae.value;
      }) ? _e.value : [Se(ae.value)].concat(_toConsumableArray(_e.value));
    }), Te = computed(function() {
      return C.filterSort ? _toConsumableArray(xe.value).sort(function(at, Ze) {
        return C.filterSort(at, Ze);
      }) : xe.value;
    }), Pe = computed(function() {
      return flattenOptions(Te.value, {
        fieldNames: te.value,
        childrenAsData: Q.value
      });
    }), $e = function(Ze) {
      var Xe = ce(Ze);
      if (ve(Xe), C.onChange && // Trigger event only when value changed
      (Xe.length !== ye.value.length || Xe.some(function(gt, yt) {
        var At;
        return ((At = ye.value[yt]) === null || At === void 0 ? void 0 : At.value) !== (gt == null ? void 0 : gt.value);
      }))) {
        var qe = C.labelInValue ? Xe.map(function(gt) {
          return _objectSpread2$1(_objectSpread2$1({}, gt), {}, {
            originLabel: gt.label,
            label: typeof gt.label == "function" ? gt.label() : gt.label
          });
        }) : Xe.map(function(gt) {
          return gt.value;
        }), dt = Xe.map(function(gt) {
          return injectPropsWithOption(Ce(gt.value));
        });
        C.onChange(
          // Value
          X.value ? qe : qe[0],
          // Option
          X.value ? dt : dt[0]
        );
      }
    }, Me = useState(null), Ee = _slicedToArray$2(Me, 2), we = Ee[0], Oe = Ee[1], Ne = useState(0), ke = _slicedToArray$2(Ne, 2), ze = ke[0], He = ke[1], We = computed(function() {
      return C.defaultActiveFirstOption !== void 0 ? C.defaultActiveFirstOption : C.mode !== "combobox";
    }), Re = function(Ze, Xe) {
      var qe = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, dt = qe.source, gt = dt === void 0 ? "keyboard" : dt;
      He(Xe), C.backfill && C.mode === "combobox" && Ze !== null && gt === "keyboard" && Oe(String(Ze));
    }, Le = function(Ze, Xe) {
      var qe = function() {
        var Fe, Be = Ce(Ze), je = Be == null ? void 0 : Be[te.value.label];
        return [C.labelInValue ? {
          label: typeof je == "function" ? je() : je,
          originLabel: je,
          value: Ze,
          key: (Fe = Be == null ? void 0 : Be.key) !== null && Fe !== void 0 ? Fe : Ze
        } : Ze, injectPropsWithOption(Be)];
      };
      if (Xe && C.onSelect) {
        var dt = qe(), gt = _slicedToArray$2(dt, 2), yt = gt[0], At = gt[1];
        C.onSelect(yt, At);
      } else if (!Xe && C.onDeselect) {
        var nt = qe(), Ke = _slicedToArray$2(nt, 2), Qe = Ke[0], pt = Ke[1];
        C.onDeselect(Qe, pt);
      }
    }, De = function(Ze, Xe) {
      var qe, dt = X.value ? Xe.selected : !0;
      dt ? qe = X.value ? [].concat(_toConsumableArray(ye.value), [Ze]) : [Ze] : qe = ye.value.filter(function(gt) {
        return gt.value !== Ze;
      }), $e(qe), Le(Ze, dt), C.mode === "combobox" ? Oe("") : (!X.value || C.autoClearSearchValue) && (ie(""), Oe(""));
    }, Ue = function(Ze, Xe) {
      $e(Ze), (Xe.type === "remove" || Xe.type === "clear") && Xe.values.forEach(function(qe) {
        Le(qe.value, !1);
      });
    }, st = function(Ze, Xe) {
      if (ie(Ze), Oe(null), Xe.source === "submit") {
        var qe = (Ze || "").trim();
        if (qe) {
          var dt = Array.from(new Set([].concat(_toConsumableArray(be.value), [qe])));
          $e(dt), Le(qe, !0), ie("");
        }
        return;
      }
      if (Xe.source !== "blur") {
        var gt;
        C.mode === "combobox" && $e(Ze), (gt = C.onSearch) === null || gt === void 0 || gt.call(C, Ze);
      }
    }, ot = function(Ze) {
      var Xe = Ze;
      C.mode !== "tags" && (Xe = Ze.map(function(dt) {
        var gt = le.value.get(dt);
        return gt == null ? void 0 : gt.value;
      }).filter(function(dt) {
        return dt !== void 0;
      }));
      var qe = Array.from(new Set([].concat(_toConsumableArray(be.value), _toConsumableArray(Xe))));
      $e(qe), qe.forEach(function(dt) {
        Le(dt, !0);
      });
    }, ct = computed(function() {
      return C.virtual !== !1 && C.dropdownMatchSelectWidth !== !1;
    });
    useProvideSelectProps(toReactive(_objectSpread2$1(_objectSpread2$1({}, se), {}, {
      flattenOptions: Pe,
      onActiveValue: Re,
      defaultActiveFirstOption: We,
      onSelect: De,
      menuItemSelectedIcon: toRef(C, "menuItemSelectedIcon"),
      rawValues: be,
      fieldNames: te,
      virtual: ct,
      listHeight: toRef(C, "listHeight"),
      listItemHeight: toRef(C, "listItemHeight"),
      childrenAsData: Q
    }))), process.env.NODE_ENV !== "production" && watchEffect(function() {
      warningProps(C);
    }, {
      flush: "post"
    });
    var vt = ref();
    U({
      focus: function() {
        var Ze;
        (Ze = vt.value) === null || Ze === void 0 || Ze.focus();
      },
      blur: function() {
        var Ze;
        (Ze = vt.value) === null || Ze === void 0 || Ze.blur();
      },
      scrollTo: function(Ze) {
        var Xe;
        (Xe = vt.value) === null || Xe === void 0 || Xe.scrollTo(Ze);
      }
    });
    var ut = computed(function() {
      return omit(C, [
        "id",
        "mode",
        "prefixCls",
        "backfill",
        "fieldNames",
        // Search
        "inputValue",
        "searchValue",
        "onSearch",
        "autoClearSearchValue",
        // Select
        "onSelect",
        "onDeselect",
        "dropdownMatchSelectWidth",
        // Options
        "filterOption",
        "filterSort",
        "optionFilterProp",
        "optionLabelProp",
        "options",
        "children",
        "defaultActiveFirstOption",
        "menuItemSelectedIcon",
        "virtual",
        "listHeight",
        "listItemHeight",
        // Value
        "value",
        "defaultValue",
        "labelInValue",
        "onChange"
      ]);
    });
    return function() {
      return createVNode$1(BaseSelect, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, ut.value), K), {}, {
        id: Z,
        prefixCls: C.prefixCls,
        ref: vt,
        omitDomProps: OMIT_DOM_PROPS,
        mode: C.mode,
        displayValues: Ie.value,
        onDisplayValuesChange: Ue,
        searchValue: ae.value,
        onSearch: st,
        onSearchSplit: ot,
        dropdownMatchSelectWidth: C.dropdownMatchSelectWidth,
        OptionList: OptionList$1,
        emptyOptions: !Pe.value.length,
        activeValue: we.value,
        activeDescendantId: "".concat(Z, "_list_").concat(ze.value)
      }), W);
    };
  }
});
var Option = function() {
  return null;
};
Option.isSelectOption = !0;
Option.displayName = "ASelectOption";
const Option$1 = Option;
var OptGroup = function() {
  return null;
};
OptGroup.isSelectOptGroup = !0;
OptGroup.displayName = "ASelectOptGroup";
const OptGroup$1 = OptGroup;
var DownOutlined$2 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M884 256h-75c-5.1 0-9.9 2.5-12.9 6.6L512 654.2 227.9 262.6c-3-4.1-7.8-6.6-12.9-6.6h-75c-6.5 0-10.3 7.4-6.5 12.7l352.6 486.1c12.8 17.6 39 17.6 51.7 0l352.6-486.1c3.9-5.3.1-12.7-6.4-12.7z" } }] }, name: "down", theme: "outlined" };
const DownOutlinedSvg = DownOutlined$2;
function _objectSpread$l(H) {
  for (var C = 1; C < arguments.length; C++) {
    var G = arguments[C] != null ? Object(arguments[C]) : {}, U = Object.keys(G);
    typeof Object.getOwnPropertySymbols == "function" && (U = U.concat(Object.getOwnPropertySymbols(G).filter(function(K) {
      return Object.getOwnPropertyDescriptor(G, K).enumerable;
    }))), U.forEach(function(K) {
      _defineProperty$l(H, K, G[K]);
    });
  }
  return H;
}
function _defineProperty$l(H, C, G) {
  return C in H ? Object.defineProperty(H, C, { value: G, enumerable: !0, configurable: !0, writable: !0 }) : H[C] = G, H;
}
var DownOutlined = function(C, G) {
  var U = _objectSpread$l({}, C, G.attrs);
  return createVNode$1(AntdIcon, _objectSpread$l({}, U, {
    icon: DownOutlinedSvg
  }), null);
};
DownOutlined.displayName = "DownOutlined";
DownOutlined.inheritAttrs = !1;
const DownOutlined$1 = DownOutlined;
var CheckOutlined$2 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M912 190h-69.9c-9.8 0-19.1 4.5-25.1 12.2L404.7 724.5 207 474a32 32 0 00-25.1-12.2H112c-6.7 0-10.4 7.7-6.3 12.9l273.9 347c12.8 16.2 37.4 16.2 50.3 0l488.4-618.9c4.1-5.1.4-12.8-6.3-12.8z" } }] }, name: "check", theme: "outlined" };
const CheckOutlinedSvg = CheckOutlined$2;
function _objectSpread$k(H) {
  for (var C = 1; C < arguments.length; C++) {
    var G = arguments[C] != null ? Object(arguments[C]) : {}, U = Object.keys(G);
    typeof Object.getOwnPropertySymbols == "function" && (U = U.concat(Object.getOwnPropertySymbols(G).filter(function(K) {
      return Object.getOwnPropertyDescriptor(G, K).enumerable;
    }))), U.forEach(function(K) {
      _defineProperty$k(H, K, G[K]);
    });
  }
  return H;
}
function _defineProperty$k(H, C, G) {
  return C in H ? Object.defineProperty(H, C, { value: G, enumerable: !0, configurable: !0, writable: !0 }) : H[C] = G, H;
}
var CheckOutlined = function(C, G) {
  var U = _objectSpread$k({}, C, G.attrs);
  return createVNode$1(AntdIcon, _objectSpread$k({}, U, {
    icon: CheckOutlinedSvg
  }), null);
};
CheckOutlined.displayName = "CheckOutlined";
CheckOutlined.inheritAttrs = !1;
const CheckOutlined$1 = CheckOutlined;
var SearchOutlined$2 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M909.6 854.5L649.9 594.8C690.2 542.7 712 479 712 412c0-80.2-31.3-155.4-87.9-212.1-56.6-56.7-132-87.9-212.1-87.9s-155.5 31.3-212.1 87.9C143.2 256.5 112 331.8 112 412c0 80.1 31.3 155.5 87.9 212.1C256.5 680.8 331.8 712 412 712c67 0 130.6-21.8 182.7-62l259.7 259.6a8.2 8.2 0 0011.6 0l43.6-43.5a8.2 8.2 0 000-11.6zM570.4 570.4C528 612.7 471.8 636 412 636s-116-23.3-158.4-65.6C211.3 528 188 471.8 188 412s23.3-116.1 65.6-158.4C296 211.3 352.2 188 412 188s116.1 23.2 158.4 65.6S636 352.2 636 412s-23.3 116.1-65.6 158.4z" } }] }, name: "search", theme: "outlined" };
const SearchOutlinedSvg = SearchOutlined$2;
function _objectSpread$j(H) {
  for (var C = 1; C < arguments.length; C++) {
    var G = arguments[C] != null ? Object(arguments[C]) : {}, U = Object.keys(G);
    typeof Object.getOwnPropertySymbols == "function" && (U = U.concat(Object.getOwnPropertySymbols(G).filter(function(K) {
      return Object.getOwnPropertyDescriptor(G, K).enumerable;
    }))), U.forEach(function(K) {
      _defineProperty$j(H, K, G[K]);
    });
  }
  return H;
}
function _defineProperty$j(H, C, G) {
  return C in H ? Object.defineProperty(H, C, { value: G, enumerable: !0, configurable: !0, writable: !0 }) : H[C] = G, H;
}
var SearchOutlined = function(C, G) {
  var U = _objectSpread$j({}, C, G.attrs);
  return createVNode$1(AntdIcon, _objectSpread$j({}, U, {
    icon: SearchOutlinedSvg
  }), null);
};
SearchOutlined.displayName = "SearchOutlined";
SearchOutlined.inheritAttrs = !1;
const SearchOutlined$1 = SearchOutlined;
function getIcons(H) {
  var C = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, G = H.loading, U = H.multiple, K = H.prefixCls, W = H.suffixIcon || C.suffixIcon && C.suffixIcon(), Z = H.clearIcon || C.clearIcon && C.clearIcon(), X = H.menuItemSelectedIcon || C.menuItemSelectedIcon && C.menuItemSelectedIcon(), Q = H.removeIcon || C.removeIcon && C.removeIcon(), ee = Z;
  Z || (ee = createVNode$1(CloseCircleFilled$1, null, null));
  var te = null;
  if (W !== void 0)
    te = W;
  else if (G)
    te = createVNode$1(LoadingOutlined$1, {
      spin: !0
    }, null);
  else {
    var re = "".concat(K, "-suffix");
    te = function(se) {
      var oe = se.open, le = se.showSearch;
      return oe && le ? createVNode$1(SearchOutlined$1, {
        class: re
      }, null) : createVNode$1(DownOutlined$1, {
        class: re
      }, null);
    };
  }
  var ne = null;
  X !== void 0 ? ne = X : U ? ne = createVNode$1(CheckOutlined$1, null, null) : ne = null;
  var ae = null;
  return Q !== void 0 ? ae = Q : ae = createVNode$1(CloseOutlined$1, null, null), {
    clearIcon: ee,
    suffixIcon: te,
    itemIcon: ne,
    removeIcon: ae
  };
}
var ContextKey$1 = Symbol("ContextProps"), InternalContextKey = Symbol("InternalContextProps"), defaultContext = {
  id: computed(function() {
  }),
  onFieldBlur: function() {
  },
  onFieldChange: function() {
  },
  clearValidate: function() {
  }
}, defaultInternalContext = {
  addFormItemField: function() {
  },
  removeFormItemField: function() {
  }
}, useInjectFormItemContext = function() {
  var C = inject(InternalContextKey, defaultInternalContext), G = Symbol("FormItemFieldKey"), U = getCurrentInstance();
  return C.addFormItemField(G, U.type), onBeforeUnmount(function() {
    C.removeFormItemField(G);
  }), provide(InternalContextKey, defaultInternalContext), provide(ContextKey$1, defaultContext), inject(ContextKey$1, defaultContext);
};
defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AFormItemRest",
  setup: function(C, G) {
    var U = G.slots;
    return provide(InternalContextKey, defaultInternalContext), provide(ContextKey$1, defaultContext), function() {
      var K;
      return (K = U.default) === null || K === void 0 ? void 0 : K.call(U);
    };
  }
});
var selectProps = function() {
  return _objectSpread2$1(_objectSpread2$1({}, omit(selectProps$1(), ["inputIcon", "mode", "getInputElement", "getRawInputElement", "backfill"])), {}, {
    value: {
      type: [Array, Object, String, Number]
    },
    defaultValue: {
      type: [Array, Object, String, Number]
    },
    notFoundContent: PropTypes$1.any,
    suffixIcon: PropTypes$1.any,
    itemIcon: PropTypes$1.any,
    size: String,
    mode: String,
    bordered: {
      type: Boolean,
      default: !0
    },
    transitionName: String,
    choiceTransitionName: {
      type: String,
      default: ""
    },
    "onUpdate:value": Function
  });
}, SECRET_COMBOBOX_MODE_DO_NOT_USE = "SECRET_COMBOBOX_MODE_DO_NOT_USE", Select = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ASelect",
  Option: Option$1,
  OptGroup: OptGroup$1,
  inheritAttrs: !1,
  props: initDefaultProps$1(selectProps(), {
    listHeight: 256,
    listItemHeight: 24
  }),
  SECRET_COMBOBOX_MODE_DO_NOT_USE,
  // emits: ['change', 'update:value', 'blur'],
  slots: [
    "notFoundContent",
    "suffixIcon",
    "itemIcon",
    "removeIcon",
    "clearIcon",
    "dropdownRender",
    "option",
    "placeholder",
    "tagRender",
    "maxTagPlaceholder",
    "optionLabel"
    // donot use, maybe remove it
  ],
  setup: function(C, G) {
    var U = G.attrs, K = G.emit, W = G.slots, Z = G.expose, X = ref(), Q = useInjectFormItemContext(), ee = function() {
      var me;
      (me = X.value) === null || me === void 0 || me.focus();
    }, te = function() {
      var me;
      (me = X.value) === null || me === void 0 || me.blur();
    }, re = function(me) {
      var ye;
      (ye = X.value) === null || ye === void 0 || ye.scrollTo(me);
    }, ne = computed(function() {
      var he = C.mode;
      if (he !== "combobox")
        return he === SECRET_COMBOBOX_MODE_DO_NOT_USE ? "combobox" : he;
    }), ae = useConfigInject("select", C), ie = ae.prefixCls, se = ae.direction, oe = ae.configProvider, le = ae.size, ue = ae.getPrefixCls, ce = computed(function() {
      return ue();
    }), de = computed(function() {
      return getTransitionName$1(ce.value, "slide-up", C.transitionName);
    }), ge = computed(function() {
      var he;
      return classNames((he = {}, _defineProperty$A(he, "".concat(ie.value, "-lg"), le.value === "large"), _defineProperty$A(he, "".concat(ie.value, "-sm"), le.value === "small"), _defineProperty$A(he, "".concat(ie.value, "-rtl"), se.value === "rtl"), _defineProperty$A(he, "".concat(ie.value, "-borderless"), !C.bordered), he));
    }), fe = function() {
      for (var me = arguments.length, ye = new Array(me), Ce = 0; Ce < me; Ce++)
        ye[Ce] = arguments[Ce];
      K("update:value", ye[0]), K.apply(void 0, ["change"].concat(ye)), Q.onFieldChange();
    }, ve = function(me) {
      K("blur", me), Q.onFieldBlur();
    };
    Z({
      blur: te,
      focus: ee,
      scrollTo: re
    });
    var pe = computed(function() {
      return ne.value === "multiple" || ne.value === "tags";
    });
    return function() {
      var he, me, ye = C.notFoundContent, Ce = C.listHeight, Ie = Ce === void 0 ? 256 : Ce, be = C.listItemHeight, Se = be === void 0 ? 24 : be, Ae = C.getPopupContainer, _e = C.dropdownClassName, xe = C.virtual, Te = C.dropdownMatchSelectWidth, Pe = C.id, $e = Pe === void 0 ? Q.id.value : Pe, Me = C.placeholder, Ee = Me === void 0 ? (he = W.placeholder) === null || he === void 0 ? void 0 : he.call(W) : Me, we = oe.renderEmpty, Oe = oe.getPopupContainer, Ne;
      ye !== void 0 ? Ne = ye : W.notFoundContent ? Ne = W.notFoundContent() : ne.value === "combobox" ? Ne = null : Ne = we("Select");
      var ke = getIcons(_objectSpread2$1(_objectSpread2$1({}, C), {}, {
        multiple: pe.value,
        prefixCls: ie.value
      }), W), ze = ke.suffixIcon, He = ke.itemIcon, We = ke.removeIcon, Re = ke.clearIcon, Le = omit(C, ["prefixCls", "suffixIcon", "itemIcon", "removeIcon", "clearIcon", "size", "bordered"]), De = classNames(_e, _defineProperty$A({}, "".concat(ie.value, "-dropdown-").concat(se.value), se.value === "rtl"));
      return createVNode$1(Select$1, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
        ref: X,
        virtual: xe,
        dropdownMatchSelectWidth: Te
      }, Le), U), {}, {
        placeholder: Ee,
        listHeight: Ie,
        listItemHeight: Se,
        mode: ne.value,
        prefixCls: ie.value,
        direction: se.value,
        inputIcon: ze,
        menuItemSelectedIcon: He,
        removeIcon: We,
        clearIcon: Re,
        notFoundContent: Ne,
        class: [ge.value, U.class],
        getPopupContainer: Ae || Oe,
        dropdownClassName: De,
        onChange: fe,
        onBlur: ve,
        id: $e,
        dropdownRender: Le.dropdownRender || W.dropdownRender,
        transitionName: de.value,
        children: (me = W.default) === null || me === void 0 ? void 0 : me.call(W),
        tagRender: C.tagRender || W.tagRender,
        optionLabelRender: W.optionLabel,
        maxTagPlaceholder: C.maxTagPlaceholder || W.maxTagPlaceholder
      }), {
        option: W.option
      });
    };
  }
});
Select.install = function(H) {
  return H.component(Select.name, Select), H.component(Select.Option.displayName, Select.Option), H.component(Select.OptGroup.displayName, Select.OptGroup), H;
};
Select.Option;
Select.OptGroup;
const VcSelect = Select;
var responsiveMap = {
  xs: "(max-width: 575px)",
  sm: "(min-width: 576px)",
  md: "(min-width: 768px)",
  lg: "(min-width: 992px)",
  xl: "(min-width: 1200px)",
  xxl: "(min-width: 1600px)",
  xxxl: "(min-width: 2000px)"
}, subscribers = /* @__PURE__ */ new Map(), subUid = -1, screens = {}, responsiveObserve = {
  matchHandlers: {},
  dispatch: function(C) {
    return screens = C, subscribers.forEach(function(G) {
      return G(screens);
    }), subscribers.size >= 1;
  },
  subscribe: function(C) {
    return subscribers.size || this.register(), subUid += 1, subscribers.set(subUid, C), C(screens), subUid;
  },
  unsubscribe: function(C) {
    subscribers.delete(C), subscribers.size || this.unregister();
  },
  unregister: function() {
    var C = this;
    Object.keys(responsiveMap).forEach(function(G) {
      var U = responsiveMap[G], K = C.matchHandlers[U];
      K == null || K.mql.removeListener(K == null ? void 0 : K.listener);
    }), subscribers.clear();
  },
  register: function() {
    var C = this;
    Object.keys(responsiveMap).forEach(function(G) {
      var U = responsiveMap[G], K = function(X) {
        var Q = X.matches;
        C.dispatch(_objectSpread2$1(_objectSpread2$1({}, screens), {}, _defineProperty$A({}, G, Q)));
      }, W = window.matchMedia(U);
      W.addListener(K), C.matchHandlers[U] = {
        mql: W,
        listener: K
      }, K(W);
    });
  }
};
const ResponsiveObserve = responsiveObserve;
function useBreakpoint() {
  var H = ref({}), C = null;
  return onMounted(function() {
    C = ResponsiveObserve.subscribe(function(G) {
      H.value = G;
    });
  }), onUnmounted(function() {
    ResponsiveObserve.unsubscribe(C);
  }), H;
}
function eagerComputed(H) {
  var C = shallowRef();
  return watchEffect(function() {
    C.value = H();
  }, {
    flush: "sync"
    // needed so updates are immediate.
  }), C;
}
var autoAdjustOverflow$2 = {
  adjustX: 1,
  adjustY: 1
}, targetOffset$2 = [0, 0], placements$3 = {
  left: {
    points: ["cr", "cl"],
    overflow: autoAdjustOverflow$2,
    offset: [-4, 0],
    targetOffset: targetOffset$2
  },
  right: {
    points: ["cl", "cr"],
    overflow: autoAdjustOverflow$2,
    offset: [4, 0],
    targetOffset: targetOffset$2
  },
  top: {
    points: ["bc", "tc"],
    overflow: autoAdjustOverflow$2,
    offset: [0, -4],
    targetOffset: targetOffset$2
  },
  bottom: {
    points: ["tc", "bc"],
    overflow: autoAdjustOverflow$2,
    offset: [0, 4],
    targetOffset: targetOffset$2
  },
  topLeft: {
    points: ["bl", "tl"],
    overflow: autoAdjustOverflow$2,
    offset: [0, -4],
    targetOffset: targetOffset$2
  },
  leftTop: {
    points: ["tr", "tl"],
    overflow: autoAdjustOverflow$2,
    offset: [-4, 0],
    targetOffset: targetOffset$2
  },
  topRight: {
    points: ["br", "tr"],
    overflow: autoAdjustOverflow$2,
    offset: [0, -4],
    targetOffset: targetOffset$2
  },
  rightTop: {
    points: ["tl", "tr"],
    overflow: autoAdjustOverflow$2,
    offset: [4, 0],
    targetOffset: targetOffset$2
  },
  bottomRight: {
    points: ["tr", "br"],
    overflow: autoAdjustOverflow$2,
    offset: [0, 4],
    targetOffset: targetOffset$2
  },
  rightBottom: {
    points: ["bl", "br"],
    overflow: autoAdjustOverflow$2,
    offset: [4, 0],
    targetOffset: targetOffset$2
  },
  bottomLeft: {
    points: ["tl", "bl"],
    overflow: autoAdjustOverflow$2,
    offset: [0, 4],
    targetOffset: targetOffset$2
  },
  leftBottom: {
    points: ["br", "bl"],
    overflow: autoAdjustOverflow$2,
    offset: [-4, 0],
    targetOffset: targetOffset$2
  }
}, tooltipContentProps = {
  prefixCls: String,
  id: String,
  overlayInnerStyle: PropTypes$1.any
};
const Content = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Content",
  props: tooltipContentProps,
  slots: ["overlay"],
  setup: function(C, G) {
    var U = G.slots;
    return function() {
      var K;
      return createVNode$1("div", {
        class: "".concat(C.prefixCls, "-inner"),
        id: C.id,
        role: "tooltip",
        style: C.overlayInnerStyle
      }, [(K = U.overlay) === null || K === void 0 ? void 0 : K.call(U)]);
    };
  }
});
var _excluded$j = ["overlayClassName", "trigger", "mouseEnterDelay", "mouseLeaveDelay", "overlayStyle", "prefixCls", "afterVisibleChange", "transitionName", "animation", "placement", "align", "destroyTooltipOnHide", "defaultVisible"];
function noop$3() {
}
const Tooltip$1 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Tooltip",
  inheritAttrs: !1,
  props: {
    trigger: PropTypes$1.any.def(["hover"]),
    defaultVisible: {
      type: Boolean,
      default: void 0
    },
    visible: {
      type: Boolean,
      default: void 0
    },
    placement: PropTypes$1.string.def("right"),
    transitionName: String,
    animation: PropTypes$1.any,
    afterVisibleChange: PropTypes$1.func.def(function() {
    }),
    overlayStyle: {
      type: Object,
      default: void 0
    },
    overlayClassName: String,
    prefixCls: PropTypes$1.string.def("rc-tooltip"),
    mouseEnterDelay: PropTypes$1.number.def(0.1),
    mouseLeaveDelay: PropTypes$1.number.def(0.1),
    getPopupContainer: Function,
    destroyTooltipOnHide: {
      type: Boolean,
      default: !1
    },
    align: PropTypes$1.object.def(function() {
      return {};
    }),
    arrowContent: PropTypes$1.any.def(null),
    tipId: String,
    builtinPlacements: PropTypes$1.object,
    overlayInnerStyle: {
      type: Object,
      default: void 0
    },
    popupVisible: {
      type: Boolean,
      default: void 0
    },
    onVisibleChange: Function,
    onPopupAlign: Function
  },
  slots: ["arrowContent", "overlay"],
  setup: function(C, G) {
    var U = G.slots, K = G.attrs, W = G.expose, Z = ref(), X = function() {
      var ne = C.prefixCls, ae = C.tipId, ie = C.overlayInnerStyle;
      return [createVNode$1("div", {
        class: "".concat(ne, "-arrow"),
        key: "arrow"
      }, [getPropsSlot(U, C, "arrowContent")]), createVNode$1(Content, {
        key: "content",
        prefixCls: ne,
        id: ae,
        overlayInnerStyle: ie
      }, {
        overlay: U.overlay
      })];
    }, Q = function() {
      return Z.value.getPopupDomNode();
    };
    W({
      getPopupDomNode: Q,
      triggerDOM: Z,
      forcePopupAlign: function() {
        var ne;
        return (ne = Z.value) === null || ne === void 0 ? void 0 : ne.forcePopupAlign();
      }
    });
    var ee = ref(!1), te = ref(!1);
    return watchEffect(function() {
      var re = C.destroyTooltipOnHide;
      if (typeof re == "boolean")
        ee.value = re;
      else if (re && _typeof$2(re) === "object") {
        var ne = re.keepParent;
        ee.value = ne === !0, te.value = ne === !1;
      }
    }), function() {
      var re = C.overlayClassName, ne = C.trigger, ae = C.mouseEnterDelay, ie = C.mouseLeaveDelay, se = C.overlayStyle, oe = C.prefixCls, le = C.afterVisibleChange, ue = C.transitionName, ce = C.animation, de = C.placement, ge = C.align;
      C.destroyTooltipOnHide;
      var fe = C.defaultVisible, ve = _objectWithoutProperties$2(C, _excluded$j), pe = _objectSpread2$1({}, ve);
      C.visible !== void 0 && (pe.popupVisible = C.visible);
      var he = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
        popupClassName: re,
        prefixCls: oe,
        action: ne,
        builtinPlacements: placements$3,
        popupPlacement: de,
        popupAlign: ge,
        afterPopupVisibleChange: le,
        popupTransitionName: ue,
        popupAnimation: ce,
        defaultPopupVisible: fe,
        destroyPopupOnHide: ee.value,
        autoDestroy: te.value,
        mouseLeaveDelay: ie,
        popupStyle: se,
        mouseEnterDelay: ae
      }, pe), K), {}, {
        onPopupVisibleChange: C.onVisibleChange || noop$3,
        onPopupAlign: C.onPopupAlign || noop$3,
        ref: Z,
        popup: X()
      });
      return createVNode$1(Trigger, he, {
        default: U.default
      });
    };
  }
});
tuple("success", "processing", "error", "default", "warning");
var PresetColorTypes = tuple("pink", "red", "yellow", "orange", "cyan", "green", "blue", "purple", "geekblue", "magenta", "volcano", "gold", "lime");
const abstractTooltipProps = function() {
  return {
    trigger: [String, Array],
    visible: {
      type: Boolean,
      default: void 0
    },
    defaultVisible: {
      type: Boolean,
      default: void 0
    },
    placement: String,
    color: String,
    transitionName: String,
    overlayStyle: {
      type: Object,
      default: void 0
    },
    overlayClassName: String,
    openClassName: String,
    prefixCls: String,
    mouseEnterDelay: Number,
    mouseLeaveDelay: Number,
    getPopupContainer: Function,
    arrowPointAtCenter: {
      type: Boolean,
      default: void 0
    },
    autoAdjustOverflow: {
      type: [Boolean, Object],
      default: void 0
    },
    destroyTooltipOnHide: {
      type: Boolean,
      default: void 0
    },
    align: {
      type: Object,
      default: void 0
    },
    builtinPlacements: {
      type: Object,
      default: void 0
    },
    children: Array,
    onVisibleChange: Function,
    "onUpdate:visible": Function
  };
};
var autoAdjustOverflowEnabled = {
  adjustX: 1,
  adjustY: 1
}, autoAdjustOverflowDisabled = {
  adjustX: 0,
  adjustY: 0
}, targetOffset$1 = [0, 0];
function getOverflowOptions(H) {
  return typeof H == "boolean" ? H ? autoAdjustOverflowEnabled : autoAdjustOverflowDisabled : _objectSpread2$1(_objectSpread2$1({}, autoAdjustOverflowDisabled), H);
}
function getPlacements(H) {
  var C = H.arrowWidth, G = C === void 0 ? 4 : C, U = H.horizontalArrowShift, K = U === void 0 ? 16 : U, W = H.verticalArrowShift, Z = W === void 0 ? 8 : W, X = H.autoAdjustOverflow, Q = H.arrowPointAtCenter, ee = {
    left: {
      points: ["cr", "cl"],
      offset: [-4, 0]
    },
    right: {
      points: ["cl", "cr"],
      offset: [4, 0]
    },
    top: {
      points: ["bc", "tc"],
      offset: [0, -4]
    },
    bottom: {
      points: ["tc", "bc"],
      offset: [0, 4]
    },
    topLeft: {
      points: ["bl", "tc"],
      offset: [-(K + G), -4]
    },
    leftTop: {
      points: ["tr", "cl"],
      offset: [-4, -(Z + G)]
    },
    topRight: {
      points: ["br", "tc"],
      offset: [K + G, -4]
    },
    rightTop: {
      points: ["tl", "cr"],
      offset: [4, -(Z + G)]
    },
    bottomRight: {
      points: ["tr", "bc"],
      offset: [K + G, 4]
    },
    rightBottom: {
      points: ["bl", "cr"],
      offset: [4, Z + G]
    },
    bottomLeft: {
      points: ["tl", "bc"],
      offset: [-(K + G), 4]
    },
    leftBottom: {
      points: ["br", "cl"],
      offset: [-4, Z + G]
    }
  };
  return Object.keys(ee).forEach(function(te) {
    ee[te] = Q ? _objectSpread2$1(_objectSpread2$1({}, ee[te]), {}, {
      overflow: getOverflowOptions(X),
      targetOffset: targetOffset$1
    }) : _objectSpread2$1(_objectSpread2$1({}, placements$3[te]), {}, {
      overflow: getOverflowOptions(X)
    }), ee[te].ignoreShake = !0;
  }), ee;
}
function firstNotUndefined() {
  for (var H = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], C = 0, G = H.length; C < G; C++)
    if (H[C] !== void 0)
      return H[C];
}
var splitObject = function(C, G) {
  var U = {}, K = _objectSpread2$1({}, C);
  return G.forEach(function(W) {
    C && W in C && (U[W] = C[W], delete K[W]);
  }), {
    picked: U,
    omitted: K
  };
}, PresetColorRegex = new RegExp("^(".concat(PresetColorTypes.join("|"), ")(-inverse)?$")), tooltipProps = function() {
  return _objectSpread2$1(_objectSpread2$1({}, abstractTooltipProps()), {}, {
    title: PropTypes$1.any
  });
};
const ToolTip = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ATooltip",
  inheritAttrs: !1,
  props: initDefaultProps$1(tooltipProps(), {
    trigger: "hover",
    transitionName: "zoom-big-fast",
    align: {},
    placement: "top",
    mouseEnterDelay: 0.1,
    mouseLeaveDelay: 0.1,
    arrowPointAtCenter: !1,
    autoAdjustOverflow: !0
  }),
  slots: ["title"],
  // emits: ['update:visible', 'visibleChange'],
  setup: function(C, G) {
    var U = G.slots, K = G.emit, W = G.attrs, Z = G.expose, X = useConfigInject("tooltip", C), Q = X.prefixCls, ee = X.getPopupContainer, te = ref(firstNotUndefined([C.visible, C.defaultVisible])), re = ref();
    onMounted(function() {
      warning$1(C.defaultVisible === void 0, "Tooltip", "'defaultVisible' is deprecated, please use 'v-model:visible'");
    });
    var ne;
    watch(function() {
      return C.visible;
    }, function(ge) {
      wrapperRaf.cancel(ne), ne = wrapperRaf(function() {
        te.value = !!ge;
      });
    });
    var ae = function() {
      var fe, ve = (fe = C.title) !== null && fe !== void 0 ? fe : U.title;
      return !ve && ve !== 0;
    }, ie = function(fe) {
      var ve = ae();
      C.visible === void 0 && (te.value = ve ? !1 : fe), ve || (K("update:visible", fe), K("visibleChange", fe));
    }, se = function() {
      return re.value.getPopupDomNode();
    };
    Z({
      getPopupDomNode: se,
      visible: te,
      forcePopupAlign: function() {
        var fe;
        return (fe = re.value) === null || fe === void 0 ? void 0 : fe.forcePopupAlign();
      }
    });
    var oe = computed(function() {
      var ge = C.builtinPlacements, fe = C.arrowPointAtCenter, ve = C.autoAdjustOverflow;
      return ge || getPlacements({
        arrowPointAtCenter: fe,
        autoAdjustOverflow: ve
      });
    }), le = function(fe) {
      return fe || fe === "";
    }, ue = function(fe) {
      var ve = fe.type;
      if (_typeof$2(ve) === "object" && fe.props && ((ve.__ANT_BUTTON === !0 || ve === "button") && le(fe.props.disabled) || ve.__ANT_SWITCH === !0 && (le(fe.props.disabled) || le(fe.props.loading)))) {
        var pe = splitObject(getStyle$1(fe), ["position", "left", "right", "top", "bottom", "float", "display", "zIndex"]), he = pe.picked, me = pe.omitted, ye = _objectSpread2$1(_objectSpread2$1({
          display: "inline-block"
        }, he), {}, {
          cursor: "not-allowed",
          lineHeight: 1,
          width: fe.props && fe.props.block ? "100%" : null
        }), Ce = _objectSpread2$1(_objectSpread2$1({}, me), {}, {
          pointerEvents: "none"
        }), Ie = cloneElement(fe, {
          style: Ce
        }, !0);
        return createVNode$1("span", {
          style: ye,
          class: "".concat(Q.value, "-disabled-compatible-wrapper")
        }, [Ie]);
      }
      return fe;
    }, ce = function() {
      var fe, ve;
      return (fe = C.title) !== null && fe !== void 0 ? fe : (ve = U.title) === null || ve === void 0 ? void 0 : ve.call(U);
    }, de = function(fe, ve) {
      var pe = oe.value, he = Object.keys(pe).filter(function(Ce) {
        return pe[Ce].points[0] === ve.points[0] && pe[Ce].points[1] === ve.points[1];
      })[0];
      if (he) {
        var me = fe.getBoundingClientRect(), ye = {
          top: "50%",
          left: "50%"
        };
        he.indexOf("top") >= 0 || he.indexOf("Bottom") >= 0 ? ye.top = "".concat(me.height - ve.offset[1], "px") : (he.indexOf("Top") >= 0 || he.indexOf("bottom") >= 0) && (ye.top = "".concat(-ve.offset[1], "px")), he.indexOf("left") >= 0 || he.indexOf("Right") >= 0 ? ye.left = "".concat(me.width - ve.offset[0], "px") : (he.indexOf("right") >= 0 || he.indexOf("Left") >= 0) && (ye.left = "".concat(-ve.offset[0], "px")), fe.style.transformOrigin = "".concat(ye.left, " ").concat(ye.top);
      }
    };
    return function() {
      var ge, fe, ve, pe = C.openClassName, he = C.color, me = C.overlayClassName, ye = (ge = filterEmpty((fe = U.default) === null || fe === void 0 ? void 0 : fe.call(U))) !== null && ge !== void 0 ? ge : null;
      ye = ye.length === 1 ? ye[0] : ye;
      var Ce = te.value;
      if (C.visible === void 0 && ae() && (Ce = !1), !ye)
        return null;
      var Ie = ue(isValidElement(ye) ? ye : createVNode$1("span", null, [ye])), be = classNames((ve = {}, _defineProperty$A(ve, pe || "".concat(Q.value, "-open"), !0), _defineProperty$A(ve, Ie.props && Ie.props.class, Ie.props && Ie.props.class), ve)), Se = classNames(me, _defineProperty$A({}, "".concat(Q.value, "-").concat(he), he && PresetColorRegex.test(he))), Ae, _e;
      he && !PresetColorRegex.test(he) && (Ae = {
        backgroundColor: he
      }, _e = {
        backgroundColor: he
      });
      var xe = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, W), C), {}, {
        prefixCls: Q.value,
        getPopupContainer: ee.value,
        builtinPlacements: oe.value,
        visible: Ce,
        ref: re,
        overlayClassName: Se,
        overlayInnerStyle: Ae,
        onVisibleChange: ie,
        onPopupAlign: de
      });
      return createVNode$1(Tooltip$1, xe, {
        default: function() {
          return [te.value ? cloneElement(Ie, {
            class: be
          }) : Ie];
        },
        arrowContent: function() {
          return createVNode$1("span", {
            class: "".concat(Q.value, "-arrow-content"),
            style: _e
          }, null);
        },
        overlay: ce
      });
    };
  }
}), Tooltip = withInstall(ToolTip);
var autoAdjustOverflow$1 = {
  adjustX: 1,
  adjustY: 1
}, targetOffset = [0, 0], placements$1 = {
  topLeft: {
    points: ["bl", "tl"],
    overflow: autoAdjustOverflow$1,
    offset: [0, -4],
    targetOffset
  },
  topCenter: {
    points: ["bc", "tc"],
    overflow: autoAdjustOverflow$1,
    offset: [0, -4],
    targetOffset
  },
  topRight: {
    points: ["br", "tr"],
    overflow: autoAdjustOverflow$1,
    offset: [0, -4],
    targetOffset
  },
  bottomLeft: {
    points: ["tl", "bl"],
    overflow: autoAdjustOverflow$1,
    offset: [0, 4],
    targetOffset
  },
  bottomCenter: {
    points: ["tc", "bc"],
    overflow: autoAdjustOverflow$1,
    offset: [0, 4],
    targetOffset
  },
  bottomRight: {
    points: ["tr", "br"],
    overflow: autoAdjustOverflow$1,
    offset: [0, 4],
    targetOffset
  }
};
const placements$2 = placements$1;
var _excluded$i = ["prefixCls", "arrow", "showAction", "overlayStyle", "trigger", "placement", "align", "getPopupContainer", "transitionName", "animation", "overlayClassName"];
const Dropdown$2 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  props: {
    minOverlayWidthMatchTrigger: {
      type: Boolean,
      default: void 0
    },
    arrow: {
      type: Boolean,
      default: !1
    },
    prefixCls: PropTypes$1.string.def("rc-dropdown"),
    transitionName: String,
    overlayClassName: PropTypes$1.string.def(""),
    openClassName: String,
    animation: PropTypes$1.any,
    align: PropTypes$1.object,
    overlayStyle: {
      type: Object,
      default: void 0
    },
    placement: PropTypes$1.string.def("bottomLeft"),
    overlay: PropTypes$1.any,
    trigger: PropTypes$1.oneOfType([PropTypes$1.string, PropTypes$1.arrayOf(PropTypes$1.string)]).def("hover"),
    alignPoint: {
      type: Boolean,
      default: void 0
    },
    showAction: PropTypes$1.array,
    hideAction: PropTypes$1.array,
    getPopupContainer: Function,
    visible: {
      type: Boolean,
      default: void 0
    },
    defaultVisible: {
      type: Boolean,
      default: !1
    },
    mouseEnterDelay: PropTypes$1.number.def(0.15),
    mouseLeaveDelay: PropTypes$1.number.def(0.1)
  },
  emits: ["visibleChange", "overlayClick"],
  slots: ["overlay"],
  setup: function(C, G) {
    var U = G.slots, K = G.emit, W = G.expose, Z = ref(!!C.visible);
    watch(function() {
      return C.visible;
    }, function(ie) {
      ie !== void 0 && (Z.value = ie);
    });
    var X = ref();
    W({
      triggerRef: X
    });
    var Q = function(se) {
      C.visible === void 0 && (Z.value = !1), K("overlayClick", se);
    }, ee = function(se) {
      C.visible === void 0 && (Z.value = se), K("visibleChange", se);
    }, te = function() {
      var se, oe = (se = U.overlay) === null || se === void 0 ? void 0 : se.call(U), le = {
        prefixCls: "".concat(C.prefixCls, "-menu"),
        onClick: Q,
        getPopupContainer: function() {
          return X.value.getPopupDomNode();
        }
      };
      return createVNode$1(Fragment, null, [C.arrow && createVNode$1("div", {
        class: "".concat(C.prefixCls, "-arrow")
      }, null), cloneElement(oe, le, !1)]);
    }, re = computed(function() {
      var ie = C.minOverlayWidthMatchTrigger, se = ie === void 0 ? !C.alignPoint : ie;
      return se;
    }), ne = function() {
      var se, oe = (se = U.default) === null || se === void 0 ? void 0 : se.call(U);
      return Z.value && oe ? cloneElement(oe[0], {
        class: C.openClassName || "".concat(C.prefixCls, "-open")
      }, !1) : oe;
    }, ae = computed(function() {
      return !C.hideAction && C.trigger.indexOf("contextmenu") !== -1 ? ["click"] : C.hideAction;
    });
    return function() {
      var ie = C.prefixCls, se = C.arrow, oe = C.showAction, le = C.overlayStyle, ue = C.trigger, ce = C.placement, de = C.align, ge = C.getPopupContainer, fe = C.transitionName, ve = C.animation, pe = C.overlayClassName, he = _objectWithoutProperties$2(C, _excluded$i);
      return createVNode$1(Trigger, _objectSpread2$1(_objectSpread2$1({}, he), {}, {
        prefixCls: ie,
        ref: X,
        popupClassName: classNames(pe, _defineProperty$A({}, "".concat(ie, "-show-arrow"), se)),
        popupStyle: le,
        builtinPlacements: placements$2,
        action: ue,
        showAction: oe,
        hideAction: ae.value || [],
        popupPlacement: ce,
        popupAlign: de,
        popupTransitionName: fe,
        popupAnimation: ve,
        popupVisible: Z.value,
        stretch: re.value ? "minWidth" : "",
        onPopupVisibleChange: ee,
        getPopupContainer: ge
      }), {
        popup: te,
        default: ne
      });
    };
  }
});
var START_EVENT_NAME_MAP = {
  transitionstart: {
    transition: "transitionstart",
    WebkitTransition: "webkitTransitionStart",
    MozTransition: "mozTransitionStart",
    OTransition: "oTransitionStart",
    msTransition: "MSTransitionStart"
  },
  animationstart: {
    animation: "animationstart",
    WebkitAnimation: "webkitAnimationStart",
    MozAnimation: "mozAnimationStart",
    OAnimation: "oAnimationStart",
    msAnimation: "MSAnimationStart"
  }
}, END_EVENT_NAME_MAP = {
  transitionend: {
    transition: "transitionend",
    WebkitTransition: "webkitTransitionEnd",
    MozTransition: "mozTransitionEnd",
    OTransition: "oTransitionEnd",
    msTransition: "MSTransitionEnd"
  },
  animationend: {
    animation: "animationend",
    WebkitAnimation: "webkitAnimationEnd",
    MozAnimation: "mozAnimationEnd",
    OAnimation: "oAnimationEnd",
    msAnimation: "MSAnimationEnd"
  }
}, startEvents = [], endEvents = [];
function detectEvents() {
  var H = document.createElement("div"), C = H.style;
  "AnimationEvent" in window || (delete START_EVENT_NAME_MAP.animationstart.animation, delete END_EVENT_NAME_MAP.animationend.animation), "TransitionEvent" in window || (delete START_EVENT_NAME_MAP.transitionstart.transition, delete END_EVENT_NAME_MAP.transitionend.transition);
  function G(U, K) {
    for (var W in U)
      if (U.hasOwnProperty(W)) {
        var Z = U[W];
        for (var X in Z)
          if (X in C) {
            K.push(Z[X]);
            break;
          }
      }
  }
  G(START_EVENT_NAME_MAP, startEvents), G(END_EVENT_NAME_MAP, endEvents);
}
typeof window < "u" && typeof document < "u" && detectEvents();
function addEventListener$1(H, C, G) {
  H.addEventListener(C, G, !1);
}
function removeEventListener$1(H, C, G) {
  H.removeEventListener(C, G, !1);
}
var TransitionEvents = {
  // Start events
  startEvents,
  addStartEventListener: function(C, G) {
    if (startEvents.length === 0) {
      setTimeout(G, 0);
      return;
    }
    startEvents.forEach(function(U) {
      addEventListener$1(C, U, G);
    });
  },
  removeStartEventListener: function(C, G) {
    startEvents.length !== 0 && startEvents.forEach(function(U) {
      removeEventListener$1(C, U, G);
    });
  },
  // End events
  endEvents,
  addEndEventListener: function(C, G) {
    if (endEvents.length === 0) {
      setTimeout(G, 0);
      return;
    }
    endEvents.forEach(function(U) {
      addEventListener$1(C, U, G);
    });
  },
  removeEndEventListener: function(C, G) {
    endEvents.length !== 0 && endEvents.forEach(function(U) {
      removeEventListener$1(C, U, G);
    });
  }
};
const TransitionEvents$1 = TransitionEvents;
var styleForPesudo;
function isHidden(H) {
  return process.env.NODE_ENV === "test" ? !1 : !H || H.offsetParent === null;
}
function isNotGrey(H) {
  var C = (H || "").match(/rgba?\((\d*), (\d*), (\d*)(, [\.\d]*)?\)/);
  return C && C[1] && C[2] && C[3] ? !(C[1] === C[2] && C[2] === C[3]) : !0;
}
const Wave = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Wave",
  props: {
    insertExtraNode: Boolean,
    disabled: Boolean
  },
  setup: function(C, G) {
    var U = G.slots, K = G.expose, W = getCurrentInstance(), Z = useConfigInject("", C), X = Z.csp, Q = Z.prefixCls;
    K({
      csp: X
    });
    var ee = null, te = null, re = null, ne = !1, ae = null, ie = !1, se = function(fe) {
      if (!ie) {
        var ve = findDOMNode(W);
        !fe || fe.target !== ve || ne || ce(ve);
      }
    }, oe = function(fe) {
      !fe || fe.animationName !== "fadeEffect" || ce(fe.target);
    }, le = function() {
      var fe = C.insertExtraNode;
      return fe ? "".concat(Q.value, "-click-animating") : "".concat(Q.value, "-click-animating-without-extra-node");
    }, ue = function(fe, ve) {
      var pe = C.insertExtraNode, he = C.disabled;
      if (!(he || !fe || isHidden(fe) || fe.className.indexOf("-leave") >= 0)) {
        ae = document.createElement("div"), ae.className = "".concat(Q.value, "-click-animating-node");
        var me = le();
        if (fe.removeAttribute(me), fe.setAttribute(me, "true"), styleForPesudo = styleForPesudo || document.createElement("style"), ve && ve !== "#ffffff" && ve !== "rgb(255, 255, 255)" && isNotGrey(ve) && !/rgba\(\d*, \d*, \d*, 0\)/.test(ve) && // any transparent rgba color
        ve !== "transparent") {
          var ye;
          (ye = X.value) !== null && ye !== void 0 && ye.nonce && (styleForPesudo.nonce = X.value.nonce), ae.style.borderColor = ve, styleForPesudo.innerHTML = `
        [`.concat(Q.value, "-click-animating-without-extra-node='true']::after, .").concat(Q.value, `-click-animating-node {
          --antd-wave-shadow-color: `).concat(ve, `;
        }`), document.body.contains(styleForPesudo) || document.body.appendChild(styleForPesudo);
        }
        pe && fe.appendChild(ae), TransitionEvents$1.addStartEventListener(fe, se), TransitionEvents$1.addEndEventListener(fe, oe);
      }
    }, ce = function(fe) {
      if (!(!fe || fe === ae || !(fe instanceof Element))) {
        var ve = C.insertExtraNode, pe = le();
        fe.setAttribute(pe, "false"), styleForPesudo && (styleForPesudo.innerHTML = ""), ve && ae && fe.contains(ae) && fe.removeChild(ae), TransitionEvents$1.removeStartEventListener(fe, se), TransitionEvents$1.removeEndEventListener(fe, oe);
      }
    }, de = function(fe) {
      if (!(!fe || !fe.getAttribute || fe.getAttribute("disabled") || fe.className.indexOf("disabled") >= 0)) {
        var ve = function(he) {
          if (!(he.target.tagName === "INPUT" || isHidden(he.target))) {
            ce(fe);
            var me = getComputedStyle(fe).getPropertyValue("border-top-color") || // Firefox Compatible
            getComputedStyle(fe).getPropertyValue("border-color") || getComputedStyle(fe).getPropertyValue("background-color");
            te = setTimeout(function() {
              return ue(fe, me);
            }, 0), wrapperRaf.cancel(re), ne = !0, re = wrapperRaf(function() {
              ne = !1;
            }, 10);
          }
        };
        return fe.addEventListener("click", ve, !0), {
          cancel: function() {
            fe.removeEventListener("click", ve, !0);
          }
        };
      }
    };
    return onMounted(function() {
      nextTick(function() {
        var ge = findDOMNode(W);
        ge.nodeType === 1 && (ee = de(ge));
      });
    }), onBeforeUnmount(function() {
      ee && ee.cancel(), clearTimeout(te), ie = !0;
    }), function() {
      var ge;
      return (ge = U.default) === null || ge === void 0 ? void 0 : ge.call(U)[0];
    };
  }
});
var buttonProps = function() {
  return {
    prefixCls: String,
    type: String,
    htmlType: {
      type: String,
      default: "button"
    },
    shape: {
      type: String
    },
    size: {
      type: String
    },
    loading: {
      type: [Boolean, Object],
      default: function() {
        return !1;
      }
    },
    disabled: {
      type: Boolean,
      default: void 0
    },
    ghost: {
      type: Boolean,
      default: void 0
    },
    block: {
      type: Boolean,
      default: void 0
    },
    danger: {
      type: Boolean,
      default: void 0
    },
    icon: PropTypes$1.any,
    href: String,
    target: String,
    title: String,
    onClick: {
      type: Function
    },
    onMousedown: {
      type: Function
    }
  };
};
const buttonTypes = buttonProps;
var getCollapsedWidth = function(C) {
  C && (C.style.width = "0px", C.style.opacity = "0", C.style.transform = "scale(0)");
}, getRealWidth = function(C) {
  nextTick(function() {
    C && (C.style.width = "".concat(C.scrollWidth, "px"), C.style.opacity = "1", C.style.transform = "scale(1)");
  });
}, resetStyle = function(C) {
  C && C.style && (C.style.width = null, C.style.opacity = null, C.style.transform = null);
};
const LoadingIcon = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "LoadingIcon",
  props: {
    prefixCls: String,
    loading: [Boolean, Object],
    existIcon: Boolean
  },
  setup: function(C) {
    return function() {
      var G = C.existIcon, U = C.prefixCls, K = C.loading;
      if (G)
        return createVNode$1("span", {
          class: "".concat(U, "-loading-icon")
        }, [createVNode$1(LoadingOutlined$1, null, null)]);
      var W = !!K;
      return createVNode$1(Transition, {
        name: "".concat(U, "-loading-icon-motion"),
        onBeforeEnter: getCollapsedWidth,
        onEnter: getRealWidth,
        onAfterEnter: resetStyle,
        onBeforeLeave: getRealWidth,
        onLeave: function(X) {
          setTimeout(function() {
            getCollapsedWidth(X);
          });
        },
        onAfterLeave: resetStyle
      }, {
        default: function() {
          return [W ? createVNode$1("span", {
            class: "".concat(U, "-loading-icon")
          }, [createVNode$1(LoadingOutlined$1, null, null)]) : null];
        }
      });
    };
  }
});
var rxTwoCNChar = /^[\u4e00-\u9fa5]{2}$/, isTwoCNChar = rxTwoCNChar.test.bind(rxTwoCNChar);
function isUnborderedButtonType(H) {
  return H === "text" || H === "link";
}
const Button$1 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AButton",
  inheritAttrs: !1,
  __ANT_BUTTON: !0,
  props: initDefaultProps$1(buttonTypes(), {
    type: "default"
  }),
  slots: ["icon"],
  // emits: ['click', 'mousedown'],
  setup: function(C, G) {
    var U = G.slots, K = G.attrs, W = G.emit, Z = useConfigInject("btn", C), X = Z.prefixCls, Q = Z.autoInsertSpaceInButton, ee = Z.direction, te = Z.size, re = ref(null), ne = ref(void 0), ae = !1, ie = ref(!1), se = ref(!1), oe = computed(function() {
      return Q.value !== !1;
    }), le = computed(function() {
      return _typeof$2(C.loading) === "object" && C.loading.delay ? C.loading.delay || !0 : !!C.loading;
    });
    watch(le, function(fe) {
      clearTimeout(ne.value), typeof le.value == "number" ? ne.value = setTimeout(function() {
        ie.value = fe;
      }, le.value) : ie.value = fe;
    }, {
      immediate: !0
    });
    var ue = computed(function() {
      var fe, ve = C.type, pe = C.shape, he = pe === void 0 ? "default" : pe, me = C.ghost, ye = C.block, Ce = C.danger, Ie = X.value, be = {
        large: "lg",
        small: "sm",
        middle: void 0
      }, Se = te.value, Ae = Se && be[Se] || "";
      return fe = {}, _defineProperty$A(fe, "".concat(Ie), !0), _defineProperty$A(fe, "".concat(Ie, "-").concat(ve), ve), _defineProperty$A(fe, "".concat(Ie, "-").concat(he), he !== "default" && he), _defineProperty$A(fe, "".concat(Ie, "-").concat(Ae), Ae), _defineProperty$A(fe, "".concat(Ie, "-loading"), ie.value), _defineProperty$A(fe, "".concat(Ie, "-background-ghost"), me && !isUnborderedButtonType(ve)), _defineProperty$A(fe, "".concat(Ie, "-two-chinese-chars"), se.value && oe.value), _defineProperty$A(fe, "".concat(Ie, "-block"), ye), _defineProperty$A(fe, "".concat(Ie, "-dangerous"), !!Ce), _defineProperty$A(fe, "".concat(Ie, "-rtl"), ee.value === "rtl"), fe;
    }), ce = function() {
      var ve = re.value;
      if (!(!ve || Q.value === !1)) {
        var pe = ve.textContent;
        ae && isTwoCNChar(pe) ? se.value || (se.value = !0) : se.value && (se.value = !1);
      }
    }, de = function(ve) {
      if (ie.value || C.disabled) {
        ve.preventDefault();
        return;
      }
      W("click", ve);
    }, ge = function(ve, pe) {
      var he = pe ? " " : "";
      if (ve.type === Text) {
        var me = ve.children.trim();
        return isTwoCNChar(me) && (me = me.split("").join(he)), createVNode$1("span", null, [me]);
      }
      return ve;
    };
    return watchEffect(function() {
      devWarning(!(C.ghost && isUnborderedButtonType(C.type)), "Button", "`link` or `text` button can't be a `ghost` button.");
    }), onMounted(ce), onUpdated(ce), onBeforeUnmount(function() {
      ne.value && clearTimeout(ne.value);
    }), function() {
      var fe, ve, pe = C.icon, he = pe === void 0 ? (fe = U.icon) === null || fe === void 0 ? void 0 : fe.call(U) : pe, me = flattenChildren((ve = U.default) === null || ve === void 0 ? void 0 : ve.call(U));
      ae = me.length === 1 && !he && !isUnborderedButtonType(C.type);
      var ye = C.type, Ce = C.htmlType, Ie = C.disabled, be = C.href, Se = C.title, Ae = C.target, _e = C.onMousedown, xe = ie.value ? "loading" : he, Te = _objectSpread2$1(_objectSpread2$1({}, K), {}, {
        title: Se,
        disabled: Ie,
        class: [ue.value, K.class, _defineProperty$A({}, "".concat(X.value, "-icon-only"), me.length === 0 && !!xe)],
        onClick: de,
        onMousedown: _e
      });
      Ie || delete Te.disabled;
      var Pe = he && !ie.value ? he : createVNode$1(LoadingIcon, {
        existIcon: !!he,
        prefixCls: X.value,
        loading: !!ie.value
      }, null), $e = me.map(function(Ee) {
        return ge(Ee, ae && oe.value);
      });
      if (be !== void 0)
        return createVNode$1("a", _objectSpread2$1(_objectSpread2$1({}, Te), {}, {
          href: be,
          target: Ae,
          ref: re
        }), [Pe, $e]);
      var Me = createVNode$1("button", _objectSpread2$1(_objectSpread2$1({}, Te), {}, {
        ref: re,
        type: Ce
      }), [Pe, $e]);
      return isUnborderedButtonType(ye) ? Me : createVNode$1(Wave, {
        ref: "wave",
        disabled: !!ie.value
      }, {
        default: function() {
          return [Me];
        }
      });
    };
  }
});
function _defineProperties(H, C) {
  for (var G = 0; G < C.length; G++) {
    var U = C[G];
    U.enumerable = U.enumerable || !1, U.configurable = !0, "value" in U && (U.writable = !0), Object.defineProperty(H, _toPropertyKey(U.key), U);
  }
}
function _createClass(H, C, G) {
  return C && _defineProperties(H.prototype, C), G && _defineProperties(H, G), Object.defineProperty(H, "prototype", {
    writable: !1
  }), H;
}
function _classCallCheck(H, C) {
  if (!(H instanceof C))
    throw new TypeError("Cannot call a class as a function");
}
var UnreachableException = /* @__PURE__ */ _createClass(function H(C) {
  _classCallCheck(this, H), this.error = new Error("unreachable case: ".concat(JSON.stringify(C)));
}), buttonGroupProps = function() {
  return {
    prefixCls: String,
    size: {
      type: String
    }
  };
};
const ButtonGroup$1 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AButtonGroup",
  props: buttonGroupProps(),
  setup: function(C, G) {
    var U = G.slots, K = useConfigInject("btn-group", C), W = K.prefixCls, Z = K.direction, X = computed(function() {
      var Q, ee = C.size, te = "";
      switch (ee) {
        case "large":
          te = "lg";
          break;
        case "small":
          te = "sm";
          break;
        case "middle":
        case void 0:
          break;
        default:
          console.warn(new UnreachableException(ee).error);
      }
      return Q = {}, _defineProperty$A(Q, "".concat(W.value), !0), _defineProperty$A(Q, "".concat(W.value, "-").concat(te), te), _defineProperty$A(Q, "".concat(W.value, "-rtl"), Z.value === "rtl"), Q;
    });
    return function() {
      var Q;
      return createVNode$1("div", {
        class: X.value
      }, [flattenChildren((Q = U.default) === null || Q === void 0 ? void 0 : Q.call(U))]);
    };
  }
});
Button$1.Group = ButtonGroup$1;
Button$1.install = function(H) {
  return H.component(Button$1.name, Button$1), H.component(ButtonGroup$1.name, ButtonGroup$1), H;
};
var dropdownProps = function() {
  return {
    arrow: {
      type: [Boolean, Object],
      default: void 0
    },
    trigger: {
      type: [Array, String]
    },
    overlay: PropTypes$1.any,
    visible: {
      type: Boolean,
      default: void 0
    },
    disabled: {
      type: Boolean,
      default: void 0
    },
    align: {
      type: Object
    },
    getPopupContainer: Function,
    prefixCls: String,
    transitionName: String,
    placement: String,
    overlayClassName: String,
    overlayStyle: {
      type: Object,
      default: void 0
    },
    forceRender: {
      type: Boolean,
      default: void 0
    },
    mouseEnterDelay: Number,
    mouseLeaveDelay: Number,
    openClassName: String,
    minOverlayWidthMatchTrigger: {
      type: Boolean,
      default: void 0
    },
    destroyPopupOnHide: {
      type: Boolean,
      default: void 0
    },
    onVisibleChange: {
      type: Function
    },
    "onUpdate:visible": {
      type: Function
    }
  };
}, buttonTypesProps = buttonTypes(), dropdownButtonProps = function() {
  return _objectSpread2$1(_objectSpread2$1({}, dropdownProps()), {}, {
    type: buttonTypesProps.type,
    size: String,
    htmlType: buttonTypesProps.htmlType,
    href: String,
    disabled: {
      type: Boolean,
      default: void 0
    },
    prefixCls: String,
    icon: PropTypes$1.any,
    title: String,
    loading: buttonTypesProps.loading,
    onClick: {
      type: Function
    }
  });
}, EllipsisOutlined$2 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M176 511a56 56 0 10112 0 56 56 0 10-112 0zm280 0a56 56 0 10112 0 56 56 0 10-112 0zm280 0a56 56 0 10112 0 56 56 0 10-112 0z" } }] }, name: "ellipsis", theme: "outlined" };
const EllipsisOutlinedSvg = EllipsisOutlined$2;
function _objectSpread$i(H) {
  for (var C = 1; C < arguments.length; C++) {
    var G = arguments[C] != null ? Object(arguments[C]) : {}, U = Object.keys(G);
    typeof Object.getOwnPropertySymbols == "function" && (U = U.concat(Object.getOwnPropertySymbols(G).filter(function(K) {
      return Object.getOwnPropertyDescriptor(G, K).enumerable;
    }))), U.forEach(function(K) {
      _defineProperty$i(H, K, G[K]);
    });
  }
  return H;
}
function _defineProperty$i(H, C, G) {
  return C in H ? Object.defineProperty(H, C, { value: G, enumerable: !0, configurable: !0, writable: !0 }) : H[C] = G, H;
}
var EllipsisOutlined = function(C, G) {
  var U = _objectSpread$i({}, C, G.attrs);
  return createVNode$1(AntdIcon, _objectSpread$i({}, U, {
    icon: EllipsisOutlinedSvg
  }), null);
};
EllipsisOutlined.displayName = "EllipsisOutlined";
EllipsisOutlined.inheritAttrs = !1;
const EllipsisOutlined$1 = EllipsisOutlined;
var _excluded$h = ["type", "disabled", "loading", "htmlType", "class", "overlay", "trigger", "align", "visible", "onVisibleChange", "placement", "href", "title", "icon", "mouseEnterDelay", "mouseLeaveDelay", "overlayClassName", "overlayStyle", "destroyPopupOnHide", "onClick", "onUpdate:visible"], ButtonGroup = Button$1.Group;
const DropdownButton = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ADropdownButton",
  inheritAttrs: !1,
  __ANT_BUTTON: !0,
  props: initDefaultProps$1(dropdownButtonProps(), {
    trigger: "hover",
    placement: "bottomRight",
    type: "default"
  }),
  // emits: ['click', 'visibleChange', 'update:visible'],
  slots: ["icon", "leftButton", "rightButton", "overlay"],
  setup: function(C, G) {
    var U = G.slots, K = G.attrs, W = G.emit, Z = function(ne) {
      W("update:visible", ne), W("visibleChange", ne);
    }, X = useConfigInject("dropdown-button", C), Q = X.prefixCls, ee = X.direction, te = X.getPopupContainer;
    return function() {
      var re, ne, ae = _objectSpread2$1(_objectSpread2$1({}, C), K), ie = ae.type, se = ie === void 0 ? "default" : ie, oe = ae.disabled, le = ae.loading, ue = ae.htmlType, ce = ae.class, de = ce === void 0 ? "" : ce, ge = ae.overlay, fe = ge === void 0 ? (re = U.overlay) === null || re === void 0 ? void 0 : re.call(U) : ge, ve = ae.trigger, pe = ae.align, he = ae.visible;
      ae.onVisibleChange;
      var me = ae.placement, ye = me === void 0 ? ee.value === "rtl" ? "bottomLeft" : "bottomRight" : me, Ce = ae.href, Ie = ae.title, be = ae.icon, Se = be === void 0 ? ((ne = U.icon) === null || ne === void 0 ? void 0 : ne.call(U)) || createVNode$1(EllipsisOutlined$1, null, null) : be, Ae = ae.mouseEnterDelay, _e = ae.mouseLeaveDelay, xe = ae.overlayClassName, Te = ae.overlayStyle, Pe = ae.destroyPopupOnHide, $e = ae.onClick;
      ae["onUpdate:visible"];
      var Me = _objectWithoutProperties$2(ae, _excluded$h), Ee = {
        align: pe,
        disabled: oe,
        trigger: oe ? [] : ve,
        placement: ye,
        getPopupContainer: te.value,
        onVisibleChange: Z,
        mouseEnterDelay: Ae,
        mouseLeaveDelay: _e,
        visible: he,
        overlayClassName: xe,
        overlayStyle: Te,
        destroyPopupOnHide: Pe
      }, we = createVNode$1(Button$1, {
        type: se,
        disabled: oe,
        loading: le,
        onClick: $e,
        htmlType: ue,
        href: Ce,
        title: Ie
      }, {
        default: U.default
      }), Oe = createVNode$1(Button$1, {
        type: se,
        icon: Se
      }, null);
      return createVNode$1(ButtonGroup, _objectSpread2$1(_objectSpread2$1({}, Me), {}, {
        class: classNames(Q.value, de)
      }), {
        default: function() {
          return [U.leftButton ? U.leftButton({
            button: we
          }) : we, createVNode$1(Dropdown$1, Ee, {
            default: function() {
              return [U.rightButton ? U.rightButton({
                button: Oe
              }) : Oe];
            },
            overlay: function() {
              return fe;
            }
          })];
        }
      });
    };
  }
});
var RightOutlined$2 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M765.7 486.8L314.9 134.7A7.97 7.97 0 00302 141v77.3c0 4.9 2.3 9.6 6.1 12.6l360 281.1-360 281.1c-3.9 3-6.1 7.7-6.1 12.6V883c0 6.7 7.7 10.4 12.9 6.3l450.8-352.1a31.96 31.96 0 000-50.4z" } }] }, name: "right", theme: "outlined" };
const RightOutlinedSvg = RightOutlined$2;
function _objectSpread$h(H) {
  for (var C = 1; C < arguments.length; C++) {
    var G = arguments[C] != null ? Object(arguments[C]) : {}, U = Object.keys(G);
    typeof Object.getOwnPropertySymbols == "function" && (U = U.concat(Object.getOwnPropertySymbols(G).filter(function(K) {
      return Object.getOwnPropertyDescriptor(G, K).enumerable;
    }))), U.forEach(function(K) {
      _defineProperty$h(H, K, G[K]);
    });
  }
  return H;
}
function _defineProperty$h(H, C, G) {
  return C in H ? Object.defineProperty(H, C, { value: G, enumerable: !0, configurable: !0, writable: !0 }) : H[C] = G, H;
}
var RightOutlined = function(C, G) {
  var U = _objectSpread$h({}, C, G.attrs);
  return createVNode$1(AntdIcon, _objectSpread$h({}, U, {
    icon: RightOutlinedSvg
  }), null);
};
RightOutlined.displayName = "RightOutlined";
RightOutlined.inheritAttrs = !1;
const RightOutlined$1 = RightOutlined;
var Dropdown = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ADropdown",
  inheritAttrs: !1,
  props: initDefaultProps$1(dropdownProps(), {
    mouseEnterDelay: 0.15,
    mouseLeaveDelay: 0.1,
    placement: "bottomLeft",
    trigger: "hover"
  }),
  // emits: ['visibleChange', 'update:visible'],
  slots: ["overlay"],
  setup: function(C, G) {
    var U = G.slots, K = G.attrs, W = G.emit, Z = useConfigInject("dropdown", C), X = Z.prefixCls, Q = Z.rootPrefixCls, ee = Z.direction, te = Z.getPopupContainer, re = computed(function() {
      var se = C.placement, oe = se === void 0 ? "" : se, le = C.transitionName;
      return le !== void 0 ? le : oe.indexOf("top") >= 0 ? "".concat(Q.value, "-slide-down") : "".concat(Q.value, "-slide-up");
    }), ne = function() {
      var oe, le, ue, ce = C.overlay || ((oe = U.overlay) === null || oe === void 0 ? void 0 : oe.call(U)), de = Array.isArray(ce) ? ce[0] : ce;
      if (!de)
        return null;
      var ge = de.props || {};
      devWarning(!ge.mode || ge.mode === "vertical", "Dropdown", 'mode="'.concat(ge.mode, `" is not supported for Dropdown's Menu.`));
      var fe = ge.selectable, ve = fe === void 0 ? !1 : fe, pe = ge.expandIcon, he = pe === void 0 ? (le = de.children) === null || le === void 0 || (ue = le.expandIcon) === null || ue === void 0 ? void 0 : ue.call(le) : pe, me = typeof he < "u" && isValidElement(he) ? he : createVNode$1("span", {
        class: "".concat(X.value, "-menu-submenu-arrow")
      }, [createVNode$1(RightOutlined$1, {
        class: "".concat(X.value, "-menu-submenu-arrow-icon")
      }, null)]), ye = isValidElement(de) ? cloneElement(de, {
        mode: "vertical",
        selectable: ve,
        expandIcon: function() {
          return me;
        }
      }) : de;
      return ye;
    }, ae = computed(function() {
      var se = C.placement;
      if (!se)
        return ee.value === "rtl" ? "bottomRight" : "bottomLeft";
      if (se.includes("Center")) {
        var oe = se.slice(0, se.indexOf("Center"));
        return devWarning(!se.includes("Center"), "Dropdown", "You are using '".concat(se, "' placement in Dropdown, which is deprecated. Try to use '").concat(oe, "' instead.")), oe;
      }
      return se;
    }), ie = function(oe) {
      W("update:visible", oe), W("visibleChange", oe);
    };
    return function() {
      var se, oe, le = C.arrow, ue = C.trigger, ce = C.disabled, de = C.overlayClassName, ge = (se = U.default) === null || se === void 0 ? void 0 : se.call(U)[0], fe = cloneElement(ge, _extends({
        class: classNames(ge == null || (oe = ge.props) === null || oe === void 0 ? void 0 : oe.class, _defineProperty$A({}, "".concat(X.value, "-rtl"), ee.value === "rtl"), "".concat(X.value, "-trigger"))
      }, ce ? {
        disabled: ce
      } : {})), ve = classNames(de, _defineProperty$A({}, "".concat(X.value, "-rtl"), ee.value === "rtl")), pe = ce ? [] : ue, he;
      pe && pe.indexOf("contextmenu") !== -1 && (he = !0);
      var me = getPlacements({
        arrowPointAtCenter: _typeof$2(le) === "object" && le.pointAtCenter,
        autoAdjustOverflow: !0
      }), ye = omit(_objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, C), K), {}, {
        builtinPlacements: me,
        overlayClassName: ve,
        arrow: le,
        alignPoint: he,
        prefixCls: X.value,
        getPopupContainer: te.value,
        transitionName: re.value,
        trigger: pe,
        onVisibleChange: ie,
        placement: ae.value
      }), ["overlay", "onUpdate:visible"]);
      return createVNode$1(Dropdown$2, ye, {
        default: function() {
          return [fe];
        },
        overlay: ne
      });
    };
  }
});
Dropdown.Button = DropdownButton;
const Dropdown$1 = Dropdown;
function shallowEqual(H, C, G, U) {
  var K = G ? G.call(U, H, C) : void 0;
  if (K !== void 0)
    return !!K;
  if (H === C)
    return !0;
  if (_typeof$2(H) !== "object" || !H || _typeof$2(C) !== "object" || !C)
    return !1;
  var W = Object.keys(H), Z = Object.keys(C);
  if (W.length !== Z.length)
    return !1;
  for (var X = Object.prototype.hasOwnProperty.bind(C), Q = 0; Q < W.length; Q++) {
    var ee = W[Q];
    if (!X(ee))
      return !1;
    var te = H[ee], re = C[ee];
    if (K = G ? G.call(U, te, re, ee) : void 0, K === !1 || K === void 0 && te !== re)
      return !1;
  }
  return !0;
}
function shallowequal(H, C, G, U) {
  return shallowEqual(toRaw(H), toRaw(C), G, U);
}
var MenuContextKey = Symbol("menuContextKey"), useProvideMenu = function(C) {
  provide(MenuContextKey, C);
}, useInjectMenu = function() {
  return inject(MenuContextKey);
}, ForceRenderKey = Symbol("ForceRenderKey"), useProvideForceRender = function(C) {
  provide(ForceRenderKey, C);
}, useInjectForceRender = function() {
  return inject(ForceRenderKey, !1);
}, MenuFirstLevelContextKey = Symbol("menuFirstLevelContextKey"), useProvideFirstLevel = function(C) {
  provide(MenuFirstLevelContextKey, C);
}, useInjectFirstLevel = function() {
  return inject(MenuFirstLevelContextKey, !0);
}, MenuContextProvider = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "MenuContextProvider",
  inheritAttrs: !1,
  props: {
    mode: {
      type: String,
      default: void 0
    },
    overflowDisabled: {
      type: Boolean,
      default: void 0
    },
    isRootMenu: {
      type: Boolean,
      default: void 0
    }
  },
  setup: function(C, G) {
    var U = G.slots, K = useInjectMenu(), W = _objectSpread2$1({}, K);
    return C.mode !== void 0 && (W.mode = toRef(C, "mode")), C.isRootMenu !== void 0 && (W.isRootMenu = toRef(C, "isRootMenu")), C.overflowDisabled !== void 0 && (W.overflowDisabled = toRef(C, "overflowDisabled")), useProvideMenu(W), function() {
      var Z;
      return (Z = U.default) === null || Z === void 0 ? void 0 : Z.call(U);
    };
  }
});
const useProvideMenu$1 = useProvideMenu;
function baseFindIndex(H, C, G, U) {
  for (var K = H.length, W = G + (U ? 1 : -1); U ? W-- : ++W < K; )
    if (C(H[W], W, H))
      return W;
  return -1;
}
function baseIsNaN(H) {
  return H !== H;
}
function strictIndexOf(H, C, G) {
  for (var U = G - 1, K = H.length; ++U < K; )
    if (H[U] === C)
      return U;
  return -1;
}
function baseIndexOf(H, C, G) {
  return C === C ? strictIndexOf(H, C, G) : baseFindIndex(H, baseIsNaN, G);
}
function arrayIncludes(H, C) {
  var G = H == null ? 0 : H.length;
  return !!G && baseIndexOf(H, C, 0) > -1;
}
function arrayIncludesWith(H, C, G) {
  for (var U = -1, K = H == null ? 0 : H.length; ++U < K; )
    if (G(C, H[U]))
      return !0;
  return !1;
}
function noop$2() {
}
var INFINITY = 1 / 0, createSet = Set$2 && 1 / setToArray(new Set$2([, -0]))[1] == INFINITY ? function(H) {
  return new Set$2(H);
} : noop$2;
const createSet$1 = createSet;
var LARGE_ARRAY_SIZE = 200;
function baseUniq(H, C, G) {
  var U = -1, K = arrayIncludes, W = H.length, Z = !0, X = [], Q = X;
  if (G)
    Z = !1, K = arrayIncludesWith;
  else if (W >= LARGE_ARRAY_SIZE) {
    var ee = C ? null : createSet$1(H);
    if (ee)
      return setToArray(ee);
    Z = !1, K = cacheHas, Q = new SetCache();
  } else
    Q = C ? [] : X;
  e:
    for (; ++U < W; ) {
      var te = H[U], re = C ? C(te) : te;
      if (te = G || te !== 0 ? te : 0, Z && re === re) {
        for (var ne = Q.length; ne--; )
          if (Q[ne] === re)
            continue e;
        C && Q.push(re), X.push(te);
      } else
        K(Q, re, G) || (Q !== X && Q.push(re), X.push(te));
    }
  return X;
}
function uniq(H) {
  return H && H.length ? baseUniq(H) : [];
}
var SiderCollapsedKey = Symbol("siderCollapsed"), OVERFLOW_KEY = "$$__vc-menu-more__key", KeyPathContext = Symbol("KeyPathContext"), useInjectKeyPath = function() {
  return inject(KeyPathContext, {
    parentEventKeys: computed(function() {
      return [];
    }),
    parentKeys: computed(function() {
      return [];
    }),
    parentInfo: {}
  });
}, useProvideKeyPath = function(C, G, U) {
  var K = useInjectKeyPath(), W = K.parentEventKeys, Z = K.parentKeys, X = computed(function() {
    return [].concat(_toConsumableArray(W.value), [C]);
  }), Q = computed(function() {
    return [].concat(_toConsumableArray(Z.value), [G]);
  });
  return provide(KeyPathContext, {
    parentEventKeys: X,
    parentKeys: Q,
    parentInfo: U
  }), Q;
}, measure = Symbol("measure"), PathContext = defineComponent({
  compatConfig: {
    MODE: 3
  },
  setup: function(C, G) {
    var U = G.slots;
    return provide(measure, !0), function() {
      var K;
      return (K = U.default) === null || K === void 0 ? void 0 : K.call(U);
    };
  }
}), useMeasure = function() {
  return inject(measure, !1);
};
const useProvideKeyPath$1 = useProvideKeyPath;
function useDirectionStyle(H) {
  var C = useInjectMenu(), G = C.mode, U = C.rtl, K = C.inlineIndent;
  return computed(function() {
    return G.value !== "inline" ? null : U.value ? {
      paddingRight: "".concat(H.value * K.value, "px")
    } : {
      paddingLeft: "".concat(H.value * K.value, "px")
    };
  });
}
var indexGuid$2 = 0, menuItemProps = function() {
  return {
    id: String,
    role: String,
    disabled: Boolean,
    danger: Boolean,
    title: {
      type: [String, Boolean],
      default: void 0
    },
    icon: PropTypes$1.any,
    onMouseenter: Function,
    onMouseleave: Function,
    onClick: Function,
    onKeydown: Function,
    onFocus: Function
  };
};
const MenuItem$1 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AMenuItem",
  inheritAttrs: !1,
  props: menuItemProps(),
  // emits: ['mouseenter', 'mouseleave', 'click', 'keydown', 'focus'],
  slots: ["icon", "title"],
  setup: function(C, G) {
    var U = G.slots, K = G.emit, W = G.attrs, Z = getCurrentInstance(), X = useMeasure(), Q = _typeof$2(Z.vnode.key) === "symbol" ? String(Z.vnode.key) : Z.vnode.key;
    devWarning(_typeof$2(Z.vnode.key) !== "symbol", "MenuItem", 'MenuItem `:key="'.concat(String(Q), '"` not support Symbol type'));
    var ee = "menu_item_".concat(++indexGuid$2, "_$$_").concat(Q), te = useInjectKeyPath(), re = te.parentEventKeys, ne = te.parentKeys, ae = useInjectMenu(), ie = ae.prefixCls, se = ae.activeKeys, oe = ae.disabled, le = ae.changeActiveKeys, ue = ae.rtl, ce = ae.inlineCollapsed, de = ae.siderCollapsed, ge = ae.onItemClick, fe = ae.selectedKeys, ve = ae.registerMenuInfo, pe = ae.unRegisterMenuInfo, he = useInjectFirstLevel(), me = ref(!1), ye = computed(function() {
      return [].concat(_toConsumableArray(ne.value), [Q]);
    }), Ce = {
      eventKey: ee,
      key: Q,
      parentEventKeys: re,
      parentKeys: ne,
      isLeaf: !0
    };
    ve(ee, Ce), onBeforeUnmount(function() {
      pe(ee);
    }), watch(se, function() {
      me.value = !!se.value.find(function(we) {
        return we === Q;
      });
    }, {
      immediate: !0
    });
    var Ie = computed(function() {
      return oe.value || C.disabled;
    }), be = computed(function() {
      return fe.value.includes(Q);
    }), Se = computed(function() {
      var we, Oe = "".concat(ie.value, "-item");
      return we = {}, _defineProperty$A(we, "".concat(Oe), !0), _defineProperty$A(we, "".concat(Oe, "-danger"), C.danger), _defineProperty$A(we, "".concat(Oe, "-active"), me.value), _defineProperty$A(we, "".concat(Oe, "-selected"), be.value), _defineProperty$A(we, "".concat(Oe, "-disabled"), Ie.value), we;
    }), Ae = function(Oe) {
      return {
        key: Q,
        eventKey: ee,
        keyPath: ye.value,
        eventKeyPath: [].concat(_toConsumableArray(re.value), [ee]),
        domEvent: Oe,
        item: _objectSpread2$1(_objectSpread2$1({}, C), W)
      };
    }, _e = function(Oe) {
      if (!Ie.value) {
        var Ne = Ae(Oe);
        K("click", Oe), ge(Ne);
      }
    }, xe = function(Oe) {
      Ie.value || (le(ye.value), K("mouseenter", Oe));
    }, Te = function(Oe) {
      Ie.value || (le([]), K("mouseleave", Oe));
    }, Pe = function(Oe) {
      if (K("keydown", Oe), Oe.which === KeyCode$1.ENTER) {
        var Ne = Ae(Oe);
        K("click", Oe), ge(Ne);
      }
    }, $e = function(Oe) {
      le(ye.value), K("focus", Oe);
    }, Me = function(Oe, Ne) {
      var ke = createVNode$1("span", {
        class: "".concat(ie.value, "-title-content")
      }, [Ne]);
      return (!Oe || isValidElement(Ne) && Ne.type === "span") && Ne && ce.value && he && typeof Ne == "string" ? createVNode$1("div", {
        class: "".concat(ie.value, "-inline-collapsed-noicon")
      }, [Ne.charAt(0)]) : ke;
    }, Ee = useDirectionStyle(computed(function() {
      return ye.value.length;
    }));
    return function() {
      var we, Oe, Ne, ke;
      if (X)
        return null;
      var ze = (we = C.title) !== null && we !== void 0 ? we : (Oe = U.title) === null || Oe === void 0 ? void 0 : Oe.call(U), He = flattenChildren((Ne = U.default) === null || Ne === void 0 ? void 0 : Ne.call(U)), We = He.length, Re = ze;
      typeof ze > "u" ? Re = he && We ? He : "" : ze === !1 && (Re = "");
      var Le = {
        title: Re
      };
      !de.value && !ce.value && (Le.title = null, Le.visible = !1);
      var De = {};
      C.role === "option" && (De["aria-selected"] = be.value);
      var Ue = getPropsSlot(U, C, "icon");
      return createVNode$1(Tooltip, _objectSpread2$1(_objectSpread2$1({}, Le), {}, {
        placement: ue.value ? "left" : "right",
        overlayClassName: "".concat(ie.value, "-inline-collapsed-tooltip")
      }), {
        default: function() {
          return [createVNode$1(Overflow$1.Item, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
            component: "li"
          }, W), {}, {
            id: C.id,
            style: _objectSpread2$1(_objectSpread2$1({}, W.style || {}), Ee.value),
            class: [Se.value, (ke = {}, _defineProperty$A(ke, "".concat(W.class), !!W.class), _defineProperty$A(ke, "".concat(ie.value, "-item-only-child"), (Ue ? We + 1 : We) === 1), ke)],
            role: C.role || "menuitem",
            tabindex: C.disabled ? null : -1,
            "data-menu-id": Q,
            "aria-disabled": C.disabled
          }, De), {}, {
            onMouseenter: xe,
            onMouseleave: Te,
            onClick: _e,
            onKeydown: Pe,
            onFocus: $e,
            title: typeof ze == "string" ? ze : void 0
          }), {
            default: function() {
              return [cloneElement(Ue, {
                class: "".concat(ie.value, "-item-icon")
              }, !1), Me(Ue, He)];
            }
          })];
        }
      });
    };
  }
});
var autoAdjustOverflow = {
  adjustX: 1,
  adjustY: 1
}, placements = {
  topLeft: {
    points: ["bl", "tl"],
    overflow: autoAdjustOverflow,
    offset: [0, -7]
  },
  bottomLeft: {
    points: ["tl", "bl"],
    overflow: autoAdjustOverflow,
    offset: [0, 7]
  },
  leftTop: {
    points: ["tr", "tl"],
    overflow: autoAdjustOverflow,
    offset: [-4, 0]
  },
  rightTop: {
    points: ["tl", "tr"],
    overflow: autoAdjustOverflow,
    offset: [4, 0]
  }
}, placementsRtl = {
  topLeft: {
    points: ["bl", "tl"],
    overflow: autoAdjustOverflow,
    offset: [0, -7]
  },
  bottomLeft: {
    points: ["tl", "bl"],
    overflow: autoAdjustOverflow,
    offset: [0, 7]
  },
  rightTop: {
    points: ["tr", "tl"],
    overflow: autoAdjustOverflow,
    offset: [-4, 0]
  },
  leftTop: {
    points: ["tl", "tr"],
    overflow: autoAdjustOverflow,
    offset: [4, 0]
  }
}, popupPlacementMap = {
  horizontal: "bottomLeft",
  vertical: "rightTop",
  "vertical-left": "rightTop",
  "vertical-right": "leftTop"
};
const PopupTrigger = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "PopupTrigger",
  inheritAttrs: !1,
  props: {
    prefixCls: String,
    mode: String,
    visible: Boolean,
    // popup: React.ReactNode;
    popupClassName: String,
    popupOffset: Array,
    disabled: Boolean,
    onVisibleChange: Function
  },
  slots: ["popup"],
  emits: ["visibleChange"],
  setup: function(C, G) {
    var U = G.slots, K = G.emit, W = ref(!1), Z = useInjectMenu(), X = Z.getPopupContainer, Q = Z.rtl, ee = Z.subMenuOpenDelay, te = Z.subMenuCloseDelay, re = Z.builtinPlacements, ne = Z.triggerSubMenuAction, ae = Z.isRootMenu, ie = Z.forceSubMenuRender, se = Z.motion, oe = Z.defaultMotions, le = useInjectForceRender(), ue = computed(function() {
      return Q.value ? _objectSpread2$1(_objectSpread2$1({}, placementsRtl), re.value) : _objectSpread2$1(_objectSpread2$1({}, placements), re.value);
    }), ce = computed(function() {
      return popupPlacementMap[C.mode];
    }), de = ref();
    watch(function() {
      return C.visible;
    }, function(ve) {
      wrapperRaf.cancel(de.value), de.value = wrapperRaf(function() {
        W.value = ve;
      });
    }, {
      immediate: !0
    }), onBeforeUnmount(function() {
      wrapperRaf.cancel(de.value);
    });
    var ge = function(pe) {
      K("visibleChange", pe);
    }, fe = computed(function() {
      var ve, pe, he = se.value || ((ve = oe.value) === null || ve === void 0 ? void 0 : ve[C.mode]) || ((pe = oe.value) === null || pe === void 0 ? void 0 : pe.other), me = typeof he == "function" ? he() : he;
      return me ? getTransitionProps(me.name, {
        css: !0
      }) : void 0;
    });
    return function() {
      var ve = C.prefixCls, pe = C.popupClassName, he = C.mode, me = C.popupOffset, ye = C.disabled;
      return createVNode$1(Trigger, {
        prefixCls: ve,
        popupClassName: classNames("".concat(ve, "-popup"), _defineProperty$A({}, "".concat(ve, "-rtl"), Q.value), pe),
        stretch: he === "horizontal" ? "minWidth" : null,
        getPopupContainer: ae.value ? X.value : function(Ce) {
          return Ce.parentNode;
        },
        builtinPlacements: ue.value,
        popupPlacement: ce.value,
        popupVisible: W.value,
        popupAlign: me && {
          offset: me
        },
        action: ye ? [] : [ne.value],
        mouseEnterDelay: ee.value,
        mouseLeaveDelay: te.value,
        onPopupVisibleChange: ge,
        forceRender: le || ie.value,
        popupAnimation: fe.value
      }, {
        popup: U.popup,
        default: U.default
      });
    };
  }
});
var InternalSubMenuList = function(C, G) {
  var U, K = G.slots, W = G.attrs, Z = useInjectMenu(), X = Z.prefixCls, Q = Z.mode;
  return createVNode$1("ul", _objectSpread2$1(_objectSpread2$1({}, W), {}, {
    class: classNames(X.value, "".concat(X.value, "-sub"), "".concat(X.value, "-").concat(Q.value === "inline" ? "inline" : "vertical")),
    "data-menu-list": !0
  }), [(U = K.default) === null || U === void 0 ? void 0 : U.call(K)]);
};
InternalSubMenuList.displayName = "SubMenuList";
const SubMenuList = InternalSubMenuList, InlineSubMenuList = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "InlineSubMenuList",
  inheritAttrs: !1,
  props: {
    id: String,
    open: Boolean,
    keyPath: Array
  },
  setup: function(C, G) {
    var U = G.slots, K = computed(function() {
      return "inline";
    }), W = useInjectMenu(), Z = W.motion, X = W.mode, Q = W.defaultMotions, ee = computed(function() {
      return X.value === K.value;
    }), te = ref(!ee.value), re = computed(function() {
      return ee.value ? C.open : !1;
    });
    watch(X, function() {
      ee.value && (te.value = !1);
    }, {
      flush: "post"
    });
    var ne = computed(function() {
      var ae, ie, se = Z.value || ((ae = Q.value) === null || ae === void 0 ? void 0 : ae[K.value]) || ((ie = Q.value) === null || ie === void 0 ? void 0 : ie.other), oe = typeof se == "function" ? se() : se;
      return _objectSpread2$1(_objectSpread2$1({}, oe), {}, {
        appear: C.keyPath.length <= 1
      });
    });
    return function() {
      var ae;
      return te.value ? null : createVNode$1(MenuContextProvider, {
        mode: K.value
      }, {
        default: function() {
          return [createVNode$1(Transition, ne.value, {
            default: function() {
              return [withDirectives(createVNode$1(SubMenuList, {
                id: C.id
              }, {
                default: function() {
                  return [(ae = U.default) === null || ae === void 0 ? void 0 : ae.call(U)];
                }
              }), [[vShow, re.value]])];
            }
          })];
        }
      });
    };
  }
});
var indexGuid$1 = 0, subMenuProps = function() {
  return {
    icon: PropTypes$1.any,
    title: PropTypes$1.any,
    disabled: Boolean,
    level: Number,
    popupClassName: String,
    popupOffset: Array,
    internalPopupClose: Boolean,
    eventKey: String,
    expandIcon: Function,
    onMouseenter: Function,
    onMouseleave: Function,
    onTitleClick: Function
  };
};
const SubMenu$1 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ASubMenu",
  inheritAttrs: !1,
  props: subMenuProps(),
  slots: ["icon", "title", "expandIcon"],
  // emits: ['titleClick', 'mouseenter', 'mouseleave'],
  setup: function(C, G) {
    var U, K, W = G.slots, Z = G.attrs, X = G.emit;
    useProvideFirstLevel(!1);
    var Q = useMeasure(), ee = getCurrentInstance(), te = _typeof$2(ee.vnode.key) === "symbol" ? String(ee.vnode.key) : ee.vnode.key;
    devWarning(_typeof$2(ee.vnode.key) !== "symbol", "SubMenu", 'SubMenu `:key="'.concat(String(te), '"` not support Symbol type'));
    var re = isValid$2(te) ? te : "sub_menu_".concat(++indexGuid$1, "_$$_not_set_key"), ne = (U = C.eventKey) !== null && U !== void 0 ? U : isValid$2(te) ? "sub_menu_".concat(++indexGuid$1, "_$$_").concat(te) : re, ae = useInjectKeyPath(), ie = ae.parentEventKeys, se = ae.parentInfo, oe = ae.parentKeys, le = computed(function() {
      return [].concat(_toConsumableArray(oe.value), [re]);
    }), ue = ref([]), ce = {
      eventKey: ne,
      key: re,
      parentEventKeys: ie,
      childrenEventKeys: ue,
      parentKeys: oe
    };
    (K = se.childrenEventKeys) === null || K === void 0 || K.value.push(ne), onBeforeUnmount(function() {
      if (se.childrenEventKeys) {
        var Xe;
        se.childrenEventKeys.value = (Xe = se.childrenEventKeys) === null || Xe === void 0 ? void 0 : Xe.value.filter(function(qe) {
          return qe != ne;
        });
      }
    }), useProvideKeyPath$1(ne, re, ce);
    var de = useInjectMenu(), ge = de.prefixCls, fe = de.activeKeys, ve = de.disabled, pe = de.changeActiveKeys, he = de.mode, me = de.inlineCollapsed, ye = de.antdMenuTheme, Ce = de.openKeys, Ie = de.overflowDisabled, be = de.onOpenChange, Se = de.registerMenuInfo, Ae = de.unRegisterMenuInfo, _e = de.selectedSubMenuKeys, xe = de.expandIcon, Te = te != null, Pe = !Q && (useInjectForceRender() || !Te);
    useProvideForceRender(Pe), (Q && Te || !Q && !Te || Pe) && (Se(ne, ce), onBeforeUnmount(function() {
      Ae(ne);
    }));
    var $e = computed(function() {
      return "".concat(ge.value, "-submenu");
    }), Me = computed(function() {
      return ve.value || C.disabled;
    }), Ee = ref(), we = ref(), Oe = computed(function() {
      return Ce.value.includes(re);
    }), Ne = computed(function() {
      return !Ie.value && Oe.value;
    }), ke = computed(function() {
      return _e.value.includes(re);
    }), ze = ref(!1);
    watch(fe, function() {
      ze.value = !!fe.value.find(function(Xe) {
        return Xe === re;
      });
    }, {
      immediate: !0
    });
    var He = function(qe) {
      Me.value || (X("titleClick", qe, re), he.value === "inline" && be(re, !Oe.value));
    }, We = function(qe) {
      Me.value || (pe(le.value), X("mouseenter", qe));
    }, Re = function(qe) {
      Me.value || (pe([]), X("mouseleave", qe));
    }, Le = useDirectionStyle(computed(function() {
      return le.value.length;
    })), De = function(qe) {
      he.value !== "inline" && be(re, qe);
    }, Ue = function() {
      pe(le.value);
    }, st = ne && "".concat(ne, "-popup"), ot = computed(function() {
      return classNames(ge.value, "".concat(ge.value, "-").concat(ye.value), C.popupClassName);
    }), ct = function(qe, dt) {
      if (!dt)
        return me.value && !oe.value.length && qe && typeof qe == "string" ? createVNode$1("div", {
          class: "".concat(ge.value, "-inline-collapsed-noicon")
        }, [qe.charAt(0)]) : createVNode$1("span", {
          class: "".concat(ge.value, "-title-content")
        }, [qe]);
      var gt = isValidElement(qe) && qe.type === "span";
      return createVNode$1(Fragment, null, [cloneElement(dt, {
        class: "".concat(ge.value, "-item-icon")
      }, !1), gt ? qe : createVNode$1("span", {
        class: "".concat(ge.value, "-title-content")
      }, [qe])]);
    }, vt = computed(function() {
      return he.value !== "inline" && le.value.length > 1 ? "vertical" : he.value;
    }), ut = computed(function() {
      return he.value === "horizontal" ? "vertical" : he.value;
    }), at = computed(function() {
      return vt.value === "horizontal" ? "vertical" : vt.value;
    }), Ze = function() {
      var qe = $e.value, dt = getPropsSlot(W, C, "icon"), gt = C.expandIcon || W.expandIcon || xe.value, yt = ct(getPropsSlot(W, C, "title"), dt);
      return createVNode$1("div", {
        style: Le.value,
        class: "".concat(qe, "-title"),
        tabindex: Me.value ? null : -1,
        ref: Ee,
        title: typeof yt == "string" ? yt : null,
        "data-menu-id": re,
        "aria-expanded": Ne.value,
        "aria-haspopup": !0,
        "aria-controls": st,
        "aria-disabled": Me.value,
        onClick: He,
        onFocus: Ue
      }, [yt, he.value !== "horizontal" && gt ? gt(_objectSpread2$1(_objectSpread2$1({}, C), {}, {
        isOpen: Ne.value
      })) : createVNode$1("i", {
        class: "".concat(qe, "-arrow")
      }, null)]);
    };
    return function() {
      var Xe;
      if (Q) {
        var qe;
        return Te ? (qe = W.default) === null || qe === void 0 ? void 0 : qe.call(W) : null;
      }
      var dt = $e.value, gt = function() {
        return null;
      };
      return !Ie.value && he.value !== "inline" ? gt = function() {
        return createVNode$1(PopupTrigger, {
          mode: vt.value,
          prefixCls: dt,
          visible: !C.internalPopupClose && Ne.value,
          popupClassName: ot.value,
          popupOffset: C.popupOffset,
          disabled: Me.value,
          onVisibleChange: De
        }, {
          default: function() {
            return [Ze()];
          },
          popup: function() {
            return createVNode$1(MenuContextProvider, {
              mode: at.value,
              isRootMenu: !1
            }, {
              default: function() {
                return [createVNode$1(SubMenuList, {
                  id: st,
                  ref: we
                }, {
                  default: W.default
                })];
              }
            });
          }
        });
      } : gt = function() {
        return createVNode$1(PopupTrigger, null, {
          default: Ze
        });
      }, createVNode$1(MenuContextProvider, {
        mode: ut.value
      }, {
        default: function() {
          return [createVNode$1(Overflow$1.Item, _objectSpread2$1(_objectSpread2$1({
            component: "li"
          }, Z), {}, {
            role: "none",
            class: classNames(dt, "".concat(dt, "-").concat(he.value), Z.class, (Xe = {}, _defineProperty$A(Xe, "".concat(dt, "-open"), Ne.value), _defineProperty$A(Xe, "".concat(dt, "-active"), ze.value), _defineProperty$A(Xe, "".concat(dt, "-selected"), ke.value), _defineProperty$A(Xe, "".concat(dt, "-disabled"), Me.value), Xe)),
            onMouseenter: We,
            onMouseleave: Re,
            "data-submenu-id": re
          }), {
            default: function() {
              return createVNode$1(Fragment, null, [gt(), !Ie.value && createVNode$1(InlineSubMenuList, {
                id: st,
                open: Ne.value,
                keyPath: le.value
              }, {
                default: W.default
              })]);
            }
          })];
        }
      });
    };
  }
});
function hasClass(H, C) {
  if (H.classList)
    return H.classList.contains(C);
  var G = H.className;
  return " ".concat(G, " ").indexOf(" ".concat(C, " ")) > -1;
}
function addClass(H, C) {
  H.classList ? H.classList.add(C) : hasClass(H, C) || (H.className = "".concat(H.className, " ").concat(C));
}
function removeClass(H, C) {
  if (H.classList)
    H.classList.remove(C);
  else if (hasClass(H, C)) {
    var G = H.className;
    H.className = " ".concat(G, " ").replace(" ".concat(C, " "), " ");
  }
}
var collapseMotion = function() {
  var C = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "ant-motion-collapse", G = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
  return {
    name: C,
    appear: G,
    css: !0,
    onBeforeEnter: function(K) {
      K.style.height = "0px", K.style.opacity = "0", addClass(K, C);
    },
    onEnter: function(K) {
      nextTick(function() {
        K.style.height = "".concat(K.scrollHeight, "px"), K.style.opacity = "1";
      });
    },
    onAfterEnter: function(K) {
      K && (removeClass(K, C), K.style.height = null, K.style.opacity = null);
    },
    onBeforeLeave: function(K) {
      addClass(K, C), K.style.height = "".concat(K.offsetHeight, "px"), K.style.opacity = null;
    },
    onLeave: function(K) {
      setTimeout(function() {
        K.style.height = "0px", K.style.opacity = "0";
      });
    },
    onAfterLeave: function(K) {
      K && (removeClass(K, C), K.style && (K.style.height = null, K.style.opacity = null));
    }
  };
};
const collapseMotion$1 = collapseMotion;
var menuProps = function() {
  return {
    id: String,
    prefixCls: String,
    disabled: Boolean,
    inlineCollapsed: Boolean,
    disabledOverflow: Boolean,
    forceSubMenuRender: Boolean,
    openKeys: Array,
    selectedKeys: Array,
    activeKey: String,
    selectable: {
      type: Boolean,
      default: !0
    },
    multiple: {
      type: Boolean,
      default: !1
    },
    motion: Object,
    theme: {
      type: String,
      default: "light"
    },
    mode: {
      type: String,
      default: "vertical"
    },
    inlineIndent: {
      type: Number,
      default: 24
    },
    subMenuOpenDelay: {
      type: Number,
      default: 0.1
    },
    subMenuCloseDelay: {
      type: Number,
      default: 0.1
    },
    builtinPlacements: {
      type: Object
    },
    triggerSubMenuAction: {
      type: String,
      default: "hover"
    },
    getPopupContainer: Function,
    expandIcon: Function,
    onOpenChange: Function,
    onSelect: Function,
    onDeselect: Function,
    onClick: [Function, Array],
    onFocus: Function,
    onBlur: Function,
    onMousedown: Function,
    "onUpdate:openKeys": Function,
    "onUpdate:selectedKeys": Function,
    "onUpdate:activeKey": Function
  };
}, EMPTY_LIST$2 = [];
const Menu = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AMenu",
  inheritAttrs: !1,
  props: menuProps(),
  slots: ["expandIcon", "overflowedIndicator"],
  setup: function(C, G) {
    var U = G.slots, K = G.emit, W = G.attrs, Z = useConfigInject("menu", C), X = Z.prefixCls, Q = Z.direction, ee = Z.getPrefixCls, te = ref({}), re = inject(SiderCollapsedKey, ref(void 0)), ne = computed(function() {
      return re.value !== void 0 ? re.value : C.inlineCollapsed;
    }), ae = ref(!1);
    onMounted(function() {
      ae.value = !0;
    }), watchEffect(function() {
      devWarning(!(C.inlineCollapsed === !0 && C.mode !== "inline"), "Menu", "`inlineCollapsed` should only be used when `mode` is inline."), devWarning(!(re.value !== void 0 && C.inlineCollapsed === !0), "Menu", "`inlineCollapsed` not control Menu under Sider. Should set `collapsed` on Sider instead.");
    });
    var ie = ref([]), se = ref([]), oe = ref({});
    watch(te, function() {
      for (var we = {}, Oe = 0, Ne = Object.values(te.value); Oe < Ne.length; Oe++) {
        var ke = Ne[Oe];
        we[ke.key] = ke;
      }
      oe.value = we;
    }, {
      flush: "post"
    }), watchEffect(function() {
      if (C.activeKey !== void 0) {
        var we = [], Oe = C.activeKey ? oe.value[C.activeKey] : void 0;
        Oe && C.activeKey !== void 0 ? we = uniq([].concat(unref(Oe.parentKeys), C.activeKey)) : we = [], shallowequal(ie.value, we) || (ie.value = we);
      }
    }), watch(function() {
      return C.selectedKeys;
    }, function(we) {
      we && (se.value = we.slice());
    }, {
      immediate: !0,
      deep: !0
    });
    var le = ref([]);
    watch([oe, se], function() {
      var we = [];
      se.value.forEach(function(Oe) {
        var Ne = oe.value[Oe];
        Ne && (we = we.concat(unref(Ne.parentKeys)));
      }), we = uniq(we), shallowequal(le.value, we) || (le.value = we);
    }, {
      immediate: !0
    });
    var ue = function(Oe) {
      if (C.selectable) {
        var Ne = Oe.key, ke = se.value.includes(Ne), ze;
        C.multiple ? ke ? ze = se.value.filter(function(We) {
          return We !== Ne;
        }) : ze = [].concat(_toConsumableArray(se.value), [Ne]) : ze = [Ne];
        var He = _objectSpread2$1(_objectSpread2$1({}, Oe), {}, {
          selectedKeys: ze
        });
        shallowequal(ze, se.value) || (C.selectedKeys === void 0 && (se.value = ze), K("update:selectedKeys", ze), ke && C.multiple ? K("deselect", He) : K("select", He)), pe.value !== "inline" && !C.multiple && ce.value.length && ye(EMPTY_LIST$2);
      }
    }, ce = ref([]);
    watch(function() {
      return C.openKeys;
    }, function() {
      var we = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ce.value;
      shallowequal(ce.value, we) || (ce.value = we.slice());
    }, {
      immediate: !0,
      deep: !0
    });
    var de, ge = function(Oe) {
      clearTimeout(de), de = setTimeout(function() {
        C.activeKey === void 0 && (ie.value = Oe), K("update:activeKey", Oe[Oe.length - 1]);
      });
    }, fe = computed(function() {
      return !!C.disabled;
    }), ve = computed(function() {
      return Q.value === "rtl";
    }), pe = ref("vertical"), he = ref(!1);
    watchEffect(function() {
      (C.mode === "inline" || C.mode === "vertical") && ne.value ? (pe.value = "vertical", he.value = ne.value) : (pe.value = C.mode, he.value = !1);
    });
    var me = computed(function() {
      return pe.value === "inline";
    }), ye = function(Oe) {
      ce.value = Oe, K("update:openKeys", Oe), K("openChange", Oe);
    }, Ce = ref(ce.value), Ie = ref(!1);
    watch(ce, function() {
      me.value && (Ce.value = ce.value);
    }, {
      immediate: !0
    }), watch(me, function() {
      if (!Ie.value) {
        Ie.value = !0;
        return;
      }
      me.value ? ce.value = Ce.value : ye(EMPTY_LIST$2);
    }, {
      immediate: !0
    });
    var be = computed(function() {
      var we;
      return we = {}, _defineProperty$A(we, "".concat(X.value), !0), _defineProperty$A(we, "".concat(X.value, "-root"), !0), _defineProperty$A(we, "".concat(X.value, "-").concat(pe.value), !0), _defineProperty$A(we, "".concat(X.value, "-inline-collapsed"), he.value), _defineProperty$A(we, "".concat(X.value, "-rtl"), ve.value), _defineProperty$A(we, "".concat(X.value, "-").concat(C.theme), !0), we;
    }), Se = computed(function() {
      return ee();
    }), Ae = computed(function() {
      return {
        horizontal: {
          name: "".concat(Se.value, "-slide-up")
        },
        inline: collapseMotion$1,
        other: {
          name: "".concat(Se.value, "-zoom-big")
        }
      };
    });
    useProvideFirstLevel(!0);
    var _e = function we() {
      var Oe = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], Ne = [], ke = te.value;
      return Oe.forEach(function(ze) {
        var He = ke[ze], We = He.key, Re = He.childrenEventKeys;
        Ne.push.apply(Ne, [We].concat(_toConsumableArray(we(unref(Re)))));
      }), Ne;
    }, xe = function(Oe) {
      K("click", Oe), ue(Oe);
    }, Te = function(Oe, Ne) {
      var ke, ze = ((ke = oe.value[Oe]) === null || ke === void 0 ? void 0 : ke.childrenEventKeys) || [], He = ce.value.filter(function(Re) {
        return Re !== Oe;
      });
      if (Ne)
        He.push(Oe);
      else if (pe.value !== "inline") {
        var We = _e(unref(ze));
        He = uniq(He.filter(function(Re) {
          return !We.includes(Re);
        }));
      }
      shallowequal(ce, He) || ye(He);
    }, Pe = function(Oe, Ne) {
      te.value = _objectSpread2$1(_objectSpread2$1({}, te.value), {}, _defineProperty$A({}, Oe, Ne));
    }, $e = function(Oe) {
      delete te.value[Oe], te.value = _objectSpread2$1({}, te.value);
    }, Me = ref(0), Ee = computed(function() {
      return C.expandIcon || U.expandIcon ? function(we) {
        var Oe = C.expandIcon || U.expandIcon;
        return Oe = typeof Oe == "function" ? Oe(we) : Oe, cloneElement(Oe, {
          class: "".concat(X.value, "-submenu-expand-icon")
        }, !1);
      } : null;
    });
    return useProvideMenu$1({
      store: te,
      prefixCls: X,
      activeKeys: ie,
      openKeys: ce,
      selectedKeys: se,
      changeActiveKeys: ge,
      disabled: fe,
      rtl: ve,
      mode: pe,
      inlineIndent: computed(function() {
        return C.inlineIndent;
      }),
      subMenuCloseDelay: computed(function() {
        return C.subMenuCloseDelay;
      }),
      subMenuOpenDelay: computed(function() {
        return C.subMenuOpenDelay;
      }),
      builtinPlacements: computed(function() {
        return C.builtinPlacements;
      }),
      triggerSubMenuAction: computed(function() {
        return C.triggerSubMenuAction;
      }),
      getPopupContainer: computed(function() {
        return C.getPopupContainer;
      }),
      inlineCollapsed: he,
      antdMenuTheme: computed(function() {
        return C.theme;
      }),
      siderCollapsed: re,
      defaultMotions: computed(function() {
        return ae.value ? Ae.value : null;
      }),
      motion: computed(function() {
        return ae.value ? C.motion : null;
      }),
      overflowDisabled: ref(void 0),
      onOpenChange: Te,
      onItemClick: xe,
      registerMenuInfo: Pe,
      unRegisterMenuInfo: $e,
      selectedSubMenuKeys: le,
      isRootMenu: ref(!0),
      expandIcon: Ee,
      forceSubMenuRender: computed(function() {
        return C.forceSubMenuRender;
      })
    }), function() {
      var we, Oe, Ne = flattenChildren((we = U.default) === null || we === void 0 ? void 0 : we.call(U)), ke = Me.value >= Ne.length - 1 || pe.value !== "horizontal" || C.disabledOverflow, ze = pe.value !== "horizontal" || C.disabledOverflow ? Ne : (
        // Need wrap for overflow dropdown that do not response for open
        Ne.map(function(We, Re) {
          return (
            // Always wrap provider to avoid sub node re-mount
            createVNode$1(MenuContextProvider, {
              key: We.key,
              overflowDisabled: Re > Me.value
            }, {
              default: function() {
                return We;
              }
            })
          );
        })
      ), He = ((Oe = U.overflowedIndicator) === null || Oe === void 0 ? void 0 : Oe.call(U)) || createVNode$1(EllipsisOutlined$1, null, null);
      return createVNode$1(Overflow$1, _objectSpread2$1(_objectSpread2$1({}, W), {}, {
        onMousedown: C.onMousedown,
        prefixCls: "".concat(X.value, "-overflow"),
        component: "ul",
        itemComponent: MenuItem$1,
        class: [be.value, W.class],
        role: "menu",
        id: C.id,
        data: ze,
        renderRawItem: function(Re) {
          return Re;
        },
        renderRawRest: function(Re) {
          var Le = Re.length, De = Le ? Ne.slice(-Le) : null;
          return createVNode$1(Fragment, null, [createVNode$1(SubMenu$1, {
            eventKey: OVERFLOW_KEY,
            key: OVERFLOW_KEY,
            title: He,
            disabled: ke,
            internalPopupClose: Le === 0
          }, {
            default: function() {
              return De;
            }
          }), createVNode$1(PathContext, null, {
            default: function() {
              return [createVNode$1(SubMenu$1, {
                eventKey: OVERFLOW_KEY,
                key: OVERFLOW_KEY,
                title: He,
                disabled: ke,
                internalPopupClose: Le === 0
              }, {
                default: function() {
                  return De;
                }
              })];
            }
          })]);
        },
        maxCount: pe.value !== "horizontal" || C.disabledOverflow ? Overflow$1.INVALIDATE : Overflow$1.RESPONSIVE,
        ssr: "full",
        "data-menu-list": !0,
        onVisibleChange: function(Re) {
          Me.value = Re;
        }
      }), {
        default: function() {
          return [createVNode$1(Teleport, {
            to: "body"
          }, {
            default: function() {
              return [createVNode$1("div", {
                style: {
                  display: "none"
                },
                "aria-hidden": !0
              }, [createVNode$1(PathContext, null, {
                default: function() {
                  return [ze];
                }
              })])];
            }
          })];
        }
      });
    };
  }
});
var menuItemGroupProps = function() {
  return {
    title: PropTypes$1.any
  };
};
const ItemGroup = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AMenuItemGroup",
  inheritAttrs: !1,
  props: menuItemGroupProps(),
  slots: ["title"],
  setup: function(C, G) {
    var U = G.slots, K = G.attrs, W = useInjectMenu(), Z = W.prefixCls, X = computed(function() {
      return "".concat(Z.value, "-item-group");
    }), Q = useMeasure();
    return function() {
      var ee, te;
      return Q ? (ee = U.default) === null || ee === void 0 ? void 0 : ee.call(U) : createVNode$1("li", _objectSpread2$1(_objectSpread2$1({}, K), {}, {
        onClick: function(ne) {
          return ne.stopPropagation();
        },
        class: X.value
      }), [createVNode$1("div", {
        title: typeof C.title == "string" ? C.title : void 0,
        class: "".concat(X.value, "-title")
      }, [getPropsSlot(U, C, "title")]), createVNode$1("ul", {
        class: "".concat(X.value, "-list")
      }, [(te = U.default) === null || te === void 0 ? void 0 : te.call(U)])]);
    };
  }
});
var menuDividerProps = function() {
  return {
    prefixCls: String,
    dashed: Boolean
  };
};
const Divider = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AMenuDivider",
  props: menuDividerProps(),
  setup: function(C) {
    var G = useConfigInject("menu", C), U = G.prefixCls, K = computed(function() {
      var W;
      return W = {}, _defineProperty$A(W, "".concat(U.value, "-item-divider"), !0), _defineProperty$A(W, "".concat(U.value, "-item-divider-dashed"), !!C.dashed), W;
    });
    return function() {
      return createVNode$1("li", {
        class: K.value
      }, null);
    };
  }
});
Menu.install = function(H) {
  return H.component(Menu.name, Menu), H.component(MenuItem$1.name, MenuItem$1), H.component(SubMenu$1.name, SubMenu$1), H.component(Divider.name, Divider), H.component(ItemGroup.name, ItemGroup), H;
};
Menu.Item = MenuItem$1;
Menu.Divider = Divider;
Menu.SubMenu = SubMenu$1;
Menu.ItemGroup = ItemGroup;
var symbolTag = "[object Symbol]";
function isSymbol(H) {
  return typeof H == "symbol" || isObjectLike(H) && baseGetTag(H) == symbolTag;
}
var reWhitespace = /\s/;
function trimmedEndIndex(H) {
  for (var C = H.length; C-- && reWhitespace.test(H.charAt(C)); )
    ;
  return C;
}
var reTrimStart = /^\s+/;
function baseTrim(H) {
  return H && H.slice(0, trimmedEndIndex(H) + 1).replace(reTrimStart, "");
}
var NAN = 0 / 0, reIsBadHex = /^[-+]0x[0-9a-f]+$/i, reIsBinary = /^0b[01]+$/i, reIsOctal = /^0o[0-7]+$/i, freeParseInt = parseInt;
function toNumber(H) {
  if (typeof H == "number")
    return H;
  if (isSymbol(H))
    return NAN;
  if (isObject$4(H)) {
    var C = typeof H.valueOf == "function" ? H.valueOf() : H;
    H = isObject$4(C) ? C + "" : C;
  }
  if (typeof H != "string")
    return H === 0 ? H : +H;
  H = baseTrim(H);
  var G = reIsBinary.test(H);
  return G || reIsOctal.test(H) ? freeParseInt(H.slice(2), G ? 2 : 8) : reIsBadHex.test(H) ? NAN : +H;
}
var _excluded$g = ["prefixCls", "name", "id", "type", "disabled", "readonly", "tabindex", "autofocus", "value", "required"], checkboxProps$1 = {
  prefixCls: String,
  name: String,
  id: String,
  type: String,
  defaultChecked: {
    type: [Boolean, Number],
    default: void 0
  },
  checked: {
    type: [Boolean, Number],
    default: void 0
  },
  disabled: Boolean,
  tabindex: {
    type: [Number, String]
  },
  readonly: Boolean,
  autofocus: Boolean,
  value: PropTypes$1.any,
  required: Boolean
};
const VcCheckbox = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Checkbox",
  inheritAttrs: !1,
  props: initDefaultProps$1(checkboxProps$1, {
    prefixCls: "rc-checkbox",
    type: "checkbox",
    defaultChecked: !1
  }),
  emits: ["click", "change"],
  setup: function(C, G) {
    var U = G.attrs, K = G.emit, W = G.expose, Z = ref(C.checked === void 0 ? C.defaultChecked : C.checked), X = ref();
    watch(function() {
      return C.checked;
    }, function() {
      Z.value = C.checked;
    }), W({
      focus: function() {
        var ne;
        (ne = X.value) === null || ne === void 0 || ne.focus();
      },
      blur: function() {
        var ne;
        (ne = X.value) === null || ne === void 0 || ne.blur();
      }
    });
    var Q = ref(), ee = function(ne) {
      if (!C.disabled) {
        C.checked === void 0 && (Z.value = ne.target.checked), ne.shiftKey = Q.value;
        var ae = {
          target: _objectSpread2$1(_objectSpread2$1({}, C), {}, {
            checked: ne.target.checked
          }),
          stopPropagation: function() {
            ne.stopPropagation();
          },
          preventDefault: function() {
            ne.preventDefault();
          },
          nativeEvent: ne
        };
        C.checked !== void 0 && (X.value.checked = !!C.checked), K("change", ae), Q.value = !1;
      }
    }, te = function(ne) {
      K("click", ne), Q.value = ne.shiftKey;
    };
    return function() {
      var re, ne = C.prefixCls, ae = C.name, ie = C.id, se = C.type, oe = C.disabled, le = C.readonly, ue = C.tabindex, ce = C.autofocus, de = C.value, ge = C.required, fe = _objectWithoutProperties$2(C, _excluded$g), ve = U.class, pe = U.onFocus, he = U.onBlur, me = U.onKeydown, ye = U.onKeypress, Ce = U.onKeyup, Ie = _objectSpread2$1(_objectSpread2$1({}, fe), U), be = Object.keys(Ie).reduce(function(_e, xe) {
        return (xe.substr(0, 5) === "aria-" || xe.substr(0, 5) === "data-" || xe === "role") && (_e[xe] = Ie[xe]), _e;
      }, {}), Se = classNames(ne, ve, (re = {}, _defineProperty$A(re, "".concat(ne, "-checked"), Z.value), _defineProperty$A(re, "".concat(ne, "-disabled"), oe), re)), Ae = _objectSpread2$1(_objectSpread2$1({
        name: ae,
        id: ie,
        type: se,
        readonly: le,
        disabled: oe,
        tabindex: ue,
        class: "".concat(ne, "-input"),
        checked: !!Z.value,
        autofocus: ce,
        value: de
      }, be), {}, {
        onChange: ee,
        onClick: te,
        onFocus: pe,
        onBlur: he,
        onKeydown: me,
        onKeypress: ye,
        onKeyup: Ce,
        required: ge
      });
      return createVNode$1("span", {
        class: Se
      }, [createVNode$1("input", _objectSpread2$1({
        ref: X
      }, Ae), null), createVNode$1("span", {
        class: "".concat(ne, "-inner")
      }, null)]);
    };
  }
});
var _excluded$f = ["prefixCls", "id"], radioProps = function() {
  return {
    prefixCls: String,
    checked: {
      type: Boolean,
      default: void 0
    },
    disabled: {
      type: Boolean,
      default: void 0
    },
    isGroup: {
      type: Boolean,
      default: void 0
    },
    value: PropTypes$1.any,
    name: String,
    id: String,
    autofocus: {
      type: Boolean,
      default: void 0
    },
    onChange: Function,
    onFocus: Function,
    onBlur: Function,
    onClick: Function,
    "onUpdate:checked": Function,
    "onUpdate:value": Function
  };
};
const Radio = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ARadio",
  props: radioProps(),
  // emits: ['update:checked', 'update:value', 'change', 'blur', 'focus'],
  setup: function(C, G) {
    var U = G.emit, K = G.expose, W = G.slots, Z = useInjectFormItemContext(), X = ref(), Q = inject("radioGroupContext", void 0), ee = useConfigInject("radio", C), te = ee.prefixCls, re = ee.direction, ne = function() {
      X.value.focus();
    }, ae = function() {
      X.value.blur();
    };
    K({
      focus: ne,
      blur: ae
    });
    var ie = function(le) {
      var ue = le.target.checked;
      U("update:checked", ue), U("update:value", ue), U("change", le), Z.onFieldChange();
    }, se = function(le) {
      U("change", le), Q && Q.onRadioChange && Q.onRadioChange(le);
    };
    return function() {
      var oe, le = Q;
      C.prefixCls;
      var ue = C.id, ce = ue === void 0 ? Z.id.value : ue, de = _objectWithoutProperties$2(C, _excluded$f), ge = _objectSpread2$1({
        prefixCls: te.value,
        id: ce
      }, omit(de, ["onUpdate:checked", "onUpdate:value"]));
      le ? (ge.name = le.props.name, ge.onChange = se, ge.checked = C.value === le.stateValue.value, ge.disabled = C.disabled || le.props.disabled) : ge.onChange = ie;
      var fe = classNames((oe = {}, _defineProperty$A(oe, "".concat(te.value, "-wrapper"), !0), _defineProperty$A(oe, "".concat(te.value, "-wrapper-checked"), ge.checked), _defineProperty$A(oe, "".concat(te.value, "-wrapper-disabled"), ge.disabled), _defineProperty$A(oe, "".concat(te.value, "-wrapper-rtl"), re.value === "rtl"), oe));
      return createVNode$1("label", {
        class: fe
      }, [createVNode$1(VcCheckbox, _objectSpread2$1(_objectSpread2$1({}, ge), {}, {
        type: "radio",
        ref: X
      }), null), W.default && createVNode$1("span", null, [W.default()])]);
    };
  }
});
var RadioGroupSizeTypes = tuple("large", "default", "small"), radioGroupProps = function() {
  return {
    prefixCls: String,
    value: PropTypes$1.any,
    size: PropTypes$1.oneOf(RadioGroupSizeTypes),
    options: {
      type: Array
    },
    disabled: {
      type: Boolean,
      default: void 0
    },
    name: String,
    buttonStyle: {
      type: String,
      default: "outline"
    },
    id: String,
    optionType: {
      type: String,
      default: "default"
    },
    onChange: Function,
    "onUpdate:value": Function
  };
};
const Group$6 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ARadioGroup",
  props: radioGroupProps(),
  // emits: ['update:value', 'change'],
  setup: function(C, G) {
    var U = G.slots, K = G.emit, W = useInjectFormItemContext(), Z = useConfigInject("radio", C), X = Z.prefixCls, Q = Z.direction, ee = Z.size, te = ref(C.value), re = ref(!1);
    watch(function() {
      return C.value;
    }, function(ae) {
      te.value = ae, re.value = !1;
    });
    var ne = function(ie) {
      var se = te.value, oe = ie.target.value;
      "value" in C || (te.value = oe), !re.value && oe !== se && (re.value = !0, K("update:value", oe), K("change", ie), W.onFieldChange()), nextTick(function() {
        re.value = !1;
      });
    };
    return provide("radioGroupContext", {
      onRadioChange: ne,
      stateValue: te,
      props: C
    }), function() {
      var ae, ie = C.options, se = C.optionType, oe = C.buttonStyle, le = C.id, ue = le === void 0 ? W.id.value : le, ce = "".concat(X.value, "-group"), de = classNames(ce, "".concat(ce, "-").concat(oe), (ae = {}, _defineProperty$A(ae, "".concat(ce, "-").concat(ee.value), ee.value), _defineProperty$A(ae, "".concat(ce, "-rtl"), Q.value === "rtl"), ae)), ge = null;
      if (ie && ie.length > 0) {
        var fe = se === "button" ? "".concat(X.value, "-button") : X.value;
        ge = ie.map(function(pe) {
          if (typeof pe == "string" || typeof pe == "number")
            return createVNode$1(Radio, {
              key: pe,
              prefixCls: fe,
              disabled: C.disabled,
              value: pe,
              checked: te.value === pe
            }, {
              default: function() {
                return [pe];
              }
            });
          var he = pe.value, me = pe.disabled, ye = pe.label;
          return createVNode$1(Radio, {
            key: "radio-group-value-options-".concat(he),
            prefixCls: fe,
            disabled: me || C.disabled,
            value: he,
            checked: te.value === he
          }, {
            default: function() {
              return [ye];
            }
          });
        });
      } else {
        var ve;
        ge = (ve = U.default) === null || ve === void 0 ? void 0 : ve.call(U);
      }
      return createVNode$1("div", {
        class: de,
        id: ue
      }, [ge]);
    };
  }
}), Button = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ARadioButton",
  props: radioProps(),
  setup: function(C, G) {
    var U = G.slots, K = useConfigInject("radio-button", C), W = K.prefixCls, Z = inject("radioGroupContext", void 0);
    return function() {
      var X, Q = _objectSpread2$1(_objectSpread2$1({}, C), {}, {
        prefixCls: W.value
      });
      return Z && (Q.onChange = Z.onRadioChange, Q.checked = Q.value === Z.stateValue.value, Q.disabled = Q.disabled || Z.props.disabled), createVNode$1(Radio, Q, {
        default: function() {
          return [(X = U.default) === null || X === void 0 ? void 0 : X.call(U)];
        }
      });
    };
  }
});
Radio.Group = Group$6;
Radio.Button = Button;
Radio.install = function(H) {
  return H.component(Radio.name, Radio), H.component(Radio.Group.name, Radio.Group), H.component(Radio.Button.name, Radio.Button), H;
};
var isStyleNameSupport = function(C) {
  if (canUseDom() && window.document.documentElement) {
    var G = Array.isArray(C) ? C : [C], U = window.document.documentElement;
    return G.some(function(K) {
      return K in U.style;
    });
  }
  return !1;
}, isStyleValueSupport = function(C, G) {
  if (!isStyleNameSupport(C))
    return !1;
  var U = document.createElement("div"), K = U.style[C];
  return U.style[C] = G, U.style[C] !== K;
};
function isStyleSupport(H, C) {
  return !Array.isArray(H) && C !== void 0 ? isStyleValueSupport(H, C) : isStyleNameSupport(H);
}
var now = function() {
  return root$1.Date.now();
};
const now$1 = now;
var FUNC_ERROR_TEXT = "Expected a function", nativeMax = Math.max, nativeMin = Math.min;
function debounce(H, C, G) {
  var U, K, W, Z, X, Q, ee = 0, te = !1, re = !1, ne = !0;
  if (typeof H != "function")
    throw new TypeError(FUNC_ERROR_TEXT);
  C = toNumber(C) || 0, isObject$4(G) && (te = !!G.leading, re = "maxWait" in G, W = re ? nativeMax(toNumber(G.maxWait) || 0, C) : W, ne = "trailing" in G ? !!G.trailing : ne);
  function ae(fe) {
    var ve = U, pe = K;
    return U = K = void 0, ee = fe, Z = H.apply(pe, ve), Z;
  }
  function ie(fe) {
    return ee = fe, X = setTimeout(le, C), te ? ae(fe) : Z;
  }
  function se(fe) {
    var ve = fe - Q, pe = fe - ee, he = C - ve;
    return re ? nativeMin(he, W - pe) : he;
  }
  function oe(fe) {
    var ve = fe - Q, pe = fe - ee;
    return Q === void 0 || ve >= C || ve < 0 || re && pe >= W;
  }
  function le() {
    var fe = now$1();
    if (oe(fe))
      return ue(fe);
    X = setTimeout(le, se(fe));
  }
  function ue(fe) {
    return X = void 0, ne && U ? ae(fe) : (U = K = void 0, Z);
  }
  function ce() {
    X !== void 0 && clearTimeout(X), ee = 0, U = Q = K = X = void 0;
  }
  function de() {
    return X === void 0 ? Z : ue(now$1());
  }
  function ge() {
    var fe = now$1(), ve = oe(fe);
    if (U = arguments, K = this, Q = fe, ve) {
      if (X === void 0)
        return ie(Q);
      if (re)
        return clearTimeout(X), X = setTimeout(le, C), ae(Q);
    }
    return X === void 0 && (X = setTimeout(le, C)), Z;
  }
  return ge.cancel = ce, ge.flush = de, ge;
}
var TreeContextKey = Symbol("TreeContextKey"), TreeContext = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "TreeContext",
  props: {
    value: {
      type: Object
    }
  },
  setup: function(C, G) {
    var U = G.slots;
    return provide(TreeContextKey, computed(function() {
      return C.value;
    })), function() {
      var K;
      return (K = U.default) === null || K === void 0 ? void 0 : K.call(U);
    };
  }
}), useInjectTreeContext = function() {
  return inject(TreeContextKey, computed(function() {
    return {};
  }));
}, KeysStateKey = Symbol("KeysStateKey"), useProvideKeysState = function(C) {
  provide(KeysStateKey, C);
}, useInjectKeysState = function() {
  return inject(KeysStateKey, {
    expandedKeys: shallowRef([]),
    selectedKeys: shallowRef([]),
    loadedKeys: shallowRef([]),
    loadingKeys: shallowRef([]),
    checkedKeys: shallowRef([]),
    halfCheckedKeys: shallowRef([]),
    expandedKeysSet: computed(function() {
      return /* @__PURE__ */ new Set();
    }),
    selectedKeysSet: computed(function() {
      return /* @__PURE__ */ new Set();
    }),
    loadedKeysSet: computed(function() {
      return /* @__PURE__ */ new Set();
    }),
    loadingKeysSet: computed(function() {
      return /* @__PURE__ */ new Set();
    }),
    checkedKeysSet: computed(function() {
      return /* @__PURE__ */ new Set();
    }),
    halfCheckedKeysSet: computed(function() {
      return /* @__PURE__ */ new Set();
    }),
    flattenNodes: shallowRef([])
  });
}, Indent = function(C) {
  for (var G = C.prefixCls, U = C.level, K = C.isStart, W = C.isEnd, Z = "".concat(G, "-indent-unit"), X = [], Q = 0; Q < U; Q += 1) {
    var ee;
    X.push(createVNode$1("span", {
      key: Q,
      class: (ee = {}, _defineProperty$A(ee, Z, !0), _defineProperty$A(ee, "".concat(Z, "-start"), K[Q]), _defineProperty$A(ee, "".concat(Z, "-end"), W[Q]), ee)
    }, null));
  }
  return createVNode$1("span", {
    "aria-hidden": "true",
    class: "".concat(G, "-indent")
  }, [X]);
};
const Indent$1 = Indent;
var treeNodeProps = {
  eventKey: [String, Number],
  prefixCls: String,
  // By parent
  // expanded: { type: Boolean, default: undefined },
  // selected: { type: Boolean, default: undefined },
  // checked: { type: Boolean, default: undefined },
  // loaded: { type: Boolean, default: undefined },
  // loading: { type: Boolean, default: undefined },
  // halfChecked: { type: Boolean, default: undefined },
  // dragOver: { type: Boolean, default: undefined },
  // dragOverGapTop: { type: Boolean, default: undefined },
  // dragOverGapBottom: { type: Boolean, default: undefined },
  // pos: String,
  title: PropTypes$1.any,
  /** New added in Tree for easy data access */
  data: {
    type: Object,
    default: void 0
  },
  parent: {
    type: Object,
    default: void 0
  },
  isStart: {
    type: Array
  },
  isEnd: {
    type: Array
  },
  active: {
    type: Boolean,
    default: void 0
  },
  onMousemove: {
    type: Function
  },
  // By user
  isLeaf: {
    type: Boolean,
    default: void 0
  },
  checkable: {
    type: Boolean,
    default: void 0
  },
  selectable: {
    type: Boolean,
    default: void 0
  },
  disabled: {
    type: Boolean,
    default: void 0
  },
  disableCheckbox: {
    type: Boolean,
    default: void 0
  },
  icon: PropTypes$1.any,
  switcherIcon: PropTypes$1.any,
  domRef: {
    type: Function
  }
}, nodeListProps = {
  prefixCls: {
    type: String
  },
  // data: { type: Array as PropType<FlattenNode[]> },
  motion: {
    type: Object
  },
  focusable: {
    type: Boolean
  },
  activeItem: {
    type: Object
  },
  focused: {
    type: Boolean
  },
  tabindex: {
    type: Number
  },
  checkable: {
    type: Boolean
  },
  selectable: {
    type: Boolean
  },
  disabled: {
    type: Boolean
  },
  // expandedKeys: { type: Array as PropType<Key[]> },
  // selectedKeys: { type: Array as PropType<Key[]> },
  // checkedKeys: { type: Array as PropType<Key[]> },
  // loadedKeys: { type: Array as PropType<Key[]> },
  // loadingKeys: { type: Array as PropType<Key[]> },
  // halfCheckedKeys: { type: Array as PropType<Key[]> },
  // keyEntities: { type: Object as PropType<Record<Key, DataEntity<DataNode>>> },
  // dragging: { type: Boolean as PropType<boolean> },
  // dragOverNodeKey: { type: [String, Number] as PropType<Key> },
  // dropPosition: { type: Number as PropType<number> },
  // Virtual list
  height: {
    type: Number
  },
  itemHeight: {
    type: Number
  },
  virtual: {
    type: Boolean
  },
  onScroll: {
    type: Function
  },
  onKeydown: {
    type: Function
  },
  onFocus: {
    type: Function
  },
  onBlur: {
    type: Function
  },
  onActiveChange: {
    type: Function
  },
  onContextmenu: {
    type: Function
  },
  onListChangeStart: {
    type: Function
  },
  onListChangeEnd: {
    type: Function
  }
}, treeProps$1 = function() {
  return {
    prefixCls: String,
    focusable: {
      type: Boolean,
      default: void 0
    },
    activeKey: [Number, String],
    tabindex: Number,
    children: PropTypes$1.any,
    treeData: {
      type: Array
    },
    fieldNames: {
      type: Object
    },
    showLine: {
      type: [Boolean, Object],
      default: void 0
    },
    showIcon: {
      type: Boolean,
      default: void 0
    },
    icon: PropTypes$1.any,
    selectable: {
      type: Boolean,
      default: void 0
    },
    disabled: {
      type: Boolean,
      default: void 0
    },
    multiple: {
      type: Boolean,
      default: void 0
    },
    checkable: {
      type: Boolean,
      default: void 0
    },
    checkStrictly: {
      type: Boolean,
      default: void 0
    },
    draggable: {
      type: [Function, Boolean]
    },
    defaultExpandParent: {
      type: Boolean,
      default: void 0
    },
    autoExpandParent: {
      type: Boolean,
      default: void 0
    },
    defaultExpandAll: {
      type: Boolean,
      default: void 0
    },
    defaultExpandedKeys: {
      type: Array
    },
    expandedKeys: {
      type: Array
    },
    defaultCheckedKeys: {
      type: Array
    },
    checkedKeys: {
      type: [Object, Array]
    },
    defaultSelectedKeys: {
      type: Array
    },
    selectedKeys: {
      type: Array
    },
    allowDrop: {
      type: Function
    },
    dropIndicatorRender: {
      type: Function
    },
    onFocus: {
      type: Function
    },
    onBlur: {
      type: Function
    },
    onKeydown: {
      type: Function
    },
    onContextmenu: {
      type: Function
    },
    onClick: {
      type: Function
    },
    onDblclick: {
      type: Function
    },
    onScroll: {
      type: Function
    },
    onExpand: {
      type: Function
    },
    onCheck: {
      type: Function
    },
    onSelect: {
      type: Function
    },
    onLoad: {
      type: Function
    },
    loadData: {
      type: Function
    },
    loadedKeys: {
      type: Array
    },
    onMouseenter: {
      type: Function
    },
    onMouseleave: {
      type: Function
    },
    onRightClick: {
      type: Function
    },
    onDragstart: {
      type: Function
    },
    onDragenter: {
      type: Function
    },
    onDragover: {
      type: Function
    },
    onDragleave: {
      type: Function
    },
    onDragend: {
      type: Function
    },
    onDrop: {
      type: Function
    },
    /**
     * Used for `rc-tree-select` only.
     * Do not use in your production code directly since this will be refactor.
     */
    onActiveChange: {
      type: Function
    },
    filterTreeNode: {
      type: Function
    },
    motion: PropTypes$1.any,
    switcherIcon: PropTypes$1.any,
    // Virtual List
    height: Number,
    itemHeight: Number,
    virtual: {
      type: Boolean,
      default: void 0
    },
    // direction for drag logic
    direction: {
      type: String
    }
  };
}, _excluded$e = ["eventKey", "isLeaf", "isStart", "isEnd", "domRef", "active", "data", "onMousemove", "selectable"], ICON_OPEN = "open", ICON_CLOSE = "close", defaultTitle = "---";
const VcTreeNode = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "TreeNode",
  inheritAttrs: !1,
  props: treeNodeProps,
  isTreeNode: 1,
  slots: ["title", "icon", "switcherIcon"],
  setup: function(C, G) {
    var U = G.attrs, K = G.slots, W = G.expose;
    warning$2(!("slots" in C.data), "treeData slots is deprecated, please use ".concat(Object.keys(C.data.slots || {}).map(function(nt) {
      return "`v-slot:" + nt + "` ";
    }), "instead"));
    var Z = ref(!1), X = useInjectTreeContext(), Q = useInjectKeysState(), ee = Q.expandedKeysSet, te = Q.selectedKeysSet, re = Q.loadedKeysSet, ne = Q.loadingKeysSet, ae = Q.checkedKeysSet, ie = Q.halfCheckedKeysSet, se = X.value, oe = se.dragOverNodeKey, le = se.dropPosition, ue = se.keyEntities, ce = computed(function() {
      return getTreeNodeProps(C.eventKey, {
        expandedKeysSet: ee.value,
        selectedKeysSet: te.value,
        loadedKeysSet: re.value,
        loadingKeysSet: ne.value,
        checkedKeysSet: ae.value,
        halfCheckedKeysSet: ie.value,
        dragOverNodeKey: oe,
        dropPosition: le,
        keyEntities: ue
      });
    }), de = eagerComputed(function() {
      return ce.value.expanded;
    }), ge = eagerComputed(function() {
      return ce.value.selected;
    }), fe = eagerComputed(function() {
      return ce.value.checked;
    }), ve = eagerComputed(function() {
      return ce.value.loaded;
    }), pe = eagerComputed(function() {
      return ce.value.loading;
    }), he = eagerComputed(function() {
      return ce.value.halfChecked;
    }), me = eagerComputed(function() {
      return ce.value.dragOver;
    }), ye = eagerComputed(function() {
      return ce.value.dragOverGapTop;
    }), Ce = eagerComputed(function() {
      return ce.value.dragOverGapBottom;
    }), Ie = eagerComputed(function() {
      return ce.value.pos;
    }), be = ref(), Se = computed(function() {
      var nt = C.eventKey, Ke = X.value.keyEntities, Qe = Ke[nt] || {}, pt = Qe.children;
      return !!(pt || []).length;
    }), Ae = computed(function() {
      var nt = C.isLeaf, Ke = X.value.loadData, Qe = Se.value;
      return nt === !1 ? !1 : nt || !Ke && !Qe || Ke && ve.value && !Qe;
    }), _e = computed(function() {
      return Ae.value ? null : de.value ? ICON_OPEN : ICON_CLOSE;
    }), xe = computed(function() {
      var nt = C.disabled, Ke = X.value.disabled;
      return !!(Ke || nt);
    }), Te = computed(function() {
      var nt = C.checkable, Ke = X.value.checkable;
      return !Ke || nt === !1 ? !1 : Ke;
    }), Pe = computed(function() {
      var nt = C.selectable, Ke = X.value.selectable;
      return typeof nt == "boolean" ? nt : Ke;
    }), $e = computed(function() {
      var nt = C.data, Ke = C.active, Qe = C.checkable, pt = C.disableCheckbox, Ye = C.disabled, Fe = C.selectable;
      return _objectSpread2$1(_objectSpread2$1({
        active: Ke,
        checkable: Qe,
        disableCheckbox: pt,
        disabled: Ye,
        selectable: Fe
      }, nt), {}, {
        dataRef: nt,
        data: nt,
        isLeaf: Ae.value,
        checked: fe.value,
        expanded: de.value,
        loading: pe.value,
        selected: ge.value,
        halfChecked: he.value
      });
    }), Me = getCurrentInstance(), Ee = computed(function() {
      var nt = C.eventKey, Ke = X.value.keyEntities, Qe = Ke[nt] || {}, pt = Qe.parent;
      return _objectSpread2$1(_objectSpread2$1({}, convertNodePropsToEventData(_extends({}, C, ce.value))), {}, {
        parent: pt
      });
    }), we = reactive({
      eventData: Ee,
      eventKey: computed(function() {
        return C.eventKey;
      }),
      selectHandle: be,
      pos: Ie,
      key: Me.vnode.key
    });
    W(we);
    var Oe = function(Ke) {
      var Qe = X.value.onNodeDoubleClick;
      Qe(Ke, Ee.value);
    }, Ne = function(Ke) {
      if (!xe.value) {
        var Qe = X.value.onNodeSelect;
        Ke.preventDefault(), Qe(Ke, Ee.value);
      }
    }, ke = function(Ke) {
      if (!xe.value) {
        var Qe = C.disableCheckbox, pt = X.value.onNodeCheck;
        if (!(!Te.value || Qe)) {
          Ke.preventDefault();
          var Ye = !fe.value;
          pt(Ke, Ee.value, Ye);
        }
      }
    }, ze = function(Ke) {
      var Qe = X.value.onNodeClick;
      Qe(Ke, Ee.value), Pe.value ? Ne(Ke) : ke(Ke);
    }, He = function(Ke) {
      var Qe = X.value.onNodeMouseEnter;
      Qe(Ke, Ee.value);
    }, We = function(Ke) {
      var Qe = X.value.onNodeMouseLeave;
      Qe(Ke, Ee.value);
    }, Re = function(Ke) {
      var Qe = X.value.onNodeContextMenu;
      Qe(Ke, Ee.value);
    }, Le = function(Ke) {
      var Qe = X.value.onNodeDragStart;
      Ke.stopPropagation(), Z.value = !0, Qe(Ke, we);
      try {
        Ke.dataTransfer.setData("text/plain", "");
      } catch {
      }
    }, De = function(Ke) {
      var Qe = X.value.onNodeDragEnter;
      Ke.preventDefault(), Ke.stopPropagation(), Qe(Ke, we);
    }, Ue = function(Ke) {
      var Qe = X.value.onNodeDragOver;
      Ke.preventDefault(), Ke.stopPropagation(), Qe(Ke, we);
    }, st = function(Ke) {
      var Qe = X.value.onNodeDragLeave;
      Ke.stopPropagation(), Qe(Ke, we);
    }, ot = function(Ke) {
      var Qe = X.value.onNodeDragEnd;
      Ke.stopPropagation(), Z.value = !1, Qe(Ke, we);
    }, ct = function(Ke) {
      var Qe = X.value.onNodeDrop;
      Ke.preventDefault(), Ke.stopPropagation(), Z.value = !1, Qe(Ke, we);
    }, vt = function(Ke) {
      var Qe = X.value.onNodeExpand;
      pe.value || Qe(Ke, Ee.value);
    }, ut = function() {
      var Ke = C.data, Qe = X.value.draggable;
      return !!(Qe && (!Qe.nodeDraggable || Qe.nodeDraggable(Ke)));
    }, at = function() {
      var Ke = X.value, Qe = Ke.draggable, pt = Ke.prefixCls;
      return Qe != null && Qe.icon ? createVNode$1("span", {
        class: "".concat(pt, "-draggable-icon")
      }, [Qe.icon]) : null;
    }, Ze = function() {
      var Ke, Qe, pt, Ye = C.switcherIcon, Fe = Ye === void 0 ? K.switcherIcon || ((Ke = X.value.slots) === null || Ke === void 0 ? void 0 : Ke[(Qe = C.data) === null || Qe === void 0 || (pt = Qe.slots) === null || pt === void 0 ? void 0 : pt.switcherIcon]) : Ye, Be = X.value.switcherIcon, je = Fe || Be;
      return typeof je == "function" ? je($e.value) : je;
    }, Xe = function() {
      var Ke = X.value, Qe = Ke.loadData, pt = Ke.onNodeLoad;
      pe.value || Qe && de.value && !Ae.value && !Se.value && !ve.value && pt(Ee.value);
    };
    onMounted(function() {
      Xe();
    }), onUpdated(function() {
      Xe();
    });
    var qe = function() {
      var Ke = X.value.prefixCls, Qe = Ze();
      if (Ae.value)
        return Qe !== !1 ? createVNode$1("span", {
          class: classNames("".concat(Ke, "-switcher"), "".concat(Ke, "-switcher-noop"))
        }, [Qe]) : null;
      var pt = classNames("".concat(Ke, "-switcher"), "".concat(Ke, "-switcher_").concat(de.value ? ICON_OPEN : ICON_CLOSE));
      return Qe !== !1 ? createVNode$1("span", {
        onClick: vt,
        class: pt
      }, [Qe]) : null;
    }, dt = function() {
      var Ke, Qe, pt = C.disableCheckbox, Ye = X.value.prefixCls, Fe = xe.value, Be = Te.value;
      return Be ? createVNode$1("span", {
        class: classNames("".concat(Ye, "-checkbox"), fe.value && "".concat(Ye, "-checkbox-checked"), !fe.value && he.value && "".concat(Ye, "-checkbox-indeterminate"), (Fe || pt) && "".concat(Ye, "-checkbox-disabled")),
        onClick: ke
      }, [(Ke = (Qe = X.value).customCheckable) === null || Ke === void 0 ? void 0 : Ke.call(Qe)]) : null;
    }, gt = function() {
      var Ke = X.value.prefixCls;
      return createVNode$1("span", {
        class: classNames("".concat(Ke, "-iconEle"), "".concat(Ke, "-icon__").concat(_e.value || "docu"), pe.value && "".concat(Ke, "-icon_loading"))
      }, null);
    }, yt = function() {
      var Ke = C.disabled, Qe = C.eventKey, pt = X.value, Ye = pt.draggable, Fe = pt.dropLevelOffset, Be = pt.dropPosition, je = pt.prefixCls, Je = pt.indent, it = pt.dropIndicatorRender, et = pt.dragOverNodeKey, Ve = pt.direction, Ge = Ye !== !1, tt = !Ke && Ge && et === Qe;
      return tt ? it({
        dropPosition: Be,
        dropLevelOffset: Fe,
        indent: Je,
        prefixCls: je,
        direction: Ve
      }) : null;
    }, At = function() {
      var Ke, Qe, pt, Ye, Fe = C.icon, Be = Fe === void 0 ? K.icon : Fe, je = C.data, Je = K.title || ((Ke = X.value.slots) === null || Ke === void 0 ? void 0 : Ke[(Qe = C.data) === null || Qe === void 0 || (pt = Qe.slots) === null || pt === void 0 ? void 0 : pt.title]) || ((Ye = X.value.slots) === null || Ye === void 0 ? void 0 : Ye.title) || C.title, it = X.value, et = it.prefixCls, Ve = it.showIcon, Ge = it.icon, tt = it.loadData, ft = xe.value, mt = "".concat(et, "-node-content-wrapper"), ht;
      if (Ve) {
        var St, Ct, bt = Be || ((St = X.value.slots) === null || St === void 0 ? void 0 : St[je == null || (Ct = je.slots) === null || Ct === void 0 ? void 0 : Ct.icon]) || Ge;
        ht = bt ? createVNode$1("span", {
          class: classNames("".concat(et, "-iconEle"), "".concat(et, "-icon__customize"))
        }, [typeof bt == "function" ? bt($e.value) : bt]) : gt();
      } else
        tt && pe.value && (ht = gt());
      var xt;
      typeof Je == "function" ? xt = Je($e.value) : xt = Je, xt = xt === void 0 ? defaultTitle : xt;
      var It = createVNode$1("span", {
        class: "".concat(et, "-title")
      }, [xt]);
      return createVNode$1("span", {
        ref: be,
        title: typeof Je == "string" ? Je : "",
        class: classNames("".concat(mt), "".concat(mt, "-").concat(_e.value || "normal"), !ft && (ge.value || Z.value) && "".concat(et, "-node-selected")),
        onMouseenter: He,
        onMouseleave: We,
        onContextmenu: Re,
        onClick: ze,
        onDblclick: Oe
      }, [ht, It, yt()]);
    };
    return function() {
      var nt, Ke = _objectSpread2$1(_objectSpread2$1({}, C), U), Qe = Ke.eventKey, pt = Ke.isLeaf, Ye = Ke.isStart, Fe = Ke.isEnd, Be = Ke.domRef, je = Ke.active;
      Ke.data;
      var Je = Ke.onMousemove, it = Ke.selectable, et = _objectWithoutProperties$2(Ke, _excluded$e), Ve = X.value, Ge = Ve.prefixCls, tt = Ve.filterTreeNode, ft = Ve.keyEntities, mt = Ve.dropContainerKey, ht = Ve.dropTargetKey, St = Ve.draggingNodeKey, Ct = xe.value, bt = pickAttrs(et, {
        aria: !0,
        data: !0
      }), xt = ft[Qe] || {}, It = xt.level, Tt = Fe[Fe.length - 1], _t = ut(), wt = !Ct && _t, Mt = St === Qe, Ot = it !== void 0 ? {
        "aria-selected": !!it
      } : void 0;
      return createVNode$1("div", _objectSpread2$1(_objectSpread2$1({
        ref: Be,
        class: classNames(U.class, "".concat(Ge, "-treenode"), (nt = {}, _defineProperty$A(nt, "".concat(Ge, "-treenode-disabled"), Ct), _defineProperty$A(nt, "".concat(Ge, "-treenode-switcher-").concat(de.value ? "open" : "close"), !pt), _defineProperty$A(nt, "".concat(Ge, "-treenode-checkbox-checked"), fe.value), _defineProperty$A(nt, "".concat(Ge, "-treenode-checkbox-indeterminate"), he.value), _defineProperty$A(nt, "".concat(Ge, "-treenode-selected"), ge.value), _defineProperty$A(nt, "".concat(Ge, "-treenode-loading"), pe.value), _defineProperty$A(nt, "".concat(Ge, "-treenode-active"), je), _defineProperty$A(nt, "".concat(Ge, "-treenode-leaf-last"), Tt), _defineProperty$A(nt, "".concat(Ge, "-treenode-draggable"), wt), _defineProperty$A(nt, "dragging", Mt), _defineProperty$A(nt, "drop-target", ht === Qe), _defineProperty$A(nt, "drop-container", mt === Qe), _defineProperty$A(nt, "drag-over", !Ct && me.value), _defineProperty$A(nt, "drag-over-gap-top", !Ct && ye.value), _defineProperty$A(nt, "drag-over-gap-bottom", !Ct && Ce.value), _defineProperty$A(nt, "filter-node", tt && tt(Ee.value)), nt)),
        style: U.style,
        draggable: wt,
        "aria-grabbed": Mt,
        onDragstart: wt ? Le : void 0,
        onDragenter: _t ? De : void 0,
        onDragover: _t ? Ue : void 0,
        onDragleave: _t ? st : void 0,
        onDrop: _t ? ct : void 0,
        onDragend: _t ? ot : void 0,
        onMousemove: Je
      }, Ot), bt), [createVNode$1(Indent$1, {
        prefixCls: Ge,
        level: It,
        isStart: Ye,
        isEnd: Fe
      }, null), at(), qe(), dt(), At()]);
    };
  }
});
function arrDel(H, C) {
  if (!H)
    return [];
  var G = H.slice(), U = G.indexOf(C);
  return U >= 0 && G.splice(U, 1), G;
}
function arrAdd(H, C) {
  var G = (H || []).slice();
  return G.indexOf(C) === -1 && G.push(C), G;
}
function posToArr(H) {
  return H.split("-");
}
function getPosition(H, C) {
  return "".concat(H, "-").concat(C);
}
function isTreeNode(H) {
  return H && H.type && H.type.isTreeNode;
}
function getDragChildrenKeys(H, C) {
  var G = [], U = C[H];
  function K() {
    var W = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    W.forEach(function(Z) {
      var X = Z.key, Q = Z.children;
      G.push(X), K(Q);
    });
  }
  return K(U.children), G;
}
function isLastChild(H) {
  if (H.parent) {
    var C = posToArr(H.pos);
    return Number(C[C.length - 1]) === H.parent.children.length - 1;
  }
  return !1;
}
function isFirstChild(H) {
  var C = posToArr(H.pos);
  return Number(C[C.length - 1]) === 0;
}
function calcDropPosition(H, C, G, U, K, W, Z, X, Q, ee) {
  var te, re = H.clientX, ne = H.clientY, ae = H.target.getBoundingClientRect(), ie = ae.top, se = ae.height, oe = (ee === "rtl" ? -1 : 1) * (((K == null ? void 0 : K.x) || 0) - re), le = (oe - 12) / U, ue = X[G.eventKey];
  if (ne < ie + se / 2) {
    var ce = Z.findIndex(function(Se) {
      return Se.key === ue.key;
    }), de = ce <= 0 ? 0 : ce - 1, ge = Z[de].key;
    ue = X[ge];
  }
  var fe = ue.key, ve = ue, pe = ue.key, he = 0, me = 0;
  if (!Q.has(fe))
    for (var ye = 0; ye < le && isLastChild(ue); ye += 1)
      ue = ue.parent, me += 1;
  var Ce = C.eventData, Ie = ue.node, be = !0;
  return isFirstChild(ue) && ue.level === 0 && ne < ie + se / 2 && W({
    dragNode: Ce,
    dropNode: Ie,
    dropPosition: -1
  }) && ue.key === G.eventKey ? he = -1 : (ve.children || []).length && Q.has(pe) ? W({
    dragNode: Ce,
    dropNode: Ie,
    dropPosition: 0
  }) ? he = 0 : be = !1 : me === 0 ? le > -1.5 ? W({
    dragNode: Ce,
    dropNode: Ie,
    dropPosition: 1
  }) ? he = 1 : be = !1 : W({
    dragNode: Ce,
    dropNode: Ie,
    dropPosition: 0
  }) ? he = 0 : W({
    dragNode: Ce,
    dropNode: Ie,
    dropPosition: 1
  }) ? he = 1 : be = !1 : W({
    dragNode: Ce,
    dropNode: Ie,
    dropPosition: 1
  }) ? he = 1 : be = !1, {
    dropPosition: he,
    dropLevelOffset: me,
    dropTargetKey: ue.key,
    dropTargetPos: ue.pos,
    dragOverNodeKey: pe,
    dropContainerKey: he === 0 ? null : ((te = ue.parent) === null || te === void 0 ? void 0 : te.key) || null,
    dropAllowed: be
  };
}
function calcSelectedKeys(H, C) {
  if (H) {
    var G = C.multiple;
    return G ? H.slice() : H.length ? [H[0]] : H;
  }
}
function parseCheckedKeys(H) {
  if (!H)
    return null;
  var C;
  if (Array.isArray(H))
    C = {
      checkedKeys: H,
      halfCheckedKeys: void 0
    };
  else if (_typeof$2(H) === "object")
    C = {
      checkedKeys: H.checked || void 0,
      halfCheckedKeys: H.halfChecked || void 0
    };
  else
    return warning$2(!1, "`checkedKeys` is not an array or an object"), null;
  return C;
}
function conductExpandParent(H, C) {
  var G = /* @__PURE__ */ new Set();
  function U(K) {
    if (!G.has(K)) {
      var W = C[K];
      if (W) {
        G.add(K);
        var Z = W.parent, X = W.node;
        X.disabled || Z && U(Z.key);
      }
    }
  }
  return (H || []).forEach(function(K) {
    U(K);
  }), _toConsumableArray(G);
}
var _excluded$d = ["title", "icon", "switcherIcon"];
function getKey$1(H, C) {
  return H ?? C;
}
function fillFieldNames(H) {
  var C = H || {}, G = C.title, U = C._title, K = C.key, W = C.children, Z = G || "title";
  return {
    title: Z,
    _title: U || [Z],
    key: K || "key",
    children: W || "children"
  };
}
function convertTreeToData(H) {
  function C() {
    var G = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], U = filterEmpty(G);
    return U.map(function(K) {
      var W, Z, X, Q;
      if (!isTreeNode(K))
        return warning$2(!K, "Tree/TreeNode can only accept TreeNode as children."), null;
      for (var ee = K.children || {}, te = K.key, re = {}, ne = 0, ae = Object.entries(K.props); ne < ae.length; ne++) {
        var ie = _slicedToArray$2(ae[ne], 2), se = ie[0], oe = ie[1];
        re[camelize$1(se)] = oe;
      }
      var le = re.isLeaf, ue = re.checkable, ce = re.selectable, de = re.disabled, ge = re.disableCheckbox, fe = {
        isLeaf: le || le === "" || void 0,
        checkable: ue || ue === "" || void 0,
        selectable: ce || ce === "" || void 0,
        disabled: de || de === "" || void 0,
        disableCheckbox: ge || ge === "" || void 0
      }, ve = _objectSpread2$1(_objectSpread2$1({}, re), fe), pe = re.title, he = pe === void 0 ? (W = ee.title) === null || W === void 0 ? void 0 : W.call(ee, ve) : pe, me = re.icon, ye = me === void 0 ? (Z = ee.icon) === null || Z === void 0 ? void 0 : Z.call(ee, ve) : me, Ce = re.switcherIcon, Ie = Ce === void 0 ? (X = ee.switcherIcon) === null || X === void 0 ? void 0 : X.call(ee, ve) : Ce, be = _objectWithoutProperties$2(re, _excluded$d), Se = (Q = ee.default) === null || Q === void 0 ? void 0 : Q.call(ee), Ae = _objectSpread2$1(_objectSpread2$1({}, be), {}, {
        title: he,
        icon: ye,
        switcherIcon: Ie,
        key: te,
        isLeaf: le
      }, fe), _e = C(Se);
      return _e.length && (Ae.children = _e), Ae;
    });
  }
  return C(H);
}
function flattenTreeData(H, C, G) {
  var U = fillFieldNames(G), K = U._title, W = U.key, Z = U.children, X = new Set(C === !0 ? [] : C), Q = [];
  function ee(te) {
    var re = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    return te.map(function(ne, ae) {
      for (var ie = getPosition(re ? re.pos : "0", ae), se = getKey$1(ne[W], ie), oe, le = 0; le < K.length; le += 1) {
        var ue = K[le];
        if (ne[ue] !== void 0) {
          oe = ne[ue];
          break;
        }
      }
      var ce = _objectSpread2$1(_objectSpread2$1({}, omit(ne, [].concat(_toConsumableArray(K), [W, Z]))), {}, {
        title: oe,
        key: se,
        parent: re,
        pos: ie,
        children: null,
        data: ne,
        isStart: [].concat(_toConsumableArray(re ? re.isStart : []), [ae === 0]),
        isEnd: [].concat(_toConsumableArray(re ? re.isEnd : []), [ae === te.length - 1])
      });
      return Q.push(ce), C === !0 || X.has(se) ? ce.children = ee(ne[Z] || [], ce) : ce.children = [], ce;
    });
  }
  return ee(H), Q;
}
function traverseDataNodes(H, C, G) {
  var U = {};
  _typeof$2(G) === "object" ? U = G : U = {
    externalGetKey: G
  }, U = U || {};
  var K = U, W = K.childrenPropName, Z = K.externalGetKey, X = K.fieldNames, Q = fillFieldNames(X), ee = Q.key, te = Q.children, re = W || te, ne;
  Z ? typeof Z == "string" ? ne = function(se) {
    return se[Z];
  } : typeof Z == "function" && (ne = function(se) {
    return Z(se);
  }) : ne = function(se, oe) {
    return getKey$1(se[ee], oe);
  };
  function ae(ie, se, oe, le) {
    var ue = ie ? ie[re] : H, ce = ie ? getPosition(oe.pos, se) : "0", de = ie ? [].concat(_toConsumableArray(le), [ie]) : [];
    if (ie) {
      var ge = ne(ie, ce), fe = {
        node: ie,
        index: se,
        pos: ce,
        key: ge,
        parentPos: oe.node ? oe.pos : null,
        level: oe.level + 1,
        nodes: de
      };
      C(fe);
    }
    ue && ue.forEach(function(ve, pe) {
      ae(ve, pe, {
        node: ie,
        pos: ce,
        level: oe ? oe.level + 1 : -1
      }, de);
    });
  }
  ae(null);
}
function convertDataToEntities(H) {
  var C = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, G = C.initWrapper, U = C.processEntity, K = C.onProcessFinished, W = C.externalGetKey, Z = C.childrenPropName, X = C.fieldNames, Q = arguments.length > 2 ? arguments[2] : void 0, ee = W || Q, te = {}, re = {}, ne = {
    posEntities: te,
    keyEntities: re
  };
  return G && (ne = G(ne) || ne), traverseDataNodes(H, function(ae) {
    var ie = ae.node, se = ae.index, oe = ae.pos, le = ae.key, ue = ae.parentPos, ce = ae.level, de = ae.nodes, ge = {
      node: ie,
      nodes: de,
      index: se,
      key: le,
      pos: oe,
      level: ce
    }, fe = getKey$1(le, oe);
    te[oe] = ge, re[fe] = ge, ge.parent = te[ue], ge.parent && (ge.parent.children = ge.parent.children || [], ge.parent.children.push(ge)), U && U(ge, ne);
  }, {
    externalGetKey: ee,
    childrenPropName: Z,
    fieldNames: X
  }), K && K(ne), ne;
}
function getTreeNodeProps(H, C) {
  var G = C.expandedKeysSet, U = C.selectedKeysSet, K = C.loadedKeysSet, W = C.loadingKeysSet, Z = C.checkedKeysSet, X = C.halfCheckedKeysSet, Q = C.dragOverNodeKey, ee = C.dropPosition, te = C.keyEntities, re = te[H], ne = {
    eventKey: H,
    expanded: G.has(H),
    selected: U.has(H),
    loaded: K.has(H),
    loading: W.has(H),
    checked: Z.has(H),
    halfChecked: X.has(H),
    pos: String(re ? re.pos : ""),
    parent: re.parent,
    // [Legacy] Drag props
    // Since the interaction of drag is changed, the semantic of the props are
    // not accuracy, I think it should be finally removed
    dragOver: Q === H && ee === 0,
    dragOverGapTop: Q === H && ee === -1,
    dragOverGapBottom: Q === H && ee === 1
  };
  return ne;
}
function convertNodePropsToEventData(H) {
  var C = H.data, G = H.expanded, U = H.selected, K = H.checked, W = H.loaded, Z = H.loading, X = H.halfChecked, Q = H.dragOver, ee = H.dragOverGapTop, te = H.dragOverGapBottom, re = H.pos, ne = H.active, ae = H.eventKey, ie = _objectSpread2$1(_objectSpread2$1({
    dataRef: C
  }, C), {}, {
    expanded: G,
    selected: U,
    checked: K,
    loaded: W,
    loading: Z,
    halfChecked: X,
    dragOver: Q,
    dragOverGapTop: ee,
    dragOverGapBottom: te,
    pos: re,
    active: ne,
    eventKey: ae,
    key: ae
  });
  return "props" in ie || Object.defineProperty(ie, "props", {
    get: function() {
      return warning$2(!1, "Second param return from event is node data instead of TreeNode instance. Please read value directly instead of reading from `props`."), H;
    }
  }), ie;
}
function removeFromCheckedKeys(H, C) {
  var G = /* @__PURE__ */ new Set();
  return H.forEach(function(U) {
    C.has(U) || G.add(U);
  }), G;
}
function isCheckDisabled(H) {
  var C = H || {}, G = C.disabled, U = C.disableCheckbox, K = C.checkable;
  return !!(G || U) || K === !1;
}
function fillConductCheck(H, C, G, U) {
  for (var K = new Set(H), W = /* @__PURE__ */ new Set(), Z = 0; Z <= G; Z += 1) {
    var X = C.get(Z) || /* @__PURE__ */ new Set();
    X.forEach(function(re) {
      var ne = re.key, ae = re.node, ie = re.children, se = ie === void 0 ? [] : ie;
      K.has(ne) && !U(ae) && se.filter(function(oe) {
        return !U(oe.node);
      }).forEach(function(oe) {
        K.add(oe.key);
      });
    });
  }
  for (var Q = /* @__PURE__ */ new Set(), ee = G; ee >= 0; ee -= 1) {
    var te = C.get(ee) || /* @__PURE__ */ new Set();
    te.forEach(function(re) {
      var ne = re.parent, ae = re.node;
      if (!(U(ae) || !re.parent || Q.has(re.parent.key))) {
        if (U(re.parent.node)) {
          Q.add(ne.key);
          return;
        }
        var ie = !0, se = !1;
        (ne.children || []).filter(function(oe) {
          return !U(oe.node);
        }).forEach(function(oe) {
          var le = oe.key, ue = K.has(le);
          ie && !ue && (ie = !1), !se && (ue || W.has(le)) && (se = !0);
        }), ie && K.add(ne.key), se && W.add(ne.key), Q.add(ne.key);
      }
    });
  }
  return {
    checkedKeys: Array.from(K),
    halfCheckedKeys: Array.from(removeFromCheckedKeys(W, K))
  };
}
function cleanConductCheck(H, C, G, U, K) {
  for (var W = new Set(H), Z = new Set(C), X = 0; X <= U; X += 1) {
    var Q = G.get(X) || /* @__PURE__ */ new Set();
    Q.forEach(function(ne) {
      var ae = ne.key, ie = ne.node, se = ne.children, oe = se === void 0 ? [] : se;
      !W.has(ae) && !Z.has(ae) && !K(ie) && oe.filter(function(le) {
        return !K(le.node);
      }).forEach(function(le) {
        W.delete(le.key);
      });
    });
  }
  Z = /* @__PURE__ */ new Set();
  for (var ee = /* @__PURE__ */ new Set(), te = U; te >= 0; te -= 1) {
    var re = G.get(te) || /* @__PURE__ */ new Set();
    re.forEach(function(ne) {
      var ae = ne.parent, ie = ne.node;
      if (!(K(ie) || !ne.parent || ee.has(ne.parent.key))) {
        if (K(ne.parent.node)) {
          ee.add(ae.key);
          return;
        }
        var se = !0, oe = !1;
        (ae.children || []).filter(function(le) {
          return !K(le.node);
        }).forEach(function(le) {
          var ue = le.key, ce = W.has(ue);
          se && !ce && (se = !1), !oe && (ce || Z.has(ue)) && (oe = !0);
        }), se || W.delete(ae.key), oe && Z.add(ae.key), ee.add(ae.key);
      }
    });
  }
  return {
    checkedKeys: Array.from(W),
    halfCheckedKeys: Array.from(removeFromCheckedKeys(Z, W))
  };
}
function conductCheck(H, C, G, U, K, W) {
  var Z = [], X;
  W ? X = W : X = isCheckDisabled;
  var Q = new Set(H.filter(function(te) {
    var re = !!G[te];
    return re || Z.push(te), re;
  }));
  note(!Z.length, "Tree missing follow keys: ".concat(Z.slice(0, 100).map(function(te) {
    return "'".concat(te, "'");
  }).join(", ")));
  var ee;
  return C === !0 ? ee = fillConductCheck(Q, K, U, X) : ee = cleanConductCheck(Q, C.halfCheckedKeys, K, U, X), ee;
}
function useMaxLevel(H) {
  var C = ref(0), G = shallowRef();
  return watchEffect(function() {
    var U = /* @__PURE__ */ new Map(), K = 0, W = H.value || {};
    for (var Z in W)
      if (Object.prototype.hasOwnProperty.call(W, Z)) {
        var X = W[Z], Q = X.level, ee = U.get(Q);
        ee || (ee = /* @__PURE__ */ new Set(), U.set(Q, ee)), ee.add(X), K = Math.max(K, Q);
      }
    C.value = K, G.value = U;
  }), {
    maxLevel: C,
    levelEntities: G
  };
}
var LeftOutlined$2 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M724 218.3V141c0-6.7-7.7-10.4-12.9-6.3L260.3 486.8a31.86 31.86 0 000 50.3l450.8 352.1c5.3 4.1 12.9.4 12.9-6.3v-77.3c0-4.9-2.3-9.6-6.1-12.6l-360-281 360-281.1c3.8-3 6.1-7.7 6.1-12.6z" } }] }, name: "left", theme: "outlined" };
const LeftOutlinedSvg = LeftOutlined$2;
function _objectSpread$g(H) {
  for (var C = 1; C < arguments.length; C++) {
    var G = arguments[C] != null ? Object(arguments[C]) : {}, U = Object.keys(G);
    typeof Object.getOwnPropertySymbols == "function" && (U = U.concat(Object.getOwnPropertySymbols(G).filter(function(K) {
      return Object.getOwnPropertyDescriptor(G, K).enumerable;
    }))), U.forEach(function(K) {
      _defineProperty$g(H, K, G[K]);
    });
  }
  return H;
}
function _defineProperty$g(H, C, G) {
  return C in H ? Object.defineProperty(H, C, { value: G, enumerable: !0, configurable: !0, writable: !0 }) : H[C] = G, H;
}
var LeftOutlined = function(C, G) {
  var U = _objectSpread$g({}, C, G.attrs);
  return createVNode$1(AntdIcon, _objectSpread$g({}, U, {
    icon: LeftOutlinedSvg
  }), null);
};
LeftOutlined.displayName = "LeftOutlined";
LeftOutlined.inheritAttrs = !1;
const LeftOutlined$1 = LeftOutlined;
var abstractCheckboxGroupProps = function() {
  return {
    name: String,
    prefixCls: String,
    options: {
      type: Array,
      default: function() {
        return [];
      }
    },
    disabled: Boolean,
    id: String
  };
}, checkboxGroupProps = function() {
  return _objectSpread2$1(_objectSpread2$1({}, abstractCheckboxGroupProps()), {}, {
    defaultValue: {
      type: Array
    },
    value: {
      type: Array
    },
    onChange: {
      type: Function
    },
    "onUpdate:value": {
      type: Function
    }
  });
}, abstractCheckboxProps = function() {
  return {
    prefixCls: String,
    defaultChecked: {
      type: Boolean,
      default: void 0
    },
    checked: {
      type: Boolean,
      default: void 0
    },
    disabled: {
      type: Boolean,
      default: void 0
    },
    isGroup: {
      type: Boolean,
      default: void 0
    },
    value: PropTypes$1.any,
    name: String,
    id: String,
    indeterminate: {
      type: Boolean,
      default: void 0
    },
    type: {
      type: String,
      default: "checkbox"
    },
    autofocus: {
      type: Boolean,
      default: void 0
    },
    onChange: Function,
    "onUpdate:checked": Function,
    onClick: Function,
    skipGroup: {
      type: Boolean,
      default: !1
    }
  };
}, checkboxProps = function() {
  return _objectSpread2$1(_objectSpread2$1({}, abstractCheckboxProps()), {}, {
    indeterminate: {
      type: Boolean,
      default: !1
    }
  });
}, CheckboxGroupContextKey = Symbol("CheckboxGroupContext"), _excluded$c = ["indeterminate", "skipGroup", "id"], _excluded2 = ["onMouseenter", "onMouseleave", "onInput", "class", "style"];
const Checkbox = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ACheckbox",
  inheritAttrs: !1,
  __ANT_CHECKBOX: !0,
  props: checkboxProps(),
  // emits: ['change', 'update:checked'],
  setup: function(C, G) {
    var U = G.emit, K = G.attrs, W = G.slots, Z = G.expose, X = useInjectFormItemContext(), Q = useConfigInject("checkbox", C), ee = Q.prefixCls, te = Q.direction, re = inject(CheckboxGroupContextKey, void 0), ne = Symbol("checkboxUniId");
    watchEffect(function() {
      !C.skipGroup && re && re.registerValue(ne, C.value);
    }), onBeforeUnmount(function() {
      re && re.cancelValue(ne);
    }), onMounted(function() {
      warning$1(C.checked !== void 0 || re || C.value === void 0, "Checkbox", "`value` is not validate prop, do you mean `checked`?");
    });
    var ae = function(ue) {
      var ce = ue.target.checked;
      U("update:checked", ce), U("change", ue);
    }, ie = ref(), se = function() {
      var ue;
      (ue = ie.value) === null || ue === void 0 || ue.focus();
    }, oe = function() {
      var ue;
      (ue = ie.value) === null || ue === void 0 || ue.blur();
    };
    return Z({
      focus: se,
      blur: oe
    }), function() {
      var le, ue, ce = flattenChildren((le = W.default) === null || le === void 0 ? void 0 : le.call(W)), de = C.indeterminate, ge = C.skipGroup, fe = C.id, ve = fe === void 0 ? X.id.value : fe, pe = _objectWithoutProperties$2(C, _excluded$c), he = K.onMouseenter, me = K.onMouseleave;
      K.onInput;
      var ye = K.class, Ce = K.style, Ie = _objectWithoutProperties$2(K, _excluded2), be = _objectSpread2$1(_objectSpread2$1({}, pe), {}, {
        id: ve,
        prefixCls: ee.value
      }, Ie);
      re && !ge ? (be.onChange = function() {
        for (var _e = arguments.length, xe = new Array(_e), Te = 0; Te < _e; Te++)
          xe[Te] = arguments[Te];
        U.apply(void 0, ["change"].concat(xe)), re.toggleOption({
          label: ce,
          value: C.value
        });
      }, be.name = re.name.value, be.checked = re.mergedValue.value.indexOf(C.value) !== -1, be.disabled = C.disabled || re.disabled.value, be.indeterminate = de) : be.onChange = ae;
      var Se = classNames((ue = {}, _defineProperty$A(ue, "".concat(ee.value, "-wrapper"), !0), _defineProperty$A(ue, "".concat(ee.value, "-rtl"), te.value === "rtl"), _defineProperty$A(ue, "".concat(ee.value, "-wrapper-checked"), be.checked), _defineProperty$A(ue, "".concat(ee.value, "-wrapper-disabled"), be.disabled), ue), ye), Ae = classNames(_defineProperty$A({}, "".concat(ee.value, "-indeterminate"), de));
      return createVNode$1("label", {
        class: Se,
        style: Ce,
        onMouseenter: he,
        onMouseleave: me
      }, [createVNode$1(VcCheckbox, _objectSpread2$1(_objectSpread2$1({}, be), {}, {
        class: Ae,
        ref: ie
      }), null), ce.length ? createVNode$1("span", null, [ce]) : null]);
    };
  }
});
function _createForOfIteratorHelper(H, C) {
  var G = typeof Symbol < "u" && H[Symbol.iterator] || H["@@iterator"];
  if (!G) {
    if (Array.isArray(H) || (G = _unsupportedIterableToArray$2(H)) || C && H && typeof H.length == "number") {
      G && (H = G);
      var U = 0, K = function() {
      };
      return {
        s: K,
        n: function() {
          return U >= H.length ? {
            done: !0
          } : {
            done: !1,
            value: H[U++]
          };
        },
        e: function(ee) {
          throw ee;
        },
        f: K
      };
    }
    throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  var W = !0, Z = !1, X;
  return {
    s: function() {
      G = G.call(H);
    },
    n: function() {
      var ee = G.next();
      return W = ee.done, ee;
    },
    e: function(ee) {
      Z = !0, X = ee;
    },
    f: function() {
      try {
        !W && G.return != null && G.return();
      } finally {
        if (Z)
          throw X;
      }
    }
  };
}
const CheckboxGroup = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ACheckboxGroup",
  props: checkboxGroupProps(),
  // emits: ['change', 'update:value'],
  setup: function(C, G) {
    var U = G.slots, K = G.emit, W = G.expose, Z = useInjectFormItemContext(), X = useConfigInject("checkbox", C), Q = X.prefixCls, ee = X.direction, te = ref((C.value === void 0 ? C.defaultValue : C.value) || []);
    watch(function() {
      return C.value;
    }, function() {
      te.value = C.value || [];
    });
    var re = computed(function() {
      return C.options.map(function(ue) {
        return typeof ue == "string" || typeof ue == "number" ? {
          label: ue,
          value: ue
        } : ue;
      });
    }), ne = ref(Symbol()), ae = ref(/* @__PURE__ */ new Map()), ie = function(ce) {
      ae.value.delete(ce), ne.value = Symbol();
    }, se = function(ce, de) {
      ae.value.set(ce, de), ne.value = Symbol();
    }, oe = ref(/* @__PURE__ */ new Map());
    watch(ne, function() {
      var ue = /* @__PURE__ */ new Map(), ce = _createForOfIteratorHelper(ae.value.values()), de;
      try {
        for (ce.s(); !(de = ce.n()).done; ) {
          var ge = de.value;
          ue.set(ge, !0);
        }
      } catch (fe) {
        ce.e(fe);
      } finally {
        ce.f();
      }
      oe.value = ue;
    });
    var le = function(ce) {
      var de = te.value.indexOf(ce.value), ge = _toConsumableArray(te.value);
      de === -1 ? ge.push(ce.value) : ge.splice(de, 1), C.value === void 0 && (te.value = ge);
      var fe = ge.filter(function(ve) {
        return oe.value.has(ve);
      }).sort(function(ve, pe) {
        var he = re.value.findIndex(function(ye) {
          return ye.value === ve;
        }), me = re.value.findIndex(function(ye) {
          return ye.value === pe;
        });
        return he - me;
      });
      K("update:value", fe), K("change", fe), Z.onFieldChange();
    };
    return provide(CheckboxGroupContextKey, {
      cancelValue: ie,
      registerValue: se,
      toggleOption: le,
      mergedValue: te,
      name: computed(function() {
        return C.name;
      }),
      disabled: computed(function() {
        return C.disabled;
      })
    }), W({
      mergedValue: te
    }), function() {
      var ue, ce = C.id, de = ce === void 0 ? Z.id.value : ce, ge = null, fe = "".concat(Q.value, "-group");
      return re.value && re.value.length > 0 && (ge = re.value.map(function(ve) {
        var pe;
        return createVNode$1(Checkbox, {
          prefixCls: Q.value,
          key: ve.value.toString(),
          disabled: "disabled" in ve ? ve.disabled : C.disabled,
          indeterminate: ve.indeterminate,
          value: ve.value,
          checked: te.value.indexOf(ve.value) !== -1,
          onChange: ve.onChange,
          class: "".concat(fe, "-item")
        }, {
          default: function() {
            return [ve.label === void 0 ? (pe = U.label) === null || pe === void 0 ? void 0 : pe.call(U, ve) : ve.label];
          }
        });
      })), createVNode$1("div", {
        class: [fe, _defineProperty$A({}, "".concat(fe, "-rtl"), ee.value === "rtl")],
        id: de
      }, [ge || ((ue = U.default) === null || ue === void 0 ? void 0 : ue.call(U))]);
    };
  }
});
Checkbox.Group = CheckboxGroup;
Checkbox.install = function(H) {
  return H.component(Checkbox.name, Checkbox), H.component(CheckboxGroup.name, CheckboxGroup), H;
};
Dropdown$1.Button = DropdownButton;
Dropdown$1.install = function(H) {
  return H.component(Dropdown$1.name, Dropdown$1), H.component(DropdownButton.name, DropdownButton), H;
};
var cached;
function getScrollBarSize(H) {
  if (typeof document > "u")
    return 0;
  if (H || cached === void 0) {
    var C = document.createElement("div");
    C.style.width = "100%", C.style.height = "200px";
    var G = document.createElement("div"), U = G.style;
    U.position = "absolute", U.top = "0", U.left = "0", U.pointerEvents = "none", U.visibility = "hidden", U.width = "200px", U.height = "150px", U.overflow = "hidden", G.appendChild(C), document.body.appendChild(G);
    var K = C.offsetWidth;
    G.style.overflow = "scroll";
    var W = C.offsetWidth;
    K === W && (W = G.clientWidth), document.body.removeChild(G), cached = K - W;
  }
  return cached;
}
function ensureSize(H) {
  var C = H.match(/^(.*)px$/), G = Number(C == null ? void 0 : C[1]);
  return Number.isNaN(G) ? getScrollBarSize() : G;
}
function getTargetScrollBarSize(H) {
  if (typeof document > "u" || !H || !(H instanceof Element))
    return {
      width: 0,
      height: 0
    };
  var C = getComputedStyle(H, "::-webkit-scrollbar"), G = C.width, U = C.height;
  return {
    width: ensureSize(G),
    height: ensureSize(U)
  };
}
var inputProps = function() {
  return {
    id: String,
    prefixCls: String,
    inputPrefixCls: String,
    defaultValue: PropTypes$1.oneOfType([PropTypes$1.string, PropTypes$1.number]),
    value: {
      type: [String, Number, Symbol],
      default: void 0
    },
    placeholder: {
      type: [String, Number]
    },
    autocomplete: String,
    type: {
      type: String,
      default: "text"
    },
    name: String,
    size: {
      type: String
    },
    disabled: {
      type: Boolean,
      default: void 0
    },
    readonly: {
      type: Boolean,
      default: void 0
    },
    addonBefore: PropTypes$1.any,
    addonAfter: PropTypes$1.any,
    prefix: PropTypes$1.any,
    suffix: PropTypes$1.any,
    autofocus: {
      type: Boolean,
      default: void 0
    },
    allowClear: {
      type: Boolean,
      default: void 0
    },
    lazy: {
      type: Boolean,
      default: !0
    },
    maxlength: Number,
    loading: {
      type: Boolean,
      default: void 0
    },
    bordered: {
      type: Boolean,
      default: void 0
    },
    showCount: {
      type: [Boolean, Object]
    },
    htmlSize: Number,
    onPressEnter: Function,
    onKeydown: Function,
    onKeyup: Function,
    onFocus: Function,
    onBlur: Function,
    onChange: Function,
    onInput: Function,
    "onUpdate:value": Function,
    valueModifiers: Object,
    hidden: Boolean
  };
};
const inputProps$1 = inputProps;
var textAreaProps = function() {
  return _objectSpread2$1(_objectSpread2$1({}, omit(inputProps(), ["prefix", "addonBefore", "addonAfter", "suffix"])), {}, {
    rows: Number,
    autosize: {
      type: [Boolean, Object],
      default: void 0
    },
    autoSize: {
      type: [Boolean, Object],
      default: void 0
    },
    onResize: {
      type: Function
    },
    onCompositionstart: Function,
    onCompositionend: Function,
    valueModifiers: Object
  });
};
function getInputClassName(H, C, G, U, K) {
  var W;
  return classNames(H, (W = {}, _defineProperty$A(W, "".concat(H, "-sm"), G === "small"), _defineProperty$A(W, "".concat(H, "-lg"), G === "large"), _defineProperty$A(W, "".concat(H, "-disabled"), U), _defineProperty$A(W, "".concat(H, "-rtl"), K === "rtl"), _defineProperty$A(W, "".concat(H, "-borderless"), !C), W));
}
var isValid = function(C) {
  return C != null && (Array.isArray(C) ? filterEmpty(C).length : !0);
};
function hasPrefixSuffix(H) {
  return isValid(H.prefix) || isValid(H.suffix) || isValid(H.allowClear);
}
function hasAddon(H) {
  return isValid(H.addonBefore) || isValid(H.addonAfter);
}
var ClearableInputType = ["text", "input"];
const ClearableLabeledInput = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ClearableLabeledInput",
  inheritAttrs: !1,
  props: {
    prefixCls: String,
    inputType: PropTypes$1.oneOf(tuple("text", "input")),
    value: PropTypes$1.any,
    defaultValue: PropTypes$1.any,
    allowClear: {
      type: Boolean,
      default: void 0
    },
    element: PropTypes$1.any,
    handleReset: Function,
    disabled: {
      type: Boolean,
      default: void 0
    },
    direction: {
      type: String
    },
    size: {
      type: String
    },
    suffix: PropTypes$1.any,
    prefix: PropTypes$1.any,
    addonBefore: PropTypes$1.any,
    addonAfter: PropTypes$1.any,
    readonly: {
      type: Boolean,
      default: void 0
    },
    focused: {
      type: Boolean,
      default: void 0
    },
    bordered: {
      type: Boolean,
      default: !0
    },
    triggerFocus: {
      type: Function
    },
    hidden: Boolean
  },
  setup: function(C, G) {
    var U = G.slots, K = G.attrs, W = ref(), Z = function(ae) {
      var ie;
      if ((ie = W.value) !== null && ie !== void 0 && ie.contains(ae.target)) {
        var se = C.triggerFocus;
        se == null || se();
      }
    }, X = function(ae) {
      var ie, se = C.allowClear, oe = C.value, le = C.disabled, ue = C.readonly, ce = C.handleReset, de = C.suffix, ge = de === void 0 ? U.suffix : de;
      if (!se)
        return null;
      var fe = !le && !ue && oe, ve = "".concat(ae, "-clear-icon");
      return createVNode$1(CloseCircleFilled$1, {
        onClick: ce,
        onMousedown: function(he) {
          return he.preventDefault();
        },
        class: classNames((ie = {}, _defineProperty$A(ie, "".concat(ve, "-hidden"), !fe), _defineProperty$A(ie, "".concat(ve, "-has-suffix"), !!ge), ie), ve),
        role: "button"
      }, null);
    }, Q = function(ae) {
      var ie, se = C.suffix, oe = se === void 0 ? (ie = U.suffix) === null || ie === void 0 ? void 0 : ie.call(U) : se, le = C.allowClear;
      return oe || le ? createVNode$1("span", {
        class: "".concat(ae, "-suffix")
      }, [X(ae), oe]) : null;
    }, ee = function(ae, ie) {
      var se, oe, le, ue = C.focused, ce = C.value, de = C.prefix, ge = de === void 0 ? (se = U.prefix) === null || se === void 0 ? void 0 : se.call(U) : de, fe = C.size, ve = C.suffix, pe = ve === void 0 ? (oe = U.suffix) === null || oe === void 0 ? void 0 : oe.call(U) : ve, he = C.disabled, me = C.allowClear, ye = C.direction, Ce = C.readonly, Ie = C.bordered, be = C.hidden, Se = C.addonAfter, Ae = Se === void 0 ? U.addonAfter : Se, _e = C.addonBefore, xe = _e === void 0 ? U.addonBefore : _e, Te = Q(ae);
      if (!hasPrefixSuffix({
        prefix: ge,
        suffix: pe,
        allowClear: me
      }))
        return cloneElement(ie, {
          value: ce
        });
      var Pe = ge ? createVNode$1("span", {
        class: "".concat(ae, "-prefix")
      }, [ge]) : null, $e = classNames("".concat(ae, "-affix-wrapper"), (le = {}, _defineProperty$A(le, "".concat(ae, "-affix-wrapper-focused"), ue), _defineProperty$A(le, "".concat(ae, "-affix-wrapper-disabled"), he), _defineProperty$A(le, "".concat(ae, "-affix-wrapper-sm"), fe === "small"), _defineProperty$A(le, "".concat(ae, "-affix-wrapper-lg"), fe === "large"), _defineProperty$A(le, "".concat(ae, "-affix-wrapper-input-with-clear-btn"), pe && me && ce), _defineProperty$A(le, "".concat(ae, "-affix-wrapper-rtl"), ye === "rtl"), _defineProperty$A(le, "".concat(ae, "-affix-wrapper-readonly"), Ce), _defineProperty$A(le, "".concat(ae, "-affix-wrapper-borderless"), !Ie), _defineProperty$A(le, "".concat(K.class), !hasAddon({
        addonAfter: Ae,
        addonBefore: xe
      }) && K.class), le));
      return createVNode$1("span", {
        ref: W,
        class: $e,
        style: K.style,
        onMouseup: Z,
        hidden: be
      }, [Pe, cloneElement(ie, {
        style: null,
        value: ce,
        class: getInputClassName(ae, Ie, fe, he)
      }), Te]);
    }, te = function(ae, ie) {
      var se, oe, le, ue = C.addonBefore, ce = ue === void 0 ? (se = U.addonBefore) === null || se === void 0 ? void 0 : se.call(U) : ue, de = C.addonAfter, ge = de === void 0 ? (oe = U.addonAfter) === null || oe === void 0 ? void 0 : oe.call(U) : de, fe = C.size, ve = C.direction, pe = C.hidden;
      if (!hasAddon({
        addonBefore: ce,
        addonAfter: ge
      }))
        return ie;
      var he = "".concat(ae, "-group"), me = "".concat(he, "-addon"), ye = ce ? createVNode$1("span", {
        class: me
      }, [ce]) : null, Ce = ge ? createVNode$1("span", {
        class: me
      }, [ge]) : null, Ie = classNames("".concat(ae, "-wrapper"), he, _defineProperty$A({}, "".concat(he, "-rtl"), ve === "rtl")), be = classNames("".concat(ae, "-group-wrapper"), (le = {}, _defineProperty$A(le, "".concat(ae, "-group-wrapper-sm"), fe === "small"), _defineProperty$A(le, "".concat(ae, "-group-wrapper-lg"), fe === "large"), _defineProperty$A(le, "".concat(ae, "-group-wrapper-rtl"), ve === "rtl"), le), K.class);
      return createVNode$1("span", {
        class: be,
        style: K.style,
        hidden: pe
      }, [createVNode$1("span", {
        class: Ie
      }, [ye, cloneElement(ie, {
        style: null
      }), Ce])]);
    }, re = function(ae, ie) {
      var se, oe = C.value, le = C.allowClear, ue = C.direction, ce = C.bordered, de = C.hidden, ge = C.addonAfter, fe = ge === void 0 ? U.addonAfter : ge, ve = C.addonBefore, pe = ve === void 0 ? U.addonBefore : ve;
      if (!le)
        return cloneElement(ie, {
          value: oe
        });
      var he = classNames("".concat(ae, "-affix-wrapper"), "".concat(ae, "-affix-wrapper-textarea-with-clear-btn"), (se = {}, _defineProperty$A(se, "".concat(ae, "-affix-wrapper-rtl"), ue === "rtl"), _defineProperty$A(se, "".concat(ae, "-affix-wrapper-borderless"), !ce), _defineProperty$A(se, "".concat(K.class), !hasAddon({
        addonAfter: fe,
        addonBefore: pe
      }) && K.class), se));
      return createVNode$1("span", {
        class: he,
        style: K.style,
        hidden: de
      }, [cloneElement(ie, {
        style: null,
        value: oe
      }), X(ae)]);
    };
    return function() {
      var ne, ae = C.prefixCls, ie = C.inputType, se = C.element, oe = se === void 0 ? (ne = U.element) === null || ne === void 0 ? void 0 : ne.call(U) : se;
      return ie === ClearableInputType[0] ? re(ae, oe) : te(ae, ee(ae, oe));
    };
  }
});
function fixControlledValue(H) {
  return typeof H > "u" || H === null ? "" : String(H);
}
function resolveOnChange(H, C, G, U) {
  if (G) {
    var K = C;
    if (C.type === "click") {
      Object.defineProperty(K, "target", {
        writable: !0
      }), Object.defineProperty(K, "currentTarget", {
        writable: !0
      });
      var W = H.cloneNode(!0);
      K.target = W, K.currentTarget = W, W.value = "", G(K);
      return;
    }
    if (U !== void 0) {
      Object.defineProperty(K, "target", {
        writable: !0
      }), Object.defineProperty(K, "currentTarget", {
        writable: !0
      }), K.target = H, K.currentTarget = H, H.value = U, G(K);
      return;
    }
    G(K);
  }
}
function triggerFocus(H, C) {
  if (H) {
    H.focus(C);
    var G = C || {}, U = G.cursor;
    if (U) {
      var K = H.value.length;
      switch (U) {
        case "start":
          H.setSelectionRange(0, 0);
          break;
        case "end":
          H.setSelectionRange(K, K);
          break;
        default:
          H.setSelectionRange(0, K);
      }
    }
  }
}
const Input = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AInput",
  inheritAttrs: !1,
  props: inputProps$1(),
  setup: function(C, G) {
    var U = G.slots, K = G.attrs, W = G.expose, Z = G.emit, X = ref(), Q = ref(), ee, te = useInjectFormItemContext(), re = useConfigInject("input", C), ne = re.direction, ae = re.prefixCls, ie = re.size, se = re.autocomplete, oe = ref(C.value === void 0 ? C.defaultValue : C.value), le = ref(!1);
    watch(function() {
      return C.value;
    }, function() {
      oe.value = C.value;
    }), watch(function() {
      return C.disabled;
    }, function() {
      C.value !== void 0 && (oe.value = C.value), C.disabled && (le.value = !1);
    });
    var ue = function() {
      ee = setTimeout(function() {
        var xe;
        ((xe = X.value) === null || xe === void 0 ? void 0 : xe.getAttribute("type")) === "password" && X.value.hasAttribute("value") && X.value.removeAttribute("value");
      });
    }, ce = function(xe) {
      triggerFocus(X.value, xe);
    }, de = function() {
      var xe;
      (xe = X.value) === null || xe === void 0 || xe.blur();
    }, ge = function(xe, Te, Pe) {
      var $e;
      ($e = X.value) === null || $e === void 0 || $e.setSelectionRange(xe, Te, Pe);
    }, fe = function() {
      var xe;
      (xe = X.value) === null || xe === void 0 || xe.select();
    };
    W({
      focus: ce,
      blur: de,
      input: X,
      stateValue: oe,
      setSelectionRange: ge,
      select: fe
    });
    var ve = function(xe) {
      var Te = C.onFocus;
      le.value = !0, Te == null || Te(xe), nextTick(function() {
        ue();
      });
    }, pe = function(xe) {
      var Te = C.onBlur;
      le.value = !1, Te == null || Te(xe), te.onFieldBlur(), nextTick(function() {
        ue();
      });
    }, he = function(xe) {
      Z("update:value", xe.target.value), Z("change", xe), Z("input", xe), te.onFieldChange();
    }, me = getCurrentInstance(), ye = function(xe, Te) {
      oe.value !== xe && (C.value === void 0 ? oe.value = xe : nextTick(function() {
        X.value.value !== oe.value && me.update();
      }), nextTick(function() {
        Te && Te();
      }));
    }, Ce = function(xe) {
      resolveOnChange(X.value, xe, he), ye("", function() {
        ce();
      });
    }, Ie = function(xe) {
      var Te = xe.target, Pe = Te.value, $e = Te.composing;
      if (!((xe.isComposing || $e) && C.lazy || oe.value === Pe)) {
        var Me = xe.target.value;
        resolveOnChange(X.value, xe, he), ye(Me, function() {
          ue();
        });
      }
    }, be = function(xe) {
      xe.keyCode === 13 && Z("pressEnter", xe), Z("keydown", xe);
    };
    onMounted(function() {
      ue();
    }), onBeforeUnmount(function() {
      clearTimeout(ee);
    });
    var Se = function() {
      var xe, Te = C.addonBefore, Pe = Te === void 0 ? U.addonBefore : Te, $e = C.addonAfter, Me = $e === void 0 ? U.addonAfter : $e, Ee = C.disabled, we = C.bordered, Oe = we === void 0 ? !0 : we, Ne = C.valueModifiers, ke = Ne === void 0 ? {} : Ne, ze = C.htmlSize, He = omit(C, [
        "prefixCls",
        "onPressEnter",
        "addonBefore",
        "addonAfter",
        "prefix",
        "suffix",
        "allowClear",
        // Input elements must be either controlled or uncontrolled,
        // specify either the value prop, or the defaultValue prop, but not both.
        "defaultValue",
        "size",
        "bordered",
        "htmlSize",
        "lazy",
        "showCount",
        "valueModifiers"
      ]), We = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, He), K), {}, {
        autocomplete: se.value,
        onChange: Ie,
        onInput: Ie,
        onFocus: ve,
        onBlur: pe,
        onKeydown: be,
        class: classNames(getInputClassName(ae.value, Oe, ie.value, Ee, ne.value), _defineProperty$A({}, K.class, K.class && !Pe && !Me)),
        ref: X,
        key: "ant-input",
        size: ze,
        id: (xe = He.id) !== null && xe !== void 0 ? xe : te.id.value
      });
      ke.lazy && delete We.onInput, We.autofocus || delete We.autofocus;
      var Re = createVNode$1("input", omit(We, ["size"]), null);
      return withDirectives(Re, [[antInputDirective]]);
    }, Ae = function() {
      var xe, Te = oe.value, Pe = C.maxlength, $e = C.suffix, Me = $e === void 0 ? (xe = U.suffix) === null || xe === void 0 ? void 0 : xe.call(U) : $e, Ee = C.showCount, we = Number(Pe) > 0;
      if (Me || Ee) {
        var Oe = _toConsumableArray(fixControlledValue(Te)).length, Ne = null;
        return _typeof$2(Ee) === "object" ? Ne = Ee.formatter({
          count: Oe,
          maxlength: Pe
        }) : Ne = "".concat(Oe).concat(we ? " / ".concat(Pe) : ""), createVNode$1(Fragment, null, [!!Ee && createVNode$1("span", {
          class: classNames("".concat(ae.value, "-show-count-suffix"), _defineProperty$A({}, "".concat(ae.value, "-show-count-has-suffix"), !!Me))
        }, [Ne]), Me]);
      }
      return null;
    };
    return function() {
      var _e = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, K), C), {}, {
        prefixCls: ae.value,
        inputType: "input",
        value: fixControlledValue(oe.value),
        handleReset: Ce,
        focused: le.value && !C.disabled
      });
      return createVNode$1(ClearableLabeledInput, _objectSpread2$1(_objectSpread2$1({}, omit(_e, ["element", "valueModifiers", "suffix", "showCount"])), {}, {
        ref: Q
      }), _objectSpread2$1(_objectSpread2$1({}, U), {}, {
        element: Se,
        suffix: Ae
      }));
    };
  }
}), Group$5 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AInputGroup",
  props: {
    prefixCls: String,
    size: {
      type: String
    },
    compact: {
      type: Boolean,
      default: void 0
    },
    onMouseenter: {
      type: Function
    },
    onMouseleave: {
      type: Function
    },
    onFocus: {
      type: Function
    },
    onBlur: {
      type: Function
    }
  },
  setup: function(C, G) {
    var U = G.slots, K = useConfigInject("input-group", C), W = K.prefixCls, Z = K.direction, X = computed(function() {
      var Q, ee = W.value;
      return Q = {}, _defineProperty$A(Q, "".concat(ee), !0), _defineProperty$A(Q, "".concat(ee, "-lg"), C.size === "large"), _defineProperty$A(Q, "".concat(ee, "-sm"), C.size === "small"), _defineProperty$A(Q, "".concat(ee, "-compact"), C.compact), _defineProperty$A(Q, "".concat(ee, "-rtl"), Z.value === "rtl"), Q;
    });
    return function() {
      var Q;
      return createVNode$1("span", {
        class: X.value,
        onMouseenter: C.onMouseenter,
        onMouseleave: C.onMouseleave,
        onFocus: C.onFocus,
        onBlur: C.onBlur
      }, [(Q = U.default) === null || Q === void 0 ? void 0 : Q.call(U)]);
    };
  }
});
var applePhone = /iPhone/i, appleIpod = /iPod/i, appleTablet = /iPad/i, androidPhone = /\bAndroid(?:.+)Mobile\b/i, androidTablet = /Android/i, amazonPhone = /\bAndroid(?:.+)SD4930UR\b/i, amazonTablet = /\bAndroid(?:.+)(?:KF[A-Z]{2,4})\b/i, windowsPhone = /Windows Phone/i, windowsTablet = /\bWindows(?:.+)ARM\b/i, otherBlackberry = /BlackBerry/i, otherBlackberry10 = /BB10/i, otherOpera = /Opera Mini/i, otherChrome = /\b(CriOS|Chrome)(?:.+)Mobile/i, otherFirefox = /Mobile(?:.+)Firefox\b/i;
function match(H, C) {
  return H.test(C);
}
function isMobile(H) {
  var C = H || (typeof navigator < "u" ? navigator.userAgent : ""), G = C.split("[FBAN");
  if (typeof G[1] < "u") {
    var U = G, K = _slicedToArray$2(U, 1);
    C = K[0];
  }
  if (G = C.split("Twitter"), typeof G[1] < "u") {
    var W = G, Z = _slicedToArray$2(W, 1);
    C = Z[0];
  }
  var X = {
    apple: {
      phone: match(applePhone, C) && !match(windowsPhone, C),
      ipod: match(appleIpod, C),
      tablet: !match(applePhone, C) && match(appleTablet, C) && !match(windowsPhone, C),
      device: (match(applePhone, C) || match(appleIpod, C) || match(appleTablet, C)) && !match(windowsPhone, C)
    },
    amazon: {
      phone: match(amazonPhone, C),
      tablet: !match(amazonPhone, C) && match(amazonTablet, C),
      device: match(amazonPhone, C) || match(amazonTablet, C)
    },
    android: {
      phone: !match(windowsPhone, C) && match(amazonPhone, C) || !match(windowsPhone, C) && match(androidPhone, C),
      tablet: !match(windowsPhone, C) && !match(amazonPhone, C) && !match(androidPhone, C) && (match(amazonTablet, C) || match(androidTablet, C)),
      device: !match(windowsPhone, C) && (match(amazonPhone, C) || match(amazonTablet, C) || match(androidPhone, C) || match(androidTablet, C)) || match(/\bokhttp\b/i, C)
    },
    windows: {
      phone: match(windowsPhone, C),
      tablet: match(windowsTablet, C),
      device: match(windowsPhone, C) || match(windowsTablet, C)
    },
    other: {
      blackberry: match(otherBlackberry, C),
      blackberry10: match(otherBlackberry10, C),
      opera: match(otherOpera, C),
      firefox: match(otherFirefox, C),
      chrome: match(otherChrome, C),
      device: match(otherBlackberry, C) || match(otherBlackberry10, C) || match(otherOpera, C) || match(otherFirefox, C) || match(otherChrome, C)
    },
    // Additional
    any: null,
    phone: null,
    tablet: null
  };
  return X.any = X.apple.device || X.android.device || X.windows.device || X.other.device, X.phone = X.apple.phone || X.android.phone || X.windows.phone, X.tablet = X.apple.tablet || X.android.tablet || X.windows.tablet, X;
}
var defaultResult = _objectSpread2$1(_objectSpread2$1({}, isMobile()), {}, {
  isMobile
});
const isMobile$1 = defaultResult;
var _excluded$b = ["disabled", "loading", "addonAfter", "suffix"];
const Search = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AInputSearch",
  inheritAttrs: !1,
  props: _objectSpread2$1(_objectSpread2$1({}, inputProps$1()), {}, {
    inputPrefixCls: String,
    // 不能设置默认值 https://github.com/vueComponent/ant-design-vue/issues/1916
    enterButton: PropTypes$1.any,
    onSearch: {
      type: Function
    }
  }),
  setup: function(C, G) {
    var U = G.slots, K = G.attrs, W = G.expose, Z = G.emit, X = ref(), Q = function() {
      var de;
      (de = X.value) === null || de === void 0 || de.focus();
    }, ee = function() {
      var de;
      (de = X.value) === null || de === void 0 || de.blur();
    };
    W({
      focus: Q,
      blur: ee
    });
    var te = function(de) {
      Z("update:value", de.target.value), de && de.target && de.type === "click" && Z("search", de.target.value, de), Z("change", de);
    }, re = function(de) {
      var ge;
      document.activeElement === ((ge = X.value) === null || ge === void 0 ? void 0 : ge.input) && de.preventDefault();
    }, ne = function(de) {
      var ge;
      Z("search", (ge = X.value) === null || ge === void 0 ? void 0 : ge.stateValue, de), isMobile$1.tablet || X.value.focus();
    }, ae = useConfigInject("input-search", C), ie = ae.prefixCls, se = ae.getPrefixCls, oe = ae.direction, le = ae.size, ue = computed(function() {
      return se("input", C.inputPrefixCls);
    });
    return function() {
      var ce, de, ge, fe, ve, pe = C.disabled, he = C.loading, me = C.addonAfter, ye = me === void 0 ? (ce = U.addonAfter) === null || ce === void 0 ? void 0 : ce.call(U) : me, Ce = C.suffix, Ie = Ce === void 0 ? (de = U.suffix) === null || de === void 0 ? void 0 : de.call(U) : Ce, be = _objectWithoutProperties$2(C, _excluded$b), Se = C.enterButton, Ae = Se === void 0 ? (ge = (fe = U.enterButton) === null || fe === void 0 ? void 0 : fe.call(U)) !== null && ge !== void 0 ? ge : !1 : Se;
      Ae = Ae || Ae === "";
      var _e = typeof Ae == "boolean" ? createVNode$1(SearchOutlined$1, null, null) : null, xe = "".concat(ie.value, "-button"), Te = Array.isArray(Ae) ? Ae[0] : Ae, Pe, $e = Te.type && isPlainObject(Te.type) && Te.type.__ANT_BUTTON;
      if ($e || Te.tagName === "button")
        Pe = cloneElement(Te, _objectSpread2$1({
          onMousedown: re,
          onClick: ne,
          key: "enterButton"
        }, $e ? {
          class: xe,
          size: le.value
        } : {}), !1);
      else {
        var Me = _e && !Ae;
        Pe = createVNode$1(Button$1, {
          class: xe,
          type: Ae ? "primary" : void 0,
          size: le.value,
          disabled: pe,
          key: "enterButton",
          onMousedown: re,
          onClick: ne,
          loading: he,
          icon: Me ? _e : null
        }, {
          default: function() {
            return [Me ? null : _e || Ae];
          }
        });
      }
      ye && (Pe = [Pe, ye]);
      var Ee = classNames(ie.value, (ve = {}, _defineProperty$A(ve, "".concat(ie.value, "-rtl"), oe.value === "rtl"), _defineProperty$A(ve, "".concat(ie.value, "-").concat(le.value), !!le.value), _defineProperty$A(ve, "".concat(ie.value, "-with-button"), !!Ae), ve), K.class);
      return createVNode$1(Input, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
        ref: X
      }, omit(be, ["onUpdate:value", "onSearch", "enterButton"])), K), {}, {
        onPressEnter: ne,
        size: le.value,
        prefixCls: ue.value,
        addonAfter: Pe,
        suffix: Ie,
        onChange: te,
        class: Ee,
        disabled: pe
      }), U);
    };
  }
});
var HIDDEN_TEXTAREA_STYLE = `
 min-height:0 !important;
 max-height:none !important;
 height:0 !important;
 visibility:hidden !important;
 overflow:hidden !important;
 position:absolute !important;
 z-index:-1000 !important;
 top:0 !important;
 right:0 !important
`, SIZING_STYLE = ["letter-spacing", "line-height", "padding-top", "padding-bottom", "font-family", "font-weight", "font-size", "font-variant", "text-rendering", "text-transform", "width", "text-indent", "padding-left", "padding-right", "border-width", "box-sizing", "word-break"], computedStyleCache = {}, hiddenTextarea;
function calculateNodeStyling(H) {
  var C = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, G = H.getAttribute("id") || H.getAttribute("data-reactid") || H.getAttribute("name");
  if (C && computedStyleCache[G])
    return computedStyleCache[G];
  var U = window.getComputedStyle(H), K = U.getPropertyValue("box-sizing") || U.getPropertyValue("-moz-box-sizing") || U.getPropertyValue("-webkit-box-sizing"), W = parseFloat(U.getPropertyValue("padding-bottom")) + parseFloat(U.getPropertyValue("padding-top")), Z = parseFloat(U.getPropertyValue("border-bottom-width")) + parseFloat(U.getPropertyValue("border-top-width")), X = SIZING_STYLE.map(function(ee) {
    return "".concat(ee, ":").concat(U.getPropertyValue(ee));
  }).join(";"), Q = {
    sizingStyle: X,
    paddingSize: W,
    borderSize: Z,
    boxSizing: K
  };
  return C && G && (computedStyleCache[G] = Q), Q;
}
function calculateNodeHeight(H) {
  var C = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, G = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, U = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  hiddenTextarea || (hiddenTextarea = document.createElement("textarea"), hiddenTextarea.setAttribute("tab-index", "-1"), hiddenTextarea.setAttribute("aria-hidden", "true"), document.body.appendChild(hiddenTextarea)), H.getAttribute("wrap") ? hiddenTextarea.setAttribute("wrap", H.getAttribute("wrap")) : hiddenTextarea.removeAttribute("wrap");
  var K = calculateNodeStyling(H, C), W = K.paddingSize, Z = K.borderSize, X = K.boxSizing, Q = K.sizingStyle;
  hiddenTextarea.setAttribute("style", "".concat(Q, ";").concat(HIDDEN_TEXTAREA_STYLE)), hiddenTextarea.value = H.value || H.placeholder || "";
  var ee = Number.MIN_SAFE_INTEGER, te = Number.MAX_SAFE_INTEGER, re = hiddenTextarea.scrollHeight, ne;
  if (X === "border-box" ? re += Z : X === "content-box" && (re -= W), G !== null || U !== null) {
    hiddenTextarea.value = " ";
    var ae = hiddenTextarea.scrollHeight - W;
    G !== null && (ee = ae * G, X === "border-box" && (ee = ee + W + Z), re = Math.max(ee, re)), U !== null && (te = ae * U, X === "border-box" && (te = te + W + Z), ne = re > te ? "" : "hidden", re = Math.min(te, re));
  }
  return {
    height: "".concat(re, "px"),
    minHeight: "".concat(ee, "px"),
    maxHeight: "".concat(te, "px"),
    overflowY: ne,
    resize: "none"
  };
}
var RESIZE_STATUS_NONE = 0, RESIZE_STATUS_RESIZING = 1, RESIZE_STATUS_RESIZED = 2, ResizableTextArea = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ResizableTextArea",
  inheritAttrs: !1,
  props: textAreaProps(),
  setup: function(C, G) {
    var U = G.attrs, K = G.emit, W = G.expose, Z, X, Q = ref(), ee = ref({}), te = ref(RESIZE_STATUS_NONE);
    onBeforeUnmount(function() {
      wrapperRaf.cancel(Z), wrapperRaf.cancel(X);
    });
    var re = function() {
      try {
        if (document.activeElement === Q.value) {
          var ue = Q.value.selectionStart, ce = Q.value.selectionEnd;
          Q.value.setSelectionRange(ue, ce);
        }
      } catch {
      }
    }, ne = function() {
      var ue = C.autoSize || C.autosize;
      if (!(!ue || !Q.value)) {
        var ce = ue.minRows, de = ue.maxRows;
        ee.value = calculateNodeHeight(Q.value, !1, ce, de), te.value = RESIZE_STATUS_RESIZING, wrapperRaf.cancel(X), X = wrapperRaf(function() {
          te.value = RESIZE_STATUS_RESIZED, X = wrapperRaf(function() {
            te.value = RESIZE_STATUS_NONE, re();
          });
        });
      }
    }, ae = function() {
      wrapperRaf.cancel(Z), Z = wrapperRaf(ne);
    }, ie = function(ue) {
      if (te.value === RESIZE_STATUS_NONE) {
        K("resize", ue);
        var ce = C.autoSize || C.autosize;
        ce && ae();
      }
    };
    warning$1(C.autosize === void 0, "Input.TextArea", "autosize is deprecated, please use autoSize instead.");
    var se = function() {
      var ue = C.prefixCls, ce = C.autoSize, de = C.autosize, ge = C.disabled, fe = omit(C, ["prefixCls", "onPressEnter", "autoSize", "autosize", "defaultValue", "allowClear", "type", "lazy", "maxlength", "valueModifiers"]), ve = classNames(ue, U.class, _defineProperty$A({}, "".concat(ue, "-disabled"), ge)), pe = [U.style, ee.value, te.value === RESIZE_STATUS_RESIZING ? {
        overflowX: "hidden",
        overflowY: "hidden"
      } : null], he = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, fe), U), {}, {
        style: pe,
        class: ve
      });
      return he.autofocus || delete he.autofocus, he.rows === 0 && delete he.rows, createVNode$1(ResizeObserver, {
        onResize: ie,
        disabled: !(ce || de)
      }, {
        default: function() {
          return [withDirectives(createVNode$1("textarea", _objectSpread2$1(_objectSpread2$1({}, he), {}, {
            ref: Q
          }), null), [[antInputDirective]])];
        }
      });
    };
    watch(function() {
      return C.value;
    }, function() {
      nextTick(function() {
        ne();
      });
    }), onMounted(function() {
      nextTick(function() {
        ne();
      });
    });
    var oe = getCurrentInstance();
    return W({
      resizeTextarea: ne,
      textArea: Q,
      instance: oe
    }), function() {
      return se();
    };
  }
});
const ResizableTextArea$1 = ResizableTextArea;
function fixEmojiLength(H, C) {
  return _toConsumableArray(H || "").slice(0, C).join("");
}
function setTriggerValue(H, C, G, U) {
  var K = G;
  return H ? K = fixEmojiLength(G, U) : _toConsumableArray(C || "").length < G.length && _toConsumableArray(G || "").length > U && (K = C), K;
}
const TextArea = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ATextarea",
  inheritAttrs: !1,
  props: textAreaProps(),
  setup: function(C, G) {
    var U = G.attrs, K = G.expose, W = G.emit, Z = useInjectFormItemContext(), X = ref(C.value === void 0 ? C.defaultValue : C.value), Q = ref(), ee = ref(""), te = useConfigInject("input", C), re = te.prefixCls, ne = te.size, ae = te.direction, ie = computed(function() {
      return C.showCount === "" || C.showCount || !1;
    }), se = computed(function() {
      return Number(C.maxlength) > 0;
    }), oe = ref(!1), le = ref(), ue = ref(0), ce = function(Ae) {
      oe.value = !0, le.value = ee.value, ue.value = Ae.currentTarget.selectionStart, W("compositionstart", Ae);
    }, de = function(Ae) {
      oe.value = !1;
      var _e = Ae.currentTarget.value;
      if (se.value) {
        var xe, Te = ue.value >= C.maxlength + 1 || ue.value === ((xe = le.value) === null || xe === void 0 ? void 0 : xe.length);
        _e = setTriggerValue(Te, le.value, _e, C.maxlength);
      }
      _e !== ee.value && (pe(_e), resolveOnChange(Ae.currentTarget, Ae, ye, _e)), W("compositionend", Ae);
    }, ge = getCurrentInstance();
    watch(function() {
      return C.value;
    }, function() {
      "value" in ge.vnode.props;
      var Se;
      X.value = (Se = C.value) !== null && Se !== void 0 ? Se : "";
    });
    var fe = function(Ae) {
      var _e;
      triggerFocus((_e = Q.value) === null || _e === void 0 ? void 0 : _e.textArea, Ae);
    }, ve = function() {
      var Ae, _e;
      (Ae = Q.value) === null || Ae === void 0 || (_e = Ae.textArea) === null || _e === void 0 || _e.blur();
    }, pe = function(Ae, _e) {
      X.value !== Ae && (C.value === void 0 ? X.value = Ae : nextTick(function() {
        if (Q.value.textArea.value !== ee.value) {
          var xe, Te, Pe;
          (xe = Q.value) === null || xe === void 0 || (Te = (Pe = xe.instance).update) === null || Te === void 0 || Te.call(Pe);
        }
      }), nextTick(function() {
        _e && _e();
      }));
    }, he = function(Ae) {
      Ae.keyCode === 13 && W("pressEnter", Ae), W("keydown", Ae);
    }, me = function(Ae) {
      var _e = C.onBlur;
      _e == null || _e(Ae), Z.onFieldBlur();
    }, ye = function(Ae) {
      W("update:value", Ae.target.value), W("change", Ae), W("input", Ae), Z.onFieldChange();
    }, Ce = function(Ae) {
      resolveOnChange(Q.value.textArea, Ae, ye), pe("", function() {
        fe();
      });
    }, Ie = function(Ae) {
      var _e = Ae.target.composing, xe = Ae.target.value;
      if (oe.value = !!(Ae.isComposing || _e), !(oe.value && C.lazy || X.value === xe)) {
        if (se.value) {
          var Te = Ae.target, Pe = Te.selectionStart >= C.maxlength + 1 || Te.selectionStart === xe.length || !Te.selectionStart;
          xe = setTriggerValue(Pe, ee.value, xe, C.maxlength);
        }
        resolveOnChange(Ae.currentTarget, Ae, ye, xe), pe(xe);
      }
    }, be = function() {
      var Ae, _e, xe, Te = U.style, Pe = U.class, $e = C.bordered, Me = $e === void 0 ? !0 : $e, Ee = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, omit(C, ["allowClear"])), U), {}, {
        style: ie.value ? {} : Te,
        class: (Ae = {}, _defineProperty$A(Ae, "".concat(re.value, "-borderless"), !Me), _defineProperty$A(Ae, "".concat(Pe), Pe && !ie.value), _defineProperty$A(Ae, "".concat(re.value, "-sm"), ne.value === "small"), _defineProperty$A(Ae, "".concat(re.value, "-lg"), ne.value === "large"), Ae),
        showCount: null,
        prefixCls: re.value,
        onInput: Ie,
        onChange: Ie,
        onBlur: me,
        onKeydown: he,
        onCompositionstart: ce,
        onCompositionend: de
      });
      return (_e = C.valueModifiers) !== null && _e !== void 0 && _e.lazy && delete Ee.onInput, createVNode$1(ResizableTextArea$1, _objectSpread2$1(_objectSpread2$1({}, Ee), {}, {
        id: (xe = Ee.id) !== null && xe !== void 0 ? xe : Z.id.value,
        ref: Q,
        maxlength: C.maxlength
      }), null);
    };
    return K({
      focus: fe,
      blur: ve,
      resizableTextArea: Q
    }), watchEffect(function() {
      var Se = fixControlledValue(X.value);
      !oe.value && se.value && (C.value === null || C.value === void 0) && (Se = fixEmojiLength(Se, C.maxlength)), ee.value = Se;
    }), function() {
      var Se = C.maxlength, Ae = C.bordered, _e = Ae === void 0 ? !0 : Ae, xe = C.hidden, Te = U.style, Pe = U.class, $e = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, C), U), {}, {
        prefixCls: re.value,
        inputType: "text",
        handleReset: Ce,
        direction: ae.value,
        bordered: _e,
        style: ie.value ? void 0 : Te
      }), Me = createVNode$1(ClearableLabeledInput, _objectSpread2$1(_objectSpread2$1({}, $e), {}, {
        value: ee.value
      }), {
        element: be
      });
      if (ie.value) {
        var Ee = _toConsumableArray(ee.value).length, we = "";
        _typeof$2(ie.value) === "object" ? we = ie.value.formatter({
          count: Ee,
          maxlength: Se
        }) : we = "".concat(Ee).concat(se.value ? " / ".concat(Se) : ""), Me = createVNode$1("div", {
          hidden: xe,
          class: classNames("".concat(re.value, "-textarea"), _defineProperty$A({}, "".concat(re.value, "-textarea-rtl"), ae.value === "rtl"), "".concat(re.value, "-textarea-show-count"), Pe),
          style: Te,
          "data-count": _typeof$2(we) !== "object" ? we : void 0
        }, [Me]);
      }
      return Me;
    };
  }
});
var EyeOutlined$2 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M942.2 486.2C847.4 286.5 704.1 186 512 186c-192.2 0-335.4 100.5-430.2 300.3a60.3 60.3 0 000 51.5C176.6 737.5 319.9 838 512 838c192.2 0 335.4-100.5 430.2-300.3 7.7-16.2 7.7-35 0-51.5zM512 766c-161.3 0-279.4-81.8-362.7-254C232.6 339.8 350.7 258 512 258c161.3 0 279.4 81.8 362.7 254C791.5 684.2 673.4 766 512 766zm-4-430c-97.2 0-176 78.8-176 176s78.8 176 176 176 176-78.8 176-176-78.8-176-176-176zm0 288c-61.9 0-112-50.1-112-112s50.1-112 112-112 112 50.1 112 112-50.1 112-112 112z" } }] }, name: "eye", theme: "outlined" };
const EyeOutlinedSvg = EyeOutlined$2;
function _objectSpread$f(H) {
  for (var C = 1; C < arguments.length; C++) {
    var G = arguments[C] != null ? Object(arguments[C]) : {}, U = Object.keys(G);
    typeof Object.getOwnPropertySymbols == "function" && (U = U.concat(Object.getOwnPropertySymbols(G).filter(function(K) {
      return Object.getOwnPropertyDescriptor(G, K).enumerable;
    }))), U.forEach(function(K) {
      _defineProperty$f(H, K, G[K]);
    });
  }
  return H;
}
function _defineProperty$f(H, C, G) {
  return C in H ? Object.defineProperty(H, C, { value: G, enumerable: !0, configurable: !0, writable: !0 }) : H[C] = G, H;
}
var EyeOutlined = function(C, G) {
  var U = _objectSpread$f({}, C, G.attrs);
  return createVNode$1(AntdIcon, _objectSpread$f({}, U, {
    icon: EyeOutlinedSvg
  }), null);
};
EyeOutlined.displayName = "EyeOutlined";
EyeOutlined.inheritAttrs = !1;
const EyeOutlined$1 = EyeOutlined;
var EyeInvisibleOutlined$2 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M942.2 486.2Q889.47 375.11 816.7 305l-50.88 50.88C807.31 395.53 843.45 447.4 874.7 512 791.5 684.2 673.4 766 512 766q-72.67 0-133.87-22.38L323 798.75Q408 838 512 838q288.3 0 430.2-300.3a60.29 60.29 0 000-51.5zm-63.57-320.64L836 122.88a8 8 0 00-11.32 0L715.31 232.2Q624.86 186 512 186q-288.3 0-430.2 300.3a60.3 60.3 0 000 51.5q56.69 119.4 136.5 191.41L112.48 835a8 8 0 000 11.31L155.17 889a8 8 0 0011.31 0l712.15-712.12a8 8 0 000-11.32zM149.3 512C232.6 339.8 350.7 258 512 258c54.54 0 104.13 9.36 149.12 28.39l-70.3 70.3a176 176 0 00-238.13 238.13l-83.42 83.42C223.1 637.49 183.3 582.28 149.3 512zm246.7 0a112.11 112.11 0 01146.2-106.69L401.31 546.2A112 112 0 01396 512z" } }, { tag: "path", attrs: { d: "M508 624c-3.46 0-6.87-.16-10.25-.47l-52.82 52.82a176.09 176.09 0 00227.42-227.42l-52.82 52.82c.31 3.38.47 6.79.47 10.25a111.94 111.94 0 01-112 112z" } }] }, name: "eye-invisible", theme: "outlined" };
const EyeInvisibleOutlinedSvg = EyeInvisibleOutlined$2;
function _objectSpread$e(H) {
  for (var C = 1; C < arguments.length; C++) {
    var G = arguments[C] != null ? Object(arguments[C]) : {}, U = Object.keys(G);
    typeof Object.getOwnPropertySymbols == "function" && (U = U.concat(Object.getOwnPropertySymbols(G).filter(function(K) {
      return Object.getOwnPropertyDescriptor(G, K).enumerable;
    }))), U.forEach(function(K) {
      _defineProperty$e(H, K, G[K]);
    });
  }
  return H;
}
function _defineProperty$e(H, C, G) {
  return C in H ? Object.defineProperty(H, C, { value: G, enumerable: !0, configurable: !0, writable: !0 }) : H[C] = G, H;
}
var EyeInvisibleOutlined = function(C, G) {
  var U = _objectSpread$e({}, C, G.attrs);
  return createVNode$1(AntdIcon, _objectSpread$e({}, U, {
    icon: EyeInvisibleOutlinedSvg
  }), null);
};
EyeInvisibleOutlined.displayName = "EyeInvisibleOutlined";
EyeInvisibleOutlined.inheritAttrs = !1;
const EyeInvisibleOutlined$1 = EyeInvisibleOutlined;
var _excluded$a = ["size", "visibilityToggle"], ActionMap = {
  click: "onClick",
  hover: "onMouseover"
}, defaultIconRender = function(C) {
  return C ? createVNode$1(EyeOutlined$1, null, null) : createVNode$1(EyeInvisibleOutlined$1, null, null);
};
const Password = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AInputPassword",
  inheritAttrs: !1,
  props: _objectSpread2$1(_objectSpread2$1({}, inputProps$1()), {}, {
    prefixCls: String,
    inputPrefixCls: String,
    action: {
      type: String,
      default: "click"
    },
    visibilityToggle: {
      type: Boolean,
      default: !0
    },
    iconRender: Function
  }),
  setup: function(C, G) {
    var U = G.slots, K = G.attrs, W = G.expose, Z = ref(!1), X = function() {
      var ue = C.disabled;
      ue || (Z.value = !Z.value);
    }, Q = ref(), ee = function() {
      var ue;
      (ue = Q.value) === null || ue === void 0 || ue.focus();
    }, te = function() {
      var ue;
      (ue = Q.value) === null || ue === void 0 || ue.blur();
    };
    W({
      focus: ee,
      blur: te
    });
    var re = function(ue) {
      var ce, de = C.action, ge = C.iconRender, fe = ge === void 0 ? U.iconRender || defaultIconRender : ge, ve = ActionMap[de] || "", pe = fe(Z.value), he = (ce = {}, _defineProperty$A(ce, ve, X), _defineProperty$A(ce, "class", "".concat(ue, "-icon")), _defineProperty$A(ce, "key", "passwordIcon"), _defineProperty$A(ce, "onMousedown", function(ye) {
        ye.preventDefault();
      }), _defineProperty$A(ce, "onMouseup", function(ye) {
        ye.preventDefault();
      }), ce);
      return cloneElement(isValidElement(pe) ? pe : createVNode$1("span", null, [pe]), he);
    }, ne = useConfigInject("input-password", C), ae = ne.prefixCls, ie = ne.getPrefixCls, se = computed(function() {
      return ie("input", C.inputPrefixCls);
    }), oe = function() {
      var ue = C.size, ce = C.visibilityToggle, de = _objectWithoutProperties$2(C, _excluded$a), ge = ce && re(ae.value), fe = classNames(ae.value, K.class, _defineProperty$A({}, "".concat(ae.value, "-").concat(ue), !!ue)), ve = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, omit(de, ["suffix", "iconRender", "action"])), K), {}, {
        type: Z.value ? "text" : "password",
        class: fe,
        prefixCls: se.value,
        suffix: ge
      });
      return ue && (ve.size = ue), createVNode$1(Input, _objectSpread2$1({
        ref: Q
      }, ve), U);
    };
    return function() {
      return oe();
    };
  }
});
Input.Group = Group$5;
Input.Search = Search;
Input.TextArea = TextArea;
Input.Password = Password;
Input.install = function(H) {
  return H.component(Input.name, Input), H.component(Input.Group.name, Input.Group), H.component(Input.Search.name, Input.Search), H.component(Input.TextArea.name, Input.TextArea), H.component(Input.Password.name, Input.Password), H;
};
function getOffset(H) {
  var C = H.getBoundingClientRect(), G = document.documentElement;
  return {
    left: C.left + (window.pageXOffset || G.scrollLeft) - (G.clientLeft || document.body.clientLeft || 0),
    top: C.top + (window.pageYOffset || G.scrollTop) - (G.clientTop || document.body.clientTop || 0)
  };
}
function _objectDestructuringEmpty(H) {
  if (H == null)
    throw new TypeError("Cannot destructure " + H);
}
var _excluded$9 = ["class", "style"], spinProps = function() {
  return {
    prefixCls: String,
    spinning: {
      type: Boolean,
      default: void 0
    },
    size: String,
    wrapperClassName: String,
    tip: PropTypes$1.any,
    delay: Number,
    indicator: PropTypes$1.any
  };
}, defaultIndicator = null;
function shouldDelay(H, C) {
  return !!H && !!C && !isNaN(Number(C));
}
function setDefaultIndicator(H) {
  var C = H.indicator;
  defaultIndicator = typeof C == "function" ? C : function() {
    return createVNode$1(C, null, null);
  };
}
const Spin = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ASpin",
  inheritAttrs: !1,
  props: initDefaultProps$1(spinProps(), {
    size: "default",
    spinning: !0,
    wrapperClassName: ""
  }),
  setup: function() {
    return {
      originalUpdateSpinning: null,
      configProvider: inject("configProvider", defaultConfigProvider)
    };
  },
  data: function() {
    var C = this.spinning, G = this.delay, U = shouldDelay(C, G);
    return {
      sSpinning: C && !U
    };
  },
  created: function() {
    this.originalUpdateSpinning = this.updateSpinning, this.debouncifyUpdateSpinning(this.$props);
  },
  mounted: function() {
    this.updateSpinning();
  },
  updated: function() {
    var C = this;
    nextTick(function() {
      C.debouncifyUpdateSpinning(), C.updateSpinning();
    });
  },
  beforeUnmount: function() {
    this.cancelExistingSpin();
  },
  methods: {
    debouncifyUpdateSpinning: function(C) {
      var G = C || this.$props, U = G.delay;
      U && (this.cancelExistingSpin(), this.updateSpinning = debounce(this.originalUpdateSpinning, U));
    },
    updateSpinning: function() {
      var C = this.spinning, G = this.sSpinning;
      G !== C && (this.sSpinning = C);
    },
    cancelExistingSpin: function() {
      var C = this.updateSpinning;
      C && C.cancel && C.cancel();
    },
    renderIndicator: function(C) {
      var G = "".concat(C, "-dot"), U = getComponent(this, "indicator");
      return U === null ? null : (Array.isArray(U) && (U = U.length === 1 ? U[0] : U), isVNode(U) ? cloneVNode(U, {
        class: G
      }) : defaultIndicator && isVNode(defaultIndicator()) ? cloneVNode(defaultIndicator(), {
        class: G
      }) : createVNode$1("span", {
        class: "".concat(G, " ").concat(C, "-dot-spin")
      }, [createVNode$1("i", {
        class: "".concat(C, "-dot-item")
      }, null), createVNode$1("i", {
        class: "".concat(C, "-dot-item")
      }, null), createVNode$1("i", {
        class: "".concat(C, "-dot-item")
      }, null), createVNode$1("i", {
        class: "".concat(C, "-dot-item")
      }, null)]));
    }
  },
  render: function() {
    var C, G, U, K = this.$props, W = K.size, Z = K.prefixCls, X = K.tip, Q = X === void 0 ? (C = (G = this.$slots).tip) === null || C === void 0 ? void 0 : C.call(G) : X, ee = K.wrapperClassName, te = this.$attrs, re = te.class, ne = te.style, ae = _objectWithoutProperties$2(te, _excluded$9), ie = this.configProvider, se = ie.getPrefixCls, oe = ie.direction, le = se("spin", Z), ue = this.sSpinning, ce = (U = {}, _defineProperty$A(U, le, !0), _defineProperty$A(U, "".concat(le, "-sm"), W === "small"), _defineProperty$A(U, "".concat(le, "-lg"), W === "large"), _defineProperty$A(U, "".concat(le, "-spinning"), ue), _defineProperty$A(U, "".concat(le, "-show-text"), !!Q), _defineProperty$A(U, "".concat(le, "-rtl"), oe === "rtl"), _defineProperty$A(U, re, !!re), U), de = createVNode$1("div", _objectSpread2$1(_objectSpread2$1({}, ae), {}, {
      style: ne,
      class: ce
    }), [this.renderIndicator(le), Q ? createVNode$1("div", {
      class: "".concat(le, "-text")
    }, [Q]) : null]), ge = getSlot(this);
    if (ge && ge.length) {
      var fe, ve = (fe = {}, _defineProperty$A(fe, "".concat(le, "-container"), !0), _defineProperty$A(fe, "".concat(le, "-blur"), ue), fe);
      return createVNode$1("div", {
        class: ["".concat(le, "-nested-loading"), ee]
      }, [ue && createVNode$1("div", {
        key: "loading"
      }, [de]), createVNode$1("div", {
        class: ve,
        key: "container"
      }, [ge])]);
    }
    return de;
  }
});
Spin.setDefaultIndicator = setDefaultIndicator;
Spin.install = function(H) {
  return H.component(Spin.name, Spin), H;
};
var DoubleLeftOutlined$2 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M272.9 512l265.4-339.1c4.1-5.2.4-12.9-6.3-12.9h-77.3c-4.9 0-9.6 2.3-12.6 6.1L186.8 492.3a31.99 31.99 0 000 39.5l255.3 326.1c3 3.9 7.7 6.1 12.6 6.1H532c6.7 0 10.4-7.7 6.3-12.9L272.9 512zm304 0l265.4-339.1c4.1-5.2.4-12.9-6.3-12.9h-77.3c-4.9 0-9.6 2.3-12.6 6.1L490.8 492.3a31.99 31.99 0 000 39.5l255.3 326.1c3 3.9 7.7 6.1 12.6 6.1H836c6.7 0 10.4-7.7 6.3-12.9L576.9 512z" } }] }, name: "double-left", theme: "outlined" };
const DoubleLeftOutlinedSvg = DoubleLeftOutlined$2;
function _objectSpread$d(H) {
  for (var C = 1; C < arguments.length; C++) {
    var G = arguments[C] != null ? Object(arguments[C]) : {}, U = Object.keys(G);
    typeof Object.getOwnPropertySymbols == "function" && (U = U.concat(Object.getOwnPropertySymbols(G).filter(function(K) {
      return Object.getOwnPropertyDescriptor(G, K).enumerable;
    }))), U.forEach(function(K) {
      _defineProperty$d(H, K, G[K]);
    });
  }
  return H;
}
function _defineProperty$d(H, C, G) {
  return C in H ? Object.defineProperty(H, C, { value: G, enumerable: !0, configurable: !0, writable: !0 }) : H[C] = G, H;
}
var DoubleLeftOutlined = function(C, G) {
  var U = _objectSpread$d({}, C, G.attrs);
  return createVNode$1(AntdIcon, _objectSpread$d({}, U, {
    icon: DoubleLeftOutlinedSvg
  }), null);
};
DoubleLeftOutlined.displayName = "DoubleLeftOutlined";
DoubleLeftOutlined.inheritAttrs = !1;
const DoubleLeftOutlined$1 = DoubleLeftOutlined;
var DoubleRightOutlined$2 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M533.2 492.3L277.9 166.1c-3-3.9-7.7-6.1-12.6-6.1H188c-6.7 0-10.4 7.7-6.3 12.9L447.1 512 181.7 851.1A7.98 7.98 0 00188 864h77.3c4.9 0 9.6-2.3 12.6-6.1l255.3-326.1c9.1-11.7 9.1-27.9 0-39.5zm304 0L581.9 166.1c-3-3.9-7.7-6.1-12.6-6.1H492c-6.7 0-10.4 7.7-6.3 12.9L751.1 512 485.7 851.1A7.98 7.98 0 00492 864h77.3c4.9 0 9.6-2.3 12.6-6.1l255.3-326.1c9.1-11.7 9.1-27.9 0-39.5z" } }] }, name: "double-right", theme: "outlined" };
const DoubleRightOutlinedSvg = DoubleRightOutlined$2;
function _objectSpread$c(H) {
  for (var C = 1; C < arguments.length; C++) {
    var G = arguments[C] != null ? Object(arguments[C]) : {}, U = Object.keys(G);
    typeof Object.getOwnPropertySymbols == "function" && (U = U.concat(Object.getOwnPropertySymbols(G).filter(function(K) {
      return Object.getOwnPropertyDescriptor(G, K).enumerable;
    }))), U.forEach(function(K) {
      _defineProperty$c(H, K, G[K]);
    });
  }
  return H;
}
function _defineProperty$c(H, C, G) {
  return C in H ? Object.defineProperty(H, C, { value: G, enumerable: !0, configurable: !0, writable: !0 }) : H[C] = G, H;
}
var DoubleRightOutlined = function(C, G) {
  var U = _objectSpread$c({}, C, G.attrs);
  return createVNode$1(AntdIcon, _objectSpread$c({}, U, {
    icon: DoubleRightOutlinedSvg
  }), null);
};
DoubleRightOutlined.displayName = "DoubleRightOutlined";
DoubleRightOutlined.inheritAttrs = !1;
const DoubleRightOutlined$1 = DoubleRightOutlined, MiniSelect = defineComponent({
  compatConfig: {
    MODE: 3
  },
  inheritAttrs: !1,
  props: selectProps(),
  Option: VcSelect.Option,
  setup: function(C, G) {
    var U = G.attrs, K = G.slots;
    return function() {
      var W = _objectSpread2$1(_objectSpread2$1({}, C), {}, {
        size: "small"
      }, U);
      return createVNode$1(VcSelect, W, K);
    };
  }
}), Pager = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Pager",
  inheritAttrs: !1,
  props: {
    rootPrefixCls: String,
    page: Number,
    active: {
      type: Boolean,
      default: void 0
    },
    last: {
      type: Boolean,
      default: void 0
    },
    locale: PropTypes$1.object,
    showTitle: {
      type: Boolean,
      default: void 0
    },
    itemRender: {
      type: Function,
      default: function() {
      }
    },
    onClick: {
      type: Function
    },
    onKeypress: {
      type: Function
    }
  },
  eimt: ["click", "keypress"],
  setup: function(C, G) {
    var U = G.emit, K = G.attrs, W = function() {
      U("click", C.page);
    }, Z = function(Q) {
      U("keypress", Q, W, C.page);
    };
    return function() {
      var X, Q = C.showTitle, ee = C.page, te = C.itemRender, re = K.class, ne = K.style, ae = "".concat(C.rootPrefixCls, "-item"), ie = classNames(ae, "".concat(ae, "-").concat(C.page), (X = {}, _defineProperty$A(X, "".concat(ae, "-active"), C.active), _defineProperty$A(X, "".concat(ae, "-disabled"), !C.page), X), re);
      return createVNode$1("li", {
        onClick: W,
        onKeypress: Z,
        title: Q ? String(ee) : null,
        tabindex: "0",
        class: ie,
        style: ne
      }, [te({
        page: ee,
        type: "page",
        originalElement: createVNode$1("a", {
          rel: "nofollow"
        }, [ee])
      })]);
    };
  }
}), KEYCODE = {
  ZERO: 48,
  NINE: 57,
  NUMPAD_ZERO: 96,
  NUMPAD_NINE: 105,
  BACKSPACE: 8,
  DELETE: 46,
  ENTER: 13,
  ARROW_UP: 38,
  ARROW_DOWN: 40
}, Options = defineComponent({
  compatConfig: {
    MODE: 3
  },
  props: {
    disabled: {
      type: Boolean,
      default: void 0
    },
    changeSize: Function,
    quickGo: Function,
    selectComponentClass: PropTypes$1.any,
    current: Number,
    pageSizeOptions: PropTypes$1.array.def(["10", "20", "50", "100"]),
    pageSize: Number,
    buildOptionText: Function,
    locale: PropTypes$1.object,
    rootPrefixCls: String,
    selectPrefixCls: String,
    goButton: PropTypes$1.any
  },
  setup: function(C) {
    var G = ref(""), U = computed(function() {
      return !G.value || isNaN(G.value) ? void 0 : Number(G.value);
    }), K = function(te) {
      return "".concat(te.value, " ").concat(C.locale.items_per_page);
    }, W = function(te) {
      var re = te.target, ne = re.value, ae = re.composing;
      te.isComposing || ae || G.value === ne || (G.value = ne);
    }, Z = function(te) {
      var re = C.goButton, ne = C.quickGo, ae = C.rootPrefixCls;
      if (!(re || G.value === ""))
        if (te.relatedTarget && (te.relatedTarget.className.indexOf("".concat(ae, "-item-link")) >= 0 || te.relatedTarget.className.indexOf("".concat(ae, "-item")) >= 0)) {
          G.value = "";
          return;
        } else
          ne(U.value), G.value = "";
    }, X = function(te) {
      G.value !== "" && (te.keyCode === KEYCODE.ENTER || te.type === "click") && (C.quickGo(U.value), G.value = "");
    }, Q = computed(function() {
      var ee = C.pageSize, te = C.pageSizeOptions;
      return te.some(function(re) {
        return re.toString() === ee.toString();
      }) ? te : te.concat([ee.toString()]).sort(function(re, ne) {
        var ae = isNaN(Number(re)) ? 0 : Number(re), ie = isNaN(Number(ne)) ? 0 : Number(ne);
        return ae - ie;
      });
    });
    return function() {
      var ee = C.rootPrefixCls, te = C.locale, re = C.changeSize, ne = C.quickGo, ae = C.goButton, ie = C.selectComponentClass, se = C.selectPrefixCls, oe = C.pageSize, le = C.disabled, ue = "".concat(ee, "-options"), ce = null, de = null, ge = null;
      if (!re && !ne)
        return null;
      if (re && ie) {
        var fe = C.buildOptionText || K, ve = Q.value.map(function(pe, he) {
          return createVNode$1(ie.Option, {
            key: he,
            value: pe
          }, {
            default: function() {
              return [fe({
                value: pe
              })];
            }
          });
        });
        ce = createVNode$1(ie, {
          disabled: le,
          prefixCls: se,
          showSearch: !1,
          class: "".concat(ue, "-size-changer"),
          optionLabelProp: "children",
          value: (oe || Q.value[0]).toString(),
          onChange: function(he) {
            return re(Number(he));
          },
          getPopupContainer: function(he) {
            return he.parentNode;
          }
        }, {
          default: function() {
            return [ve];
          }
        });
      }
      return ne && (ae && (ge = typeof ae == "boolean" ? createVNode$1("button", {
        type: "button",
        onClick: X,
        onKeyup: X,
        disabled: le,
        class: "".concat(ue, "-quick-jumper-button")
      }, [te.jump_to_confirm]) : createVNode$1("span", {
        onClick: X,
        onKeyup: X
      }, [ae])), de = createVNode$1("div", {
        class: "".concat(ue, "-quick-jumper")
      }, [te.jump_to, withDirectives(createVNode$1("input", {
        disabled: le,
        type: "text",
        value: G.value,
        onInput: W,
        onChange: W,
        onKeyup: X,
        onBlur: Z
      }, null), [[antInputDirective]]), te.page, ge])), createVNode$1("li", {
        class: "".concat(ue)
      }, [ce, de]);
    };
  }
}), LOCALE = {
  // Options.jsx
  items_per_page: "条/页",
  jump_to: "跳至",
  jump_to_confirm: "确定",
  page: "页",
  // Pagination.jsx
  prev_page: "上一页",
  next_page: "下一页",
  prev_5: "向前 5 页",
  next_5: "向后 5 页",
  prev_3: "向前 3 页",
  next_3: "向后 3 页"
};
var _excluded$8 = ["class"];
function isInteger(H) {
  return typeof H == "number" && isFinite(H) && Math.floor(H) === H;
}
function defaultItemRender(H) {
  var C = H.originalElement;
  return C;
}
function calculatePage(H, C, G) {
  var U = typeof H > "u" ? C.statePageSize : H;
  return Math.floor((G.total - 1) / U) + 1;
}
const VcPagination = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Pagination",
  mixins: [BaseMixin],
  inheritAttrs: !1,
  props: {
    disabled: {
      type: Boolean,
      default: void 0
    },
    prefixCls: PropTypes$1.string.def("rc-pagination"),
    selectPrefixCls: PropTypes$1.string.def("rc-select"),
    current: Number,
    defaultCurrent: PropTypes$1.number.def(1),
    total: PropTypes$1.number.def(0),
    pageSize: Number,
    defaultPageSize: PropTypes$1.number.def(10),
    hideOnSinglePage: {
      type: Boolean,
      default: !1
    },
    showSizeChanger: {
      type: Boolean,
      default: void 0
    },
    showLessItems: {
      type: Boolean,
      default: !1
    },
    // showSizeChange: PropTypes.func.def(noop),
    selectComponentClass: PropTypes$1.any,
    showPrevNextJumpers: {
      type: Boolean,
      default: !0
    },
    showQuickJumper: PropTypes$1.oneOfType([PropTypes$1.looseBool, PropTypes$1.object]).def(!1),
    showTitle: {
      type: Boolean,
      default: !0
    },
    pageSizeOptions: PropTypes$1.arrayOf(PropTypes$1.oneOfType([PropTypes$1.number, PropTypes$1.string])),
    buildOptionText: Function,
    showTotal: Function,
    simple: {
      type: Boolean,
      default: void 0
    },
    locale: PropTypes$1.object.def(LOCALE),
    itemRender: PropTypes$1.func.def(defaultItemRender),
    prevIcon: PropTypes$1.any,
    nextIcon: PropTypes$1.any,
    jumpPrevIcon: PropTypes$1.any,
    jumpNextIcon: PropTypes$1.any,
    totalBoundaryShowSizeChanger: PropTypes$1.number.def(50)
  },
  data: function() {
    var C = this.$props, G = firstNotUndefined([this.current, this.defaultCurrent]), U = firstNotUndefined([this.pageSize, this.defaultPageSize]);
    return G = Math.min(G, calculatePage(U, void 0, C)), {
      stateCurrent: G,
      stateCurrentInputValue: G,
      statePageSize: U
    };
  },
  watch: {
    current: function(C) {
      this.setState({
        stateCurrent: C,
        stateCurrentInputValue: C
      });
    },
    pageSize: function(C) {
      var G = {}, U = this.stateCurrent, K = calculatePage(C, this.$data, this.$props);
      U = U > K ? K : U, hasProp(this, "current") || (G.stateCurrent = U, G.stateCurrentInputValue = U), G.statePageSize = C, this.setState(G);
    },
    stateCurrent: function(C, G) {
      var U = this;
      this.$nextTick(function() {
        if (U.$refs.paginationNode) {
          var K = U.$refs.paginationNode.querySelector(".".concat(U.prefixCls, "-item-").concat(G));
          K && document.activeElement === K && K.blur();
        }
      });
    },
    total: function() {
      var C = {}, G = calculatePage(this.pageSize, this.$data, this.$props);
      if (hasProp(this, "current")) {
        var U = Math.min(this.current, G);
        C.stateCurrent = U, C.stateCurrentInputValue = U;
      } else {
        var K = this.stateCurrent;
        K === 0 && G > 0 ? K = 1 : K = Math.min(this.stateCurrent, G), C.stateCurrent = K;
      }
      this.setState(C);
    }
  },
  methods: {
    getJumpPrevPage: function() {
      return Math.max(1, this.stateCurrent - (this.showLessItems ? 3 : 5));
    },
    getJumpNextPage: function() {
      return Math.min(calculatePage(void 0, this.$data, this.$props), this.stateCurrent + (this.showLessItems ? 3 : 5));
    },
    getItemIcon: function(C, G) {
      var U = this.$props.prefixCls, K = getComponent(this, C, this.$props) || createVNode$1("button", {
        type: "button",
        "aria-label": G,
        class: "".concat(U, "-item-link")
      }, null);
      return K;
    },
    getValidValue: function(C) {
      var G = C.target.value, U = calculatePage(void 0, this.$data, this.$props), K = this.$data.stateCurrentInputValue, W;
      return G === "" ? W = G : isNaN(Number(G)) ? W = K : G >= U ? W = U : W = Number(G), W;
    },
    isValid: function(C) {
      return isInteger(C) && C !== this.stateCurrent;
    },
    shouldDisplayQuickJumper: function() {
      var C = this.$props, G = C.showQuickJumper, U = C.pageSize, K = C.total;
      return K <= U ? !1 : G;
    },
    // calculatePage (p) {
    //   let pageSize = p
    //   if (typeof pageSize === 'undefined') {
    //     pageSize = this.statePageSize
    //   }
    //   return Math.floor((this.total - 1) / pageSize) + 1
    // },
    handleKeyDown: function(C) {
      (C.keyCode === KEYCODE.ARROW_UP || C.keyCode === KEYCODE.ARROW_DOWN) && C.preventDefault();
    },
    handleKeyUp: function(C) {
      if (!(C.isComposing || C.target.composing)) {
        var G = this.getValidValue(C), U = this.stateCurrentInputValue;
        G !== U && this.setState({
          stateCurrentInputValue: G
        }), C.keyCode === KEYCODE.ENTER ? this.handleChange(G) : C.keyCode === KEYCODE.ARROW_UP ? this.handleChange(G - 1) : C.keyCode === KEYCODE.ARROW_DOWN && this.handleChange(G + 1);
      }
    },
    changePageSize: function(C) {
      var G = this.stateCurrent, U = G, K = calculatePage(C, this.$data, this.$props);
      G = G > K ? K : G, K === 0 && (G = this.stateCurrent), typeof C == "number" && (hasProp(this, "pageSize") || this.setState({
        statePageSize: C
      }), hasProp(this, "current") || this.setState({
        stateCurrent: G,
        stateCurrentInputValue: G
      })), this.__emit("update:pageSize", C), G !== U && this.__emit("update:current", G), this.__emit("showSizeChange", G, C), this.__emit("change", G, C);
    },
    handleChange: function(C) {
      var G = this.$props.disabled, U = C;
      if (this.isValid(U) && !G) {
        var K = calculatePage(void 0, this.$data, this.$props);
        return U > K ? U = K : U < 1 && (U = 1), hasProp(this, "current") || this.setState({
          stateCurrent: U,
          stateCurrentInputValue: U
        }), this.__emit("update:current", U), this.__emit("change", U, this.statePageSize), U;
      }
      return this.stateCurrent;
    },
    prev: function() {
      this.hasPrev() && this.handleChange(this.stateCurrent - 1);
    },
    next: function() {
      this.hasNext() && this.handleChange(this.stateCurrent + 1);
    },
    jumpPrev: function() {
      this.handleChange(this.getJumpPrevPage());
    },
    jumpNext: function() {
      this.handleChange(this.getJumpNextPage());
    },
    hasPrev: function() {
      return this.stateCurrent > 1;
    },
    hasNext: function() {
      return this.stateCurrent < calculatePage(void 0, this.$data, this.$props);
    },
    getShowSizeChanger: function() {
      var C = this.$props, G = C.showSizeChanger, U = C.total, K = C.totalBoundaryShowSizeChanger;
      return typeof G < "u" ? G : U > K;
    },
    runIfEnter: function(C, G) {
      if (C.key === "Enter" || C.charCode === 13) {
        for (var U = arguments.length, K = new Array(U > 2 ? U - 2 : 0), W = 2; W < U; W++)
          K[W - 2] = arguments[W];
        G.apply(void 0, K);
      }
    },
    runIfEnterPrev: function(C) {
      this.runIfEnter(C, this.prev);
    },
    runIfEnterNext: function(C) {
      this.runIfEnter(C, this.next);
    },
    runIfEnterJumpPrev: function(C) {
      this.runIfEnter(C, this.jumpPrev);
    },
    runIfEnterJumpNext: function(C) {
      this.runIfEnter(C, this.jumpNext);
    },
    handleGoTO: function(C) {
      (C.keyCode === KEYCODE.ENTER || C.type === "click") && this.handleChange(this.stateCurrentInputValue);
    },
    renderPrev: function(C) {
      var G = this.$props.itemRender, U = G({
        page: C,
        type: "prev",
        originalElement: this.getItemIcon("prevIcon", "prev page")
      }), K = !this.hasPrev();
      return isValidElement(U) ? cloneElement(U, K ? {
        disabled: K
      } : {}) : U;
    },
    renderNext: function(C) {
      var G = this.$props.itemRender, U = G({
        page: C,
        type: "next",
        originalElement: this.getItemIcon("nextIcon", "next page")
      }), K = !this.hasNext();
      return isValidElement(U) ? cloneElement(U, K ? {
        disabled: K
      } : {}) : U;
    }
  },
  render: function() {
    var C, G = this.$props, U = G.prefixCls, K = G.disabled, W = G.hideOnSinglePage, Z = G.total, X = G.locale, Q = G.showQuickJumper, ee = G.showLessItems, te = G.showTitle, re = G.showTotal, ne = G.simple, ae = G.itemRender, ie = G.showPrevNextJumpers, se = G.jumpPrevIcon, oe = G.jumpNextIcon, le = G.selectComponentClass, ue = G.selectPrefixCls, ce = G.pageSizeOptions, de = this.stateCurrent, ge = this.statePageSize, fe = splitAttrs(this.$attrs).extraAttrs, ve = fe.class, pe = _objectWithoutProperties$2(fe, _excluded$8);
    if (W === !0 && this.total <= ge)
      return null;
    var he = calculatePage(void 0, this.$data, this.$props), me = [], ye = null, Ce = null, Ie = null, be = null, Se = null, Ae = Q && Q.goButton, _e = ee ? 1 : 2, xe = de - 1 > 0 ? de - 1 : 0, Te = de + 1 < he ? de + 1 : he, Pe = this.hasPrev(), $e = this.hasNext();
    if (ne)
      return Ae && (typeof Ae == "boolean" ? Se = createVNode$1("button", {
        type: "button",
        onClick: this.handleGoTO,
        onKeyup: this.handleGoTO
      }, [X.jump_to_confirm]) : Se = createVNode$1("span", {
        onClick: this.handleGoTO,
        onKeyup: this.handleGoTO
      }, [Ae]), Se = createVNode$1("li", {
        title: te ? "".concat(X.jump_to).concat(de, "/").concat(he) : null,
        class: "".concat(U, "-simple-pager")
      }, [Se])), createVNode$1("ul", _objectSpread2$1({
        class: classNames("".concat(U, " ").concat(U, "-simple"), _defineProperty$A({}, "".concat(U, "-disabled"), K), ve)
      }, pe), [createVNode$1("li", {
        title: te ? X.prev_page : null,
        onClick: this.prev,
        tabindex: Pe ? 0 : null,
        onKeypress: this.runIfEnterPrev,
        class: classNames("".concat(U, "-prev"), _defineProperty$A({}, "".concat(U, "-disabled"), !Pe)),
        "aria-disabled": !Pe
      }, [this.renderPrev(xe)]), createVNode$1("li", {
        title: te ? "".concat(de, "/").concat(he) : null,
        class: "".concat(U, "-simple-pager")
      }, [withDirectives(createVNode$1("input", {
        type: "text",
        value: this.stateCurrentInputValue,
        disabled: K,
        onKeydown: this.handleKeyDown,
        onKeyup: this.handleKeyUp,
        onInput: this.handleKeyUp,
        onChange: this.handleKeyUp,
        size: "3"
      }, null), [[antInputDirective]]), createVNode$1("span", {
        class: "".concat(U, "-slash")
      }, [createTextVNode("／")]), he]), createVNode$1("li", {
        title: te ? X.next_page : null,
        onClick: this.next,
        tabindex: $e ? 0 : null,
        onKeypress: this.runIfEnterNext,
        class: classNames("".concat(U, "-next"), _defineProperty$A({}, "".concat(U, "-disabled"), !$e)),
        "aria-disabled": !$e
      }, [this.renderNext(Te)]), Se]);
    if (he <= 3 + _e * 2) {
      var Me = {
        locale: X,
        rootPrefixCls: U,
        showTitle: te,
        itemRender: ae,
        onClick: this.handleChange,
        onKeypress: this.runIfEnter
      };
      he || me.push(createVNode$1(Pager, _objectSpread2$1(_objectSpread2$1({}, Me), {}, {
        key: "noPager",
        page: 1,
        class: "".concat(U, "-item-disabled")
      }), null));
      for (var Ee = 1; Ee <= he; Ee += 1) {
        var we = de === Ee;
        me.push(createVNode$1(Pager, _objectSpread2$1(_objectSpread2$1({}, Me), {}, {
          key: Ee,
          page: Ee,
          active: we
        }), null));
      }
    } else {
      var Oe = ee ? X.prev_3 : X.prev_5, Ne = ee ? X.next_3 : X.next_5;
      ie && (ye = createVNode$1("li", {
        title: this.showTitle ? Oe : null,
        key: "prev",
        onClick: this.jumpPrev,
        tabindex: "0",
        onKeypress: this.runIfEnterJumpPrev,
        class: classNames("".concat(U, "-jump-prev"), _defineProperty$A({}, "".concat(U, "-jump-prev-custom-icon"), !!se))
      }, [ae({
        page: this.getJumpPrevPage(),
        type: "jump-prev",
        originalElement: this.getItemIcon("jumpPrevIcon", "prev page")
      })]), Ce = createVNode$1("li", {
        title: this.showTitle ? Ne : null,
        key: "next",
        tabindex: "0",
        onClick: this.jumpNext,
        onKeypress: this.runIfEnterJumpNext,
        class: classNames("".concat(U, "-jump-next"), _defineProperty$A({}, "".concat(U, "-jump-next-custom-icon"), !!oe))
      }, [ae({
        page: this.getJumpNextPage(),
        type: "jump-next",
        originalElement: this.getItemIcon("jumpNextIcon", "next page")
      })])), be = createVNode$1(Pager, {
        locale: X,
        last: !0,
        rootPrefixCls: U,
        onClick: this.handleChange,
        onKeypress: this.runIfEnter,
        key: he,
        page: he,
        active: !1,
        showTitle: te,
        itemRender: ae
      }, null), Ie = createVNode$1(Pager, {
        locale: X,
        rootPrefixCls: U,
        onClick: this.handleChange,
        onKeypress: this.runIfEnter,
        key: 1,
        page: 1,
        active: !1,
        showTitle: te,
        itemRender: ae
      }, null);
      var ke = Math.max(1, de - _e), ze = Math.min(de + _e, he);
      de - 1 <= _e && (ze = 1 + _e * 2), he - de <= _e && (ke = he - _e * 2);
      for (var He = ke; He <= ze; He += 1) {
        var We = de === He;
        me.push(createVNode$1(Pager, {
          locale: X,
          rootPrefixCls: U,
          onClick: this.handleChange,
          onKeypress: this.runIfEnter,
          key: He,
          page: He,
          active: We,
          showTitle: te,
          itemRender: ae
        }, null));
      }
      de - 1 >= _e * 2 && de !== 1 + 2 && (me[0] = createVNode$1(Pager, {
        locale: X,
        rootPrefixCls: U,
        onClick: this.handleChange,
        onKeypress: this.runIfEnter,
        key: ke,
        page: ke,
        class: "".concat(U, "-item-after-jump-prev"),
        active: !1,
        showTitle: this.showTitle,
        itemRender: ae
      }, null), me.unshift(ye)), he - de >= _e * 2 && de !== he - 2 && (me[me.length - 1] = createVNode$1(Pager, {
        locale: X,
        rootPrefixCls: U,
        onClick: this.handleChange,
        onKeypress: this.runIfEnter,
        key: ze,
        page: ze,
        class: "".concat(U, "-item-before-jump-next"),
        active: !1,
        showTitle: this.showTitle,
        itemRender: ae
      }, null), me.push(Ce)), ke !== 1 && me.unshift(Ie), ze !== he && me.push(be);
    }
    var Re = null;
    re && (Re = createVNode$1("li", {
      class: "".concat(U, "-total-text")
    }, [re(Z, [Z === 0 ? 0 : (de - 1) * ge + 1, de * ge > Z ? Z : de * ge])]));
    var Le = !Pe || !he, De = !$e || !he, Ue = this.buildOptionText || this.$slots.buildOptionText;
    return createVNode$1("ul", _objectSpread2$1(_objectSpread2$1({
      unselectable: "on",
      ref: "paginationNode"
    }, pe), {}, {
      class: classNames((C = {}, _defineProperty$A(C, "".concat(U), !0), _defineProperty$A(C, "".concat(U, "-disabled"), K), C), ve)
    }), [Re, createVNode$1("li", {
      title: te ? X.prev_page : null,
      onClick: this.prev,
      tabindex: Le ? null : 0,
      onKeypress: this.runIfEnterPrev,
      class: classNames("".concat(U, "-prev"), _defineProperty$A({}, "".concat(U, "-disabled"), Le)),
      "aria-disabled": Le
    }, [this.renderPrev(xe)]), me, createVNode$1("li", {
      title: te ? X.next_page : null,
      onClick: this.next,
      tabindex: De ? null : 0,
      onKeypress: this.runIfEnterNext,
      class: classNames("".concat(U, "-next"), _defineProperty$A({}, "".concat(U, "-disabled"), De)),
      "aria-disabled": De
    }, [this.renderNext(Te)]), createVNode$1(Options, {
      disabled: K,
      locale: X,
      rootPrefixCls: U,
      selectComponentClass: le,
      selectPrefixCls: ue,
      changeSize: this.getShowSizeChanger() ? this.changePageSize : null,
      current: de,
      pageSize: ge,
      pageSizeOptions: ce,
      buildOptionText: Ue || null,
      quickGo: this.shouldDisplayQuickJumper() ? this.handleChange : null,
      goButton: Ae
    }, null)]);
  }
});
var _excluded$7 = ["size", "itemRender", "buildOptionText", "selectComponentClass", "responsive"], paginationProps = function() {
  return {
    total: Number,
    defaultCurrent: Number,
    disabled: {
      type: Boolean,
      default: void 0
    },
    current: Number,
    defaultPageSize: Number,
    pageSize: Number,
    hideOnSinglePage: {
      type: Boolean,
      default: void 0
    },
    showSizeChanger: {
      type: Boolean,
      default: void 0
    },
    pageSizeOptions: Array,
    buildOptionText: Function,
    showQuickJumper: {
      type: [Boolean, Object],
      default: void 0
    },
    showTotal: Function,
    size: String,
    simple: {
      type: Boolean,
      default: void 0
    },
    locale: Object,
    prefixCls: String,
    selectPrefixCls: String,
    totalBoundaryShowSizeChanger: Number,
    selectComponentClass: String,
    itemRender: Function,
    role: String,
    responsive: Boolean,
    showLessItems: {
      type: Boolean,
      default: void 0
    },
    onChange: Function,
    onShowSizeChange: Function,
    "onUpdate:current": Function,
    "onUpdate:pageSize": Function
  };
};
const Pagination$1 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "APagination",
  inheritAttrs: !1,
  props: paginationProps(),
  // emits: ['change', 'showSizeChange', 'update:current', 'update:pageSize'],
  setup: function(C, G) {
    var U = G.slots, K = G.attrs, W = useConfigInject("pagination", C), Z = W.prefixCls, X = W.configProvider, Q = W.direction, ee = computed(function() {
      return X.getPrefixCls("select", C.selectPrefixCls);
    }), te = useBreakpoint(), re = useLocaleReceiver("Pagination", enUS$1, toRef(C, "locale")), ne = _slicedToArray$2(re, 1), ae = ne[0], ie = function(oe) {
      var le = createVNode$1("span", {
        class: "".concat(oe, "-item-ellipsis")
      }, [createTextVNode("•••")]), ue = createVNode$1("button", {
        class: "".concat(oe, "-item-link"),
        type: "button",
        tabindex: -1
      }, [createVNode$1(LeftOutlined$1, null, null)]), ce = createVNode$1("button", {
        class: "".concat(oe, "-item-link"),
        type: "button",
        tabindex: -1
      }, [createVNode$1(RightOutlined$1, null, null)]), de = createVNode$1("a", {
        rel: "nofollow",
        class: "".concat(oe, "-item-link")
      }, [createVNode$1("div", {
        class: "".concat(oe, "-item-container")
      }, [createVNode$1(DoubleLeftOutlined$1, {
        class: "".concat(oe, "-item-link-icon")
      }, null), le])]), ge = createVNode$1("a", {
        rel: "nofollow",
        class: "".concat(oe, "-item-link")
      }, [createVNode$1("div", {
        class: "".concat(oe, "-item-container")
      }, [createVNode$1(DoubleRightOutlined$1, {
        class: "".concat(oe, "-item-link-icon")
      }, null), le])]);
      if (Q.value === "rtl") {
        var fe = [ce, ue];
        ue = fe[0], ce = fe[1];
        var ve = [ge, de];
        de = ve[0], ge = ve[1];
      }
      return {
        prevIcon: ue,
        nextIcon: ce,
        jumpPrevIcon: de,
        jumpNextIcon: ge
      };
    };
    return function() {
      var se, oe = C.size, le = C.itemRender, ue = le === void 0 ? U.itemRender : le, ce = C.buildOptionText, de = ce === void 0 ? U.buildOptionText : ce, ge = C.selectComponentClass, fe = C.responsive, ve = _objectWithoutProperties$2(C, _excluded$7), pe = oe === "small" || !!((se = te.value) !== null && se !== void 0 && se.xs && !oe && fe), he = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, ve), ie(Z.value)), {}, {
        prefixCls: Z.value,
        selectPrefixCls: ee.value,
        selectComponentClass: ge || (pe ? MiniSelect : VcSelect),
        locale: ae.value,
        buildOptionText: de
      }, K), {}, {
        class: classNames(_defineProperty$A({
          mini: pe
        }, "".concat(Z.value, "-rtl"), Q.value === "rtl"), K.class),
        itemRender: ue
      });
      return createVNode$1(VcPagination, he, null);
    };
  }
}), Pagination = withInstall(Pagination$1);
var TableContextKey = Symbol("TableContextProps"), useProvideTable = function(C) {
  provide(TableContextKey, C);
}, useInjectTable = function() {
  return inject(TableContextKey, {});
}, INTERNAL_KEY_PREFIX = "RC_TABLE_KEY";
function toArray(H) {
  return H == null ? [] : Array.isArray(H) ? H : [H];
}
function getPathValue(H, C) {
  if (!C && typeof C != "number")
    return H;
  for (var G = toArray(C), U = H, K = 0; K < G.length; K += 1) {
    if (!U)
      return null;
    var W = G[K];
    U = U[W];
  }
  return U;
}
function getColumnsKey(H) {
  var C = [], G = {};
  return H.forEach(function(U) {
    for (var K = U || {}, W = K.key, Z = K.dataIndex, X = W || toArray(Z).join("-") || INTERNAL_KEY_PREFIX; G[X]; )
      X = "".concat(X, "_next");
    G[X] = !0, C.push(X);
  }), C;
}
function mergeObject() {
  var H = {};
  function C(W, Z) {
    Z && Object.keys(Z).forEach(function(X) {
      var Q = Z[X];
      Q && _typeof$2(Q) === "object" ? (W[X] = W[X] || {}, C(W[X], Q)) : W[X] = Q;
    });
  }
  for (var G = arguments.length, U = new Array(G), K = 0; K < G; K++)
    U[K] = arguments[K];
  return U.forEach(function(W) {
    C(H, W);
  }), H;
}
function validateValue(H) {
  return H != null;
}
var SlotsContextKey = Symbol("SlotsContextProps"), useProvideSlots = function(C) {
  provide(SlotsContextKey, C);
}, useInjectSlots = function() {
  return inject(SlotsContextKey, computed(function() {
    return {};
  }));
}, ContextKey = Symbol("ContextProps"), useProvideTableContext = function(C) {
  provide(ContextKey, C);
}, useInjectTableContext = function() {
  return inject(ContextKey, {
    onResizeColumn: function() {
    }
  });
}, INTERNAL_COL_DEFINE = "RC_TABLE_INTERNAL_COL_DEFINE", HoverContextKey = Symbol("HoverContextProps"), useProvideHover = function(C) {
  provide(HoverContextKey, C);
}, useInjectHover = function() {
  return inject(HoverContextKey, {
    startRow: ref(-1),
    endRow: ref(-1),
    onHover: function() {
    }
  });
}, supportSticky = ref(!1), useProvideSticky = function() {
  onMounted(function() {
    supportSticky.value = supportSticky.value || isStyleSupport("position", "sticky");
  });
}, useInjectSticky = function() {
  return supportSticky;
}, _excluded$6 = ["colSpan", "rowSpan", "style", "class"];
function inHoverRange(H, C, G, U) {
  var K = H + C - 1;
  return H <= U && K >= G;
}
function isRenderCell(H) {
  return H && _typeof$2(H) === "object" && !Array.isArray(H) && !isVNode(H);
}
const Cell = defineComponent({
  name: "Cell",
  props: ["prefixCls", "record", "index", "renderIndex", "dataIndex", "customRender", "component", "colSpan", "rowSpan", "fixLeft", "fixRight", "firstFixLeft", "lastFixLeft", "firstFixRight", "lastFixRight", "appendNode", "additionalProps", "ellipsis", "align", "rowType", "isSticky", "column", "cellType", "transformCellText"],
  slots: ["appendNode"],
  setup: function(C, G) {
    var U = G.slots, K = useInjectSlots(), W = useInjectHover(), Z = W.onHover, X = W.startRow, Q = W.endRow, ee = computed(function() {
      var oe, le, ue, ce;
      return (oe = (le = C.colSpan) !== null && le !== void 0 ? le : (ue = C.additionalProps) === null || ue === void 0 ? void 0 : ue.colSpan) !== null && oe !== void 0 ? oe : (ce = C.additionalProps) === null || ce === void 0 ? void 0 : ce.colspan;
    }), te = computed(function() {
      var oe, le, ue, ce;
      return (oe = (le = C.rowSpan) !== null && le !== void 0 ? le : (ue = C.additionalProps) === null || ue === void 0 ? void 0 : ue.rowSpan) !== null && oe !== void 0 ? oe : (ce = C.additionalProps) === null || ce === void 0 ? void 0 : ce.rowspan;
    }), re = eagerComputed(function() {
      var oe = C.index;
      return inHoverRange(oe, te.value || 1, X.value, Q.value);
    }), ne = useInjectSticky(), ae = function(le, ue) {
      var ce, de = C.record, ge = C.index, fe = C.additionalProps;
      de && Z(ge, ge + ue - 1), fe == null || (ce = fe.onMouseenter) === null || ce === void 0 || ce.call(fe, le);
    }, ie = function(le) {
      var ue, ce = C.record, de = C.additionalProps;
      ce && Z(-1, -1), de == null || (ue = de.onMouseleave) === null || ue === void 0 || ue.call(de, le);
    }, se = function oe(le) {
      var ue = filterEmpty(le)[0];
      return isVNode(ue) ? ue.type === Text ? ue.children : Array.isArray(ue.children) ? oe(ue.children) : void 0 : ue;
    };
    return function() {
      var oe, le, ue, ce, de, ge, fe = C.prefixCls, ve = C.record, pe = C.index, he = C.renderIndex, me = C.dataIndex, ye = C.customRender, Ce = C.component, Ie = Ce === void 0 ? "td" : Ce, be = C.fixLeft, Se = C.fixRight, Ae = C.firstFixLeft, _e = C.lastFixLeft, xe = C.firstFixRight, Te = C.lastFixRight, Pe = C.appendNode, $e = Pe === void 0 ? (oe = U.appendNode) === null || oe === void 0 ? void 0 : oe.call(U) : Pe, Me = C.additionalProps, Ee = Me === void 0 ? {} : Me, we = C.ellipsis, Oe = C.align, Ne = C.rowType, ke = C.isSticky, ze = C.column, He = ze === void 0 ? {} : ze, We = C.cellType, Re = "".concat(fe, "-cell"), Le, De, Ue = (le = U.default) === null || le === void 0 ? void 0 : le.call(U);
      if (validateValue(Ue) || We === "header")
        De = Ue;
      else {
        var st, ot = getPathValue(ve, me);
        if (De = ot, ye) {
          var ct = ye({
            text: ot,
            value: ot,
            record: ve,
            index: pe,
            renderIndex: he,
            column: He.__originColumn__
          });
          isRenderCell(ct) ? (process.env.NODE_ENV !== "production" && warning$2(!1, "`columns.customRender` return cell props is deprecated with perf issue, please use `customCell` instead."), De = ct.children, Le = ct.props) : De = ct;
        }
        if (!(INTERNAL_COL_DEFINE in He) && We === "body" && K.value.bodyCell && !((st = He.slots) !== null && st !== void 0 && st.customRender)) {
          var vt = renderSlot(K.value, "bodyCell", {
            text: ot,
            value: ot,
            record: ve,
            index: pe,
            column: He.__originColumn__
          }, function() {
            var Be = De === void 0 ? ot : De;
            return [_typeof$2(Be) === "object" && isValidElement(Be) || _typeof$2(Be) !== "object" ? Be : null];
          });
          De = flattenChildren(vt);
        }
        C.transformCellText && (De = C.transformCellText({
          text: De,
          record: ve,
          index: pe,
          column: He.__originColumn__
        }));
      }
      _typeof$2(De) === "object" && !Array.isArray(De) && !isVNode(De) && (De = null), we && (_e || xe) && (De = createVNode$1("span", {
        class: "".concat(Re, "-content")
      }, [De])), Array.isArray(De) && De.length === 1 && (De = De[0]);
      var ut = Le || {}, at = ut.colSpan, Ze = ut.rowSpan, Xe = ut.style, qe = ut.class, dt = _objectWithoutProperties$2(ut, _excluded$6), gt = (ue = at !== void 0 ? at : ee.value) !== null && ue !== void 0 ? ue : 1, yt = (ce = Ze !== void 0 ? Ze : te.value) !== null && ce !== void 0 ? ce : 1;
      if (gt === 0 || yt === 0)
        return null;
      var At = {}, nt = typeof be == "number" && ne.value, Ke = typeof Se == "number" && ne.value;
      nt && (At.position = "sticky", At.left = "".concat(be, "px")), Ke && (At.position = "sticky", At.right = "".concat(Se, "px"));
      var Qe = {};
      Oe && (Qe.textAlign = Oe);
      var pt, Ye = we === !0 ? {
        showTitle: !0
      } : we;
      Ye && (Ye.showTitle || Ne === "header") && (typeof De == "string" || typeof De == "number" ? pt = De.toString() : isVNode(De) && (pt = se([De])));
      var Fe = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
        title: pt
      }, dt), Ee), {}, {
        colSpan: gt !== 1 ? gt : null,
        rowSpan: yt !== 1 ? yt : null,
        class: classNames(Re, (de = {}, _defineProperty$A(de, "".concat(Re, "-fix-left"), nt && ne.value), _defineProperty$A(de, "".concat(Re, "-fix-left-first"), Ae && ne.value), _defineProperty$A(de, "".concat(Re, "-fix-left-last"), _e && ne.value), _defineProperty$A(de, "".concat(Re, "-fix-right"), Ke && ne.value), _defineProperty$A(de, "".concat(Re, "-fix-right-first"), xe && ne.value), _defineProperty$A(de, "".concat(Re, "-fix-right-last"), Te && ne.value), _defineProperty$A(de, "".concat(Re, "-ellipsis"), we), _defineProperty$A(de, "".concat(Re, "-with-append"), $e), _defineProperty$A(de, "".concat(Re, "-fix-sticky"), (nt || Ke) && ke && ne.value), _defineProperty$A(de, "".concat(Re, "-row-hover"), !Le && re.value), de), Ee.class, qe),
        onMouseenter: function(je) {
          ae(je, yt);
        },
        onMouseleave: ie,
        style: _objectSpread2$1(_objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, parseStyleText(Ee.style)), Qe), At), Xe)
      });
      return createVNode$1(Ie, Fe, {
        default: function() {
          return [$e, De, (ge = U.dragHandle) === null || ge === void 0 ? void 0 : ge.call(U)];
        }
      });
    };
  }
});
function getCellFixedInfo(H, C, G, U, K) {
  var W = G[H] || {}, Z = G[C] || {}, X, Q;
  W.fixed === "left" ? X = U.left[H] : Z.fixed === "right" && (Q = U.right[C]);
  var ee = !1, te = !1, re = !1, ne = !1, ae = G[C + 1], ie = G[H - 1];
  if (K === "rtl") {
    if (X !== void 0) {
      var se = ie && ie.fixed === "left";
      ne = !se;
    } else if (Q !== void 0) {
      var oe = ae && ae.fixed === "right";
      re = !oe;
    }
  } else if (X !== void 0) {
    var le = ae && ae.fixed === "left";
    ee = !le;
  } else if (Q !== void 0) {
    var ue = ie && ie.fixed === "right";
    te = !ue;
  }
  return {
    fixLeft: X,
    fixRight: Q,
    lastFixLeft: ee,
    firstFixRight: te,
    lastFixRight: re,
    firstFixLeft: ne,
    isSticky: U.isSticky
  };
}
var events = {
  mouse: {
    start: "mousedown",
    move: "mousemove",
    stop: "mouseup"
  },
  touch: {
    start: "touchstart",
    move: "touchmove",
    stop: "touchend"
  }
}, defaultMinWidth = 50;
const DragHandleVue = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "DragHandle",
  props: {
    prefixCls: String,
    width: {
      type: Number,
      required: !0
    },
    minWidth: {
      type: Number,
      default: defaultMinWidth
    },
    maxWidth: {
      type: Number,
      default: 1 / 0
    },
    column: {
      type: Object,
      default: void 0
    }
  },
  setup: function(C) {
    var G = 0, U = {
      remove: function() {
      }
    }, K = {
      remove: function() {
      }
    }, W = function() {
      U.remove(), K.remove();
    };
    onUnmounted(function() {
      W();
    }), watchEffect(function() {
      devWarning(!isNaN(C.width), "Table", "width must be a number when use resizable");
    });
    var Z = useInjectTableContext(), X = Z.onResizeColumn, Q = computed(function() {
      return typeof C.minWidth == "number" && !isNaN(C.minWidth) ? C.minWidth : defaultMinWidth;
    }), ee = computed(function() {
      return typeof C.maxWidth == "number" && !isNaN(C.maxWidth) ? C.maxWidth : 1 / 0;
    }), te = getCurrentInstance(), re = 0, ne = ref(!1), ae, ie = function(fe) {
      var ve = 0;
      fe.touches ? fe.touches.length ? ve = fe.touches[0].pageX : ve = fe.changedTouches[0].pageX : ve = fe.pageX;
      var pe = G - ve, he = Math.max(re - pe, Q.value);
      he = Math.min(he, ee.value), wrapperRaf.cancel(ae), ae = wrapperRaf(function() {
        X(he, C.column.__originColumn__);
      });
    }, se = function(fe) {
      ie(fe);
    }, oe = function(fe) {
      ne.value = !1, ie(fe), W();
    }, le = function(fe, ve) {
      ne.value = !0, W(), re = te.vnode.el.parentNode.getBoundingClientRect().width, !(fe instanceof MouseEvent && fe.which !== 1) && (fe.stopPropagation && fe.stopPropagation(), G = fe.touches ? fe.touches[0].pageX : fe.pageX, U = addEventListenerWrap(document.documentElement, ve.move, se), K = addEventListenerWrap(document.documentElement, ve.stop, oe));
    }, ue = function(fe) {
      fe.stopPropagation(), fe.preventDefault(), le(fe, events.mouse);
    }, ce = function(fe) {
      fe.stopPropagation(), fe.preventDefault(), le(fe, events.touch);
    }, de = function(fe) {
      fe.stopPropagation(), fe.preventDefault();
    };
    return function() {
      var ge = C.prefixCls, fe = _defineProperty$A({}, supportsPassive$1 ? "onTouchstartPassive" : "onTouchstart", function(ve) {
        return ce(ve);
      });
      return createVNode$1("div", _objectSpread2$1(_objectSpread2$1({
        class: "".concat(ge, "-resize-handle ").concat(ne.value ? "dragging" : ""),
        onMousedown: ue
      }, fe), {}, {
        onClick: de
      }), [createVNode$1("div", {
        class: "".concat(ge, "-resize-handle-line")
      }, null)]);
    };
  }
}), HeaderRow = defineComponent({
  name: "HeaderRow",
  props: ["cells", "stickyOffsets", "flattenColumns", "rowComponent", "cellComponent", "index", "customHeaderRow"],
  setup: function(C) {
    var G = useInjectTable();
    return function() {
      var U = G.prefixCls, K = G.direction, W = C.cells, Z = C.stickyOffsets, X = C.flattenColumns, Q = C.rowComponent, ee = C.cellComponent, te = C.customHeaderRow, re = C.index, ne;
      te && (ne = te(W.map(function(ie) {
        return ie.column;
      }), re));
      var ae = getColumnsKey(W.map(function(ie) {
        return ie.column;
      }));
      return createVNode$1(Q, ne, {
        default: function() {
          return [W.map(function(se, oe) {
            var le = se.column, ue = getCellFixedInfo(se.colStart, se.colEnd, X, Z, K), ce;
            le && le.customHeaderCell && (ce = se.column.customHeaderCell(le));
            var de = le;
            return createVNode$1(Cell, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, se), {}, {
              cellType: "header",
              ellipsis: le.ellipsis,
              align: le.align,
              component: ee,
              prefixCls: U,
              key: ae[oe]
            }, ue), {}, {
              additionalProps: ce,
              rowType: "header",
              column: le
            }), {
              default: function() {
                return le.title;
              },
              dragHandle: function() {
                return de.resizable ? createVNode$1(DragHandleVue, {
                  prefixCls: U,
                  width: de.width,
                  minWidth: de.minWidth,
                  maxWidth: de.maxWidth,
                  column: de
                }, null) : null;
              }
            });
          })];
        }
      });
    };
  }
});
function parseHeaderRows(H) {
  var C = [];
  function G(Z, X) {
    var Q = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    C[Q] = C[Q] || [];
    var ee = X, te = Z.filter(Boolean).map(function(re) {
      var ne = {
        key: re.key,
        class: classNames(re.className, re.class),
        // children: column.title,
        column: re,
        colStart: ee
      }, ae = 1, ie = re.children;
      return ie && ie.length > 0 && (ae = G(ie, ee, Q + 1).reduce(function(se, oe) {
        return se + oe;
      }, 0), ne.hasSubColumns = !0), "colSpan" in re && (ae = re.colSpan), "rowSpan" in re && (ne.rowSpan = re.rowSpan), ne.colSpan = ae, ne.colEnd = ne.colStart + ae - 1, C[Q].push(ne), ee += ae, ae;
    });
    return te;
  }
  G(H, 0);
  for (var U = C.length, K = function(X) {
    C[X].forEach(function(Q) {
      !("rowSpan" in Q) && !Q.hasSubColumns && (Q.rowSpan = U - X);
    });
  }, W = 0; W < U; W += 1)
    K(W);
  return C;
}
const Header = defineComponent({
  name: "Header",
  inheritAttrs: !1,
  props: ["columns", "flattenColumns", "stickyOffsets", "customHeaderRow"],
  setup: function(C) {
    var G = useInjectTable(), U = computed(function() {
      return parseHeaderRows(C.columns);
    });
    return function() {
      var K = G.prefixCls, W = G.getComponent, Z = C.stickyOffsets, X = C.flattenColumns, Q = C.customHeaderRow, ee = W(["header", "wrapper"], "thead"), te = W(["header", "row"], "tr"), re = W(["header", "cell"], "th");
      return createVNode$1(ee, {
        class: "".concat(K, "-thead")
      }, {
        default: function() {
          return [U.value.map(function(ae, ie) {
            var se = createVNode$1(HeaderRow, {
              key: ie,
              flattenColumns: X,
              cells: ae,
              stickyOffsets: Z,
              rowComponent: te,
              cellComponent: re,
              customHeaderRow: Q,
              index: ie
            }, null);
            return se;
          })];
        }
      });
    };
  }
});
var ExpandedRowContextKey = Symbol("ExpandedRowProps"), useProvideExpandedRow = function(C) {
  provide(ExpandedRowContextKey, C);
}, useInjectExpandedRow = function() {
  return inject(ExpandedRowContextKey, {});
};
const ExpandedRow = defineComponent({
  name: "ExpandedRow",
  inheritAttrs: !1,
  props: ["prefixCls", "component", "cellComponent", "expanded", "colSpan", "isEmpty"],
  setup: function(C, G) {
    var U = G.slots, K = G.attrs, W = useInjectTable(), Z = useInjectExpandedRow(), X = Z.fixHeader, Q = Z.fixColumn, ee = Z.componentWidth, te = Z.horizonScroll;
    return function() {
      var re = C.prefixCls, ne = C.component, ae = C.cellComponent, ie = C.expanded, se = C.colSpan, oe = C.isEmpty;
      return createVNode$1(ne, {
        class: K.class,
        style: {
          display: ie ? null : "none"
        }
      }, {
        default: function() {
          return [createVNode$1(Cell, {
            component: ae,
            prefixCls: re,
            colSpan: se
          }, {
            default: function() {
              var ce, de = (ce = U.default) === null || ce === void 0 ? void 0 : ce.call(U);
              return (oe ? te.value : Q.value) && (de = createVNode$1("div", {
                style: {
                  width: "".concat(ee.value - (X.value ? W.scrollbarSize : 0), "px"),
                  position: "sticky",
                  left: 0,
                  overflow: "hidden"
                },
                class: "".concat(re, "-expanded-row-fixed")
              }, [de])), de;
            }
          })];
        }
      });
    };
  }
}), MeasureCell = defineComponent({
  name: "MeasureCell",
  props: ["columnKey"],
  setup: function(C, G) {
    var U = G.emit, K = ref();
    return onMounted(function() {
      K.value && U("columnResize", C.columnKey, K.value.offsetWidth);
    }), function() {
      return createVNode$1(ResizeObserver, {
        onResize: function(Z) {
          var X = Z.offsetWidth;
          U("columnResize", C.columnKey, X);
        }
      }, {
        default: function() {
          return [createVNode$1("td", {
            ref: K,
            style: {
              padding: 0,
              border: 0,
              height: 0
            }
          }, [createVNode$1("div", {
            style: {
              height: 0,
              overflow: "hidden"
            }
          }, [createTextVNode(" ")])])];
        }
      });
    };
  }
});
var BodyContextKey = Symbol("BodyContextProps"), useProvideBody = function(C) {
  provide(BodyContextKey, C);
}, useInjectBody = function() {
  return inject(BodyContextKey, {});
};
const BodyRow = defineComponent({
  name: "BodyRow",
  inheritAttrs: !1,
  props: ["record", "index", "renderIndex", "recordKey", "expandedKeys", "rowComponent", "cellComponent", "customRow", "rowExpandable", "indent", "rowKey", "getRowKey", "childrenColumnName"],
  setup: function(C, G) {
    var U = G.attrs, K = useInjectTable(), W = useInjectBody(), Z = ref(!1), X = computed(function() {
      return C.expandedKeys && C.expandedKeys.has(C.recordKey);
    });
    watchEffect(function() {
      X.value && (Z.value = !0);
    });
    var Q = computed(function() {
      return W.expandableType === "row" && (!C.rowExpandable || C.rowExpandable(C.record));
    }), ee = computed(function() {
      return W.expandableType === "nest";
    }), te = computed(function() {
      return C.childrenColumnName && C.record && C.record[C.childrenColumnName];
    }), re = computed(function() {
      return Q.value || ee.value;
    }), ne = function(ue, ce) {
      W.onTriggerExpand(ue, ce);
    }, ae = computed(function() {
      var le;
      return ((le = C.customRow) === null || le === void 0 ? void 0 : le.call(C, C.record, C.index)) || {};
    }), ie = function(ue) {
      var ce, de;
      W.expandRowByClick && re.value && ne(C.record, ue);
      for (var ge = arguments.length, fe = new Array(ge > 1 ? ge - 1 : 0), ve = 1; ve < ge; ve++)
        fe[ve - 1] = arguments[ve];
      (ce = ae.value) === null || ce === void 0 || (de = ce.onClick) === null || de === void 0 || de.call.apply(de, [ce, ue].concat(fe));
    }, se = computed(function() {
      var le = C.record, ue = C.index, ce = C.indent, de = W.rowClassName;
      return typeof de == "string" ? de : typeof de == "function" ? de(le, ue, ce) : "";
    }), oe = computed(function() {
      return getColumnsKey(W.flattenColumns);
    });
    return function() {
      var le = U.class, ue = U.style, ce = C.record, de = C.index, ge = C.rowKey, fe = C.indent, ve = fe === void 0 ? 0 : fe, pe = C.rowComponent, he = C.cellComponent, me = K.prefixCls, ye = K.fixedInfoList, Ce = K.transformCellText, Ie = W.flattenColumns, be = W.expandedRowClassName, Se = W.indentSize, Ae = W.expandIcon, _e = W.expandedRowRender, xe = W.expandIconColumnIndex, Te = createVNode$1(pe, _objectSpread2$1(_objectSpread2$1({}, ae.value), {}, {
        "data-row-key": ge,
        class: classNames(le, "".concat(me, "-row"), "".concat(me, "-row-level-").concat(ve), se.value, ae.value.class),
        style: _objectSpread2$1(_objectSpread2$1({}, ue), parseStyleText(ae.value.style)),
        onClick: ie
      }), {
        default: function() {
          return [Ie.map(function(we, Oe) {
            var Ne = we.customRender, ke = we.dataIndex, ze = we.className, He = oe[Oe], We = ye[Oe], Re;
            we.customCell && (Re = we.customCell(ce, de, we));
            var Le = Oe === (xe || 0) && ee.value ? createVNode$1(Fragment, null, [createVNode$1("span", {
              style: {
                paddingLeft: "".concat(Se * ve, "px")
              },
              class: "".concat(me, "-row-indent indent-level-").concat(ve)
            }, null), Ae({
              prefixCls: me,
              expanded: X.value,
              expandable: te.value,
              record: ce,
              onExpand: ne
            })]) : null;
            return createVNode$1(Cell, _objectSpread2$1(_objectSpread2$1({
              cellType: "body",
              class: ze,
              ellipsis: we.ellipsis,
              align: we.align,
              component: he,
              prefixCls: me,
              key: He,
              record: ce,
              index: de,
              renderIndex: C.renderIndex,
              dataIndex: ke,
              customRender: Ne
            }, We), {}, {
              additionalProps: Re,
              column: we,
              transformCellText: Ce,
              appendNode: Le
            }), null);
          })];
        }
      }), Pe;
      if (Q.value && (Z.value || X.value)) {
        var $e = _e({
          record: ce,
          index: de,
          indent: ve + 1,
          expanded: X.value
        }), Me = be && be(ce, de, ve);
        Pe = createVNode$1(ExpandedRow, {
          expanded: X.value,
          class: classNames("".concat(me, "-expanded-row"), "".concat(me, "-expanded-row-level-").concat(ve + 1), Me),
          prefixCls: me,
          component: pe,
          cellComponent: he,
          colSpan: Ie.length,
          isEmpty: !1
        }, {
          default: function() {
            return [$e];
          }
        });
      }
      return createVNode$1(Fragment, null, [Te, Pe]);
    };
  }
});
function flatRecord(H, C, G, U, K, W) {
  var Z = [];
  Z.push({
    record: H,
    indent: C,
    index: W
  });
  var X = K(H), Q = U == null ? void 0 : U.has(X);
  if (H && Array.isArray(H[G]) && Q)
    for (var ee = 0; ee < H[G].length; ee += 1) {
      var te = flatRecord(H[G][ee], C + 1, G, U, K, ee);
      Z.push.apply(Z, _toConsumableArray(te));
    }
  return Z;
}
function useFlattenRecords(H, C, G, U) {
  var K = computed(function() {
    var W = C.value, Z = G.value, X = H.value;
    if (Z != null && Z.size) {
      for (var Q = [], ee = 0; ee < (X == null ? void 0 : X.length); ee += 1) {
        var te = X[ee];
        Q.push.apply(Q, _toConsumableArray(flatRecord(te, 0, W, Z, U.value, ee)));
      }
      return Q;
    }
    return X == null ? void 0 : X.map(function(re, ne) {
      return {
        record: re,
        indent: 0,
        index: ne
      };
    });
  });
  return K;
}
var ResizeContextKey = Symbol("ResizeContextProps"), useProvideResize = function(C) {
  provide(ResizeContextKey, C);
}, useInjectResize = function() {
  return inject(ResizeContextKey, {
    onColumnResize: function() {
    }
  });
};
const Body = defineComponent({
  name: "Body",
  props: ["data", "getRowKey", "measureColumnWidth", "expandedKeys", "customRow", "rowExpandable", "childrenColumnName"],
  slots: ["emptyNode"],
  setup: function(C, G) {
    var U = G.slots, K = useInjectResize(), W = useInjectTable(), Z = useInjectBody(), X = useFlattenRecords(toRef(C, "data"), toRef(C, "childrenColumnName"), toRef(C, "expandedKeys"), toRef(C, "getRowKey")), Q = ref(-1), ee = ref(-1), te;
    return useProvideHover({
      startRow: Q,
      endRow: ee,
      onHover: function(ne, ae) {
        clearTimeout(te), te = setTimeout(function() {
          Q.value = ne, ee.value = ae;
        }, 100);
      }
    }), function() {
      var re = C.data, ne = C.getRowKey, ae = C.measureColumnWidth, ie = C.expandedKeys, se = C.customRow, oe = C.rowExpandable, le = C.childrenColumnName, ue = K.onColumnResize, ce = W.prefixCls, de = W.getComponent, ge = Z.flattenColumns, fe = de(["body", "wrapper"], "tbody"), ve = de(["body", "row"], "tr"), pe = de(["body", "cell"], "td"), he;
      if (re.length)
        he = X.value.map(function(Ce, Ie) {
          var be = Ce.record, Se = Ce.indent, Ae = Ce.index, _e = ne(be, Ie);
          return createVNode$1(BodyRow, {
            key: _e,
            rowKey: _e,
            record: be,
            recordKey: _e,
            index: Ie,
            renderIndex: Ae,
            rowComponent: ve,
            cellComponent: pe,
            expandedKeys: ie,
            customRow: se,
            getRowKey: ne,
            rowExpandable: oe,
            childrenColumnName: le,
            indent: Se
          }, null);
        });
      else {
        var me;
        he = createVNode$1(ExpandedRow, {
          expanded: !0,
          class: "".concat(ce, "-placeholder"),
          prefixCls: ce,
          component: ve,
          cellComponent: pe,
          colSpan: ge.length,
          isEmpty: !0
        }, {
          default: function() {
            return [(me = U.emptyNode) === null || me === void 0 ? void 0 : me.call(U)];
          }
        });
      }
      var ye = getColumnsKey(ge);
      return createVNode$1(fe, {
        class: "".concat(ce, "-tbody")
      }, {
        default: function() {
          return [ae && createVNode$1("tr", {
            "aria-hidden": "true",
            class: "".concat(ce, "-measure-row"),
            style: {
              height: 0,
              fontSize: 0
            }
          }, [ye.map(function(Ie) {
            return createVNode$1(MeasureCell, {
              key: Ie,
              columnKey: Ie,
              onColumnResize: ue
            }, null);
          })]), he];
        }
      });
    };
  }
});
var EXPAND_COLUMN = {}, _excluded$5 = ["fixed"];
function flatColumns(H) {
  return H.reduce(function(C, G) {
    var U = G.fixed, K = U === !0 ? "left" : U, W = G.children;
    return W && W.length > 0 ? [].concat(_toConsumableArray(C), _toConsumableArray(flatColumns(W).map(function(Z) {
      return _objectSpread2$1({
        fixed: K
      }, Z);
    }))) : [].concat(_toConsumableArray(C), [_objectSpread2$1(_objectSpread2$1({}, G), {}, {
      fixed: K
    })]);
  }, []);
}
function warningFixed(H) {
  for (var C = !0, G = 0; G < H.length; G += 1) {
    var U = H[G];
    if (C && U.fixed !== "left")
      C = !1;
    else if (!C && U.fixed === "left") {
      warning$2(!1, "Index ".concat(G - 1, " of `columns` missing `fixed='left'` prop."));
      break;
    }
  }
  for (var K = !0, W = H.length - 1; W >= 0; W -= 1) {
    var Z = H[W];
    if (K && Z.fixed !== "right")
      K = !1;
    else if (!K && Z.fixed === "right") {
      warning$2(!1, "Index ".concat(W + 1, " of `columns` missing `fixed='right'` prop."));
      break;
    }
  }
}
function revertForRtl(H) {
  return H.map(function(C) {
    var G = C.fixed, U = _objectWithoutProperties$2(C, _excluded$5), K = G;
    return G === "left" ? K = "right" : G === "right" && (K = "left"), _objectSpread2$1({
      fixed: K
    }, U);
  });
}
function useColumns$1(H, C) {
  var G = H.prefixCls, U = H.columns, K = H.expandable, W = H.expandedKeys, Z = H.getRowKey, X = H.onTriggerExpand, Q = H.expandIcon, ee = H.rowExpandable, te = H.expandIconColumnIndex, re = H.direction, ne = H.expandRowByClick, ae = H.expandColumnWidth, ie = H.expandFixed, se = computed(function() {
    if (K.value) {
      var ue, ce = U.value.slice();
      if (process.env.NODE_ENV !== "production" && te.value >= 0 && warning$2(!1, "`expandIconColumnIndex` is deprecated. Please use `Table.EXPAND_COLUMN` in `columns` instead."), !ce.includes(EXPAND_COLUMN)) {
        var de = te.value || 0;
        de >= 0 && ce.splice(de, 0, EXPAND_COLUMN);
      }
      process.env.NODE_ENV !== "production" && ce.filter(function(be) {
        return be === EXPAND_COLUMN;
      }).length > 1 && warning$2(!1, "There exist more than one `EXPAND_COLUMN` in `columns`.");
      var ge = ce.indexOf(EXPAND_COLUMN);
      ce = ce.filter(function(be, Se) {
        return be !== EXPAND_COLUMN || Se === ge;
      });
      var fe = U.value[ge], ve;
      (ie.value === "left" || ie.value) && !te.value ? ve = "left" : (ie.value === "right" || ie.value) && te.value === U.value.length ? ve = "right" : ve = fe ? fe.fixed : null;
      var pe = W.value, he = ee.value, me = Q.value, ye = G.value, Ce = ne.value, Ie = (ue = {}, _defineProperty$A(ue, INTERNAL_COL_DEFINE, {
        class: "".concat(G.value, "-expand-icon-col"),
        columnType: "EXPAND_COLUMN"
      }), _defineProperty$A(ue, "title", ""), _defineProperty$A(ue, "fixed", ve), _defineProperty$A(ue, "class", "".concat(G.value, "-row-expand-icon-cell")), _defineProperty$A(ue, "width", ae.value), _defineProperty$A(ue, "customRender", function(Se) {
        var Ae = Se.record, _e = Se.index, xe = Z.value(Ae, _e), Te = pe.has(xe), Pe = he ? he(Ae) : !0, $e = me({
          prefixCls: ye,
          expanded: Te,
          expandable: Pe,
          record: Ae,
          onExpand: X
        });
        return Ce ? createVNode$1("span", {
          onClick: function(Ee) {
            return Ee.stopPropagation();
          }
        }, [$e]) : $e;
      }), ue);
      return ce.map(function(be) {
        return be === EXPAND_COLUMN ? Ie : be;
      });
    }
    return process.env.NODE_ENV !== "production" && U.value.includes(EXPAND_COLUMN) && warning$2(!1, "`expandable` is not config but there exist `EXPAND_COLUMN` in `columns`."), U.value.filter(function(be) {
      return be !== EXPAND_COLUMN;
    });
  }), oe = computed(function() {
    var ue = se.value;
    return C.value && (ue = C.value(ue)), ue.length || (ue = [{
      customRender: function() {
        return null;
      }
    }]), ue;
  }), le = computed(function() {
    return re.value === "rtl" ? revertForRtl(flatColumns(oe.value)) : flatColumns(oe.value);
  });
  return process.env.NODE_ENV !== "production" && watchEffect(function() {
    setTimeout(function() {
      warningFixed(le.value);
    });
  }), [oe, le];
}
function useLayoutState(H) {
  var C = shallowRef(H), G, U = shallowRef([]);
  function K(W) {
    U.value.push(W), wrapperRaf.cancel(G), G = wrapperRaf(function() {
      var Z = U.value;
      U.value = [], Z.forEach(function(X) {
        C.value = X(C.value);
      });
    });
  }
  return onBeforeUnmount(function() {
    wrapperRaf.cancel(G);
  }), [C, K];
}
function useTimeoutLock(H) {
  var C = ref(H || null), G = ref();
  function U() {
    clearTimeout(G.value);
  }
  function K(Z) {
    C.value = Z, U(), G.value = setTimeout(function() {
      C.value = null, G.value = void 0;
    }, 100);
  }
  function W() {
    return C.value;
  }
  return onBeforeUnmount(function() {
    U();
  }), [K, W];
}
function useStickyOffsets(H, C, G) {
  var U = computed(function() {
    for (var K = [], W = [], Z = 0, X = 0, Q = H.value, ee = C.value, te = G.value, re = 0; re < ee; re += 1)
      if (te === "rtl") {
        W[re] = X, X += Q[re] || 0;
        var ne = ee - re - 1;
        K[ne] = Z, Z += Q[ne] || 0;
      } else {
        K[re] = Z, Z += Q[re] || 0;
        var ae = ee - re - 1;
        W[ae] = X, X += Q[ae] || 0;
      }
    return {
      left: K,
      right: W
    };
  });
  return U;
}
var _excluded$4 = ["columnType"];
function ColGroup(H) {
  for (var C = H.colWidths, G = H.columns, U = H.columCount, K = [], W = U || G.length, Z = !1, X = W - 1; X >= 0; X -= 1) {
    var Q = C[X], ee = G && G[X], te = ee && ee[INTERNAL_COL_DEFINE];
    if (Q || te || Z) {
      var re = te || {};
      re.columnType;
      var ne = _objectWithoutProperties$2(re, _excluded$4);
      K.unshift(createVNode$1("col", _objectSpread2$1({
        key: X,
        style: {
          width: typeof Q == "number" ? "".concat(Q, "px") : Q
        }
      }, ne), null)), Z = !0;
    }
  }
  return createVNode$1("colgroup", null, [K]);
}
function Panel(H, C) {
  var G, U = C.slots;
  return createVNode$1("div", null, [(G = U.default) === null || G === void 0 ? void 0 : G.call(U)]);
}
Panel.displayName = "Panel";
var indexGuid = 0, Summary = defineComponent({
  name: "Summary",
  props: ["fixed"],
  setup: function(C, G) {
    var U = G.slots, K = useInjectTable(), W = "table-summary-uni-key-".concat(++indexGuid), Z = computed(function() {
      return C.fixed === "" || C.fixed;
    });
    return watchEffect(function() {
      K.summaryCollect(W, Z.value);
    }), onBeforeUnmount(function() {
      K.summaryCollect(W, !1);
    }), function() {
      var X;
      return (X = U.default) === null || X === void 0 ? void 0 : X.call(U);
    };
  }
});
const Summary$1 = Summary, SummaryRow = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "FooterRow",
  setup: function(C, G) {
    var U = G.slots;
    return function() {
      var K;
      return createVNode$1("tr", null, [(K = U.default) === null || K === void 0 ? void 0 : K.call(U)]);
    };
  }
});
var SummaryContextKey = Symbol("SummaryContextProps"), useProvideSummary = function(C) {
  provide(SummaryContextKey, C);
}, useInjectSummary = function() {
  return inject(SummaryContextKey, {});
};
const SummaryCell = defineComponent({
  name: "SummaryCell",
  props: ["index", "colSpan", "rowSpan", "align"],
  setup: function(C, G) {
    var U = G.attrs, K = G.slots, W = useInjectTable(), Z = useInjectSummary();
    return function() {
      var X = C.index, Q = C.colSpan, ee = Q === void 0 ? 1 : Q, te = C.rowSpan, re = C.align, ne = W.prefixCls, ae = W.direction, ie = Z.scrollColumnIndex, se = Z.stickyOffsets, oe = Z.flattenColumns, le = X + ee - 1, ue = le + 1 === ie ? ee + 1 : ee, ce = getCellFixedInfo(X, X + ue - 1, oe, se, ae);
      return createVNode$1(Cell, _objectSpread2$1({
        class: U.class,
        index: X,
        component: "td",
        prefixCls: ne,
        record: null,
        dataIndex: null,
        align: re,
        colSpan: ue,
        rowSpan: te,
        customRender: function() {
          var ge;
          return (ge = K.default) === null || ge === void 0 ? void 0 : ge.call(K);
        }
      }, ce), null);
    };
  }
}), Footer = defineComponent({
  name: "Footer",
  inheritAttrs: !1,
  props: ["stickyOffsets", "flattenColumns"],
  setup: function(C, G) {
    var U = G.slots, K = useInjectTable();
    return useProvideSummary(reactive({
      stickyOffsets: toRef(C, "stickyOffsets"),
      flattenColumns: toRef(C, "flattenColumns"),
      scrollColumnIndex: computed(function() {
        var W = C.flattenColumns.length - 1, Z = C.flattenColumns[W];
        return Z != null && Z.scrollbar ? W : null;
      })
    })), function() {
      var W, Z = K.prefixCls;
      return createVNode$1("tfoot", {
        class: "".concat(Z, "-summary")
      }, [(W = U.default) === null || W === void 0 ? void 0 : W.call(U)]);
    };
  }
});
var FooterComponents = Summary$1;
function renderExpandIcon$1(H) {
  var C, G = H.prefixCls, U = H.record, K = H.onExpand, W = H.expanded, Z = H.expandable, X = "".concat(G, "-row-expand-icon");
  if (!Z)
    return createVNode$1("span", {
      class: [X, "".concat(G, "-row-spaced")]
    }, null);
  var Q = function(te) {
    K(U, te), te.stopPropagation();
  };
  return createVNode$1("span", {
    class: (C = {}, _defineProperty$A(C, X, !0), _defineProperty$A(C, "".concat(G, "-row-expanded"), W), _defineProperty$A(C, "".concat(G, "-row-collapsed"), !W), C),
    onClick: Q
  }, null);
}
function findAllChildrenKeys(H, C, G) {
  var U = [];
  function K(W) {
    (W || []).forEach(function(Z, X) {
      U.push(C(Z, X)), K(Z[G]);
    });
  }
  return K(H), U;
}
const StickyScrollBar = defineComponent({
  name: "StickyScrollBar",
  inheritAttrs: !1,
  props: ["offsetScroll", "container", "scrollBodyRef", "scrollBodySizeInfo"],
  emits: ["scroll"],
  setup: function(C, G) {
    var U = G.emit, K = G.expose, W = useInjectTable(), Z = ref(0), X = ref(0), Q = ref(0);
    watchEffect(function() {
      Z.value = C.scrollBodySizeInfo.scrollWidth || 0, X.value = C.scrollBodySizeInfo.clientWidth || 0, Q.value = Z.value && X.value * (X.value / Z.value);
    }, {
      flush: "post"
    });
    var ee = ref(), te = useLayoutState({
      scrollLeft: 0,
      isHiddenScrollBar: !0
    }), re = _slicedToArray$2(te, 2), ne = re[0], ae = re[1], ie = ref({
      delta: 0,
      x: 0
    }), se = ref(!1), oe = function() {
      se.value = !1;
    }, le = function(ye) {
      ie.value = {
        delta: ye.pageX - ne.value.scrollLeft,
        x: 0
      }, se.value = !0, ye.preventDefault();
    }, ue = function(ye) {
      var Ce, Ie = ye || ((Ce = window) === null || Ce === void 0 ? void 0 : Ce.event), be = Ie.buttons;
      if (!se.value || be === 0) {
        se.value && (se.value = !1);
        return;
      }
      var Se = ie.value.x + ye.pageX - ie.value.x - ie.value.delta;
      Se <= 0 && (Se = 0), Se + Q.value >= X.value && (Se = X.value - Q.value), U("scroll", {
        scrollLeft: Se / X.value * (Z.value + 2)
      }), ie.value.x = ye.pageX;
    }, ce = function() {
      if (C.scrollBodyRef.value) {
        var ye = getOffset(C.scrollBodyRef.value).top, Ce = ye + C.scrollBodyRef.value.offsetHeight, Ie = C.container === window ? document.documentElement.scrollTop + window.innerHeight : getOffset(C.container).top + C.container.clientHeight;
        Ce - getScrollBarSize() <= Ie || ye >= Ie - C.offsetScroll ? ae(function(be) {
          return _objectSpread2$1(_objectSpread2$1({}, be), {}, {
            isHiddenScrollBar: !0
          });
        }) : ae(function(be) {
          return _objectSpread2$1(_objectSpread2$1({}, be), {}, {
            isHiddenScrollBar: !1
          });
        });
      }
    }, de = function(ye) {
      ae(function(Ce) {
        return _objectSpread2$1(_objectSpread2$1({}, Ce), {}, {
          scrollLeft: ye / Z.value * X.value || 0
        });
      });
    };
    K({
      setScrollLeft: de
    });
    var ge = null, fe = null, ve = null, pe = null;
    onMounted(function() {
      ge = addEventListenerWrap(document.body, "mouseup", oe, !1), fe = addEventListenerWrap(document.body, "mousemove", ue, !1), ve = addEventListenerWrap(window, "resize", ce, !1);
    }), onActivated(function() {
      nextTick(function() {
        ce();
      });
    }), onMounted(function() {
      setTimeout(function() {
        watch([Q, se], function() {
          ce();
        }, {
          immediate: !0,
          flush: "post"
        });
      });
    }), watch(function() {
      return C.container;
    }, function() {
      var me;
      (me = pe) === null || me === void 0 || me.remove(), pe = addEventListenerWrap(C.container, "scroll", ce, !1);
    }, {
      immediate: !0,
      flush: "post"
    }), onBeforeUnmount(function() {
      var me, ye, Ce, Ie;
      (me = ge) === null || me === void 0 || me.remove(), (ye = fe) === null || ye === void 0 || ye.remove(), (Ce = pe) === null || Ce === void 0 || Ce.remove(), (Ie = ve) === null || Ie === void 0 || Ie.remove();
    }), watch(function() {
      return _objectSpread2$1({}, ne.value);
    }, function(me, ye) {
      me.isHiddenScrollBar !== (ye == null ? void 0 : ye.isHiddenScrollBar) && !me.isHiddenScrollBar && ae(function(Ce) {
        var Ie = C.scrollBodyRef.value;
        return Ie ? _objectSpread2$1(_objectSpread2$1({}, Ce), {}, {
          scrollLeft: Ie.scrollLeft / Ie.scrollWidth * Ie.clientWidth
        }) : Ce;
      });
    }, {
      immediate: !0
    });
    var he = getScrollBarSize();
    return function() {
      if (Z.value <= X.value || !Q.value || ne.value.isHiddenScrollBar)
        return null;
      var me = W.prefixCls;
      return createVNode$1("div", {
        style: {
          height: "".concat(he, "px"),
          width: "".concat(X.value, "px"),
          bottom: "".concat(C.offsetScroll, "px")
        },
        class: "".concat(me, "-sticky-scroll")
      }, [createVNode$1("div", {
        onMousedown: le,
        ref: ee,
        class: classNames("".concat(me, "-sticky-scroll-bar"), _defineProperty$A({}, "".concat(me, "-sticky-scroll-bar-active"), se)),
        style: {
          width: "".concat(Q.value, "px"),
          transform: "translate3d(".concat(ne.value.scrollLeft, "px, 0, 0)")
        }
      }, null)]);
    };
  }
});
var defaultContainer = canUseDom() ? window : null;
function useSticky(H, C) {
  return computed(function() {
    var G = _typeof$2(H.value) === "object" ? H.value : {}, U = G.offsetHeader, K = U === void 0 ? 0 : U, W = G.offsetSummary, Z = W === void 0 ? 0 : W, X = G.offsetScroll, Q = X === void 0 ? 0 : X, ee = G.getContainer, te = ee === void 0 ? function() {
      return defaultContainer;
    } : ee, re = te() || defaultContainer, ne = !!H.value;
    return {
      isSticky: ne,
      stickyClassName: ne ? "".concat(C.value, "-sticky-holder") : "",
      offsetHeader: K,
      offsetSummary: Z,
      offsetScroll: Q,
      container: re
    };
  });
}
function useColumnWidth(H, C) {
  return computed(function() {
    for (var G = [], U = H.value, K = C.value, W = 0; W < K; W += 1) {
      var Z = U[W];
      if (Z !== void 0)
        G[W] = Z;
      else
        return null;
    }
    return G;
  });
}
const FixedHolder = defineComponent({
  name: "FixedHolder",
  inheritAttrs: !1,
  props: ["columns", "flattenColumns", "stickyOffsets", "customHeaderRow", "noData", "maxContentScroll", "colWidths", "columCount", "direction", "fixHeader", "stickyTopOffset", "stickyBottomOffset", "stickyClassName"],
  emits: ["scroll"],
  setup: function(C, G) {
    var U = G.attrs, K = G.slots, W = G.emit, Z = useInjectTable(), X = computed(function() {
      return Z.isSticky && !C.fixHeader ? 0 : Z.scrollbarSize;
    }), Q = ref(), ee = function(le) {
      var ue = le.currentTarget, ce = le.deltaX;
      ce && (W("scroll", {
        currentTarget: ue,
        scrollLeft: ue.scrollLeft + ce
      }), le.preventDefault());
    }, te = ref();
    onMounted(function() {
      nextTick(function() {
        te.value = addEventListenerWrap(Q.value, "wheel", ee);
      });
    }), onBeforeUnmount(function() {
      var oe;
      (oe = te.value) === null || oe === void 0 || oe.remove();
    });
    var re = computed(function() {
      return C.flattenColumns.every(function(oe) {
        return oe.width && oe.width !== 0 && oe.width !== "0px";
      });
    }), ne = ref([]), ae = ref([]);
    watchEffect(function() {
      var oe = C.flattenColumns[C.flattenColumns.length - 1], le = {
        fixed: oe ? oe.fixed : null,
        scrollbar: !0,
        customHeaderCell: function() {
          return {
            class: "".concat(Z.prefixCls, "-cell-scrollbar")
          };
        }
      };
      ne.value = X.value ? [].concat(_toConsumableArray(C.columns), [le]) : C.columns, ae.value = X.value ? [].concat(_toConsumableArray(C.flattenColumns), [le]) : C.flattenColumns;
    });
    var ie = computed(function() {
      var oe = C.stickyOffsets, le = C.direction, ue = oe.right, ce = oe.left;
      return _objectSpread2$1(_objectSpread2$1({}, oe), {}, {
        left: le === "rtl" ? [].concat(_toConsumableArray(ce.map(function(de) {
          return de + X.value;
        })), [0]) : ce,
        right: le === "rtl" ? ue : [].concat(_toConsumableArray(ue.map(function(de) {
          return de + X.value;
        })), [0]),
        isSticky: Z.isSticky
      });
    }), se = useColumnWidth(toRef(C, "colWidths"), toRef(C, "columCount"));
    return function() {
      var oe, le = C.noData, ue = C.columCount, ce = C.stickyTopOffset, de = C.stickyBottomOffset, ge = C.stickyClassName, fe = C.maxContentScroll, ve = Z.isSticky;
      return createVNode$1("div", {
        style: _objectSpread2$1({
          overflow: "hidden"
        }, ve ? {
          top: "".concat(ce, "px"),
          bottom: "".concat(de, "px")
        } : {}),
        ref: Q,
        class: classNames(U.class, _defineProperty$A({}, ge, !!ge))
      }, [createVNode$1("table", {
        style: {
          tableLayout: "fixed",
          visibility: le || se.value ? null : "hidden"
        }
      }, [(!le || !fe || re.value) && createVNode$1(ColGroup, {
        colWidths: se.value ? [].concat(_toConsumableArray(se.value), [X.value]) : [],
        columCount: ue + 1,
        columns: ae.value
      }, null), (oe = K.default) === null || oe === void 0 ? void 0 : oe.call(K, _objectSpread2$1(_objectSpread2$1({}, C), {}, {
        stickyOffsets: ie.value,
        columns: ne.value,
        flattenColumns: ae.value
      }))])]);
    };
  }
});
function fromPairs(H) {
  for (var C = -1, G = H == null ? 0 : H.length, U = {}; ++C < G; ) {
    var K = H[C];
    U[K[0]] = K[1];
  }
  return U;
}
function reactivePick(H) {
  for (var C = arguments.length, G = new Array(C > 1 ? C - 1 : 0), U = 1; U < C; U++)
    G[U - 1] = arguments[U];
  return reactive(fromPairs(G.map(function(K) {
    return [K, toRef(H, K)];
  })));
}
var EMPTY_DATA = [], EMPTY_SCROLL_TARGET = {}, INTERNAL_HOOKS = "rc-table-internal-hook";
const Table$3 = defineComponent({
  name: "Table",
  inheritAttrs: !1,
  props: ["prefixCls", "data", "columns", "rowKey", "tableLayout", "scroll", "rowClassName", "title", "footer", "id", "showHeader", "components", "customRow", "customHeaderRow", "direction", "expandFixed", "expandColumnWidth", "expandedRowKeys", "defaultExpandedRowKeys", "expandedRowRender", "expandRowByClick", "expandIcon", "onExpand", "onExpandedRowsChange", "onUpdate:expandedRowKeys", "defaultExpandAllRows", "indentSize", "expandIconColumnIndex", "expandedRowClassName", "childrenColumnName", "rowExpandable", "sticky", "transformColumns", "internalHooks", "internalRefs", "canExpandable", "onUpdateInternalRefs", "transformCellText"],
  slots: ["title", "footer", "summary", "emptyText"],
  emits: ["expand", "expandedRowsChange", "updateInternalRefs", "update:expandedRowKeys"],
  setup: function(C, G) {
    var U = G.attrs, K = G.slots, W = G.emit, Z = computed(function() {
      return C.data || EMPTY_DATA;
    }), X = computed(function() {
      return !!Z.value.length;
    }), Q = computed(function() {
      return mergeObject(C.components, {});
    }), ee = function(Ge, tt) {
      return getPathValue(Q.value, Ge) || tt;
    }, te = computed(function() {
      var Ve = C.rowKey;
      return typeof Ve == "function" ? Ve : function(Ge) {
        var tt = Ge && Ge[Ve];
        return process.env.NODE_ENV !== "production" && warning$2(tt !== void 0, "Each record in table should have a unique `key` prop, or set `rowKey` to an unique primary key."), tt;
      };
    }), re = computed(function() {
      return C.expandIcon || renderExpandIcon$1;
    }), ne = computed(function() {
      return C.childrenColumnName || "children";
    }), ae = computed(function() {
      return C.expandedRowRender ? "row" : C.canExpandable || Z.value.some(function(Ve) {
        return Ve && _typeof$2(Ve) === "object" && Ve[ne.value];
      }) ? "nest" : !1;
    }), ie = shallowRef([]), se = watchEffect(function() {
      C.defaultExpandedRowKeys && (ie.value = C.defaultExpandedRowKeys), C.defaultExpandAllRows && (ie.value = findAllChildrenKeys(Z.value, te.value, ne.value));
    });
    se();
    var oe = computed(function() {
      return new Set(C.expandedRowKeys || ie.value || []);
    }), le = function(Ge) {
      var tt = te.value(Ge, Z.value.indexOf(Ge)), ft, mt = oe.value.has(tt);
      mt ? (oe.value.delete(tt), ft = _toConsumableArray(oe.value)) : ft = [].concat(_toConsumableArray(oe.value), [tt]), ie.value = ft, W("expand", !mt, Ge), W("update:expandedRowKeys", ft), W("expandedRowsChange", ft);
    };
    process.env.NODE_ENV !== "production" && C.expandedRowRender && Z.value.some(function(Ve) {
      return Array.isArray(Ve == null ? void 0 : Ve[ne.value]);
    }) && warning$2(!1, "`expandedRowRender` should not use with nested Table");
    var ue = ref(0), ce = useColumns$1(_objectSpread2$1(_objectSpread2$1({}, toRefs(C)), {}, {
      // children,
      expandable: computed(function() {
        return !!C.expandedRowRender;
      }),
      expandedKeys: oe,
      getRowKey: te,
      onTriggerExpand: le,
      expandIcon: re
    }), computed(function() {
      return C.internalHooks === INTERNAL_HOOKS ? C.transformColumns : null;
    })), de = _slicedToArray$2(ce, 2), ge = de[0], fe = de[1], ve = computed(function() {
      return {
        columns: ge.value,
        flattenColumns: fe.value
      };
    }), pe = ref(), he = ref(), me = ref(), ye = ref({
      scrollWidth: 0,
      clientWidth: 0
    }), Ce = ref(), Ie = useState(!1), be = _slicedToArray$2(Ie, 2), Se = be[0], Ae = be[1], _e = useState(!1), xe = _slicedToArray$2(_e, 2), Te = xe[0], Pe = xe[1], $e = useLayoutState(/* @__PURE__ */ new Map()), Me = _slicedToArray$2($e, 2), Ee = Me[0], we = Me[1], Oe = computed(function() {
      return getColumnsKey(fe.value);
    }), Ne = computed(function() {
      return Oe.value.map(function(Ve) {
        return Ee.value.get(Ve);
      });
    }), ke = computed(function() {
      return fe.value.length;
    }), ze = useStickyOffsets(Ne, ke, toRef(C, "direction")), He = computed(function() {
      return C.scroll && validateValue(C.scroll.y);
    }), We = computed(function() {
      return C.scroll && validateValue(C.scroll.x) || Boolean(C.expandFixed);
    }), Re = computed(function() {
      return We.value && fe.value.some(function(Ve) {
        var Ge = Ve.fixed;
        return Ge;
      });
    }), Le = ref(), De = useSticky(toRef(C, "sticky"), toRef(C, "prefixCls")), Ue = reactive({}), st = computed(function() {
      var Ve = Object.values(Ue)[0];
      return (He.value || De.value.isSticky) && Ve;
    }), ot = function(Ge, tt) {
      tt ? Ue[Ge] = tt : delete Ue[Ge];
    }, ct = ref({}), vt = ref({}), ut = ref({});
    watchEffect(function() {
      He.value && (vt.value = {
        overflowY: "scroll",
        maxHeight: toPx(C.scroll.y)
      }), We.value && (ct.value = {
        overflowX: "auto"
      }, He.value || (vt.value = {
        overflowY: "hidden"
      }), ut.value = {
        width: C.scroll.x === !0 ? "auto" : toPx(C.scroll.x),
        minWidth: "100%"
      });
    });
    var at = function(Ge, tt) {
      isVisible(pe.value) && we(function(ft) {
        if (ft.get(Ge) !== tt) {
          var mt = new Map(ft);
          return mt.set(Ge, tt), mt;
        }
        return ft;
      });
    }, Ze = useTimeoutLock(null), Xe = _slicedToArray$2(Ze, 2), qe = Xe[0], dt = Xe[1];
    function gt(Ve, Ge) {
      if (Ge) {
        if (typeof Ge == "function") {
          Ge(Ve);
          return;
        }
        var tt = Ge.$el || Ge;
        tt.scrollLeft !== Ve && (tt.scrollLeft = Ve);
      }
    }
    var yt = function(Ge) {
      var tt = Ge.currentTarget, ft = Ge.scrollLeft, mt = C.direction === "rtl", ht = typeof ft == "number" ? ft : tt.scrollLeft, St = tt || EMPTY_SCROLL_TARGET;
      if (!dt() || dt() === St) {
        var Ct;
        qe(St), gt(ht, he.value), gt(ht, me.value), gt(ht, Ce.value), gt(ht, (Ct = Le.value) === null || Ct === void 0 ? void 0 : Ct.setScrollLeft);
      }
      if (tt) {
        var bt = tt.scrollWidth, xt = tt.clientWidth;
        mt ? (Ae(-ht < bt - xt), Pe(-ht > 0)) : (Ae(ht > 0), Pe(ht < bt - xt));
      }
    }, At = function() {
      We.value && me.value ? yt({
        currentTarget: me.value
      }) : (Ae(!1), Pe(!1));
    }, nt, Ke = function(Ge) {
      Ge !== ue.value && (At(), ue.value = pe.value ? pe.value.offsetWidth : Ge);
    }, Qe = function(Ge) {
      var tt = Ge.width;
      if (clearTimeout(nt), ue.value === 0) {
        Ke(tt);
        return;
      }
      nt = setTimeout(function() {
        Ke(tt);
      }, 100);
    };
    watch([We, function() {
      return C.data;
    }, function() {
      return C.columns;
    }], function() {
      We.value && At();
    }, {
      flush: "post"
    });
    var pt = useState(0), Ye = _slicedToArray$2(pt, 2), Fe = Ye[0], Be = Ye[1];
    useProvideSticky(), onMounted(function() {
      nextTick(function() {
        var Ve, Ge;
        At(), Be(getTargetScrollBarSize(me.value).width), ye.value = {
          scrollWidth: ((Ve = me.value) === null || Ve === void 0 ? void 0 : Ve.scrollWidth) || 0,
          clientWidth: ((Ge = me.value) === null || Ge === void 0 ? void 0 : Ge.clientWidth) || 0
        };
      });
    }), onUpdated(function() {
      nextTick(function() {
        var Ve, Ge, tt = ((Ve = me.value) === null || Ve === void 0 ? void 0 : Ve.scrollWidth) || 0, ft = ((Ge = me.value) === null || Ge === void 0 ? void 0 : Ge.clientWidth) || 0;
        (ye.value.scrollWidth !== tt || ye.value.clientWidth !== ft) && (ye.value = {
          scrollWidth: tt,
          clientWidth: ft
        });
      });
    }), watchEffect(function() {
      C.internalHooks === INTERNAL_HOOKS && C.internalRefs && C.onUpdateInternalRefs({
        body: me.value ? me.value.$el || me.value : null
      });
    }, {
      flush: "post"
    });
    var je = computed(function() {
      return C.tableLayout ? C.tableLayout : Re.value ? C.scroll.x === "max-content" ? "auto" : "fixed" : He.value || De.value.isSticky || fe.value.some(function(Ve) {
        var Ge = Ve.ellipsis;
        return Ge;
      }) ? "fixed" : "auto";
    }), Je = function() {
      var Ge;
      return X.value ? null : ((Ge = K.emptyText) === null || Ge === void 0 ? void 0 : Ge.call(K)) || "No Data";
    };
    useProvideTable(reactive(_objectSpread2$1(_objectSpread2$1({}, toRefs(reactivePick(C, "prefixCls", "direction", "transformCellText"))), {}, {
      getComponent: ee,
      scrollbarSize: Fe,
      fixedInfoList: computed(function() {
        return fe.value.map(function(Ve, Ge) {
          return getCellFixedInfo(Ge, Ge, fe.value, ze.value, C.direction);
        });
      }),
      isSticky: computed(function() {
        return De.value.isSticky;
      }),
      summaryCollect: ot
    }))), useProvideBody(reactive(_objectSpread2$1(_objectSpread2$1({}, toRefs(reactivePick(C, "rowClassName", "expandedRowClassName", "expandRowByClick", "expandedRowRender", "expandIconColumnIndex", "indentSize"))), {}, {
      columns: ge,
      flattenColumns: fe,
      tableLayout: je,
      expandIcon: re,
      expandableType: ae,
      onTriggerExpand: le
    }))), useProvideResize({
      onColumnResize: at
    }), useProvideExpandedRow({
      componentWidth: ue,
      fixHeader: He,
      fixColumn: Re,
      horizonScroll: We
    });
    var it = function() {
      return createVNode$1(Body, {
        data: Z.value,
        measureColumnWidth: He.value || We.value || De.value.isSticky,
        expandedKeys: oe.value,
        rowExpandable: C.rowExpandable,
        getRowKey: te.value,
        customRow: C.customRow,
        childrenColumnName: ne.value
      }, {
        emptyNode: Je
      });
    }, et = function() {
      return createVNode$1(ColGroup, {
        colWidths: fe.value.map(function(Ge) {
          var tt = Ge.width;
          return tt;
        }),
        columns: fe.value
      }, null);
    };
    return function() {
      var Ve, Ge = C.prefixCls, tt = C.scroll, ft = C.tableLayout, mt = C.direction, ht = C.title, St = ht === void 0 ? K.title : ht, Ct = C.footer, bt = Ct === void 0 ? K.footer : Ct, xt = C.id, It = C.showHeader, Tt = C.customHeaderRow, _t = De.value, wt = _t.isSticky, Mt = _t.offsetHeader, Ot = _t.offsetSummary, kt = _t.offsetScroll, Ft = _t.stickyClassName, Rt = _t.container, $t = ee(["table"], "table"), Nt = ee(["body"]), Dt = (Ve = K.summary) === null || Ve === void 0 ? void 0 : Ve.call(K, {
        pageData: Z.value
      }), Bt = function() {
        return null;
      }, Pt = {
        colWidths: Ne.value,
        columCount: fe.value.length,
        stickyOffsets: ze.value,
        customHeaderRow: Tt,
        fixHeader: He.value,
        scroll: tt
      };
      if (process.env.NODE_ENV !== "production" && typeof Nt == "function" && X.value && !He.value && warning$2(!1, "`components.body` with render props is only work on `scroll.y`."), He.value || wt) {
        var zt = function() {
          return null;
        };
        typeof Nt == "function" ? (zt = function() {
          return Nt(Z.value, {
            scrollbarSize: Fe.value,
            ref: me,
            onScroll: yt
          });
        }, Pt.colWidths = fe.value.map(function(Vt, Et) {
          var Lt = Vt.width, jt = Et === ge.value.length - 1 ? Lt - Fe.value : Lt;
          return typeof jt == "number" && !Number.isNaN(jt) ? jt : (warning$2(!1, "When use `components.body` with render props. Each column should have a fixed `width` value."), 0);
        })) : zt = function() {
          return createVNode$1("div", {
            style: _objectSpread2$1(_objectSpread2$1({}, ct.value), vt.value),
            onScroll: yt,
            ref: me,
            class: classNames("".concat(Ge, "-body"))
          }, [createVNode$1($t, {
            style: _objectSpread2$1(_objectSpread2$1({}, ut.value), {}, {
              tableLayout: je.value
            })
          }, {
            default: function() {
              return [et(), it(), !st.value && Dt && createVNode$1(Footer, {
                stickyOffsets: ze.value,
                flattenColumns: fe.value
              }, {
                default: function() {
                  return [Dt];
                }
              })];
            }
          })]);
        };
        var Ht = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
          noData: !Z.value.length,
          maxContentScroll: We.value && tt.x === "max-content"
        }, Pt), ve.value), {}, {
          direction: mt,
          stickyClassName: Ft,
          onScroll: yt
        });
        Bt = function() {
          return createVNode$1(Fragment, null, [It !== !1 && createVNode$1(FixedHolder, _objectSpread2$1(_objectSpread2$1({}, Ht), {}, {
            stickyTopOffset: Mt,
            class: "".concat(Ge, "-header"),
            ref: he
          }), {
            default: function(Lt) {
              return createVNode$1(Fragment, null, [createVNode$1(Header, Lt, null), st.value === "top" && createVNode$1(Footer, Lt, {
                default: function() {
                  return [Dt];
                }
              })]);
            }
          }), zt(), st.value && st.value !== "top" && createVNode$1(FixedHolder, _objectSpread2$1(_objectSpread2$1({}, Ht), {}, {
            stickyBottomOffset: Ot,
            class: "".concat(Ge, "-summary"),
            ref: Ce
          }), {
            default: function(Lt) {
              return createVNode$1(Footer, Lt, {
                default: function() {
                  return [Dt];
                }
              });
            }
          }), wt && me.value && createVNode$1(StickyScrollBar, {
            ref: Le,
            offsetScroll: kt,
            scrollBodyRef: me,
            onScroll: yt,
            container: Rt,
            scrollBodySizeInfo: ye.value
          }, null)]);
        };
      } else
        Bt = function() {
          return createVNode$1("div", {
            style: _objectSpread2$1(_objectSpread2$1({}, ct.value), vt.value),
            class: classNames("".concat(Ge, "-content")),
            onScroll: yt,
            ref: me
          }, [createVNode$1($t, {
            style: _objectSpread2$1(_objectSpread2$1({}, ut.value), {}, {
              tableLayout: je.value
            })
          }, {
            default: function() {
              return [et(), It !== !1 && createVNode$1(Header, _objectSpread2$1(_objectSpread2$1({}, Pt), ve.value), null), it(), Dt && createVNode$1(Footer, {
                stickyOffsets: ze.value,
                flattenColumns: fe.value
              }, {
                default: function() {
                  return [Dt];
                }
              })];
            }
          })]);
        };
      var Ut = pickAttrs(U, {
        aria: !0,
        data: !0
      }), Gt = function() {
        var Et;
        return createVNode$1("div", _objectSpread2$1(_objectSpread2$1({}, Ut), {}, {
          class: classNames(Ge, (Et = {}, _defineProperty$A(Et, "".concat(Ge, "-rtl"), mt === "rtl"), _defineProperty$A(Et, "".concat(Ge, "-ping-left"), Se.value), _defineProperty$A(Et, "".concat(Ge, "-ping-right"), Te.value), _defineProperty$A(Et, "".concat(Ge, "-layout-fixed"), ft === "fixed"), _defineProperty$A(Et, "".concat(Ge, "-fixed-header"), He.value), _defineProperty$A(Et, "".concat(Ge, "-fixed-column"), Re.value), _defineProperty$A(Et, "".concat(Ge, "-scroll-horizontal"), We.value), _defineProperty$A(Et, "".concat(Ge, "-has-fix-left"), fe.value[0] && fe.value[0].fixed), _defineProperty$A(Et, "".concat(Ge, "-has-fix-right"), fe.value[ke.value - 1] && fe.value[ke.value - 1].fixed === "right"), _defineProperty$A(Et, U.class, U.class), Et)),
          style: U.style,
          id: xt,
          ref: pe
        }), [St && createVNode$1(Panel, {
          class: "".concat(Ge, "-title")
        }, {
          default: function() {
            return [St(Z.value)];
          }
        }), createVNode$1("div", {
          class: "".concat(Ge, "-container")
        }, [Bt()]), bt && createVNode$1(Panel, {
          class: "".concat(Ge, "-footer")
        }, {
          default: function() {
            return [bt(Z.value)];
          }
        })]);
      };
      return We.value ? createVNode$1(ResizeObserver, {
        onResize: Qe
      }, {
        default: Gt
      }) : Gt();
    };
  }
});
var DEFAULT_PAGE_SIZE = 10;
function getPaginationParam(H, C) {
  var G = {
    current: C.current,
    pageSize: C.pageSize
  }, U = H && _typeof$2(H) === "object" ? H : {};
  return Object.keys(U).forEach(function(K) {
    var W = C[K];
    typeof W != "function" && (G[K] = W);
  }), G;
}
function extendsObject() {
  for (var H = {}, C = arguments.length, G = new Array(C), U = 0; U < C; U++)
    G[U] = arguments[U];
  return G.forEach(function(K) {
    K && Object.keys(K).forEach(function(W) {
      var Z = K[W];
      Z !== void 0 && (H[W] = Z);
    });
  }), H;
}
function usePagination(H, C, G) {
  var U = computed(function() {
    return C.value && _typeof$2(C.value) === "object" ? C.value : {};
  }), K = computed(function() {
    return U.value.total || 0;
  }), W = useState(function() {
    return {
      current: "defaultCurrent" in U.value ? U.value.defaultCurrent : 1,
      pageSize: "defaultPageSize" in U.value ? U.value.defaultPageSize : DEFAULT_PAGE_SIZE
    };
  }), Z = _slicedToArray$2(W, 2), X = Z[0], Q = Z[1], ee = computed(function() {
    var ne = extendsObject(X.value, U.value, {
      total: K.value > 0 ? K.value : H.value
    }), ae = Math.ceil((K.value || H.value) / ne.pageSize);
    return ne.current > ae && (ne.current = ae || 1), ne;
  }), te = function(ae, ie) {
    U.value !== !1 && Q({
      current: ae ?? 1,
      pageSize: ie || ee.value.pageSize
    });
  }, re = function(ae, ie) {
    if (U.value) {
      var se, oe;
      (se = (oe = U.value).onChange) === null || se === void 0 || se.call(oe, ae, ie);
    }
    te(ae, ie), G(ae, ie || ee.value.pageSize);
  };
  return [computed(function() {
    return U.value === !1 ? {} : _objectSpread2$1(_objectSpread2$1({}, ee.value), {}, {
      onChange: re
    });
  }), te];
}
function useLazyKVMap(H, C, G) {
  var U = shallowRef({});
  watch([H, C, G], function() {
    var W = /* @__PURE__ */ new Map(), Z = G.value, X = C.value;
    function Q(ee) {
      ee.forEach(function(te, re) {
        var ne = Z(te, re);
        W.set(ne, te), te && _typeof$2(te) === "object" && X in te && Q(te[X] || []);
      });
    }
    Q(H.value), U.value = {
      kvMap: W
    };
  }, {
    deep: !0,
    immediate: !0
  });
  function K(W) {
    return U.value.kvMap.get(W);
  }
  return [K];
}
var SELECTION_COLUMN = {}, SELECTION_ALL = "SELECT_ALL", SELECTION_INVERT = "SELECT_INVERT", SELECTION_NONE = "SELECT_NONE", EMPTY_LIST$1 = [];
function flattenData(H, C) {
  var G = [];
  return (H || []).forEach(function(U) {
    G.push(U), U && _typeof$2(U) === "object" && C in U && (G = [].concat(_toConsumableArray(G), _toConsumableArray(flattenData(U[C], C))));
  }), G;
}
function useSelection(H, C) {
  var G = computed(function() {
    var be = H.value || {}, Se = be.checkStrictly, Ae = Se === void 0 ? !0 : Se;
    return _objectSpread2$1(_objectSpread2$1({}, be), {}, {
      checkStrictly: Ae
    });
  }), U = useMergedState(G.value.selectedRowKeys || G.value.defaultSelectedRowKeys || EMPTY_LIST$1, {
    value: computed(function() {
      return G.value.selectedRowKeys;
    })
  }), K = _slicedToArray$2(U, 2), W = K[0], Z = K[1], X = shallowRef(/* @__PURE__ */ new Map()), Q = function(Se) {
    if (G.value.preserveSelectedRowKeys) {
      var Ae = /* @__PURE__ */ new Map();
      Se.forEach(function(_e) {
        var xe = C.getRecordByKey(_e);
        !xe && X.value.has(_e) && (xe = X.value.get(_e)), Ae.set(_e, xe);
      }), X.value = Ae;
    }
  };
  watchEffect(function() {
    Q(W.value);
  });
  var ee = computed(function() {
    return G.value.checkStrictly ? null : convertDataToEntities(C.data.value, {
      externalGetKey: C.getRowKey.value,
      childrenPropName: C.childrenColumnName.value
    }).keyEntities;
  }), te = computed(function() {
    return flattenData(C.pageData.value, C.childrenColumnName.value);
  }), re = computed(function() {
    var be = /* @__PURE__ */ new Map(), Se = C.getRowKey.value, Ae = G.value.getCheckboxProps;
    return te.value.forEach(function(_e, xe) {
      var Te = Se(_e, xe), Pe = (Ae ? Ae(_e) : null) || {};
      be.set(Te, Pe), process.env.NODE_ENV !== "production" && ("checked" in Pe || "defaultChecked" in Pe) && devWarning(!1, "Table", "Do not set `checked` or `defaultChecked` in `getCheckboxProps`. Please use `selectedRowKeys` instead.");
    }), be;
  }), ne = useMaxLevel(ee), ae = ne.maxLevel, ie = ne.levelEntities, se = function(Se) {
    var Ae;
    return !!((Ae = re.value.get(C.getRowKey.value(Se))) !== null && Ae !== void 0 && Ae.disabled);
  }, oe = computed(function() {
    if (G.value.checkStrictly)
      return [W.value || [], []];
    var be = conductCheck(W.value, !0, ee.value, ae.value, ie.value, se), Se = be.checkedKeys, Ae = be.halfCheckedKeys;
    return [Se || [], Ae];
  }), le = computed(function() {
    return oe.value[0];
  }), ue = computed(function() {
    return oe.value[1];
  }), ce = computed(function() {
    var be = G.value.type === "radio" ? le.value.slice(0, 1) : le.value;
    return new Set(be);
  }), de = computed(function() {
    return G.value.type === "radio" ? /* @__PURE__ */ new Set() : new Set(ue.value);
  }), ge = useState(null), fe = _slicedToArray$2(ge, 2), ve = fe[0], pe = fe[1], he = function(Se) {
    var Ae, _e;
    Q(Se);
    var xe = G.value, Te = xe.preserveSelectedRowKeys, Pe = xe.onChange, $e = C.getRecordByKey;
    Te ? (Ae = Se, _e = Se.map(function(Me) {
      return X.value.get(Me);
    })) : (Ae = [], _e = [], Se.forEach(function(Me) {
      var Ee = $e(Me);
      Ee !== void 0 && (Ae.push(Me), _e.push(Ee));
    })), Z(Ae), Pe == null || Pe(Ae, _e);
  }, me = function(Se, Ae, _e, xe) {
    var Te = G.value.onSelect, Pe = C || {}, $e = Pe.getRecordByKey;
    if (Te) {
      var Me = _e.map(function(Ee) {
        return $e(Ee);
      });
      Te($e(Se), Ae, Me, xe);
    }
    he(_e);
  }, ye = computed(function() {
    var be = G.value, Se = be.onSelectInvert, Ae = be.onSelectNone, _e = be.selections, xe = be.hideSelectAll, Te = C.data, Pe = C.pageData, $e = C.getRowKey, Me = C.locale;
    if (!_e || xe)
      return null;
    var Ee = _e === !0 ? [SELECTION_ALL, SELECTION_INVERT, SELECTION_NONE] : _e;
    return Ee.map(function(we) {
      return we === SELECTION_ALL ? {
        key: "all",
        text: Me.value.selectionAll,
        onSelect: function() {
          he(Te.value.map(function(Ne, ke) {
            return $e.value(Ne, ke);
          }).filter(function(Ne) {
            var ke = re.value.get(Ne);
            return !(ke != null && ke.disabled) || ce.value.has(Ne);
          }));
        }
      } : we === SELECTION_INVERT ? {
        key: "invert",
        text: Me.value.selectInvert,
        onSelect: function() {
          var Ne = new Set(ce.value);
          Pe.value.forEach(function(ze, He) {
            var We = $e.value(ze, He), Re = re.value.get(We);
            Re != null && Re.disabled || (Ne.has(We) ? Ne.delete(We) : Ne.add(We));
          });
          var ke = Array.from(Ne);
          Se && (devWarning(!1, "Table", "`onSelectInvert` will be removed in future. Please use `onChange` instead."), Se(ke)), he(ke);
        }
      } : we === SELECTION_NONE ? {
        key: "none",
        text: Me.value.selectNone,
        onSelect: function() {
          Ae == null || Ae(), he(Array.from(ce.value).filter(function(Ne) {
            var ke = re.value.get(Ne);
            return ke == null ? void 0 : ke.disabled;
          }));
        }
      } : we;
    });
  }), Ce = computed(function() {
    return te.value.length;
  }), Ie = function(Se) {
    var Ae, _e = G.value, xe = _e.onSelectAll, Te = _e.onSelectMultiple, Pe = _e.columnWidth, $e = _e.type, Me = _e.fixed, Ee = _e.renderCell, we = _e.hideSelectAll, Oe = _e.checkStrictly, Ne = C.prefixCls, ke = C.getRecordByKey, ze = C.getRowKey, He = C.expandType, We = C.getPopupContainer;
    if (!H.value)
      return process.env.NODE_ENV !== "production" && devWarning(!Se.includes(SELECTION_COLUMN), "Table", "`rowSelection` is not config but `SELECTION_COLUMN` exists in the `columns`."), Se.filter(function(je) {
        return je !== SELECTION_COLUMN;
      });
    var Re = Se.slice(), Le = new Set(ce.value), De = te.value.map(ze.value).filter(function(je) {
      return !re.value.get(je).disabled;
    }), Ue = De.every(function(je) {
      return Le.has(je);
    }), st = De.some(function(je) {
      return Le.has(je);
    }), ot = function() {
      var Je = [];
      Ue ? De.forEach(function(et) {
        Le.delete(et), Je.push(et);
      }) : De.forEach(function(et) {
        Le.has(et) || (Le.add(et), Je.push(et));
      });
      var it = Array.from(Le);
      xe == null || xe(!Ue, it.map(function(et) {
        return ke(et);
      }), Je.map(function(et) {
        return ke(et);
      })), he(it);
    }, ct;
    if ($e !== "radio") {
      var vt;
      if (ye.value) {
        var ut = createVNode$1(Menu, {
          getPopupContainer: We.value
        }, {
          default: function() {
            return [ye.value.map(function(Je, it) {
              var et = Je.key, Ve = Je.text, Ge = Je.onSelect;
              return createVNode$1(Menu.Item, {
                key: et || it,
                onClick: function() {
                  Ge == null || Ge(De);
                }
              }, {
                default: function() {
                  return [Ve];
                }
              });
            })];
          }
        });
        vt = createVNode$1("div", {
          class: "".concat(Ne.value, "-selection-extra")
        }, [createVNode$1(Dropdown$1, {
          overlay: ut,
          getPopupContainer: We.value
        }, {
          default: function() {
            return [createVNode$1("span", null, [createVNode$1(DownOutlined$1, null, null)])];
          }
        })]);
      }
      var at = te.value.map(function(je, Je) {
        var it = ze.value(je, Je), et = re.value.get(it) || {};
        return _objectSpread2$1({
          checked: Le.has(it)
        }, et);
      }).filter(function(je) {
        var Je = je.disabled;
        return Je;
      }), Ze = !!at.length && at.length === Ce.value, Xe = Ze && at.every(function(je) {
        var Je = je.checked;
        return Je;
      }), qe = Ze && at.some(function(je) {
        var Je = je.checked;
        return Je;
      });
      ct = !we && createVNode$1("div", {
        class: "".concat(Ne.value, "-selection")
      }, [createVNode$1(Checkbox, {
        checked: Ze ? Xe : !!Ce.value && Ue,
        indeterminate: Ze ? !Xe && qe : !Ue && st,
        onChange: ot,
        disabled: Ce.value === 0 || Ze,
        skipGroup: !0
      }, null), vt]);
    }
    var dt;
    $e === "radio" ? dt = function(Je) {
      var it = Je.record, et = Je.index, Ve = ze.value(it, et), Ge = Le.has(Ve);
      return {
        node: createVNode$1(Radio, _objectSpread2$1(_objectSpread2$1({}, re.value.get(Ve)), {}, {
          checked: Ge,
          onClick: function(ft) {
            return ft.stopPropagation();
          },
          onChange: function(ft) {
            Le.has(Ve) || me(Ve, !0, [Ve], ft.nativeEvent);
          }
        }), null),
        checked: Ge
      };
    } : dt = function(Je) {
      var it = Je.record, et = Je.index, Ve = ze.value(it, et), Ge = Le.has(Ve), tt = de.value.has(Ve), ft = re.value.get(Ve), mt;
      if (He.value === "nest")
        mt = tt, devWarning(typeof (ft == null ? void 0 : ft.indeterminate) != "boolean", "Table", "set `indeterminate` using `rowSelection.getCheckboxProps` is not allowed with tree structured dataSource.");
      else {
        var ht;
        mt = (ht = ft == null ? void 0 : ft.indeterminate) !== null && ht !== void 0 ? ht : tt;
      }
      return {
        node: createVNode$1(Checkbox, _objectSpread2$1(_objectSpread2$1({}, ft), {}, {
          indeterminate: mt,
          checked: Ge,
          skipGroup: !0,
          onClick: function(Ct) {
            return Ct.stopPropagation();
          },
          onChange: function(Ct) {
            var bt = Ct.nativeEvent, xt = bt.shiftKey, It = -1, Tt = -1;
            if (xt && Oe) {
              var _t = /* @__PURE__ */ new Set([ve.value, Ve]);
              De.some(function(Pt, zt) {
                if (_t.has(Pt))
                  if (It === -1)
                    It = zt;
                  else
                    return Tt = zt, !0;
                return !1;
              });
            }
            if (Tt !== -1 && It !== Tt && Oe) {
              var wt = De.slice(It, Tt + 1), Mt = [];
              Ge ? wt.forEach(function(Pt) {
                Le.has(Pt) && (Mt.push(Pt), Le.delete(Pt));
              }) : wt.forEach(function(Pt) {
                Le.has(Pt) || (Mt.push(Pt), Le.add(Pt));
              });
              var Ot = Array.from(Le);
              Te == null || Te(!Ge, Ot.map(function(Pt) {
                return ke(Pt);
              }), Mt.map(function(Pt) {
                return ke(Pt);
              })), he(Ot);
            } else {
              var kt = le.value;
              if (Oe) {
                var Ft = Ge ? arrDel(kt, Ve) : arrAdd(kt, Ve);
                me(Ve, !Ge, Ft, bt);
              } else {
                var Rt = conductCheck([].concat(_toConsumableArray(kt), [Ve]), !0, ee.value, ae.value, ie.value, se), $t = Rt.checkedKeys, Nt = Rt.halfCheckedKeys, Dt = $t;
                if (Ge) {
                  var Bt = new Set($t);
                  Bt.delete(Ve), Dt = conductCheck(Array.from(Bt), {
                    checked: !1,
                    halfCheckedKeys: Nt
                  }, ee.value, ae.value, ie.value, se).checkedKeys;
                }
                me(Ve, !Ge, Dt, bt);
              }
            }
            pe(Ve);
          }
        }), null),
        checked: Ge
      };
    };
    var gt = function(Je) {
      var it = Je.record, et = Je.index, Ve = dt({
        record: it,
        index: et
      }), Ge = Ve.node, tt = Ve.checked;
      return Ee ? Ee(tt, it, et, Ge) : Ge;
    };
    if (!Re.includes(SELECTION_COLUMN))
      if (Re.findIndex(function(je) {
        var Je;
        return ((Je = je[INTERNAL_COL_DEFINE]) === null || Je === void 0 ? void 0 : Je.columnType) === "EXPAND_COLUMN";
      }) === 0) {
        var yt = Re, At = _toArray(yt), nt = At[0], Ke = At.slice(1);
        Re = [nt, SELECTION_COLUMN].concat(_toConsumableArray(Ke));
      } else
        Re = [SELECTION_COLUMN].concat(_toConsumableArray(Re));
    var Qe = Re.indexOf(SELECTION_COLUMN);
    process.env.NODE_ENV !== "production" && Re.filter(function(je) {
      return je === SELECTION_COLUMN;
    }).length > 1 && devWarning(!1, "Table", "Multiple `SELECTION_COLUMN` exist in `columns`."), Re = Re.filter(function(je, Je) {
      return je !== SELECTION_COLUMN || Je === Qe;
    });
    var pt = Re[Qe - 1], Ye = Re[Qe + 1], Fe = Me;
    Fe === void 0 && ((Ye == null ? void 0 : Ye.fixed) !== void 0 ? Fe = Ye.fixed : (pt == null ? void 0 : pt.fixed) !== void 0 && (Fe = pt.fixed)), Fe && pt && ((Ae = pt[INTERNAL_COL_DEFINE]) === null || Ae === void 0 ? void 0 : Ae.columnType) === "EXPAND_COLUMN" && pt.fixed === void 0 && (pt.fixed = Fe);
    var Be = _defineProperty$A({
      fixed: Fe,
      width: Pe,
      className: "".concat(Ne.value, "-selection-column"),
      title: G.value.columnTitle || ct,
      customRender: gt
    }, INTERNAL_COL_DEFINE, {
      class: "".concat(Ne.value, "-selection-col")
    });
    return Re.map(function(je) {
      return je === SELECTION_COLUMN ? Be : je;
    });
  };
  return [Ie, ce];
}
var CaretDownOutlined$2 = { icon: { tag: "svg", attrs: { viewBox: "0 0 1024 1024", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M840.4 300H183.6c-19.7 0-30.7 20.8-18.5 35l328.4 380.8c9.4 10.9 27.5 10.9 37 0L858.9 335c12.2-14.2 1.2-35-18.5-35z" } }] }, name: "caret-down", theme: "outlined" };
const CaretDownOutlinedSvg = CaretDownOutlined$2;
function _objectSpread$b(H) {
  for (var C = 1; C < arguments.length; C++) {
    var G = arguments[C] != null ? Object(arguments[C]) : {}, U = Object.keys(G);
    typeof Object.getOwnPropertySymbols == "function" && (U = U.concat(Object.getOwnPropertySymbols(G).filter(function(K) {
      return Object.getOwnPropertyDescriptor(G, K).enumerable;
    }))), U.forEach(function(K) {
      _defineProperty$b(H, K, G[K]);
    });
  }
  return H;
}
function _defineProperty$b(H, C, G) {
  return C in H ? Object.defineProperty(H, C, { value: G, enumerable: !0, configurable: !0, writable: !0 }) : H[C] = G, H;
}
var CaretDownOutlined = function(C, G) {
  var U = _objectSpread$b({}, C, G.attrs);
  return createVNode$1(AntdIcon, _objectSpread$b({}, U, {
    icon: CaretDownOutlinedSvg
  }), null);
};
CaretDownOutlined.displayName = "CaretDownOutlined";
CaretDownOutlined.inheritAttrs = !1;
const CaretDownOutlined$1 = CaretDownOutlined;
var CaretUpOutlined$2 = { icon: { tag: "svg", attrs: { viewBox: "0 0 1024 1024", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M858.9 689L530.5 308.2c-9.4-10.9-27.5-10.9-37 0L165.1 689c-12.2 14.2-1.2 35 18.5 35h656.8c19.7 0 30.7-20.8 18.5-35z" } }] }, name: "caret-up", theme: "outlined" };
const CaretUpOutlinedSvg = CaretUpOutlined$2;
function _objectSpread$a(H) {
  for (var C = 1; C < arguments.length; C++) {
    var G = arguments[C] != null ? Object(arguments[C]) : {}, U = Object.keys(G);
    typeof Object.getOwnPropertySymbols == "function" && (U = U.concat(Object.getOwnPropertySymbols(G).filter(function(K) {
      return Object.getOwnPropertyDescriptor(G, K).enumerable;
    }))), U.forEach(function(K) {
      _defineProperty$a(H, K, G[K]);
    });
  }
  return H;
}
function _defineProperty$a(H, C, G) {
  return C in H ? Object.defineProperty(H, C, { value: G, enumerable: !0, configurable: !0, writable: !0 }) : H[C] = G, H;
}
var CaretUpOutlined = function(C, G) {
  var U = _objectSpread$a({}, C, G.attrs);
  return createVNode$1(AntdIcon, _objectSpread$a({}, U, {
    icon: CaretUpOutlinedSvg
  }), null);
};
CaretUpOutlined.displayName = "CaretUpOutlined";
CaretUpOutlined.inheritAttrs = !1;
const CaretUpOutlined$1 = CaretUpOutlined;
var _excluded$3 = ["default"];
function getColumnKey(H, C) {
  return "key" in H && H.key !== void 0 && H.key !== null ? H.key : H.dataIndex ? Array.isArray(H.dataIndex) ? H.dataIndex.join(".") : H.dataIndex : C;
}
function getColumnPos(H, C) {
  return C ? "".concat(C, "-").concat(H) : "".concat(H);
}
function renderColumnTitle(H, C) {
  return typeof H == "function" ? H(C) : H;
}
function convertChildrenToColumns() {
  var H = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], C = flattenChildren(H), G = [];
  return C.forEach(function(U) {
    var K, W, Z;
    if (U) {
      for (var X = U.key, Q = ((K = U.props) === null || K === void 0 ? void 0 : K.style) || {}, ee = ((W = U.props) === null || W === void 0 ? void 0 : W.class) || "", te = U.props || {}, re = 0, ne = Object.entries(te); re < ne.length; re++) {
        var ae = _slicedToArray$2(ne[re], 2), ie = ae[0], se = ae[1];
        te[camelize$1(ie)] = se;
      }
      var oe = U.children || {}, le = oe.default, ue = _objectWithoutProperties$2(oe, _excluded$3), ce = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, ue), te), {}, {
        style: Q,
        class: ee
      });
      if (X && (ce.key = X), (Z = U.type) !== null && Z !== void 0 && Z.__ANT_TABLE_COLUMN_GROUP)
        ce.children = convertChildrenToColumns(typeof le == "function" ? le() : le);
      else {
        var de, ge = (de = U.children) === null || de === void 0 ? void 0 : de.default;
        ce.customRender = ce.customRender || ge;
      }
      G.push(ce);
    }
  }), G;
}
var ASCEND = "ascend", DESCEND = "descend";
function getMultiplePriority(H) {
  return _typeof$2(H.sorter) === "object" && typeof H.sorter.multiple == "number" ? H.sorter.multiple : !1;
}
function getSortFunction(H) {
  return typeof H == "function" ? H : H && _typeof$2(H) === "object" && H.compare ? H.compare : !1;
}
function nextSortDirection(H, C) {
  return C ? H[H.indexOf(C) + 1] : H[0];
}
function collectSortStates(H, C, G) {
  var U = [];
  function K(W, Z) {
    U.push({
      column: W,
      key: getColumnKey(W, Z),
      multiplePriority: getMultiplePriority(W),
      sortOrder: W.sortOrder
    });
  }
  return (H || []).forEach(function(W, Z) {
    var X = getColumnPos(Z, G);
    W.children ? ("sortOrder" in W && K(W, X), U = [].concat(_toConsumableArray(U), _toConsumableArray(collectSortStates(W.children, C, X)))) : W.sorter && ("sortOrder" in W ? K(W, X) : C && W.defaultSortOrder && U.push({
      column: W,
      key: getColumnKey(W, X),
      multiplePriority: getMultiplePriority(W),
      sortOrder: W.defaultSortOrder
    }));
  }), U;
}
function injectSorter(H, C, G, U, K, W, Z, X) {
  return (C || []).map(function(Q, ee) {
    var te = getColumnPos(ee, X), re = Q;
    if (re.sorter) {
      var ne = re.sortDirections || K, ae = re.showSorterTooltip === void 0 ? Z : re.showSorterTooltip, ie = getColumnKey(re, te), se = G.find(function(me) {
        var ye = me.key;
        return ye === ie;
      }), oe = se ? se.sortOrder : null, le = nextSortDirection(ne, oe), ue = ne.includes(ASCEND) && createVNode$1(CaretUpOutlined$1, {
        class: classNames("".concat(H, "-column-sorter-up"), {
          active: oe === ASCEND
        })
      }, null), ce = ne.includes(DESCEND) && createVNode$1(CaretDownOutlined$1, {
        class: classNames("".concat(H, "-column-sorter-down"), {
          active: oe === DESCEND
        })
      }, null), de = W || {}, ge = de.cancelSort, fe = de.triggerAsc, ve = de.triggerDesc, pe = ge;
      le === DESCEND ? pe = ve : le === ASCEND && (pe = fe);
      var he = _typeof$2(ae) === "object" ? ae : {
        title: pe
      };
      re = _objectSpread2$1(_objectSpread2$1({}, re), {}, {
        className: classNames(re.className, _defineProperty$A({}, "".concat(H, "-column-sort"), oe)),
        title: function(ye) {
          var Ce = createVNode$1("div", {
            class: "".concat(H, "-column-sorters")
          }, [createVNode$1("span", {
            class: "".concat(H, "-column-title")
          }, [renderColumnTitle(Q.title, ye)]), createVNode$1("span", {
            class: classNames("".concat(H, "-column-sorter"), _defineProperty$A({}, "".concat(H, "-column-sorter-full"), !!(ue && ce)))
          }, [createVNode$1("span", {
            class: "".concat(H, "-column-sorter-inner")
          }, [ue, ce])])]);
          return ae ? createVNode$1(Tooltip, he, {
            default: function() {
              return [Ce];
            }
          }) : Ce;
        },
        customHeaderCell: function(ye) {
          var Ce = Q.customHeaderCell && Q.customHeaderCell(ye) || {}, Ie = Ce.onClick;
          return Ce.onClick = function(be) {
            U({
              column: Q,
              key: ie,
              sortOrder: le,
              multiplePriority: getMultiplePriority(Q)
            }), Ie && Ie(be);
          }, Ce.class = classNames(Ce.class, "".concat(H, "-column-has-sorters")), Ce;
        }
      });
    }
    return "children" in re && (re = _objectSpread2$1(_objectSpread2$1({}, re), {}, {
      children: injectSorter(H, re.children, G, U, K, W, Z, te)
    })), re;
  });
}
function stateToInfo(H) {
  var C = H.column, G = H.sortOrder;
  return {
    column: C,
    order: G,
    field: C.dataIndex,
    columnKey: C.key
  };
}
function generateSorterInfo(H) {
  var C = H.filter(function(G) {
    var U = G.sortOrder;
    return U;
  }).map(stateToInfo);
  return C.length === 0 && H.length ? _objectSpread2$1(_objectSpread2$1({}, stateToInfo(H[H.length - 1])), {}, {
    column: void 0
  }) : C.length <= 1 ? C[0] || {} : C;
}
function getSortData(H, C, G) {
  var U = C.slice().sort(function(Z, X) {
    return X.multiplePriority - Z.multiplePriority;
  }), K = H.slice(), W = U.filter(function(Z) {
    var X = Z.column.sorter, Q = Z.sortOrder;
    return getSortFunction(X) && Q;
  });
  return W.length ? K.sort(function(Z, X) {
    for (var Q = 0; Q < W.length; Q += 1) {
      var ee = W[Q], te = ee.column.sorter, re = ee.sortOrder, ne = getSortFunction(te);
      if (ne && re) {
        var ae = ne(Z, X, re);
        if (ae !== 0)
          return re === ASCEND ? ae : -ae;
      }
    }
    return 0;
  }).map(function(Z) {
    var X = Z[G];
    return X ? _objectSpread2$1(_objectSpread2$1({}, Z), {}, _defineProperty$A({}, G, getSortData(X, C, G))) : Z;
  }) : K;
}
function useFilterSorter(H) {
  var C = H.prefixCls, G = H.mergedColumns, U = H.onSorterChange, K = H.sortDirections, W = H.tableLocale, Z = H.showSorterTooltip, X = useState(collectSortStates(G.value, !0)), Q = _slicedToArray$2(X, 2), ee = Q[0], te = Q[1], re = computed(function() {
    var oe = !0, le = collectSortStates(G.value, !1);
    if (!le.length)
      return ee.value;
    var ue = [];
    function ce(ge) {
      oe ? ue.push(ge) : ue.push(_objectSpread2$1(_objectSpread2$1({}, ge), {}, {
        sortOrder: null
      }));
    }
    var de = null;
    return le.forEach(function(ge) {
      de === null ? (ce(ge), ge.sortOrder && (ge.multiplePriority === !1 ? oe = !1 : de = !0)) : (de && ge.multiplePriority !== !1 || (oe = !1), ce(ge));
    }), ue;
  }), ne = computed(function() {
    var oe = re.value.map(function(le) {
      var ue = le.column, ce = le.sortOrder;
      return {
        column: ue,
        order: ce
      };
    });
    return {
      sortColumns: oe,
      // Legacy
      sortColumn: oe[0] && oe[0].column,
      sortOrder: oe[0] && oe[0].order
    };
  });
  function ae(oe) {
    var le;
    oe.multiplePriority === !1 || !re.value.length || re.value[0].multiplePriority === !1 ? le = [oe] : le = [].concat(_toConsumableArray(re.value.filter(function(ue) {
      var ce = ue.key;
      return ce !== oe.key;
    })), [oe]), te(le), U(generateSorterInfo(le), le);
  }
  var ie = function(le) {
    return injectSorter(C.value, le, re.value, ae, K.value, W.value, Z.value);
  }, se = computed(function() {
    return generateSorterInfo(re.value);
  });
  return [ie, re, ne, se];
}
var FilterFilled$2 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M349 838c0 17.7 14.2 32 31.8 32h262.4c17.6 0 31.8-14.3 31.8-32V642H349v196zm531.1-684H143.9c-24.5 0-39.8 26.7-27.5 48l221.3 376h348.8l221.3-376c12.1-21.3-3.2-48-27.7-48z" } }] }, name: "filter", theme: "filled" };
const FilterFilledSvg = FilterFilled$2;
function _objectSpread$9(H) {
  for (var C = 1; C < arguments.length; C++) {
    var G = arguments[C] != null ? Object(arguments[C]) : {}, U = Object.keys(G);
    typeof Object.getOwnPropertySymbols == "function" && (U = U.concat(Object.getOwnPropertySymbols(G).filter(function(K) {
      return Object.getOwnPropertyDescriptor(G, K).enumerable;
    }))), U.forEach(function(K) {
      _defineProperty$9(H, K, G[K]);
    });
  }
  return H;
}
function _defineProperty$9(H, C, G) {
  return C in H ? Object.defineProperty(H, C, { value: G, enumerable: !0, configurable: !0, writable: !0 }) : H[C] = G, H;
}
var FilterFilled = function(C, G) {
  var U = _objectSpread$9({}, C, G.attrs);
  return createVNode$1(AntdIcon, _objectSpread$9({}, U, {
    icon: FilterFilledSvg
  }), null);
};
FilterFilled.displayName = "FilterFilled";
FilterFilled.inheritAttrs = !1;
const FilterFilled$1 = FilterFilled;
var FilterDropdownMenuWrapper = function(C, G) {
  var U, K = G.slots;
  return createVNode$1("div", {
    onClick: function(Z) {
      return Z.stopPropagation();
    }
  }, [(U = K.default) === null || U === void 0 ? void 0 : U.call(K)]);
};
const FilterDropdownMenuWrapper$1 = FilterDropdownMenuWrapper, FilterSearch = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "FilterSearch",
  inheritAttrs: !1,
  props: {
    value: String,
    onChange: Function,
    filterSearch: Boolean,
    tablePrefixCls: String,
    locale: {
      type: Object,
      default: void 0
    }
  },
  setup: function(C) {
    return function() {
      var G = C.value, U = C.onChange, K = C.filterSearch, W = C.tablePrefixCls, Z = C.locale;
      return K ? createVNode$1("div", {
        class: "".concat(W, "-filter-dropdown-search")
      }, [createVNode$1(Input, {
        placeholder: Z.filterSearchPlaceholder,
        onChange: U,
        value: G,
        htmlSize: 1,
        class: "".concat(W, "-filter-dropdown-search-input")
      }, {
        prefix: function() {
          return createVNode$1(SearchOutlined$1, null, null);
        }
      })]) : null;
    };
  }
});
var _excluded$2 = ["motion", "motionNodes", "motionType", "active", "eventKey"];
const MotionTreeNode = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "MotionTreeNode",
  inheritAttrs: !1,
  props: _objectSpread2$1(_objectSpread2$1({}, treeNodeProps), {}, {
    active: Boolean,
    motion: Object,
    motionNodes: {
      type: Array
    },
    onMotionStart: Function,
    onMotionEnd: Function,
    motionType: String
    // treeNodeRequiredProps: { type: Object as PropType<TreeNodeRequiredProps> },
  }),
  slots: ["title", "icon", "switcherIcon", "checkable"],
  setup: function(C, G) {
    var U = G.attrs, K = G.slots, W = ref(!0), Z = useInjectTreeContext(), X = ref(!1), Q = computed(function() {
      return C.motion ? C.motion : collapseMotion$1();
    }), ee = function(re, ne) {
      if (ne === "appear") {
        var ae, ie;
        (ae = Q.value) === null || ae === void 0 || (ie = ae.onAfterEnter) === null || ie === void 0 || ie.call(ae, re);
      } else if (ne === "leave") {
        var se, oe;
        (se = Q.value) === null || se === void 0 || (oe = se.onAfterLeave) === null || oe === void 0 || oe.call(se, re);
      }
      X.value || C.onMotionEnd(), X.value = !0;
    };
    return watch(function() {
      return C.motionNodes;
    }, function() {
      C.motionNodes && C.motionType === "hide" && W.value && nextTick(function() {
        W.value = !1;
      });
    }, {
      immediate: !0,
      flush: "post"
    }), onMounted(function() {
      C.motionNodes && C.onMotionStart();
    }), onBeforeUnmount(function() {
      C.motionNodes && ee();
    }), function() {
      C.motion;
      var te = C.motionNodes, re = C.motionType, ne = C.active, ae = C.eventKey, ie = _objectWithoutProperties$2(C, _excluded$2);
      return te ? createVNode$1(Transition, _objectSpread2$1(_objectSpread2$1({}, Q.value), {}, {
        appear: re === "show",
        onAfterAppear: function(oe) {
          return ee(oe, "appear");
        },
        onAfterLeave: function(oe) {
          return ee(oe, "leave");
        }
      }), {
        default: function() {
          return [withDirectives(createVNode$1("div", {
            class: "".concat(Z.value.prefixCls, "-treenode-motion")
          }, [te.map(function(oe) {
            var le = _extends({}, (_objectDestructuringEmpty(oe.data), oe.data)), ue = oe.title, ce = oe.key, de = oe.isStart, ge = oe.isEnd;
            return delete le.children, createVNode$1(VcTreeNode, _objectSpread2$1(_objectSpread2$1({}, le), {}, {
              title: ue,
              active: ne,
              data: oe.data,
              key: ce,
              eventKey: ce,
              isStart: de,
              isEnd: ge
            }), K);
          })]), [[vShow, W.value]])];
        }
      }) : createVNode$1(VcTreeNode, _objectSpread2$1(_objectSpread2$1({
        domRef: ref,
        class: U.class,
        style: U.style
      }, ie), {}, {
        active: ne,
        eventKey: ae
      }), K);
    };
  }
});
function findExpandedKeys() {
  var H = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], C = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], G = H.length, U = C.length;
  if (Math.abs(G - U) !== 1)
    return {
      add: !1,
      key: null
    };
  function K(W, Z) {
    var X = /* @__PURE__ */ new Map();
    W.forEach(function(ee) {
      X.set(ee, !0);
    });
    var Q = Z.filter(function(ee) {
      return !X.has(ee);
    });
    return Q.length === 1 ? Q[0] : null;
  }
  return G < U ? {
    add: !0,
    key: K(H, C)
  } : {
    add: !1,
    key: K(C, H)
  };
}
function getExpandRange(H, C, G) {
  var U = H.findIndex(function(X) {
    return X.key === G;
  }), K = H[U + 1], W = C.findIndex(function(X) {
    return X.key === G;
  });
  if (K) {
    var Z = C.findIndex(function(X) {
      return X.key === K.key;
    });
    return C.slice(W + 1, Z);
  }
  return C.slice(W + 1);
}
var _excluded$1 = ["prefixCls", "selectable", "checkable", "disabled", "motion", "height", "itemHeight", "virtual", "focusable", "activeItem", "focused", "tabindex", "onKeydown", "onFocus", "onBlur", "onListChangeStart", "onListChangeEnd"], HIDDEN_STYLE = {
  width: 0,
  height: 0,
  display: "flex",
  overflow: "hidden",
  opacity: 0,
  border: 0,
  padding: 0,
  margin: 0
}, noop$1 = function() {
}, MOTION_KEY = "RC_TREE_MOTION_".concat(Math.random()), MotionNode = {
  key: MOTION_KEY
}, MotionEntity = {
  key: MOTION_KEY,
  level: 0,
  index: 0,
  pos: "0",
  node: MotionNode,
  nodes: [MotionNode]
}, MotionFlattenData = {
  parent: null,
  children: [],
  pos: MotionEntity.pos,
  data: MotionNode,
  title: null,
  key: MOTION_KEY,
  /** Hold empty list here since we do not use it */
  isStart: [],
  isEnd: []
};
function getMinimumRangeTransitionRange(H, C, G, U) {
  return C === !1 || !G ? H : H.slice(0, Math.ceil(G / U) + 1);
}
function itemKey(H) {
  var C = H.key, G = H.pos;
  return getKey$1(C, G);
}
function getAccessibilityPath(H) {
  for (var C = String(H.key), G = H; G.parent; )
    G = G.parent, C = "".concat(G.key, " > ").concat(C);
  return C;
}
const NodeList = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "NodeList",
  inheritAttrs: !1,
  props: nodeListProps,
  setup: function(C, G) {
    var U = G.expose, K = G.attrs, W = ref(), Z = ref(), X = useInjectKeysState(), Q = X.expandedKeys, ee = X.flattenNodes;
    U({
      scrollTo: function(ue) {
        W.value.scrollTo(ue);
      },
      getIndentWidth: function() {
        return Z.value.offsetWidth;
      }
    });
    var te = shallowRef(ee.value), re = shallowRef([]), ne = ref(null);
    function ae() {
      te.value = ee.value, re.value = [], ne.value = null, C.onListChangeEnd();
    }
    var ie = useInjectTreeContext();
    watch([function() {
      return Q.value.slice();
    }, ee], function(le, ue) {
      var ce = _slicedToArray$2(le, 2), de = ce[0], ge = ce[1], fe = _slicedToArray$2(ue, 2), ve = fe[0], pe = fe[1], he = findExpandedKeys(ve, de);
      if (he.key !== null) {
        var me = C.virtual, ye = C.height, Ce = C.itemHeight;
        if (he.add) {
          var Ie = pe.findIndex(function(Te) {
            var Pe = Te.key;
            return Pe === he.key;
          }), be = getMinimumRangeTransitionRange(getExpandRange(pe, ge, he.key), me, ye, Ce), Se = pe.slice();
          Se.splice(Ie + 1, 0, MotionFlattenData), te.value = Se, re.value = be, ne.value = "show";
        } else {
          var Ae = ge.findIndex(function(Te) {
            var Pe = Te.key;
            return Pe === he.key;
          }), _e = getMinimumRangeTransitionRange(getExpandRange(ge, pe, he.key), me, ye, Ce), xe = ge.slice();
          xe.splice(Ae + 1, 0, MotionFlattenData), te.value = xe, re.value = _e, ne.value = "hide";
        }
      } else
        pe !== ge && (te.value = ge);
    }), watch(function() {
      return ie.value.dragging;
    }, function(le) {
      le || ae();
    });
    var se = computed(function() {
      return C.motion === void 0 ? te.value : ee.value;
    }), oe = function() {
      C.onActiveChange(null);
    };
    return function() {
      var le = _objectSpread2$1(_objectSpread2$1({}, C), K), ue = le.prefixCls;
      le.selectable, le.checkable;
      var ce = le.disabled, de = le.motion, ge = le.height, fe = le.itemHeight, ve = le.virtual, pe = le.focusable, he = le.activeItem, me = le.focused, ye = le.tabindex, Ce = le.onKeydown, Ie = le.onFocus, be = le.onBlur, Se = le.onListChangeStart;
      le.onListChangeEnd;
      var Ae = _objectWithoutProperties$2(le, _excluded$1);
      return createVNode$1(Fragment, null, [me && he && createVNode$1("span", {
        style: HIDDEN_STYLE,
        "aria-live": "assertive"
      }, [getAccessibilityPath(he)]), createVNode$1("div", null, [createVNode$1("input", {
        style: HIDDEN_STYLE,
        disabled: pe === !1 || ce,
        tabindex: pe !== !1 ? ye : null,
        onKeydown: Ce,
        onFocus: Ie,
        onBlur: be,
        value: "",
        onChange: noop$1,
        "aria-label": "for screen reader"
      }, null)]), createVNode$1("div", {
        class: "".concat(ue, "-treenode"),
        "aria-hidden": !0,
        style: {
          position: "absolute",
          pointerEvents: "none",
          visibility: "hidden",
          height: 0,
          overflow: "hidden"
        }
      }, [createVNode$1("div", {
        class: "".concat(ue, "-indent")
      }, [createVNode$1("div", {
        ref: Z,
        class: "".concat(ue, "-indent-unit")
      }, null)])]), createVNode$1(List$1, _objectSpread2$1(_objectSpread2$1({}, omit(Ae, ["onActiveChange"])), {}, {
        data: se.value,
        itemKey,
        height: ge,
        fullHeight: !1,
        virtual: ve,
        itemHeight: fe,
        prefixCls: "".concat(ue, "-list"),
        ref: W,
        onVisibleChange: function(xe, Te) {
          var Pe = new Set(xe), $e = Te.filter(function(Me) {
            return !Pe.has(Me);
          });
          $e.some(function(Me) {
            return itemKey(Me) === MOTION_KEY;
          }) && ae();
        }
      }), {
        default: function(xe) {
          var Te = xe.pos, Pe = _extends({}, (_objectDestructuringEmpty(xe.data), xe.data)), $e = xe.title, Me = xe.key, Ee = xe.isStart, we = xe.isEnd, Oe = getKey$1(Me, Te);
          return delete Pe.key, delete Pe.children, createVNode$1(MotionTreeNode, _objectSpread2$1(_objectSpread2$1({}, Pe), {}, {
            eventKey: Oe,
            title: $e,
            active: !!he && Me === he.key,
            data: xe.data,
            isStart: Ee,
            isEnd: we,
            motion: de,
            motionNodes: Me === MOTION_KEY ? re.value : null,
            motionType: ne.value,
            onMotionStart: Se,
            onMotionEnd: ae,
            onMousemove: oe
          }), null);
        }
      })]);
    };
  }
});
function DropIndicator(H) {
  var C = H.dropPosition, G = H.dropLevelOffset, U = H.indent, K = {
    pointerEvents: "none",
    position: "absolute",
    right: 0,
    backgroundColor: "red",
    height: "".concat(2, "px")
  };
  switch (C) {
    case -1:
      K.top = 0, K.left = "".concat(-G * U, "px");
      break;
    case 1:
      K.bottom = 0, K.left = "".concat(-G * U, "px");
      break;
    case 0:
      K.bottom = 0, K.left = "".concat(U);
      break;
  }
  return createVNode$1("div", {
    style: K
  }, null);
}
var MAX_RETRY_TIMES = 10;
const Tree$4 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Tree",
  inheritAttrs: !1,
  slots: ["checkable", "title", "icon", "titleRender"],
  props: initDefaultProps$1(treeProps$1(), {
    prefixCls: "vc-tree",
    showLine: !1,
    showIcon: !0,
    selectable: !0,
    multiple: !1,
    checkable: !1,
    disabled: !1,
    checkStrictly: !1,
    draggable: !1,
    defaultExpandParent: !0,
    autoExpandParent: !1,
    defaultExpandAll: !1,
    defaultExpandedKeys: [],
    defaultCheckedKeys: [],
    defaultSelectedKeys: [],
    dropIndicatorRender: DropIndicator,
    allowDrop: function() {
      return !0;
    }
  }),
  setup: function(C, G) {
    var U = G.attrs, K = G.slots, W = G.expose, Z = ref(!1), X = {}, Q = ref(), ee = shallowRef([]), te = shallowRef([]), re = shallowRef([]), ne = shallowRef([]), ae = shallowRef([]), ie = shallowRef([]), se = {}, oe = reactive({
      draggingNodeKey: null,
      dragChildrenKeys: [],
      // dropTargetKey is the key of abstract-drop-node
      // the abstract-drop-node is the real drop node when drag and drop
      // not the DOM drag over node
      dropTargetKey: null,
      dropPosition: null,
      dropContainerKey: null,
      dropLevelOffset: null,
      dropTargetPos: null,
      dropAllowed: !0,
      // the abstract-drag-over-node
      // if mouse is on the bottom of top dom node or no the top of the bottom dom node
      // abstract-drag-over-node is the top node
      dragOverNodeKey: null
    }), le = shallowRef([]);
    watch([function() {
      return C.treeData;
    }, function() {
      return C.children;
    }], function() {
      le.value = C.treeData !== void 0 ? toRaw(C.treeData).slice() : convertTreeToData(toRaw(C.children));
    }, {
      immediate: !0,
      deep: !0
    });
    var ue = shallowRef({}), ce = ref(!1), de = ref(null), ge = ref(!1), fe = computed(function() {
      return fillFieldNames(C.fieldNames);
    }), ve = ref(), pe = null, he = null, me = null, ye = computed(function() {
      return {
        expandedKeysSet: Ce.value,
        selectedKeysSet: Ie.value,
        loadedKeysSet: be.value,
        loadingKeysSet: Se.value,
        checkedKeysSet: Ae.value,
        halfCheckedKeysSet: _e.value,
        dragOverNodeKey: oe.dragOverNodeKey,
        dropPosition: oe.dropPosition,
        keyEntities: ue.value
      };
    }), Ce = computed(function() {
      return new Set(ie.value);
    }), Ie = computed(function() {
      return new Set(ee.value);
    }), be = computed(function() {
      return new Set(ne.value);
    }), Se = computed(function() {
      return new Set(ae.value);
    }), Ae = computed(function() {
      return new Set(te.value);
    }), _e = computed(function() {
      return new Set(re.value);
    });
    watchEffect(function() {
      if (le.value) {
        var Ye = convertDataToEntities(le.value, {
          fieldNames: fe.value
        });
        ue.value = _objectSpread2$1(_defineProperty$A({}, MOTION_KEY, MotionEntity), Ye.keyEntities);
      }
    });
    var xe = !1;
    watch(
      [function() {
        return C.expandedKeys;
      }, function() {
        return C.autoExpandParent;
      }, ue],
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      function(Ye, Fe) {
        var Be = _slicedToArray$2(Ye, 2);
        Be[0];
        var je = Be[1], Je = _slicedToArray$2(Fe, 2);
        Je[0];
        var it = Je[1], et = ie.value;
        if (C.expandedKeys !== void 0 || xe && je !== it)
          et = C.autoExpandParent || !xe && C.defaultExpandParent ? conductExpandParent(C.expandedKeys, ue.value) : C.expandedKeys;
        else if (!xe && C.defaultExpandAll) {
          var Ve = _objectSpread2$1({}, ue.value);
          delete Ve[MOTION_KEY], et = Object.keys(Ve).map(function(Ge) {
            return Ve[Ge].key;
          });
        } else
          !xe && C.defaultExpandedKeys && (et = C.autoExpandParent || C.defaultExpandParent ? conductExpandParent(C.defaultExpandedKeys, ue.value) : C.defaultExpandedKeys);
        et && (ie.value = et), xe = !0;
      },
      {
        immediate: !0
      }
    );
    var Te = shallowRef([]);
    watchEffect(function() {
      Te.value = flattenTreeData(le.value, ie.value, fe.value);
    }), watchEffect(function() {
      C.selectable && (C.selectedKeys !== void 0 ? ee.value = calcSelectedKeys(C.selectedKeys, C) : !xe && C.defaultSelectedKeys && (ee.value = calcSelectedKeys(C.defaultSelectedKeys, C)));
    });
    var Pe = useMaxLevel(ue), $e = Pe.maxLevel, Me = Pe.levelEntities;
    watchEffect(function() {
      if (C.checkable) {
        var Ye;
        if (C.checkedKeys !== void 0 ? Ye = parseCheckedKeys(C.checkedKeys) || {} : !xe && C.defaultCheckedKeys ? Ye = parseCheckedKeys(C.defaultCheckedKeys) || {} : le.value && (Ye = parseCheckedKeys(C.checkedKeys) || {
          checkedKeys: te.value,
          halfCheckedKeys: re.value
        }), Ye) {
          var Fe = Ye, Be = Fe.checkedKeys, je = Be === void 0 ? [] : Be, Je = Fe.halfCheckedKeys, it = Je === void 0 ? [] : Je;
          if (!C.checkStrictly) {
            var et = conductCheck(je, !0, ue.value, $e.value, Me.value);
            je = et.checkedKeys, it = et.halfCheckedKeys;
          }
          te.value = je, re.value = it;
        }
      }
    }), watchEffect(function() {
      C.loadedKeys && (ne.value = C.loadedKeys);
    });
    var Ee = function() {
      _extends(oe, {
        dragOverNodeKey: null,
        dropPosition: null,
        dropLevelOffset: null,
        dropTargetKey: null,
        dropContainerKey: null,
        dropTargetPos: null,
        dropAllowed: !1
      });
    }, we = function(Fe) {
      ve.value.scrollTo(Fe);
    };
    watch(function() {
      return C.activeKey;
    }, function() {
      C.activeKey !== void 0 && (de.value = C.activeKey);
    }, {
      immediate: !0
    }), watch(de, function(Ye) {
      nextTick(function() {
        Ye !== null && we({
          key: Ye
        });
      });
    }, {
      immediate: !0,
      flush: "post"
    });
    var Oe = function(Fe) {
      C.expandedKeys === void 0 && (ie.value = Fe);
    }, Ne = function() {
      oe.draggingNodeKey !== null && _extends(oe, {
        draggingNodeKey: null,
        dropPosition: null,
        dropContainerKey: null,
        dropTargetKey: null,
        dropLevelOffset: null,
        dropAllowed: !0,
        dragOverNodeKey: null
      }), pe = null, me = null;
    }, ke = function(Fe, Be) {
      var je = C.onDragend;
      oe.dragOverNodeKey = null, Ne(), je == null || je({
        event: Fe,
        node: Be.eventData
      }), he = null;
    }, ze = function Ye(Fe) {
      ke(Fe, null), window.removeEventListener("dragend", Ye);
    }, He = function(Fe, Be) {
      var je = C.onDragstart, Je = Be.eventKey, it = Be.eventData;
      he = Be, pe = {
        x: Fe.clientX,
        y: Fe.clientY
      };
      var et = arrDel(ie.value, Je);
      oe.draggingNodeKey = Je, oe.dragChildrenKeys = getDragChildrenKeys(Je, ue.value), Q.value = ve.value.getIndentWidth(), Oe(et), window.addEventListener("dragend", ze), je && je({
        event: Fe,
        node: it
      });
    }, We = function(Fe, Be) {
      var je = C.onDragenter, Je = C.onExpand, it = C.allowDrop, et = C.direction, Ve = Be.pos, Ge = Be.eventKey;
      if (me !== Ge && (me = Ge), !he) {
        Ee();
        return;
      }
      var tt = calcDropPosition(Fe, he, Be, Q.value, pe, it, Te.value, ue.value, Ce.value, et), ft = tt.dropPosition, mt = tt.dropLevelOffset, ht = tt.dropTargetKey, St = tt.dropContainerKey, Ct = tt.dropTargetPos, bt = tt.dropAllowed, xt = tt.dragOverNodeKey;
      if (// don't allow drop inside its children
      oe.dragChildrenKeys.indexOf(ht) !== -1 || // don't allow drop when drop is not allowed caculated by calcDropPosition
      !bt) {
        Ee();
        return;
      }
      if (X || (X = {}), Object.keys(X).forEach(function(It) {
        clearTimeout(X[It]);
      }), he.eventKey !== Be.eventKey && (X[Ve] = window.setTimeout(function() {
        if (oe.draggingNodeKey !== null) {
          var It = ie.value.slice(), Tt = ue.value[Be.eventKey];
          Tt && (Tt.children || []).length && (It = arrAdd(ie.value, Be.eventKey)), Oe(It), Je && Je(It, {
            node: Be.eventData,
            expanded: !0,
            nativeEvent: Fe
          });
        }
      }, 800)), he.eventKey === ht && mt === 0) {
        Ee();
        return;
      }
      _extends(oe, {
        dragOverNodeKey: xt,
        dropPosition: ft,
        dropLevelOffset: mt,
        dropTargetKey: ht,
        dropContainerKey: St,
        dropTargetPos: Ct,
        dropAllowed: bt
      }), je && je({
        event: Fe,
        node: Be.eventData,
        expandedKeys: ie.value
      });
    }, Re = function(Fe, Be) {
      var je = C.onDragover, Je = C.allowDrop, it = C.direction;
      if (he) {
        var et = calcDropPosition(Fe, he, Be, Q.value, pe, Je, Te.value, ue.value, Ce.value, it), Ve = et.dropPosition, Ge = et.dropLevelOffset, tt = et.dropTargetKey, ft = et.dropContainerKey, mt = et.dropAllowed, ht = et.dropTargetPos, St = et.dragOverNodeKey;
        oe.dragChildrenKeys.indexOf(tt) !== -1 || !mt || (he.eventKey === tt && Ge === 0 ? oe.dropPosition === null && oe.dropLevelOffset === null && oe.dropTargetKey === null && oe.dropContainerKey === null && oe.dropTargetPos === null && oe.dropAllowed === !1 && oe.dragOverNodeKey === null || Ee() : Ve === oe.dropPosition && Ge === oe.dropLevelOffset && tt === oe.dropTargetKey && ft === oe.dropContainerKey && ht === oe.dropTargetPos && mt === oe.dropAllowed && St === oe.dragOverNodeKey || _extends(oe, {
          dropPosition: Ve,
          dropLevelOffset: Ge,
          dropTargetKey: tt,
          dropContainerKey: ft,
          dropTargetPos: ht,
          dropAllowed: mt,
          dragOverNodeKey: St
        }), je && je({
          event: Fe,
          node: Be.eventData
        }));
      }
    }, Le = function(Fe, Be) {
      me === Be.eventKey && !Fe.currentTarget.contains(Fe.relatedTarget) && (Ee(), me = null);
      var je = C.onDragleave;
      je && je({
        event: Fe,
        node: Be.eventData
      });
    }, De = function(Fe, Be) {
      var je, Je = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, it = oe.dragChildrenKeys, et = oe.dropPosition, Ve = oe.dropTargetKey, Ge = oe.dropTargetPos, tt = oe.dropAllowed;
      if (tt) {
        var ft = C.onDrop;
        if (oe.dragOverNodeKey = null, Ne(), Ve !== null) {
          var mt = _objectSpread2$1(_objectSpread2$1({}, getTreeNodeProps(Ve, toRaw(ye.value))), {}, {
            active: ((je = nt.value) === null || je === void 0 ? void 0 : je.key) === Ve,
            data: ue.value[Ve].node
          }), ht = it.indexOf(Ve) !== -1;
          warning$2(!ht, "Can not drop to dragNode's children node. Maybe this is a bug of ant-design-vue. Please report an issue.");
          var St = posToArr(Ge), Ct = {
            event: Fe,
            node: convertNodePropsToEventData(mt),
            dragNode: he ? he.eventData : null,
            dragNodesKeys: [he.eventKey].concat(it),
            dropToGap: et !== 0,
            dropPosition: et + Number(St[St.length - 1])
          };
          Je || ft == null || ft(Ct), he = null;
        }
      }
    }, Ue = function(Fe, Be) {
      var je = C.onClick;
      je && je(Fe, Be);
    }, st = function(Fe, Be) {
      var je = C.onDblclick;
      je && je(Fe, Be);
    }, ot = function(Fe, Be) {
      var je = ee.value, Je = C.onSelect, it = C.multiple, et = Be.selected, Ve = Be[fe.value.key], Ge = !et;
      Ge ? it ? je = arrAdd(je, Ve) : je = [Ve] : je = arrDel(je, Ve);
      var tt = ue.value, ft = je.map(function(mt) {
        var ht = tt[mt];
        return ht ? ht.node : null;
      }).filter(function(mt) {
        return mt;
      });
      C.selectedKeys === void 0 && (ee.value = je), Je && Je(je, {
        event: "select",
        selected: Ge,
        node: Be,
        selectedNodes: ft,
        nativeEvent: Fe
      });
    }, ct = function(Fe, Be, je) {
      var Je = C.checkStrictly, it = C.onCheck, et = Be[fe.value.key], Ve, Ge = {
        event: "check",
        node: Be,
        checked: je,
        nativeEvent: Fe
      }, tt = ue.value;
      if (Je) {
        var ft = je ? arrAdd(te.value, et) : arrDel(te.value, et), mt = arrDel(re.value, et);
        Ve = {
          checked: ft,
          halfChecked: mt
        }, Ge.checkedNodes = ft.map(function(It) {
          return tt[It];
        }).filter(function(It) {
          return It;
        }).map(function(It) {
          return It.node;
        }), C.checkedKeys === void 0 && (te.value = ft);
      } else {
        var ht = conductCheck([].concat(_toConsumableArray(te.value), [et]), !0, tt, $e.value, Me.value), St = ht.checkedKeys, Ct = ht.halfCheckedKeys;
        if (!je) {
          var bt = new Set(St);
          bt.delete(et);
          var xt = conductCheck(Array.from(bt), {
            checked: !1,
            halfCheckedKeys: Ct
          }, tt, $e.value, Me.value);
          St = xt.checkedKeys, Ct = xt.halfCheckedKeys;
        }
        Ve = St, Ge.checkedNodes = [], Ge.checkedNodesPositions = [], Ge.halfCheckedKeys = Ct, St.forEach(function(It) {
          var Tt = tt[It];
          if (Tt) {
            var _t = Tt.node, wt = Tt.pos;
            Ge.checkedNodes.push(_t), Ge.checkedNodesPositions.push({
              node: _t,
              pos: wt
            });
          }
        }), C.checkedKeys === void 0 && (te.value = St, re.value = Ct);
      }
      it && it(Ve, Ge);
    }, vt = function(Fe) {
      var Be = Fe[fe.value.key], je = new Promise(function(Je, it) {
        var et = C.loadData, Ve = C.onLoad;
        if (!et || be.value.has(Be) || Se.value.has(Be))
          return null;
        var Ge = et(Fe);
        Ge.then(function() {
          var tt = arrAdd(ne.value, Be), ft = arrDel(ae.value, Be);
          Ve && Ve(tt, {
            event: "load",
            node: Fe
          }), C.loadedKeys === void 0 && (ne.value = tt), ae.value = ft, Je();
        }).catch(function(tt) {
          var ft = arrDel(ae.value, Be);
          if (ae.value = ft, se[Be] = (se[Be] || 0) + 1, se[Be] >= MAX_RETRY_TIMES) {
            warning$2(!1, "Retry for `loadData` many times but still failed. No more retry.");
            var mt = arrAdd(ne.value, Be);
            C.loadedKeys === void 0 && (ne.value = mt), Je();
          }
          it(tt);
        }), ae.value = arrAdd(ae.value, Be);
      });
      return je.catch(function() {
      }), je;
    }, ut = function(Fe, Be) {
      var je = C.onMouseenter;
      je && je({
        event: Fe,
        node: Be
      });
    }, at = function(Fe, Be) {
      var je = C.onMouseleave;
      je && je({
        event: Fe,
        node: Be
      });
    }, Ze = function(Fe, Be) {
      var je = C.onRightClick;
      je && (Fe.preventDefault(), je({
        event: Fe,
        node: Be
      }));
    }, Xe = function(Fe) {
      var Be = C.onFocus;
      ce.value = !0, Be && Be(Fe);
    }, qe = function(Fe) {
      var Be = C.onBlur;
      ce.value = !1, At(null), Be && Be(Fe);
    }, dt = function(Fe, Be) {
      var je = ie.value, Je = C.onExpand, it = C.loadData, et = Be.expanded, Ve = Be[fe.value.key];
      if (!ge.value) {
        var Ge = je.indexOf(Ve), tt = !et;
        if (warning$2(et && Ge !== -1 || !et && Ge === -1, "Expand state not sync with index check"), tt ? je = arrAdd(je, Ve) : je = arrDel(je, Ve), Oe(je), Je && Je(je, {
          node: Be,
          expanded: tt,
          nativeEvent: Fe
        }), tt && it) {
          var ft = vt(Be);
          ft && ft.then(function() {
          }).catch(function(mt) {
            var ht = arrDel(ie.value, Ve);
            Oe(ht), Promise.reject(mt);
          });
        }
      }
    }, gt = function() {
      ge.value = !0;
    }, yt = function() {
      setTimeout(function() {
        ge.value = !1;
      });
    }, At = function(Fe) {
      var Be = C.onActiveChange;
      de.value !== Fe && (C.activeKey !== void 0 && (de.value = Fe), Fe !== null && we({
        key: Fe
      }), Be && Be(Fe));
    }, nt = computed(function() {
      return de.value === null ? null : Te.value.find(function(Ye) {
        var Fe = Ye.key;
        return Fe === de.value;
      }) || null;
    }), Ke = function(Fe) {
      var Be = Te.value.findIndex(function(it) {
        var et = it.key;
        return et === de.value;
      });
      Be === -1 && Fe < 0 && (Be = Te.value.length), Be = (Be + Fe + Te.value.length) % Te.value.length;
      var je = Te.value[Be];
      if (je) {
        var Je = je.key;
        At(Je);
      } else
        At(null);
    }, Qe = computed(function() {
      return convertNodePropsToEventData(_objectSpread2$1(_objectSpread2$1({}, getTreeNodeProps(de.value, ye.value)), {}, {
        data: nt.value.data,
        active: !0
      }));
    }), pt = function(Fe) {
      var Be = C.onKeydown, je = C.checkable, Je = C.selectable;
      switch (Fe.which) {
        case KeyCode$1.UP: {
          Ke(-1), Fe.preventDefault();
          break;
        }
        case KeyCode$1.DOWN: {
          Ke(1), Fe.preventDefault();
          break;
        }
      }
      var it = nt.value;
      if (it && it.data) {
        var et = it.data.isLeaf === !1 || !!(it.data.children || []).length, Ve = Qe.value;
        switch (Fe.which) {
          case KeyCode$1.LEFT: {
            et && Ce.value.has(de.value) ? dt({}, Ve) : it.parent && At(it.parent.key), Fe.preventDefault();
            break;
          }
          case KeyCode$1.RIGHT: {
            et && !Ce.value.has(de.value) ? dt({}, Ve) : it.children && it.children.length && At(it.children[0].key), Fe.preventDefault();
            break;
          }
          case KeyCode$1.ENTER:
          case KeyCode$1.SPACE: {
            je && !Ve.disabled && Ve.checkable !== !1 && !Ve.disableCheckbox ? ct({}, Ve, !Ae.value.has(de.value)) : !je && Je && !Ve.disabled && Ve.selectable !== !1 && ot({}, Ve);
            break;
          }
        }
      }
      Be && Be(Fe);
    };
    return W({
      onNodeExpand: dt,
      scrollTo: we,
      onKeydown: pt,
      selectedKeys: computed(function() {
        return ee.value;
      }),
      checkedKeys: computed(function() {
        return te.value;
      }),
      halfCheckedKeys: computed(function() {
        return re.value;
      }),
      loadedKeys: computed(function() {
        return ne.value;
      }),
      loadingKeys: computed(function() {
        return ae.value;
      }),
      expandedKeys: computed(function() {
        return ie.value;
      })
    }), onUnmounted(function() {
      window.removeEventListener("dragend", ze), Z.value = !0;
    }), useProvideKeysState({
      expandedKeys: ie,
      selectedKeys: ee,
      loadedKeys: ne,
      loadingKeys: ae,
      checkedKeys: te,
      halfCheckedKeys: re,
      expandedKeysSet: Ce,
      selectedKeysSet: Ie,
      loadedKeysSet: be,
      loadingKeysSet: Se,
      checkedKeysSet: Ae,
      halfCheckedKeysSet: _e,
      flattenNodes: Te
    }), function() {
      var Ye, Fe = oe.draggingNodeKey, Be = oe.dropLevelOffset, je = oe.dropContainerKey, Je = oe.dropTargetKey, it = oe.dropPosition, et = oe.dragOverNodeKey, Ve = C.prefixCls, Ge = C.showLine, tt = C.focusable, ft = C.tabindex, mt = ft === void 0 ? 0 : ft, ht = C.selectable, St = C.showIcon, Ct = C.icon, bt = Ct === void 0 ? K.icon : Ct, xt = C.switcherIcon, It = C.draggable, Tt = C.checkable, _t = C.checkStrictly, wt = C.disabled, Mt = C.motion, Ot = C.loadData, kt = C.filterTreeNode, Ft = C.height, Rt = C.itemHeight, $t = C.virtual, Nt = C.dropIndicatorRender, Dt = C.onContextmenu, Bt = C.onScroll, Pt = C.direction, zt = U.class, Ht = U.style, Ut = pickAttrs(_objectSpread2$1(_objectSpread2$1({}, C), U), {
        aria: !0,
        data: !0
      }), Gt;
      return It && (_typeof$2(It) === "object" ? Gt = It : typeof It == "function" ? Gt = {
        nodeDraggable: It
      } : Gt = {}), createVNode$1(TreeContext, {
        value: {
          prefixCls: Ve,
          selectable: ht,
          showIcon: St,
          icon: bt,
          switcherIcon: xt,
          draggable: Gt,
          draggingNodeKey: Fe,
          checkable: Tt,
          customCheckable: K.checkable,
          checkStrictly: _t,
          disabled: wt,
          keyEntities: ue.value,
          dropLevelOffset: Be,
          dropContainerKey: je,
          dropTargetKey: Je,
          dropPosition: it,
          dragOverNodeKey: et,
          dragging: Fe !== null,
          indent: Q.value,
          direction: Pt,
          dropIndicatorRender: Nt,
          loadData: Ot,
          filterTreeNode: kt,
          onNodeClick: Ue,
          onNodeDoubleClick: st,
          onNodeExpand: dt,
          onNodeSelect: ot,
          onNodeCheck: ct,
          onNodeLoad: vt,
          onNodeMouseEnter: ut,
          onNodeMouseLeave: at,
          onNodeContextMenu: Ze,
          onNodeDragStart: He,
          onNodeDragEnter: We,
          onNodeDragOver: Re,
          onNodeDragLeave: Le,
          onNodeDragEnd: ke,
          onNodeDrop: De,
          slots: K
        }
      }, {
        default: function() {
          return [createVNode$1("div", {
            role: "tree",
            class: classNames(Ve, zt, (Ye = {}, _defineProperty$A(Ye, "".concat(Ve, "-show-line"), Ge), _defineProperty$A(Ye, "".concat(Ve, "-focused"), ce.value), _defineProperty$A(Ye, "".concat(Ve, "-active-focused"), de.value !== null), Ye))
          }, [createVNode$1(NodeList, _objectSpread2$1({
            ref: ve,
            prefixCls: Ve,
            style: Ht,
            disabled: wt,
            selectable: ht,
            checkable: !!Tt,
            motion: Mt,
            height: Ft,
            itemHeight: Rt,
            virtual: $t,
            focusable: tt,
            focused: ce.value,
            tabindex: mt,
            activeItem: nt.value,
            onFocus: Xe,
            onBlur: qe,
            onKeydown: pt,
            onActiveChange: At,
            onListChangeStart: gt,
            onListChangeEnd: yt,
            onContextmenu: Dt,
            onScroll: Bt
          }, Ut), null)])];
        }
      });
    };
  }
});
var FileOutlined$2 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M854.6 288.6L639.4 73.4c-6-6-14.1-9.4-22.6-9.4H192c-17.7 0-32 14.3-32 32v832c0 17.7 14.3 32 32 32h640c17.7 0 32-14.3 32-32V311.3c0-8.5-3.4-16.7-9.4-22.7zM790.2 326H602V137.8L790.2 326zm1.8 562H232V136h302v216a42 42 0 0042 42h216v494z" } }] }, name: "file", theme: "outlined" };
const FileOutlinedSvg = FileOutlined$2;
function _objectSpread$8(H) {
  for (var C = 1; C < arguments.length; C++) {
    var G = arguments[C] != null ? Object(arguments[C]) : {}, U = Object.keys(G);
    typeof Object.getOwnPropertySymbols == "function" && (U = U.concat(Object.getOwnPropertySymbols(G).filter(function(K) {
      return Object.getOwnPropertyDescriptor(G, K).enumerable;
    }))), U.forEach(function(K) {
      _defineProperty$8(H, K, G[K]);
    });
  }
  return H;
}
function _defineProperty$8(H, C, G) {
  return C in H ? Object.defineProperty(H, C, { value: G, enumerable: !0, configurable: !0, writable: !0 }) : H[C] = G, H;
}
var FileOutlined = function(C, G) {
  var U = _objectSpread$8({}, C, G.attrs);
  return createVNode$1(AntdIcon, _objectSpread$8({}, U, {
    icon: FileOutlinedSvg
  }), null);
};
FileOutlined.displayName = "FileOutlined";
FileOutlined.inheritAttrs = !1;
const FileOutlined$1 = FileOutlined;
var MinusSquareOutlined$2 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M328 544h368c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8H328c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8z" } }, { tag: "path", attrs: { d: "M880 112H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V144c0-17.7-14.3-32-32-32zm-40 728H184V184h656v656z" } }] }, name: "minus-square", theme: "outlined" };
const MinusSquareOutlinedSvg = MinusSquareOutlined$2;
function _objectSpread$7(H) {
  for (var C = 1; C < arguments.length; C++) {
    var G = arguments[C] != null ? Object(arguments[C]) : {}, U = Object.keys(G);
    typeof Object.getOwnPropertySymbols == "function" && (U = U.concat(Object.getOwnPropertySymbols(G).filter(function(K) {
      return Object.getOwnPropertyDescriptor(G, K).enumerable;
    }))), U.forEach(function(K) {
      _defineProperty$7(H, K, G[K]);
    });
  }
  return H;
}
function _defineProperty$7(H, C, G) {
  return C in H ? Object.defineProperty(H, C, { value: G, enumerable: !0, configurable: !0, writable: !0 }) : H[C] = G, H;
}
var MinusSquareOutlined = function(C, G) {
  var U = _objectSpread$7({}, C, G.attrs);
  return createVNode$1(AntdIcon, _objectSpread$7({}, U, {
    icon: MinusSquareOutlinedSvg
  }), null);
};
MinusSquareOutlined.displayName = "MinusSquareOutlined";
MinusSquareOutlined.inheritAttrs = !1;
const MinusSquareOutlined$1 = MinusSquareOutlined;
var PlusSquareOutlined$2 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M328 544h152v152c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V544h152c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8H544V328c0-4.4-3.6-8-8-8h-48c-4.4 0-8 3.6-8 8v152H328c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8z" } }, { tag: "path", attrs: { d: "M880 112H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V144c0-17.7-14.3-32-32-32zm-40 728H184V184h656v656z" } }] }, name: "plus-square", theme: "outlined" };
const PlusSquareOutlinedSvg = PlusSquareOutlined$2;
function _objectSpread$6(H) {
  for (var C = 1; C < arguments.length; C++) {
    var G = arguments[C] != null ? Object(arguments[C]) : {}, U = Object.keys(G);
    typeof Object.getOwnPropertySymbols == "function" && (U = U.concat(Object.getOwnPropertySymbols(G).filter(function(K) {
      return Object.getOwnPropertyDescriptor(G, K).enumerable;
    }))), U.forEach(function(K) {
      _defineProperty$6(H, K, G[K]);
    });
  }
  return H;
}
function _defineProperty$6(H, C, G) {
  return C in H ? Object.defineProperty(H, C, { value: G, enumerable: !0, configurable: !0, writable: !0 }) : H[C] = G, H;
}
var PlusSquareOutlined = function(C, G) {
  var U = _objectSpread$6({}, C, G.attrs);
  return createVNode$1(AntdIcon, _objectSpread$6({}, U, {
    icon: PlusSquareOutlinedSvg
  }), null);
};
PlusSquareOutlined.displayName = "PlusSquareOutlined";
PlusSquareOutlined.inheritAttrs = !1;
const PlusSquareOutlined$1 = PlusSquareOutlined;
var CaretDownFilled$2 = { icon: { tag: "svg", attrs: { viewBox: "0 0 1024 1024", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M840.4 300H183.6c-19.7 0-30.7 20.8-18.5 35l328.4 380.8c9.4 10.9 27.5 10.9 37 0L858.9 335c12.2-14.2 1.2-35-18.5-35z" } }] }, name: "caret-down", theme: "filled" };
const CaretDownFilledSvg = CaretDownFilled$2;
function _objectSpread$5(H) {
  for (var C = 1; C < arguments.length; C++) {
    var G = arguments[C] != null ? Object(arguments[C]) : {}, U = Object.keys(G);
    typeof Object.getOwnPropertySymbols == "function" && (U = U.concat(Object.getOwnPropertySymbols(G).filter(function(K) {
      return Object.getOwnPropertyDescriptor(G, K).enumerable;
    }))), U.forEach(function(K) {
      _defineProperty$5(H, K, G[K]);
    });
  }
  return H;
}
function _defineProperty$5(H, C, G) {
  return C in H ? Object.defineProperty(H, C, { value: G, enumerable: !0, configurable: !0, writable: !0 }) : H[C] = G, H;
}
var CaretDownFilled = function(C, G) {
  var U = _objectSpread$5({}, C, G.attrs);
  return createVNode$1(AntdIcon, _objectSpread$5({}, U, {
    icon: CaretDownFilledSvg
  }), null);
};
CaretDownFilled.displayName = "CaretDownFilled";
CaretDownFilled.inheritAttrs = !1;
const CaretDownFilled$1 = CaretDownFilled;
function renderSwitcherIcon(H, C, G, U) {
  var K = U.isLeaf, W = U.expanded, Z = U.loading, X = C;
  if (Z)
    return createVNode$1(LoadingOutlined$1, {
      class: "".concat(H, "-switcher-loading-icon")
    }, null);
  var Q;
  G && _typeof$2(G) === "object" && (Q = G.showLeafIcon);
  var ee = null, te = "".concat(H, "-switcher-icon");
  return K ? (G && (_typeof$2(G) === "object" && !Q ? ee = createVNode$1("span", {
    class: "".concat(H, "-switcher-leaf-line")
  }, null) : ee = createVNode$1(FileOutlined$1, {
    class: "".concat(H, "-switcher-line-icon")
  }, null)), ee) : (ee = createVNode$1(CaretDownFilled$1, {
    class: te
  }, null), G && (ee = W ? createVNode$1(MinusSquareOutlined$1, {
    class: "".concat(H, "-switcher-line-icon")
  }, null) : createVNode$1(PlusSquareOutlined$1, {
    class: "".concat(H, "-switcher-line-icon")
  }, null)), typeof C == "function" ? X = C(_objectSpread2$1(_objectSpread2$1({}, U), {}, {
    defaultIcon: ee,
    switcherCls: te
  })) : isValidElement(X) && (X = cloneVNode(X, {
    class: te
  })), X || ee);
}
var offset = 4;
function dropIndicatorRender(H) {
  var C, G = H.dropPosition, U = H.dropLevelOffset, K = H.prefixCls, W = H.indent, Z = H.direction, X = Z === void 0 ? "ltr" : Z, Q = X === "ltr" ? "left" : "right", ee = X === "ltr" ? "right" : "left", te = (C = {}, _defineProperty$A(C, Q, "".concat(-U * W + offset, "px")), _defineProperty$A(C, ee, 0), C);
  switch (G) {
    case -1:
      te.top = "".concat(-3, "px");
      break;
    case 1:
      te.bottom = "".concat(-3, "px");
      break;
    default:
      te.bottom = "".concat(-3, "px"), te[Q] = "".concat(W + offset, "px");
      break;
  }
  return createVNode$1("div", {
    style: te,
    class: "".concat(K, "-drop-indicator")
  }, null);
}
var treeProps = function() {
  var C = treeProps$1();
  return _objectSpread2$1(_objectSpread2$1({}, C), {}, {
    showLine: {
      type: [Boolean, Object],
      default: void 0
    },
    /** 是否支持多选 */
    multiple: {
      type: Boolean,
      default: void 0
    },
    /** 是否自动展开父节点 */
    autoExpandParent: {
      type: Boolean,
      default: void 0
    },
    /** checkable状态下节点选择完全受控（父子节点选中状态不再关联）*/
    checkStrictly: {
      type: Boolean,
      default: void 0
    },
    /** 是否支持选中 */
    checkable: {
      type: Boolean,
      default: void 0
    },
    /** 是否禁用树 */
    disabled: {
      type: Boolean,
      default: void 0
    },
    /** 默认展开所有树节点 */
    defaultExpandAll: {
      type: Boolean,
      default: void 0
    },
    /** 默认展开对应树节点 */
    defaultExpandParent: {
      type: Boolean,
      default: void 0
    },
    /** 默认展开指定的树节点 */
    defaultExpandedKeys: {
      type: Array
    },
    /** （受控）展开指定的树节点 */
    expandedKeys: {
      type: Array
    },
    /** （受控）选中复选框的树节点 */
    checkedKeys: {
      type: [Array, Object]
    },
    /** 默认选中复选框的树节点 */
    defaultCheckedKeys: {
      type: Array
    },
    /** （受控）设置选中的树节点 */
    selectedKeys: {
      type: Array
    },
    /** 默认选中的树节点 */
    defaultSelectedKeys: {
      type: Array
    },
    selectable: {
      type: Boolean,
      default: void 0
    },
    loadedKeys: {
      type: Array
    },
    draggable: {
      type: Boolean,
      default: void 0
    },
    showIcon: {
      type: Boolean,
      default: void 0
    },
    icon: {
      type: Function
    },
    switcherIcon: PropTypes$1.any,
    prefixCls: String,
    /**
     * @default{title,key,children}
     * deprecated, please use `fieldNames` instead
     * 替换treeNode中 title,key,children字段为treeData中对应的字段
     */
    replaceFields: {
      type: Object
    },
    blockNode: {
      type: Boolean,
      default: void 0
    },
    openAnimation: PropTypes$1.any,
    onDoubleclick: C.onDblclick,
    "onUpdate:selectedKeys": Function,
    "onUpdate:checkedKeys": Function,
    "onUpdate:expandedKeys": Function
  });
};
const Tree$3 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ATree",
  inheritAttrs: !1,
  props: initDefaultProps$1(treeProps(), {
    checkable: !1,
    selectable: !0,
    showIcon: !1,
    blockNode: !1
  }),
  slots: ["icon", "title", "switcherIcon", "titleRender"],
  // emits: [
  //   'update:selectedKeys',
  //   'update:checkedKeys',
  //   'update:expandedKeys',
  //   'expand',
  //   'select',
  //   'check',
  //   'doubleclick',
  //   'dblclick',
  // ],
  setup: function(C, G) {
    var U = G.attrs, K = G.expose, W = G.emit, Z = G.slots;
    warning$2(!(C.treeData === void 0 && Z.default), "`children` of Tree is deprecated. Please use `treeData` instead.");
    var X = useConfigInject("tree", C), Q = X.prefixCls, ee = X.direction, te = X.virtual, re = ref(), ne = function(le) {
      var ue;
      (ue = re.value) === null || ue === void 0 || ue.scrollTo(le);
    };
    K({
      treeRef: re,
      onNodeExpand: function() {
        for (var le, ue = arguments.length, ce = new Array(ue), de = 0; de < ue; de++)
          ce[de] = arguments[de];
        (le = re.value) === null || le === void 0 || le.onNodeExpand.apply(le, ce);
      },
      scrollTo: ne,
      selectedKeys: computed(function() {
        var oe;
        return (oe = re.value) === null || oe === void 0 ? void 0 : oe.selectedKeys;
      }),
      checkedKeys: computed(function() {
        var oe;
        return (oe = re.value) === null || oe === void 0 ? void 0 : oe.checkedKeys;
      }),
      halfCheckedKeys: computed(function() {
        var oe;
        return (oe = re.value) === null || oe === void 0 ? void 0 : oe.halfCheckedKeys;
      }),
      loadedKeys: computed(function() {
        var oe;
        return (oe = re.value) === null || oe === void 0 ? void 0 : oe.loadedKeys;
      }),
      loadingKeys: computed(function() {
        var oe;
        return (oe = re.value) === null || oe === void 0 ? void 0 : oe.loadingKeys;
      }),
      expandedKeys: computed(function() {
        var oe;
        return (oe = re.value) === null || oe === void 0 ? void 0 : oe.expandedKeys;
      })
    }), watchEffect(function() {
      devWarning(C.replaceFields === void 0, "Tree", "`replaceFields` is deprecated, please use fieldNames instead");
    });
    var ae = function(le, ue) {
      W("update:checkedKeys", le), W("check", le, ue);
    }, ie = function(le, ue) {
      W("update:expandedKeys", le), W("expand", le, ue);
    }, se = function(le, ue) {
      W("update:selectedKeys", le), W("select", le, ue);
    };
    return function() {
      var oe, le = C.showIcon, ue = C.showLine, ce = C.switcherIcon, de = ce === void 0 ? Z.switcherIcon : ce, ge = C.icon, fe = ge === void 0 ? Z.icon : ge, ve = C.blockNode, pe = C.checkable, he = C.selectable, me = C.fieldNames, ye = me === void 0 ? C.replaceFields : me, Ce = C.motion, Ie = Ce === void 0 ? C.openAnimation : Ce, be = C.itemHeight, Se = be === void 0 ? 28 : be, Ae = C.onDoubleclick, _e = C.onDblclick, xe = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, U), omit(C, ["onUpdate:checkedKeys", "onUpdate:expandedKeys", "onUpdate:selectedKeys", "onDoubleclick"])), {}, {
        showLine: Boolean(ue),
        dropIndicatorRender,
        fieldNames: ye,
        icon: fe,
        itemHeight: Se
      }), Te = Z.default ? filterEmpty(Z.default()) : void 0;
      return createVNode$1(Tree$4, _objectSpread2$1(_objectSpread2$1({}, xe), {}, {
        virtual: te.value,
        motion: Ie,
        ref: re,
        prefixCls: Q.value,
        class: classNames((oe = {}, _defineProperty$A(oe, "".concat(Q.value, "-icon-hide"), !le), _defineProperty$A(oe, "".concat(Q.value, "-block-node"), ve), _defineProperty$A(oe, "".concat(Q.value, "-unselectable"), !he), _defineProperty$A(oe, "".concat(Q.value, "-rtl"), ee.value === "rtl"), oe), U.class),
        direction: ee.value,
        checkable: pe,
        selectable: he,
        switcherIcon: function($e) {
          return renderSwitcherIcon(Q.value, de, ue, $e);
        },
        onCheck: ae,
        onExpand: ie,
        onSelect: se,
        onDblclick: _e || Ae,
        children: Te
      }), _objectSpread2$1(_objectSpread2$1({}, Z), {}, {
        checkable: function() {
          return createVNode$1("span", {
            class: "".concat(Q.value, "-checkbox-inner")
          }, null);
        }
      }));
    };
  }
});
var FolderOpenOutlined$2 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M928 444H820V330.4c0-17.7-14.3-32-32-32H473L355.7 186.2a8.15 8.15 0 00-5.5-2.2H96c-17.7 0-32 14.3-32 32v592c0 17.7 14.3 32 32 32h698c13 0 24.8-7.9 29.7-20l134-332c1.5-3.8 2.3-7.9 2.3-12 0-17.7-14.3-32-32-32zM136 256h188.5l119.6 114.4H748V444H238c-13 0-24.8 7.9-29.7 20L136 643.2V256zm635.3 512H159l103.3-256h612.4L771.3 768z" } }] }, name: "folder-open", theme: "outlined" };
const FolderOpenOutlinedSvg = FolderOpenOutlined$2;
function _objectSpread$4(H) {
  for (var C = 1; C < arguments.length; C++) {
    var G = arguments[C] != null ? Object(arguments[C]) : {}, U = Object.keys(G);
    typeof Object.getOwnPropertySymbols == "function" && (U = U.concat(Object.getOwnPropertySymbols(G).filter(function(K) {
      return Object.getOwnPropertyDescriptor(G, K).enumerable;
    }))), U.forEach(function(K) {
      _defineProperty$4(H, K, G[K]);
    });
  }
  return H;
}
function _defineProperty$4(H, C, G) {
  return C in H ? Object.defineProperty(H, C, { value: G, enumerable: !0, configurable: !0, writable: !0 }) : H[C] = G, H;
}
var FolderOpenOutlined = function(C, G) {
  var U = _objectSpread$4({}, C, G.attrs);
  return createVNode$1(AntdIcon, _objectSpread$4({}, U, {
    icon: FolderOpenOutlinedSvg
  }), null);
};
FolderOpenOutlined.displayName = "FolderOpenOutlined";
FolderOpenOutlined.inheritAttrs = !1;
const FolderOpenOutlined$1 = FolderOpenOutlined;
var FolderOutlined$2 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M880 298.4H521L403.7 186.2a8.15 8.15 0 00-5.5-2.2H144c-17.7 0-32 14.3-32 32v592c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V330.4c0-17.7-14.3-32-32-32zM840 768H184V256h188.5l119.6 114.4H840V768z" } }] }, name: "folder", theme: "outlined" };
const FolderOutlinedSvg = FolderOutlined$2;
function _objectSpread$3(H) {
  for (var C = 1; C < arguments.length; C++) {
    var G = arguments[C] != null ? Object(arguments[C]) : {}, U = Object.keys(G);
    typeof Object.getOwnPropertySymbols == "function" && (U = U.concat(Object.getOwnPropertySymbols(G).filter(function(K) {
      return Object.getOwnPropertyDescriptor(G, K).enumerable;
    }))), U.forEach(function(K) {
      _defineProperty$3(H, K, G[K]);
    });
  }
  return H;
}
function _defineProperty$3(H, C, G) {
  return C in H ? Object.defineProperty(H, C, { value: G, enumerable: !0, configurable: !0, writable: !0 }) : H[C] = G, H;
}
var FolderOutlined = function(C, G) {
  var U = _objectSpread$3({}, C, G.attrs);
  return createVNode$1(AntdIcon, _objectSpread$3({}, U, {
    icon: FolderOutlinedSvg
  }), null);
};
FolderOutlined.displayName = "FolderOutlined";
FolderOutlined.inheritAttrs = !1;
const FolderOutlined$1 = FolderOutlined;
var Record;
(function(H) {
  H[H.None = 0] = "None", H[H.Start = 1] = "Start", H[H.End = 2] = "End";
})(Record || (Record = {}));
function traverseNodesKey(H, C, G) {
  function U(K) {
    var W = K[C.key], Z = K[C.children];
    G(W, K) !== !1 && traverseNodesKey(Z || [], C, G);
  }
  H.forEach(U);
}
function calcRangeKeys(H) {
  var C = H.treeData, G = H.expandedKeys, U = H.startKey, K = H.endKey, W = H.fieldNames, Z = W === void 0 ? {
    title: "title",
    key: "key",
    children: "children"
  } : W, X = [], Q = Record.None;
  if (U && U === K)
    return [U];
  if (!U || !K)
    return [];
  function ee(te) {
    return te === U || te === K;
  }
  return traverseNodesKey(C, Z, function(te) {
    if (Q === Record.End)
      return !1;
    if (ee(te)) {
      if (X.push(te), Q === Record.None)
        Q = Record.Start;
      else if (Q === Record.Start)
        return Q = Record.End, !1;
    } else
      Q === Record.Start && X.push(te);
    return G.indexOf(te) !== -1;
  }), X;
}
function convertDirectoryKeysToNodes(H, C, G) {
  var U = _toConsumableArray(C), K = [];
  return traverseNodesKey(H, G, function(W, Z) {
    var X = U.indexOf(W);
    return X !== -1 && (K.push(Z), U.splice(X, 1)), !!U.length;
  }), K;
}
var _excluded = ["icon", "blockNode"], directoryTreeProps = function() {
  return _objectSpread2$1(_objectSpread2$1({}, treeProps()), {}, {
    expandAction: {
      type: [Boolean, String]
    }
  });
};
function getIcon(H) {
  var C = H.isLeaf, G = H.expanded;
  return C ? createVNode$1(FileOutlined$1, null, null) : G ? createVNode$1(FolderOpenOutlined$1, null, null) : createVNode$1(FolderOutlined$1, null, null);
}
const DirectoryTree = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ADirectoryTree",
  inheritAttrs: !1,
  props: initDefaultProps$1(directoryTreeProps(), {
    showIcon: !0,
    expandAction: "click"
  }),
  slots: ["icon", "title", "switcherIcon", "titleRender"],
  // emits: [
  //   'update:selectedKeys',
  //   'update:checkedKeys',
  //   'update:expandedKeys',
  //   'expand',
  //   'select',
  //   'check',
  //   'doubleclick',
  //   'dblclick',
  //   'click',
  // ],
  setup: function(C, G) {
    var U, K = G.attrs, W = G.slots, Z = G.emit, X = G.expose, Q = ref(C.treeData || convertTreeToData(filterEmpty((U = W.default) === null || U === void 0 ? void 0 : U.call(W))));
    watch(function() {
      return C.treeData;
    }, function() {
      Q.value = C.treeData;
    }), onUpdated(function() {
      nextTick(function() {
        if (C.treeData === void 0 && W.default) {
          var ye;
          Q.value = convertTreeToData(filterEmpty((ye = W.default) === null || ye === void 0 ? void 0 : ye.call(W)));
        }
      });
    });
    var ee = ref(), te = ref(), re = computed(function() {
      return fillFieldNames(C.fieldNames);
    }), ne = ref(), ae = function(Ce) {
      var Ie;
      (Ie = ne.value) === null || Ie === void 0 || Ie.scrollTo(Ce);
    };
    X({
      scrollTo: ae,
      selectedKeys: computed(function() {
        var ye;
        return (ye = ne.value) === null || ye === void 0 ? void 0 : ye.selectedKeys;
      }),
      checkedKeys: computed(function() {
        var ye;
        return (ye = ne.value) === null || ye === void 0 ? void 0 : ye.checkedKeys;
      }),
      halfCheckedKeys: computed(function() {
        var ye;
        return (ye = ne.value) === null || ye === void 0 ? void 0 : ye.halfCheckedKeys;
      }),
      loadedKeys: computed(function() {
        var ye;
        return (ye = ne.value) === null || ye === void 0 ? void 0 : ye.loadedKeys;
      }),
      loadingKeys: computed(function() {
        var ye;
        return (ye = ne.value) === null || ye === void 0 ? void 0 : ye.loadingKeys;
      }),
      expandedKeys: computed(function() {
        var ye;
        return (ye = ne.value) === null || ye === void 0 ? void 0 : ye.expandedKeys;
      })
    });
    var ie = function() {
      var Ce = convertDataToEntities(Q.value, {
        fieldNames: re.value
      }), Ie = Ce.keyEntities, be;
      return C.defaultExpandAll ? be = Object.keys(Ie) : C.defaultExpandParent ? be = conductExpandParent(C.expandedKeys || C.defaultExpandedKeys || [], Ie) : be = C.expandedKeys || C.defaultExpandedKeys, be;
    }, se = ref(C.selectedKeys || C.defaultSelectedKeys || []), oe = ref(ie());
    watch(function() {
      return C.selectedKeys;
    }, function() {
      C.selectedKeys !== void 0 && (se.value = C.selectedKeys);
    }, {
      immediate: !0
    }), watch(function() {
      return C.expandedKeys;
    }, function() {
      C.expandedKeys !== void 0 && (oe.value = C.expandedKeys);
    }, {
      immediate: !0
    });
    var le = function(Ce, Ie) {
      var be = Ie.isLeaf;
      be || Ce.shiftKey || Ce.metaKey || Ce.ctrlKey || ne.value.onNodeExpand(Ce, Ie);
    }, ue = debounce(le, 200, {
      leading: !0
    }), ce = function(Ce, Ie) {
      C.expandedKeys === void 0 && (oe.value = Ce), Z("update:expandedKeys", Ce), Z("expand", Ce, Ie);
    }, de = function(Ce, Ie) {
      var be = C.expandAction;
      be === "click" && ue(Ce, Ie), Z("click", Ce, Ie);
    }, ge = function(Ce, Ie) {
      var be = C.expandAction;
      (be === "dblclick" || be === "doubleclick") && ue(Ce, Ie), Z("doubleclick", Ce, Ie), Z("dblclick", Ce, Ie);
    }, fe = function(Ce, Ie) {
      var be = C.multiple, Se = Ie.node, Ae = Ie.nativeEvent, _e = Se[re.value.key], xe = _objectSpread2$1(_objectSpread2$1({}, Ie), {}, {
        selected: !0
        // Directory selected always true
      }), Te = (Ae == null ? void 0 : Ae.ctrlKey) || (Ae == null ? void 0 : Ae.metaKey), Pe = Ae == null ? void 0 : Ae.shiftKey, $e;
      be && Te ? ($e = Ce, ee.value = _e, te.value = $e, xe.selectedNodes = convertDirectoryKeysToNodes(Q.value, $e, re.value)) : be && Pe ? ($e = Array.from(new Set([].concat(_toConsumableArray(te.value || []), _toConsumableArray(calcRangeKeys({
        treeData: Q.value,
        expandedKeys: oe.value,
        startKey: _e,
        endKey: ee.value,
        fieldNames: re.value
      }))))), xe.selectedNodes = convertDirectoryKeysToNodes(Q.value, $e, re.value)) : ($e = [_e], ee.value = _e, te.value = $e, xe.selectedNodes = convertDirectoryKeysToNodes(Q.value, $e, re.value)), Z("update:selectedKeys", $e), Z("select", $e, xe), C.selectedKeys === void 0 && (se.value = $e);
    }, ve = function(Ce, Ie) {
      Z("update:checkedKeys", Ce), Z("check", Ce, Ie);
    }, pe = useConfigInject("tree", C), he = pe.prefixCls, me = pe.direction;
    return function() {
      var ye = classNames("".concat(he.value, "-directory"), _defineProperty$A({}, "".concat(he.value, "-directory-rtl"), me.value === "rtl"), K.class), Ce = C.icon, Ie = Ce === void 0 ? W.icon : Ce, be = C.blockNode, Se = be === void 0 ? !0 : be, Ae = _objectWithoutProperties$2(C, _excluded);
      return createVNode$1(Tree$3, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, K), {}, {
        icon: Ie || getIcon,
        ref: ne,
        blockNode: Se
      }, Ae), {}, {
        prefixCls: he.value,
        class: ye,
        expandedKeys: oe.value,
        selectedKeys: se.value,
        onSelect: fe,
        onClick: de,
        onDblclick: ge,
        onExpand: ce,
        onCheck: ve
      }), W);
    };
  }
});
var TreeNode$1 = defineComponent(_objectSpread2$1(_objectSpread2$1({}, VcTreeNode), {}, {
  name: "ATreeNode",
  props: treeNodeProps
}));
const Tree$2 = _extends(Tree$3, {
  DirectoryTree,
  TreeNode: TreeNode$1,
  install: function(C) {
    return C.component(Tree$3.name, Tree$3), C.component(TreeNode$1.name, TreeNode$1), C.component(DirectoryTree.name, DirectoryTree), C;
  }
});
var SubMenu = Menu.SubMenu, MenuItem = Menu.Item;
function hasSubMenu(H) {
  return H.some(function(C) {
    var G = C.children;
    return G && G.length > 0;
  });
}
function searchValueMatched(H, C) {
  return typeof C == "string" || typeof C == "number" ? C == null ? void 0 : C.toString().toLowerCase().includes(H.trim().toLowerCase()) : !1;
}
function renderFilterItems(H) {
  var C = H.filters, G = H.prefixCls, U = H.filteredKeys, K = H.filterMultiple, W = H.searchValue, Z = H.filterSearch;
  return C.map(function(X, Q) {
    var ee = String(X.value);
    if (X.children)
      return createVNode$1(SubMenu, {
        key: ee || Q,
        title: X.text,
        popupClassName: "".concat(G, "-dropdown-submenu")
      }, {
        default: function() {
          return [renderFilterItems({
            filters: X.children,
            prefixCls: G,
            filteredKeys: U,
            filterMultiple: K,
            searchValue: W,
            filterSearch: Z
          })];
        }
      });
    var te = K ? Checkbox : Radio, re = createVNode$1(MenuItem, {
      key: X.value !== void 0 ? ee : Q
    }, {
      default: function() {
        return [createVNode$1(te, {
          checked: U.includes(ee)
        }, null), createVNode$1("span", null, [X.text])];
      }
    });
    return W.trim() ? typeof Z == "function" ? Z(W, X) ? re : void 0 : searchValueMatched(W, X.text) ? re : void 0 : re;
  });
}
const FilterDropdown = defineComponent({
  name: "FilterDropdown",
  props: ["tablePrefixCls", "prefixCls", "dropdownPrefixCls", "column", "filterState", "filterMultiple", "filterMode", "filterSearch", "columnKey", "triggerFilter", "locale", "getPopupContainer"],
  setup: function(C, G) {
    var U = G.slots, K = useInjectSlots(), W = computed(function() {
      var $e;
      return ($e = C.filterMode) !== null && $e !== void 0 ? $e : "menu";
    }), Z = computed(function() {
      var $e;
      return ($e = C.filterSearch) !== null && $e !== void 0 ? $e : !1;
    }), X = computed(function() {
      return C.column.filterDropdownVisible;
    }), Q = ref(!1), ee = computed(function() {
      var $e;
      return !!(C.filterState && (($e = C.filterState.filteredKeys) !== null && $e !== void 0 && $e.length || C.filterState.forceFiltered));
    }), te = computed(function() {
      var $e;
      return flattenKeys(($e = C.column) === null || $e === void 0 ? void 0 : $e.filters);
    }), re = computed(function() {
      var $e = C.column, Me = $e.filterDropdown, Ee = $e.slots, we = Ee === void 0 ? {} : Ee, Oe = $e.customFilterDropdown;
      return Me || we.filterDropdown && K.value[we.filterDropdown] || Oe && K.value.customFilterDropdown;
    }), ne = computed(function() {
      var $e = C.column, Me = $e.filterIcon, Ee = $e.slots, we = Ee === void 0 ? {} : Ee;
      return Me || we.filterIcon && K.value[we.filterIcon] || K.value.customFilterIcon;
    }), ae = function(Me) {
      var Ee, we;
      Q.value = Me, (Ee = (we = C.column).onFilterDropdownVisibleChange) === null || Ee === void 0 || Ee.call(we, Me);
    }, ie = computed(function() {
      return typeof X.value == "boolean" ? X.value : Q.value;
    }), se = computed(function() {
      var $e;
      return ($e = C.filterState) === null || $e === void 0 ? void 0 : $e.filteredKeys;
    }), oe = shallowRef([]), le = function(Me) {
      var Ee = Me.selectedKeys;
      oe.value = Ee;
    }, ue = function(Me, Ee) {
      var we = Ee.node, Oe = Ee.checked;
      C.filterMultiple ? le({
        selectedKeys: Me
      }) : le({
        selectedKeys: Oe && we.key ? [we.key] : []
      });
    };
    watch(se, function() {
      Q.value && le({
        selectedKeys: se.value || []
      });
    }, {
      immediate: !0
    });
    var ce = shallowRef([]), de = ref(), ge = function(Me) {
      de.value = setTimeout(function() {
        ce.value = Me;
      });
    }, fe = function() {
      clearTimeout(de.value);
    };
    onBeforeUnmount(function() {
      clearTimeout(de.value);
    });
    var ve = ref(""), pe = function(Me) {
      var Ee = Me.target.value;
      ve.value = Ee;
    };
    watch(Q, function() {
      Q.value || (ve.value = "");
    });
    var he = function(Me) {
      var Ee = C.column, we = C.columnKey, Oe = C.filterState, Ne = Me && Me.length ? Me : null;
      if (Ne === null && (!Oe || !Oe.filteredKeys) || isEqual(Ne, Oe == null ? void 0 : Oe.filteredKeys))
        return null;
      C.triggerFilter({
        column: Ee,
        key: we,
        filteredKeys: Ne
      });
    }, me = function() {
      ae(!1), he(oe.value);
    }, ye = function() {
      var Me = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
        confirm: !1,
        closeDropdown: !1
      }, Ee = Me.confirm, we = Me.closeDropdown;
      Ee && he([]), we && ae(!1), ve.value = "", oe.value = [];
    }, Ce = function() {
      var Me = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
        closeDropdown: !0
      }, Ee = Me.closeDropdown;
      Ee && ae(!1), he(oe.value);
    }, Ie = function(Me) {
      Me && se.value !== void 0 && (oe.value = se.value || []), ae(Me), !Me && !re.value && me();
    }, be = useConfigInject("", C), Se = be.direction, Ae = function(Me) {
      if (Me.target.checked) {
        var Ee = te.value;
        oe.value = Ee;
      } else
        oe.value = [];
    }, _e = function $e(Me) {
      var Ee = Me.filters;
      return (Ee || []).map(function(we, Oe) {
        var Ne = String(we.value), ke = {
          title: we.text,
          key: we.value !== void 0 ? Ne : Oe
        };
        return we.children && (ke.children = $e({
          filters: we.children
        })), ke;
      });
    }, xe = computed(function() {
      return _e({
        filters: C.column.filters
      });
    }), Te = computed(function() {
      return classNames(_defineProperty$A({}, "".concat(C.dropdownPrefixCls, "-menu-without-submenu"), !hasSubMenu(C.column.filters || [])));
    }), Pe = function() {
      var Me = oe.value, Ee = C.column, we = C.locale, Oe = C.tablePrefixCls, Ne = C.filterMultiple, ke = C.dropdownPrefixCls, ze = C.getPopupContainer, He = C.prefixCls;
      return (Ee.filters || []).length === 0 ? createVNode$1(Empty$1, {
        image: Empty$1.PRESENTED_IMAGE_SIMPLE,
        description: we.filterEmptyText,
        imageStyle: {
          height: 24
        },
        style: {
          margin: 0,
          padding: "16px 0"
        }
      }, null) : W.value === "tree" ? createVNode$1(Fragment, null, [createVNode$1(FilterSearch, {
        filterSearch: Z.value,
        value: ve.value,
        onChange: pe,
        tablePrefixCls: Oe,
        locale: we
      }, null), createVNode$1("div", {
        class: "".concat(Oe, "-filter-dropdown-tree")
      }, [Ne ? createVNode$1(Checkbox, {
        class: "".concat(Oe, "-filter-dropdown-checkall"),
        onChange: Ae,
        checked: Me.length === te.value.length,
        indeterminate: Me.length > 0 && Me.length < te.value.length
      }, {
        default: function() {
          return [we.filterCheckall];
        }
      }) : null, createVNode$1(Tree$2, {
        checkable: !0,
        selectable: !1,
        blockNode: !0,
        multiple: Ne,
        checkStrictly: !Ne,
        class: "".concat(ke, "-menu"),
        onCheck: ue,
        checkedKeys: Me,
        selectedKeys: Me,
        showIcon: !1,
        treeData: xe.value,
        autoExpandParent: !0,
        defaultExpandAll: !0,
        filterTreeNode: ve.value.trim() ? function(We) {
          return searchValueMatched(ve.value, We.title);
        } : void 0
      }, null)])]) : createVNode$1(Fragment, null, [createVNode$1(FilterSearch, {
        filterSearch: Z.value,
        value: ve.value,
        onChange: pe,
        tablePrefixCls: Oe,
        locale: we
      }, null), createVNode$1(Menu, {
        multiple: Ne,
        prefixCls: "".concat(ke, "-menu"),
        class: Te.value,
        onClick: fe,
        onSelect: le,
        onDeselect: le,
        selectedKeys: Me,
        getPopupContainer: ze,
        openKeys: ce.value,
        onOpenChange: ge
      }, {
        default: function() {
          return renderFilterItems({
            filters: Ee.filters || [],
            filterSearch: Z.value,
            prefixCls: He,
            filteredKeys: oe.value,
            filterMultiple: Ne,
            searchValue: ve.value
          });
        }
      })]);
    };
    return function() {
      var $e, Me = C.tablePrefixCls, Ee = C.prefixCls, we = C.column, Oe = C.dropdownPrefixCls, Ne = C.locale, ke = C.getPopupContainer, ze;
      if (typeof re.value == "function")
        ze = re.value({
          prefixCls: "".concat(Oe, "-custom"),
          setSelectedKeys: function(De) {
            return le({
              selectedKeys: De
            });
          },
          selectedKeys: oe.value,
          confirm: Ce,
          clearFilters: ye,
          filters: we.filters,
          visible: ie.value,
          column: we.__originColumn__
        });
      else if (re.value)
        ze = re.value;
      else {
        var He = oe.value;
        ze = createVNode$1(Fragment, null, [Pe(), createVNode$1("div", {
          class: "".concat(Ee, "-dropdown-btns")
        }, [createVNode$1(Button$1, {
          type: "link",
          size: "small",
          disabled: He.length === 0,
          onClick: function() {
            return ye();
          }
        }, {
          default: function() {
            return [Ne.filterReset];
          }
        }), createVNode$1(Button$1, {
          type: "primary",
          size: "small",
          onClick: me
        }, {
          default: function() {
            return [Ne.filterConfirm];
          }
        })])]);
      }
      var We = createVNode$1(FilterDropdownMenuWrapper$1, {
        class: "".concat(Ee, "-dropdown")
      }, {
        default: function() {
          return [ze];
        }
      }), Re;
      return typeof ne.value == "function" ? Re = ne.value({
        filtered: ee.value,
        column: we.__originColumn__
      }) : ne.value ? Re = ne.value : Re = createVNode$1(FilterFilled$1, null, null), createVNode$1("div", {
        class: "".concat(Ee, "-column")
      }, [createVNode$1("span", {
        class: "".concat(Me, "-column-title")
      }, [($e = U.default) === null || $e === void 0 ? void 0 : $e.call(U)]), createVNode$1(Dropdown$1, {
        overlay: We,
        trigger: ["click"],
        visible: ie.value,
        onVisibleChange: Ie,
        getPopupContainer: ke,
        placement: Se.value === "rtl" ? "bottomLeft" : "bottomRight"
      }, {
        default: function() {
          return [createVNode$1("span", {
            role: "button",
            tabindex: -1,
            class: classNames("".concat(Ee, "-trigger"), {
              active: ee.value
            }),
            onClick: function(Ue) {
              Ue.stopPropagation();
            }
          }, [Re])];
        }
      })]);
    };
  }
});
function collectFilterStates(H, C, G) {
  var U = [];
  return (H || []).forEach(function(K, W) {
    var Z, X = getColumnPos(W, G), Q = K.filterDropdown || (K == null || (Z = K.slots) === null || Z === void 0 ? void 0 : Z.filterDropdown) || K.customFilterDropdown;
    if (K.filters || Q || "onFilter" in K)
      if ("filteredValue" in K) {
        var ee = K.filteredValue;
        if (!Q) {
          var te, re;
          ee = (te = (re = ee) === null || re === void 0 ? void 0 : re.map(String)) !== null && te !== void 0 ? te : ee;
        }
        U.push({
          column: K,
          key: getColumnKey(K, X),
          filteredKeys: ee,
          forceFiltered: K.filtered
        });
      } else
        U.push({
          column: K,
          key: getColumnKey(K, X),
          filteredKeys: C && K.defaultFilteredValue ? K.defaultFilteredValue : void 0,
          forceFiltered: K.filtered
        });
    "children" in K && (U = [].concat(_toConsumableArray(U), _toConsumableArray(collectFilterStates(K.children, C, X))));
  }), U;
}
function injectFilter(H, C, G, U, K, W, Z, X) {
  return G.map(function(Q, ee) {
    var te, re = getColumnPos(ee, X), ne = Q.filterMultiple, ae = ne === void 0 ? !0 : ne, ie = Q.filterMode, se = Q.filterSearch, oe = Q, le = Q.filterDropdown || (Q == null || (te = Q.slots) === null || te === void 0 ? void 0 : te.filterDropdown) || Q.customFilterDropdown;
    if (oe.filters || le) {
      var ue = getColumnKey(oe, re), ce = U.find(function(de) {
        var ge = de.key;
        return ue === ge;
      });
      oe = _objectSpread2$1(_objectSpread2$1({}, oe), {}, {
        title: function(ge) {
          return createVNode$1(FilterDropdown, {
            tablePrefixCls: H,
            prefixCls: "".concat(H, "-filter"),
            dropdownPrefixCls: C,
            column: oe,
            columnKey: ue,
            filterState: ce,
            filterMultiple: ae,
            filterMode: ie,
            filterSearch: se,
            triggerFilter: K,
            locale: Z,
            getPopupContainer: W
          }, {
            default: function() {
              return [renderColumnTitle(Q.title, ge)];
            }
          });
        }
      });
    }
    return "children" in oe && (oe = _objectSpread2$1(_objectSpread2$1({}, oe), {}, {
      children: injectFilter(H, C, oe.children, U, K, W, Z, re)
    })), oe;
  });
}
function flattenKeys(H) {
  var C = [];
  return (H || []).forEach(function(G) {
    var U = G.value, K = G.children;
    C.push(U), K && (C = [].concat(_toConsumableArray(C), _toConsumableArray(flattenKeys(K))));
  }), C;
}
function generateFilterInfo(H) {
  var C = {};
  return H.forEach(function(G) {
    var U, K = G.key, W = G.filteredKeys, Z = G.column, X = Z.filterDropdown || (Z == null || (U = Z.slots) === null || U === void 0 ? void 0 : U.filterDropdown) || Z.customFilterDropdown, Q = Z.filters;
    if (X)
      C[K] = W || null;
    else if (Array.isArray(W)) {
      var ee = flattenKeys(Q);
      C[K] = ee.filter(function(te) {
        return W.includes(String(te));
      });
    } else
      C[K] = null;
  }), C;
}
function getFilterData(H, C) {
  return C.reduce(function(G, U) {
    var K = U.column, W = K.onFilter, Z = K.filters, X = U.filteredKeys;
    return W && X && X.length ? G.filter(function(Q) {
      return X.some(function(ee) {
        var te = flattenKeys(Z), re = te.findIndex(function(ae) {
          return String(ae) === String(ee);
        }), ne = re !== -1 ? te[re] : ee;
        return W(ne, Q);
      });
    }) : G;
  }, H);
}
function useFilter(H) {
  var C = H.prefixCls, G = H.dropdownPrefixCls, U = H.mergedColumns, K = H.locale, W = H.onFilterChange, Z = H.getPopupContainer, X = useState(collectFilterStates(U.value, !0)), Q = _slicedToArray$2(X, 2), ee = Q[0], te = Q[1], re = computed(function() {
    var se = collectFilterStates(U.value, !1), oe = se.every(function(ue) {
      var ce = ue.filteredKeys;
      return ce === void 0;
    });
    if (oe)
      return ee.value;
    var le = se.every(function(ue) {
      var ce = ue.filteredKeys;
      return ce !== void 0;
    });
    return devWarning(oe || le, "Table", "`FilteredKeys` should all be controlled or not controlled."), se;
  }), ne = computed(function() {
    return generateFilterInfo(re.value);
  }), ae = function(oe) {
    var le = re.value.filter(function(ue) {
      var ce = ue.key;
      return ce !== oe.key;
    });
    le.push(oe), te(le), W(generateFilterInfo(le), le);
  }, ie = function(oe) {
    return injectFilter(C.value, G.value, oe, re.value, ae, Z.value, K.value);
  };
  return [ie, re, ne];
}
function fillTitle(H, C) {
  return H.map(function(G) {
    var U = _objectSpread2$1({}, G);
    return U.title = renderColumnTitle(U.title, C), "children" in U && (U.children = fillTitle(U.children, C)), U;
  });
}
function useTitleColumns(H) {
  var C = function(U) {
    return fillTitle(U, H.value);
  };
  return [C];
}
function renderExpandIcon(H) {
  return function(G) {
    var U, K = G.prefixCls, W = G.onExpand, Z = G.record, X = G.expanded, Q = G.expandable, ee = "".concat(K, "-row-expand-icon");
    return createVNode$1("button", {
      type: "button",
      onClick: function(re) {
        W(Z, re), re.stopPropagation();
      },
      class: classNames(ee, (U = {}, _defineProperty$A(U, "".concat(ee, "-spaced"), !Q), _defineProperty$A(U, "".concat(ee, "-expanded"), Q && X), _defineProperty$A(U, "".concat(ee, "-collapsed"), Q && !X), U)),
      "aria-label": X ? H.collapse : H.expand
    }, null);
  };
}
function fillSlots(H, C) {
  var G = C.value;
  return H.map(function(U) {
    var K;
    if (U === SELECTION_COLUMN || U === EXPAND_COLUMN)
      return U;
    var W = _objectSpread2$1({}, U), Z = W.slots, X = Z === void 0 ? {} : Z;
    return W.__originColumn__ = U, devWarning(!("slots" in W), "Table", "`column.slots` is deprecated. Please use `v-slot:headerCell` `v-slot:bodyCell` instead."), Object.keys(X).forEach(function(Q) {
      var ee = X[Q];
      W[Q] === void 0 && G[ee] && (W[Q] = G[ee]);
    }), C.value.headerCell && !((K = U.slots) !== null && K !== void 0 && K.title) && (W.title = renderSlot(C.value, "headerCell", {
      title: U.title,
      column: U
    }, function() {
      return [U.title];
    })), "children" in W && (W.children = fillSlots(W.children, C)), W;
  });
}
function useColumns(H) {
  var C = function(U) {
    return fillSlots(U, H);
  };
  return [C];
}
var EMPTY_LIST = [], tableProps = function() {
  return {
    prefixCls: {
      type: String,
      default: void 0
    },
    columns: {
      type: Array,
      default: void 0
    },
    rowKey: {
      type: [String, Function],
      default: void 0
    },
    tableLayout: {
      type: String,
      default: void 0
    },
    rowClassName: {
      type: [String, Function],
      default: void 0
    },
    title: {
      type: Function,
      default: void 0
    },
    footer: {
      type: Function,
      default: void 0
    },
    id: {
      type: String,
      default: void 0
    },
    showHeader: {
      type: Boolean,
      default: void 0
    },
    components: {
      type: Object,
      default: void 0
    },
    customRow: {
      type: Function,
      default: void 0
    },
    customHeaderRow: {
      type: Function,
      default: void 0
    },
    direction: {
      type: String,
      default: void 0
    },
    expandFixed: {
      type: [Boolean, String],
      default: void 0
    },
    expandColumnWidth: {
      type: Number,
      default: void 0
    },
    expandedRowKeys: {
      type: Array,
      default: void 0
    },
    defaultExpandedRowKeys: {
      type: Array,
      default: void 0
    },
    expandedRowRender: {
      type: Function,
      default: void 0
    },
    expandRowByClick: {
      type: Boolean,
      default: void 0
    },
    expandIcon: {
      type: Function,
      default: void 0
    },
    onExpand: {
      type: Function,
      default: void 0
    },
    onExpandedRowsChange: {
      type: Function,
      default: void 0
    },
    "onUpdate:expandedRowKeys": {
      type: Function,
      default: void 0
    },
    defaultExpandAllRows: {
      type: Boolean,
      default: void 0
    },
    indentSize: {
      type: Number,
      default: void 0
    },
    /** @deprecated Please use `EXPAND_COLUMN` in `columns` directly */
    expandIconColumnIndex: {
      type: Number,
      default: void 0
    },
    showExpandColumn: {
      type: Boolean,
      default: void 0
    },
    expandedRowClassName: {
      type: Function,
      default: void 0
    },
    childrenColumnName: {
      type: String,
      default: void 0
    },
    rowExpandable: {
      type: Function,
      default: void 0
    },
    sticky: {
      type: [Boolean, Object],
      default: void 0
    },
    dropdownPrefixCls: String,
    dataSource: {
      type: Array,
      default: void 0
    },
    pagination: {
      type: [Boolean, Object],
      default: void 0
    },
    loading: {
      type: [Boolean, Object],
      default: void 0
    },
    size: {
      type: String,
      default: void 0
    },
    bordered: Boolean,
    locale: {
      type: Object,
      default: void 0
    },
    onChange: {
      type: Function,
      default: void 0
    },
    onResizeColumn: {
      type: Function,
      default: void 0
    },
    rowSelection: {
      type: Object,
      default: void 0
    },
    getPopupContainer: {
      type: Function,
      default: void 0
    },
    scroll: {
      type: Object,
      default: void 0
    },
    sortDirections: {
      type: Array,
      default: void 0
    },
    showSorterTooltip: {
      type: [Boolean, Object],
      default: !0
    },
    contextSlots: {
      type: Object
    },
    transformCellText: {
      type: Function
    }
  };
}, InteralTable = defineComponent({
  name: "InteralTable",
  inheritAttrs: !1,
  props: initDefaultProps$1(tableProps(), {
    rowKey: "key"
  }),
  // emits: ['expandedRowsChange', 'change', 'expand'],
  slots: ["emptyText", "expandIcon", "title", "footer", "summary", "expandedRowRender", "bodyCell", "headerCell", "customFilterIcon", "customFilterDropdown"],
  setup: function(C, G) {
    var U = G.attrs, K = G.slots, W = G.expose, Z = G.emit;
    devWarning(!(typeof C.rowKey == "function" && C.rowKey.length > 1), "Table", "`index` parameter of `rowKey` function is deprecated. There is no guarantee that it will work as expected."), useProvideSlots(computed(function() {
      return C.contextSlots;
    })), useProvideTableContext({
      onResizeColumn: function(Fe, Be) {
        Z("resizeColumn", Fe, Be);
      }
    });
    var X = useBreakpoint(), Q = computed(function() {
      var Ye = new Set(Object.keys(X.value).filter(function(Fe) {
        return X.value[Fe];
      }));
      return C.columns.filter(function(Fe) {
        return !Fe.responsive || Fe.responsive.some(function(Be) {
          return Ye.has(Be);
        });
      });
    }), ee = useConfigInject("table", C), te = ee.size, re = ee.renderEmpty, ne = ee.direction, ae = ee.prefixCls, ie = ee.configProvider, se = computed(function() {
      return C.transformCellText || ie.transformCellText;
    }), oe = useLocaleReceiver("Table", defaultLocale.Table, toRef(C, "locale")), le = _slicedToArray$2(oe, 1), ue = le[0], ce = computed(function() {
      return C.dataSource || EMPTY_LIST;
    }), de = computed(function() {
      return ie.getPrefixCls("dropdown", C.dropdownPrefixCls);
    }), ge = computed(function() {
      return C.childrenColumnName || "children";
    }), fe = computed(function() {
      return ce.value.some(function(Ye) {
        return Ye == null ? void 0 : Ye[ge.value];
      }) ? "nest" : C.expandedRowRender ? "row" : null;
    }), ve = reactive({
      body: null
    }), pe = function(Fe) {
      _extends(ve, Fe);
    }, he = computed(function() {
      return typeof C.rowKey == "function" ? C.rowKey : function(Ye) {
        return Ye == null ? void 0 : Ye[C.rowKey];
      };
    }), me = useLazyKVMap(ce, ge, he), ye = _slicedToArray$2(me, 1), Ce = ye[0], Ie = {}, be = function(Fe, Be) {
      var je = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, Je = C.pagination, it = C.scroll, et = C.onChange, Ve = _objectSpread2$1(_objectSpread2$1({}, Ie), Fe);
      je && (Ie.resetPagination(), Ve.pagination.current && (Ve.pagination.current = 1), Je && Je.onChange && Je.onChange(1, Ve.pagination.pageSize)), it && it.scrollToFirstRowOnChange !== !1 && ve.body && scrollTo(0, {
        getContainer: function() {
          return ve.body;
        }
      }), et == null || et(Ve.pagination, Ve.filters, Ve.sorter, {
        currentDataSource: getFilterData(getSortData(ce.value, Ve.sorterStates, ge.value), Ve.filterStates),
        action: Be
      });
    }, Se = function(Fe, Be) {
      be({
        sorter: Fe,
        sorterStates: Be
      }, "sort", !1);
    }, Ae = useFilterSorter({
      prefixCls: ae,
      mergedColumns: Q,
      onSorterChange: Se,
      sortDirections: computed(function() {
        return C.sortDirections || ["ascend", "descend"];
      }),
      tableLocale: ue,
      showSorterTooltip: toRef(C, "showSorterTooltip")
    }), _e = _slicedToArray$2(Ae, 4), xe = _e[0], Te = _e[1], Pe = _e[2], $e = _e[3], Me = computed(function() {
      return getSortData(ce.value, Te.value, ge.value);
    }), Ee = function(Fe, Be) {
      be({
        filters: Fe,
        filterStates: Be
      }, "filter", !0);
    }, we = useFilter({
      prefixCls: ae,
      locale: ue,
      dropdownPrefixCls: de,
      mergedColumns: Q,
      onFilterChange: Ee,
      getPopupContainer: toRef(C, "getPopupContainer")
    }), Oe = _slicedToArray$2(we, 3), Ne = Oe[0], ke = Oe[1], ze = Oe[2], He = computed(function() {
      return getFilterData(Me.value, ke.value);
    }), We = useColumns(toRef(C, "contextSlots")), Re = _slicedToArray$2(We, 1), Le = Re[0], De = computed(function() {
      return _objectSpread2$1({}, Pe.value);
    }), Ue = useTitleColumns(De), st = _slicedToArray$2(Ue, 1), ot = st[0], ct = function(Fe, Be) {
      be({
        pagination: _objectSpread2$1(_objectSpread2$1({}, Ie.pagination), {}, {
          current: Fe,
          pageSize: Be
        })
      }, "paginate");
    }, vt = usePagination(computed(function() {
      return He.value.length;
    }), toRef(C, "pagination"), ct), ut = _slicedToArray$2(vt, 2), at = ut[0], Ze = ut[1];
    watchEffect(function() {
      Ie.sorter = $e.value, Ie.sorterStates = Te.value, Ie.filters = ze.value, Ie.filterStates = ke.value, Ie.pagination = C.pagination === !1 ? {} : getPaginationParam(C.pagination, at.value), Ie.resetPagination = Ze;
    });
    var Xe = computed(function() {
      if (C.pagination === !1 || !at.value.pageSize)
        return He.value;
      var Ye = at.value, Fe = Ye.current, Be = Fe === void 0 ? 1 : Fe, je = Ye.total, Je = Ye.pageSize, it = Je === void 0 ? DEFAULT_PAGE_SIZE : Je;
      return devWarning(Be > 0, "Table", "`current` should be positive number."), He.value.length < je ? He.value.length > it ? He.value.slice((Be - 1) * it, Be * it) : He.value : He.value.slice((Be - 1) * it, Be * it);
    });
    watchEffect(function() {
      nextTick(function() {
        var Ye = at.value, Fe = Ye.total, Be = Ye.pageSize, je = Be === void 0 ? DEFAULT_PAGE_SIZE : Be;
        He.value.length < Fe && He.value.length > je && devWarning(!1, "Table", "`dataSource` length is less than `pagination.total` but large than `pagination.pageSize`. Please make sure your config correct data with async mode.");
      });
    }, {
      flush: "post"
    });
    var qe = computed(function() {
      return C.showExpandColumn === !1 ? -1 : fe.value === "nest" && C.expandIconColumnIndex === void 0 ? C.rowSelection ? 1 : 0 : C.expandIconColumnIndex > 0 && C.rowSelection ? C.expandIconColumnIndex - 1 : C.expandIconColumnIndex;
    }), dt = ref();
    watch(function() {
      return C.rowSelection;
    }, function() {
      dt.value = C.rowSelection ? _objectSpread2$1({}, C.rowSelection) : C.rowSelection;
    }, {
      deep: !0,
      immediate: !0
    });
    var gt = useSelection(dt, {
      prefixCls: ae,
      data: He,
      pageData: Xe,
      getRowKey: he,
      getRecordByKey: Ce,
      expandType: fe,
      childrenColumnName: ge,
      locale: ue,
      getPopupContainer: computed(function() {
        return C.getPopupContainer;
      })
    }), yt = _slicedToArray$2(gt, 2), At = yt[0], nt = yt[1], Ke = function(Fe, Be, je) {
      var Je, it = C.rowClassName;
      return typeof it == "function" ? Je = classNames(it(Fe, Be, je)) : Je = classNames(it), classNames(_defineProperty$A({}, "".concat(ae.value, "-row-selected"), nt.value.has(he.value(Fe, Be))), Je);
    };
    W({
      selectedKeySet: nt
    });
    var Qe = computed(function() {
      return typeof C.indentSize == "number" ? C.indentSize : 15;
    }), pt = function(Fe) {
      var Be = ot(At(Ne(xe(Le(Fe)))));
      return Be;
    };
    return function() {
      var Ye, Fe, Be = C.expandIcon, je = Be === void 0 ? K.expandIcon || renderExpandIcon(ue.value) : Be, Je = C.pagination, it = C.loading, et = C.bordered, Ve, Ge;
      if (Je !== !1 && (Ye = at.value) !== null && Ye !== void 0 && Ye.total) {
        var tt;
        at.value.size ? tt = at.value.size : tt = te.value === "small" || te.value === "middle" ? "small" : void 0;
        var ft = function(wt) {
          return createVNode$1(Pagination, _objectSpread2$1(_objectSpread2$1({}, at.value), {}, {
            class: ["".concat(ae.value, "-pagination ").concat(ae.value, "-pagination-").concat(wt), at.value.class],
            size: tt
          }), null);
        }, mt = ne.value === "rtl" ? "left" : "right", ht = at.value.position;
        if (ht !== null && Array.isArray(ht)) {
          var St = ht.find(function(_t) {
            return _t.indexOf("top") !== -1;
          }), Ct = ht.find(function(_t) {
            return _t.indexOf("bottom") !== -1;
          }), bt = ht.every(function(_t) {
            return "".concat(_t) === "none";
          });
          !St && !Ct && !bt && (Ge = ft(mt)), St && (Ve = ft(St.toLowerCase().replace("top", ""))), Ct && (Ge = ft(Ct.toLowerCase().replace("bottom", "")));
        } else
          Ge = ft(mt);
      }
      var xt;
      typeof it == "boolean" ? xt = {
        spinning: it
      } : _typeof$2(it) === "object" && (xt = _objectSpread2$1({
        spinning: !0
      }, it));
      var It = classNames("".concat(ae.value, "-wrapper"), _defineProperty$A({}, "".concat(ae.value, "-wrapper-rtl"), ne.value === "rtl"), U.class), Tt = omit(C, ["columns"]);
      return createVNode$1("div", {
        class: It,
        style: U.style
      }, [createVNode$1(Spin, _objectSpread2$1({
        spinning: !1
      }, xt), {
        default: function() {
          return [Ve, createVNode$1(Table$3, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, U), Tt), {}, {
            expandedRowKeys: C.expandedRowKeys,
            defaultExpandedRowKeys: C.defaultExpandedRowKeys,
            expandIconColumnIndex: qe.value,
            indentSize: Qe.value,
            expandIcon: je,
            columns: Q.value,
            direction: ne.value,
            prefixCls: ae.value,
            class: classNames((Fe = {}, _defineProperty$A(Fe, "".concat(ae.value, "-middle"), te.value === "middle"), _defineProperty$A(Fe, "".concat(ae.value, "-small"), te.value === "small"), _defineProperty$A(Fe, "".concat(ae.value, "-bordered"), et), _defineProperty$A(Fe, "".concat(ae.value, "-empty"), ce.value.length === 0), Fe)),
            data: Xe.value,
            rowKey: he.value,
            rowClassName: Ke,
            internalHooks: INTERNAL_HOOKS,
            internalRefs: ve,
            onUpdateInternalRefs: pe,
            transformColumns: pt,
            transformCellText: se.value
          }), _objectSpread2$1(_objectSpread2$1({}, K), {}, {
            emptyText: function() {
              var Mt, Ot;
              return ((Mt = K.emptyText) === null || Mt === void 0 ? void 0 : Mt.call(K)) || ((Ot = C.locale) === null || Ot === void 0 ? void 0 : Ot.emptyText) || re.value("Table");
            }
          })), Ge];
        }
      })]);
    };
  }
}), Table$1 = defineComponent({
  name: "ATable",
  inheritAttrs: !1,
  setup: function(C, G) {
    var U = G.attrs, K = G.slots, W = G.expose, Z = ref();
    return W({
      table: Z
    }), function() {
      var X, Q = U, ee = Q.columns || convertChildrenToColumns((X = K.default) === null || X === void 0 ? void 0 : X.call(K));
      return createVNode$1(InteralTable, _objectSpread2$1(_objectSpread2$1({
        ref: Z
      }, U), {}, {
        columns: ee || [],
        expandedRowRender: K.expandedRowRender,
        contextSlots: _objectSpread2$1({}, K)
      }), K);
    };
  }
});
const Table$2 = Table$1, Column = defineComponent({
  name: "ATableColumn",
  slots: ["title", "filterIcon"],
  render: function() {
    return null;
  }
}), ColumnGroup = defineComponent({
  name: "ATableColumnGroup",
  slots: ["title"],
  __ANT_TABLE_COLUMN_GROUP: !0,
  render: function() {
    return null;
  }
});
var TableSummaryRow = defineComponent(_objectSpread2$1(_objectSpread2$1({}, SummaryRow), {}, {
  name: "ATableSummaryRow"
})), TableSummaryCell = defineComponent(_objectSpread2$1(_objectSpread2$1({}, SummaryCell), {}, {
  name: "ATableSummaryCell"
})), TableSummary = _extends(FooterComponents, {
  Cell: TableSummaryCell,
  Row: TableSummaryRow,
  name: "ATableSummary"
});
const Table = _extends(Table$2, {
  SELECTION_ALL,
  SELECTION_INVERT,
  SELECTION_NONE,
  SELECTION_COLUMN,
  EXPAND_COLUMN,
  Column,
  ColumnGroup,
  Summary: TableSummary,
  install: function(C) {
    return C.component(TableSummary.name, TableSummary), C.component(TableSummaryCell.name, TableSummaryCell), C.component(TableSummaryRow.name, TableSummaryRow), C.component(Table$2.name, Table$2), C.component(Column.name, Column), C.component(ColumnGroup.name, ColumnGroup), C;
  }
});
var BarChartOutlined$2 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M888 792H200V168c0-4.4-3.6-8-8-8h-56c-4.4 0-8 3.6-8 8v688c0 4.4 3.6 8 8 8h752c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm-600-80h56c4.4 0 8-3.6 8-8V560c0-4.4-3.6-8-8-8h-56c-4.4 0-8 3.6-8 8v144c0 4.4 3.6 8 8 8zm152 0h56c4.4 0 8-3.6 8-8V384c0-4.4-3.6-8-8-8h-56c-4.4 0-8 3.6-8 8v320c0 4.4 3.6 8 8 8zm152 0h56c4.4 0 8-3.6 8-8V462c0-4.4-3.6-8-8-8h-56c-4.4 0-8 3.6-8 8v242c0 4.4 3.6 8 8 8zm152 0h56c4.4 0 8-3.6 8-8V304c0-4.4-3.6-8-8-8h-56c-4.4 0-8 3.6-8 8v400c0 4.4 3.6 8 8 8z" } }] }, name: "bar-chart", theme: "outlined" };
const BarChartOutlinedSvg = BarChartOutlined$2;
function _objectSpread$2(H) {
  for (var C = 1; C < arguments.length; C++) {
    var G = arguments[C] != null ? Object(arguments[C]) : {}, U = Object.keys(G);
    typeof Object.getOwnPropertySymbols == "function" && (U = U.concat(Object.getOwnPropertySymbols(G).filter(function(K) {
      return Object.getOwnPropertyDescriptor(G, K).enumerable;
    }))), U.forEach(function(K) {
      _defineProperty$2(H, K, G[K]);
    });
  }
  return H;
}
function _defineProperty$2(H, C, G) {
  return C in H ? Object.defineProperty(H, C, { value: G, enumerable: !0, configurable: !0, writable: !0 }) : H[C] = G, H;
}
var BarChartOutlined = function(C, G) {
  var U = _objectSpread$2({}, C, G.attrs);
  return createVNode$1(AntdIcon, _objectSpread$2({}, U, {
    icon: BarChartOutlinedSvg
  }), null);
};
BarChartOutlined.displayName = "BarChartOutlined";
BarChartOutlined.inheritAttrs = !1;
const BarChartOutlined$1 = BarChartOutlined;
var ExportOutlined$2 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M888.3 757.4h-53.8c-4.2 0-7.7 3.5-7.7 7.7v61.8H197.1V197.1h629.8v61.8c0 4.2 3.5 7.7 7.7 7.7h53.8c4.2 0 7.7-3.4 7.7-7.7V158.7c0-17-13.7-30.7-30.7-30.7H158.7c-17 0-30.7 13.7-30.7 30.7v706.6c0 17 13.7 30.7 30.7 30.7h706.6c17 0 30.7-13.7 30.7-30.7V765.1c0-4.3-3.5-7.7-7.7-7.7zm18.6-251.7L765 393.7c-5.3-4.2-13-.4-13 6.3v76H438c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h314v76c0 6.7 7.8 10.5 13 6.3l141.9-112a8 8 0 000-12.6z" } }] }, name: "export", theme: "outlined" };
const ExportOutlinedSvg = ExportOutlined$2;
function _objectSpread$1(H) {
  for (var C = 1; C < arguments.length; C++) {
    var G = arguments[C] != null ? Object(arguments[C]) : {}, U = Object.keys(G);
    typeof Object.getOwnPropertySymbols == "function" && (U = U.concat(Object.getOwnPropertySymbols(G).filter(function(K) {
      return Object.getOwnPropertyDescriptor(G, K).enumerable;
    }))), U.forEach(function(K) {
      _defineProperty$1(H, K, G[K]);
    });
  }
  return H;
}
function _defineProperty$1(H, C, G) {
  return C in H ? Object.defineProperty(H, C, { value: G, enumerable: !0, configurable: !0, writable: !0 }) : H[C] = G, H;
}
var ExportOutlined = function(C, G) {
  var U = _objectSpread$1({}, C, G.attrs);
  return createVNode$1(AntdIcon, _objectSpread$1({}, U, {
    icon: ExportOutlinedSvg
  }), null);
};
ExportOutlined.displayName = "ExportOutlined";
ExportOutlined.inheritAttrs = !1;
const ExportOutlined$1 = ExportOutlined;
var TableOutlined$2 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M928 160H96c-17.7 0-32 14.3-32 32v640c0 17.7 14.3 32 32 32h832c17.7 0 32-14.3 32-32V192c0-17.7-14.3-32-32-32zm-40 208H676V232h212v136zm0 224H676V432h212v160zM412 432h200v160H412V432zm200-64H412V232h200v136zm-476 64h212v160H136V432zm0-200h212v136H136V232zm0 424h212v136H136V656zm276 0h200v136H412V656zm476 136H676V656h212v136z" } }] }, name: "table", theme: "outlined" };
const TableOutlinedSvg = TableOutlined$2;
function _objectSpread(H) {
  for (var C = 1; C < arguments.length; C++) {
    var G = arguments[C] != null ? Object(arguments[C]) : {}, U = Object.keys(G);
    typeof Object.getOwnPropertySymbols == "function" && (U = U.concat(Object.getOwnPropertySymbols(G).filter(function(K) {
      return Object.getOwnPropertyDescriptor(G, K).enumerable;
    }))), U.forEach(function(K) {
      _defineProperty(H, K, G[K]);
    });
  }
  return H;
}
function _defineProperty(H, C, G) {
  return C in H ? Object.defineProperty(H, C, { value: G, enumerable: !0, configurable: !0, writable: !0 }) : H[C] = G, H;
}
var TableOutlined = function(C, G) {
  var U = _objectSpread({}, C, G.attrs);
  return createVNode$1(AntdIcon, _objectSpread({}, U, {
    icon: TableOutlinedSvg
  }), null);
};
TableOutlined.displayName = "TableOutlined";
TableOutlined.inheritAttrs = !1;
const TableOutlined$1 = TableOutlined, _sfc_main$9 = defineComponent({
  name: "NoData",
  props: {
    data: {
      type: Array,
      default: () => []
    },
    text: {
      type: String,
      default: () => "暂无数据"
    }
  }
}), _export_sfc = (H, C) => {
  const G = H.__vccOpts || H;
  for (const [U, K] of C)
    G[U] = K;
  return G;
}, _hoisted_1$8 = { className: "ant-empty ant-empty-normal" }, _hoisted_2$7 = /* @__PURE__ */ createElementVNode("div", { className: "ant-empty-image" }, [
  /* @__PURE__ */ createElementVNode("svg", {
    width: "64",
    height: "41",
    viewBox: "0 0 64 41",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    /* @__PURE__ */ createElementVNode("g", {
      transform: "translate(0 1)",
      fill: "none",
      fillRule: "evenodd"
    }, [
      /* @__PURE__ */ createElementVNode("ellipse", {
        fill: "#F5F5F5",
        cx: "32",
        cy: "33",
        rx: "32",
        ry: "7"
      }),
      /* @__PURE__ */ createElementVNode("g", {
        fillRule: "nonzero",
        stroke: "#D9D9D9"
      }, [
        /* @__PURE__ */ createElementVNode("path", { d: "M55 12.76L44.854 1.258C44.367.474 43.656 0 42.907 0H21.093c-.749 0-1.46.474-1.947 1.257L9 12.761V22h46v-9.24z" }),
        /* @__PURE__ */ createElementVNode("path", {
          d: "M41.613 15.931c0-1.605.994-2.93 2.227-2.931H55v18.137C55 33.26 53.68 35 52.05 35h-40.1C10.32 35 9 33.259 9 31.137V13h11.16c1.233 0 2.227 1.323 2.227 2.928v.022c0 1.605 1.005 2.901 2.237 2.901h14.752c1.232 0 2.237-1.308 2.237-2.913v-.007z",
          fill: "#FAFAFA"
        })
      ])
    ])
  ])
], -1), _hoisted_3$1 = { className: "ant-empty-description" };
function _sfc_render$9(H, C, G, U, K, W) {
  return openBlock(), createElementBlock("div", {
    style: normalizeStyle$1({
      display: `${H.data && H.data.length > 0 ? "none" : "block"}`,
      position: "absolute",
      top: "50%",
      left: "50%",
      transform: "translate(-50%,-50%)"
    })
  }, [
    createElementVNode("div", _hoisted_1$8, [
      _hoisted_2$7,
      createElementVNode("p", _hoisted_3$1, toDisplayString(H.text), 1)
    ])
  ], 4);
}
const NoData = /* @__PURE__ */ _export_sfc(_sfc_main$9, [["render", _sfc_render$9]]);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$1 = function(H, C) {
  return extendStatics$1 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(G, U) {
    G.__proto__ = U;
  } || function(G, U) {
    for (var K in U)
      Object.prototype.hasOwnProperty.call(U, K) && (G[K] = U[K]);
  }, extendStatics$1(H, C);
};
function __extends$1(H, C) {
  if (typeof C != "function" && C !== null)
    throw new TypeError("Class extends value " + String(C) + " is not a constructor or null");
  extendStatics$1(H, C);
  function G() {
    this.constructor = H;
  }
  H.prototype = C === null ? Object.create(C) : (G.prototype = C.prototype, new G());
}
var Browser = function() {
  function H() {
    this.firefox = !1, this.ie = !1, this.edge = !1, this.newEdge = !1, this.weChat = !1;
  }
  return H;
}(), Env = function() {
  function H() {
    this.browser = new Browser(), this.node = !1, this.wxa = !1, this.worker = !1, this.svgSupported = !1, this.touchEventsSupported = !1, this.pointerEventsSupported = !1, this.domSupported = !1, this.transformSupported = !1, this.transform3dSupported = !1, this.hasGlobalWindow = typeof window < "u";
  }
  return H;
}(), env = new Env();
typeof wx == "object" && typeof wx.getSystemInfoSync == "function" ? (env.wxa = !0, env.touchEventsSupported = !0) : typeof document > "u" && typeof self < "u" ? env.worker = !0 : typeof navigator > "u" ? (env.node = !0, env.svgSupported = !0) : detect(navigator.userAgent, env);
function detect(H, C) {
  var G = C.browser, U = H.match(/Firefox\/([\d.]+)/), K = H.match(/MSIE\s([\d.]+)/) || H.match(/Trident\/.+?rv:(([\d.]+))/), W = H.match(/Edge?\/([\d.]+)/), Z = /micromessenger/i.test(H);
  U && (G.firefox = !0, G.version = U[1]), K && (G.ie = !0, G.version = K[1]), W && (G.edge = !0, G.version = W[1], G.newEdge = +W[1].split(".")[0] > 18), Z && (G.weChat = !0), C.svgSupported = typeof SVGRect < "u", C.touchEventsSupported = "ontouchstart" in window && !G.ie && !G.edge, C.pointerEventsSupported = "onpointerdown" in window && (G.edge || G.ie && +G.version >= 11), C.domSupported = typeof document < "u";
  var X = document.documentElement.style;
  C.transform3dSupported = (G.ie && "transition" in X || G.edge || "WebKitCSSMatrix" in window && "m11" in new WebKitCSSMatrix() || "MozPerspective" in X) && !("OTransition" in X), C.transformSupported = C.transform3dSupported || G.ie && +G.version >= 9;
}
const env$1 = env;
var DEFAULT_FONT_SIZE = 12, DEFAULT_FONT_FAMILY = "sans-serif", DEFAULT_FONT = DEFAULT_FONT_SIZE + "px " + DEFAULT_FONT_FAMILY, OFFSET = 20, SCALE = 100, defaultWidthMapStr = "007LLmW'55;N0500LLLLLLLLLL00NNNLzWW\\\\WQb\\0FWLg\\bWb\\WQ\\WrWWQ000CL5LLFLL0LL**F*gLLLL5F0LF\\FFF5.5N";
function getTextWidthMap(H) {
  var C = {};
  if (typeof JSON > "u")
    return C;
  for (var G = 0; G < H.length; G++) {
    var U = String.fromCharCode(G + 32), K = (H.charCodeAt(G) - OFFSET) / SCALE;
    C[U] = K;
  }
  return C;
}
var DEFAULT_TEXT_WIDTH_MAP = getTextWidthMap(defaultWidthMapStr), platformApi = {
  createCanvas: function() {
    return typeof document < "u" && document.createElement("canvas");
  },
  measureText: function() {
    var H, C;
    return function(G, U) {
      if (!H) {
        var K = platformApi.createCanvas();
        H = K && K.getContext("2d");
      }
      if (H)
        return C !== U && (C = H.font = U || DEFAULT_FONT), H.measureText(G);
      G = G || "", U = U || DEFAULT_FONT;
      var W = /(\d+)px/.exec(U), Z = W && +W[1] || DEFAULT_FONT_SIZE, X = 0;
      if (U.indexOf("mono") >= 0)
        X = Z * G.length;
      else
        for (var Q = 0; Q < G.length; Q++) {
          var ee = DEFAULT_TEXT_WIDTH_MAP[G[Q]];
          X += ee == null ? Z : ee * Z;
        }
      return { width: X };
    };
  }(),
  loadImage: function(H, C, G) {
    var U = new Image();
    return U.onload = C, U.onerror = G, U.src = H, U;
  }
}, BUILTIN_OBJECT = reduce([
  "Function",
  "RegExp",
  "Date",
  "Error",
  "CanvasGradient",
  "CanvasPattern",
  "Image",
  "Canvas"
], function(H, C) {
  return H["[object " + C + "]"] = !0, H;
}, {}), TYPED_ARRAY = reduce([
  "Int8",
  "Uint8",
  "Uint8Clamped",
  "Int16",
  "Uint16",
  "Int32",
  "Uint32",
  "Float32",
  "Float64"
], function(H, C) {
  return H["[object " + C + "Array]"] = !0, H;
}, {}), objToString = Object.prototype.toString, arrayProto = Array.prototype, nativeForEach = arrayProto.forEach, nativeFilter = arrayProto.filter, nativeSlice = arrayProto.slice, nativeMap = arrayProto.map, ctorFunction = function() {
}.constructor, protoFunction = ctorFunction ? ctorFunction.prototype : null, protoKey = "__proto__", idStart = 2311;
function guid() {
  return idStart++;
}
function logError() {
  for (var H = [], C = 0; C < arguments.length; C++)
    H[C] = arguments[C];
  typeof console < "u" && console.error.apply(console, H);
}
function clone$4(H) {
  if (H == null || typeof H != "object")
    return H;
  var C = H, G = objToString.call(H);
  if (G === "[object Array]") {
    if (!isPrimitive(H)) {
      C = [];
      for (var U = 0, K = H.length; U < K; U++)
        C[U] = clone$4(H[U]);
    }
  } else if (TYPED_ARRAY[G]) {
    if (!isPrimitive(H)) {
      var W = H.constructor;
      if (W.from)
        C = W.from(H);
      else {
        C = new W(H.length);
        for (var U = 0, K = H.length; U < K; U++)
          C[U] = H[U];
      }
    }
  } else if (!BUILTIN_OBJECT[G] && !isPrimitive(H) && !isDom(H)) {
    C = {};
    for (var Z in H)
      H.hasOwnProperty(Z) && Z !== protoKey && (C[Z] = clone$4(H[Z]));
  }
  return C;
}
function merge(H, C, G) {
  if (!isObject$3(C) || !isObject$3(H))
    return G ? clone$4(C) : H;
  for (var U in C)
    if (C.hasOwnProperty(U) && U !== protoKey) {
      var K = H[U], W = C[U];
      isObject$3(W) && isObject$3(K) && !isArray$1(W) && !isArray$1(K) && !isDom(W) && !isDom(K) && !isBuiltInObject(W) && !isBuiltInObject(K) && !isPrimitive(W) && !isPrimitive(K) ? merge(K, W, G) : (G || !(U in H)) && (H[U] = clone$4(C[U]));
    }
  return H;
}
function mergeAll(H, C) {
  for (var G = H[0], U = 1, K = H.length; U < K; U++)
    G = merge(G, H[U], C);
  return G;
}
function extend(H, C) {
  if (Object.assign)
    Object.assign(H, C);
  else
    for (var G in C)
      C.hasOwnProperty(G) && G !== protoKey && (H[G] = C[G]);
  return H;
}
function defaults(H, C, G) {
  for (var U = keys(C), K = 0; K < U.length; K++) {
    var W = U[K];
    (G ? C[W] != null : H[W] == null) && (H[W] = C[W]);
  }
  return H;
}
function indexOf(H, C) {
  if (H) {
    if (H.indexOf)
      return H.indexOf(C);
    for (var G = 0, U = H.length; G < U; G++)
      if (H[G] === C)
        return G;
  }
  return -1;
}
function inherits(H, C) {
  var G = H.prototype;
  function U() {
  }
  U.prototype = C.prototype, H.prototype = new U();
  for (var K in G)
    G.hasOwnProperty(K) && (H.prototype[K] = G[K]);
  H.prototype.constructor = H, H.superClass = C;
}
function mixin(H, C, G) {
  if (H = "prototype" in H ? H.prototype : H, C = "prototype" in C ? C.prototype : C, Object.getOwnPropertyNames)
    for (var U = Object.getOwnPropertyNames(C), K = 0; K < U.length; K++) {
      var W = U[K];
      W !== "constructor" && (G ? C[W] != null : H[W] == null) && (H[W] = C[W]);
    }
  else
    defaults(H, C, G);
}
function isArrayLike(H) {
  return !H || typeof H == "string" ? !1 : typeof H.length == "number";
}
function each$f(H, C, G) {
  if (H && C)
    if (H.forEach && H.forEach === nativeForEach)
      H.forEach(C, G);
    else if (H.length === +H.length)
      for (var U = 0, K = H.length; U < K; U++)
        C.call(G, H[U], U, H);
    else
      for (var W in H)
        H.hasOwnProperty(W) && C.call(G, H[W], W, H);
}
function map$1(H, C, G) {
  if (!H)
    return [];
  if (!C)
    return slice(H);
  if (H.map && H.map === nativeMap)
    return H.map(C, G);
  for (var U = [], K = 0, W = H.length; K < W; K++)
    U.push(C.call(G, H[K], K, H));
  return U;
}
function reduce(H, C, G, U) {
  if (H && C) {
    for (var K = 0, W = H.length; K < W; K++)
      G = C.call(U, G, H[K], K, H);
    return G;
  }
}
function filter(H, C, G) {
  if (!H)
    return [];
  if (!C)
    return slice(H);
  if (H.filter && H.filter === nativeFilter)
    return H.filter(C, G);
  for (var U = [], K = 0, W = H.length; K < W; K++)
    C.call(G, H[K], K, H) && U.push(H[K]);
  return U;
}
function find(H, C, G) {
  if (H && C) {
    for (var U = 0, K = H.length; U < K; U++)
      if (C.call(G, H[U], U, H))
        return H[U];
  }
}
function keys(H) {
  if (!H)
    return [];
  if (Object.keys)
    return Object.keys(H);
  var C = [];
  for (var G in H)
    H.hasOwnProperty(G) && C.push(G);
  return C;
}
function bindPolyfill(H, C) {
  for (var G = [], U = 2; U < arguments.length; U++)
    G[U - 2] = arguments[U];
  return function() {
    return H.apply(C, G.concat(nativeSlice.call(arguments)));
  };
}
var bind$1 = protoFunction && isFunction(protoFunction.bind) ? protoFunction.call.bind(protoFunction.bind) : bindPolyfill;
function curry$1(H) {
  for (var C = [], G = 1; G < arguments.length; G++)
    C[G - 1] = arguments[G];
  return function() {
    return H.apply(this, C.concat(nativeSlice.call(arguments)));
  };
}
function isArray$1(H) {
  return Array.isArray ? Array.isArray(H) : objToString.call(H) === "[object Array]";
}
function isFunction(H) {
  return typeof H == "function";
}
function isString(H) {
  return typeof H == "string";
}
function isStringSafe(H) {
  return objToString.call(H) === "[object String]";
}
function isNumber(H) {
  return typeof H == "number";
}
function isObject$3(H) {
  var C = typeof H;
  return C === "function" || !!H && C === "object";
}
function isBuiltInObject(H) {
  return !!BUILTIN_OBJECT[objToString.call(H)];
}
function isTypedArray(H) {
  return !!TYPED_ARRAY[objToString.call(H)];
}
function isDom(H) {
  return typeof H == "object" && typeof H.nodeType == "number" && typeof H.ownerDocument == "object";
}
function isGradientObject(H) {
  return H.colorStops != null;
}
function isImagePatternObject(H) {
  return H.image != null;
}
function isRegExp(H) {
  return objToString.call(H) === "[object RegExp]";
}
function eqNaN(H) {
  return H !== H;
}
function retrieve() {
  for (var H = [], C = 0; C < arguments.length; C++)
    H[C] = arguments[C];
  for (var G = 0, U = H.length; G < U; G++)
    if (H[G] != null)
      return H[G];
}
function retrieve2(H, C) {
  return H ?? C;
}
function retrieve3(H, C, G) {
  return H ?? C ?? G;
}
function slice(H) {
  for (var C = [], G = 1; G < arguments.length; G++)
    C[G - 1] = arguments[G];
  return nativeSlice.apply(H, C);
}
function normalizeCssArray$1(H) {
  if (typeof H == "number")
    return [H, H, H, H];
  var C = H.length;
  return C === 2 ? [H[0], H[1], H[0], H[1]] : C === 3 ? [H[0], H[1], H[2], H[1]] : H;
}
function assert(H, C) {
  if (!H)
    throw new Error(C);
}
function trim$1(H) {
  return H == null ? null : typeof H.trim == "function" ? H.trim() : H.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
}
var primitiveKey = "__ec_primitive__";
function setAsPrimitive(H) {
  H[primitiveKey] = !0;
}
function isPrimitive(H) {
  return H[primitiveKey];
}
var MapPolyfill = function() {
  function H() {
    this.data = {};
  }
  return H.prototype.delete = function(C) {
    var G = this.has(C);
    return G && delete this.data[C], G;
  }, H.prototype.has = function(C) {
    return this.data.hasOwnProperty(C);
  }, H.prototype.get = function(C) {
    return this.data[C];
  }, H.prototype.set = function(C, G) {
    return this.data[C] = G, this;
  }, H.prototype.keys = function() {
    return keys(this.data);
  }, H.prototype.forEach = function(C) {
    var G = this.data;
    for (var U in G)
      G.hasOwnProperty(U) && C(G[U], U);
  }, H;
}(), isNativeMapSupported = typeof Map == "function";
function maybeNativeMap() {
  return isNativeMapSupported ? /* @__PURE__ */ new Map() : new MapPolyfill();
}
var HashMap = function() {
  function H(C) {
    var G = isArray$1(C);
    this.data = maybeNativeMap();
    var U = this;
    C instanceof H ? C.each(K) : C && each$f(C, K);
    function K(W, Z) {
      G ? U.set(W, Z) : U.set(Z, W);
    }
  }
  return H.prototype.hasKey = function(C) {
    return this.data.has(C);
  }, H.prototype.get = function(C) {
    return this.data.get(C);
  }, H.prototype.set = function(C, G) {
    return this.data.set(C, G), G;
  }, H.prototype.each = function(C, G) {
    this.data.forEach(function(U, K) {
      C.call(G, U, K);
    });
  }, H.prototype.keys = function() {
    var C = this.data.keys();
    return isNativeMapSupported ? Array.from(C) : C;
  }, H.prototype.removeKey = function(C) {
    this.data.delete(C);
  }, H;
}();
function createHashMap(H) {
  return new HashMap(H);
}
function concatArray(H, C) {
  for (var G = new H.constructor(H.length + C.length), U = 0; U < H.length; U++)
    G[U] = H[U];
  for (var K = H.length, U = 0; U < C.length; U++)
    G[U + K] = C[U];
  return G;
}
function createObject(H, C) {
  var G;
  if (Object.create)
    G = Object.create(H);
  else {
    var U = function() {
    };
    U.prototype = H, G = new U();
  }
  return C && extend(G, C), G;
}
function disableUserSelect(H) {
  var C = H.style;
  C.webkitUserSelect = "none", C.userSelect = "none", C.webkitTapHighlightColor = "rgba(0,0,0,0)", C["-webkit-touch-callout"] = "none";
}
function hasOwn(H, C) {
  return H.hasOwnProperty(C);
}
function noop() {
}
var RADIAN_TO_DEGREE = 180 / Math.PI;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(H, C) {
  return extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(G, U) {
    G.__proto__ = U;
  } || function(G, U) {
    for (var K in U)
      Object.prototype.hasOwnProperty.call(U, K) && (G[K] = U[K]);
  }, extendStatics(H, C);
};
function __extends(H, C) {
  if (typeof C != "function" && C !== null)
    throw new TypeError("Class extends value " + String(C) + " is not a constructor or null");
  extendStatics(H, C);
  function G() {
    this.constructor = H;
  }
  H.prototype = C === null ? Object.create(C) : (G.prototype = C.prototype, new G());
}
function create$2(H, C) {
  return H == null && (H = 0), C == null && (C = 0), [H, C];
}
function copy$1(H, C) {
  return H[0] = C[0], H[1] = C[1], H;
}
function clone$3(H) {
  return [H[0], H[1]];
}
function set$1(H, C, G) {
  return H[0] = C, H[1] = G, H;
}
function add(H, C, G) {
  return H[0] = C[0] + G[0], H[1] = C[1] + G[1], H;
}
function scaleAndAdd$1(H, C, G, U) {
  return H[0] = C[0] + G[0] * U, H[1] = C[1] + G[1] * U, H;
}
function sub(H, C, G) {
  return H[0] = C[0] - G[0], H[1] = C[1] - G[1], H;
}
function len(H) {
  return Math.sqrt(lenSquare(H));
}
function lenSquare(H) {
  return H[0] * H[0] + H[1] * H[1];
}
function scale$2(H, C, G) {
  return H[0] = C[0] * G, H[1] = C[1] * G, H;
}
function normalize$3(H, C) {
  var G = len(C);
  return G === 0 ? (H[0] = 0, H[1] = 0) : (H[0] = C[0] / G, H[1] = C[1] / G), H;
}
function distance(H, C) {
  return Math.sqrt((H[0] - C[0]) * (H[0] - C[0]) + (H[1] - C[1]) * (H[1] - C[1]));
}
var dist$1 = distance;
function distanceSquare(H, C) {
  return (H[0] - C[0]) * (H[0] - C[0]) + (H[1] - C[1]) * (H[1] - C[1]);
}
var distSquare = distanceSquare;
function lerp$1(H, C, G, U) {
  return H[0] = C[0] + U * (G[0] - C[0]), H[1] = C[1] + U * (G[1] - C[1]), H;
}
function applyTransform$1(H, C, G) {
  var U = C[0], K = C[1];
  return H[0] = G[0] * U + G[2] * K + G[4], H[1] = G[1] * U + G[3] * K + G[5], H;
}
function min$1(H, C, G) {
  return H[0] = Math.min(C[0], G[0]), H[1] = Math.min(C[1], G[1]), H;
}
function max$1(H, C, G) {
  return H[0] = Math.max(C[0], G[0]), H[1] = Math.max(C[1], G[1]), H;
}
var Param = function() {
  function H(C, G) {
    this.target = C, this.topTarget = G && G.topTarget;
  }
  return H;
}(), Draggable = function() {
  function H(C) {
    this.handler = C, C.on("mousedown", this._dragStart, this), C.on("mousemove", this._drag, this), C.on("mouseup", this._dragEnd, this);
  }
  return H.prototype._dragStart = function(C) {
    for (var G = C.target; G && !G.draggable; )
      G = G.parent || G.__hostTarget;
    G && (this._draggingTarget = G, G.dragging = !0, this._x = C.offsetX, this._y = C.offsetY, this.handler.dispatchToElement(new Param(G, C), "dragstart", C.event));
  }, H.prototype._drag = function(C) {
    var G = this._draggingTarget;
    if (G) {
      var U = C.offsetX, K = C.offsetY, W = U - this._x, Z = K - this._y;
      this._x = U, this._y = K, G.drift(W, Z, C), this.handler.dispatchToElement(new Param(G, C), "drag", C.event);
      var X = this.handler.findHover(U, K, G).target, Q = this._dropTarget;
      this._dropTarget = X, G !== X && (Q && X !== Q && this.handler.dispatchToElement(new Param(Q, C), "dragleave", C.event), X && X !== Q && this.handler.dispatchToElement(new Param(X, C), "dragenter", C.event));
    }
  }, H.prototype._dragEnd = function(C) {
    var G = this._draggingTarget;
    G && (G.dragging = !1), this.handler.dispatchToElement(new Param(G, C), "dragend", C.event), this._dropTarget && this.handler.dispatchToElement(new Param(this._dropTarget, C), "drop", C.event), this._draggingTarget = null, this._dropTarget = null;
  }, H;
}();
const Draggable$1 = Draggable;
var Eventful = function() {
  function H(C) {
    C && (this._$eventProcessor = C);
  }
  return H.prototype.on = function(C, G, U, K) {
    this._$handlers || (this._$handlers = {});
    var W = this._$handlers;
    if (typeof G == "function" && (K = U, U = G, G = null), !U || !C)
      return this;
    var Z = this._$eventProcessor;
    G != null && Z && Z.normalizeQuery && (G = Z.normalizeQuery(G)), W[C] || (W[C] = []);
    for (var X = 0; X < W[C].length; X++)
      if (W[C][X].h === U)
        return this;
    var Q = {
      h: U,
      query: G,
      ctx: K || this,
      callAtLast: U.zrEventfulCallAtLast
    }, ee = W[C].length - 1, te = W[C][ee];
    return te && te.callAtLast ? W[C].splice(ee, 0, Q) : W[C].push(Q), this;
  }, H.prototype.isSilent = function(C) {
    var G = this._$handlers;
    return !G || !G[C] || !G[C].length;
  }, H.prototype.off = function(C, G) {
    var U = this._$handlers;
    if (!U)
      return this;
    if (!C)
      return this._$handlers = {}, this;
    if (G) {
      if (U[C]) {
        for (var K = [], W = 0, Z = U[C].length; W < Z; W++)
          U[C][W].h !== G && K.push(U[C][W]);
        U[C] = K;
      }
      U[C] && U[C].length === 0 && delete U[C];
    } else
      delete U[C];
    return this;
  }, H.prototype.trigger = function(C) {
    for (var G = [], U = 1; U < arguments.length; U++)
      G[U - 1] = arguments[U];
    if (!this._$handlers)
      return this;
    var K = this._$handlers[C], W = this._$eventProcessor;
    if (K)
      for (var Z = G.length, X = K.length, Q = 0; Q < X; Q++) {
        var ee = K[Q];
        if (!(W && W.filter && ee.query != null && !W.filter(C, ee.query)))
          switch (Z) {
            case 0:
              ee.h.call(ee.ctx);
              break;
            case 1:
              ee.h.call(ee.ctx, G[0]);
              break;
            case 2:
              ee.h.call(ee.ctx, G[0], G[1]);
              break;
            default:
              ee.h.apply(ee.ctx, G);
              break;
          }
      }
    return W && W.afterTrigger && W.afterTrigger(C), this;
  }, H.prototype.triggerWithContext = function(C) {
    for (var G = [], U = 1; U < arguments.length; U++)
      G[U - 1] = arguments[U];
    if (!this._$handlers)
      return this;
    var K = this._$handlers[C], W = this._$eventProcessor;
    if (K)
      for (var Z = G.length, X = G[Z - 1], Q = K.length, ee = 0; ee < Q; ee++) {
        var te = K[ee];
        if (!(W && W.filter && te.query != null && !W.filter(C, te.query)))
          switch (Z) {
            case 0:
              te.h.call(X);
              break;
            case 1:
              te.h.call(X, G[0]);
              break;
            case 2:
              te.h.call(X, G[0], G[1]);
              break;
            default:
              te.h.apply(X, G.slice(1, Z - 1));
              break;
          }
      }
    return W && W.afterTrigger && W.afterTrigger(C), this;
  }, H;
}();
const Eventful$1 = Eventful;
var LN2 = Math.log(2);
function determinant(H, C, G, U, K, W) {
  var Z = U + "-" + K, X = H.length;
  if (W.hasOwnProperty(Z))
    return W[Z];
  if (C === 1) {
    var Q = Math.round(Math.log((1 << X) - 1 & ~K) / LN2);
    return H[G][Q];
  }
  for (var ee = U | 1 << G, te = G + 1; U & 1 << te; )
    te++;
  for (var re = 0, ne = 0, ae = 0; ne < X; ne++) {
    var ie = 1 << ne;
    ie & K || (re += (ae % 2 ? -1 : 1) * H[G][ne] * determinant(H, C - 1, te, ee, K | ie, W), ae++);
  }
  return W[Z] = re, re;
}
function buildTransformer(H, C) {
  var G = [
    [H[0], H[1], 1, 0, 0, 0, -C[0] * H[0], -C[0] * H[1]],
    [0, 0, 0, H[0], H[1], 1, -C[1] * H[0], -C[1] * H[1]],
    [H[2], H[3], 1, 0, 0, 0, -C[2] * H[2], -C[2] * H[3]],
    [0, 0, 0, H[2], H[3], 1, -C[3] * H[2], -C[3] * H[3]],
    [H[4], H[5], 1, 0, 0, 0, -C[4] * H[4], -C[4] * H[5]],
    [0, 0, 0, H[4], H[5], 1, -C[5] * H[4], -C[5] * H[5]],
    [H[6], H[7], 1, 0, 0, 0, -C[6] * H[6], -C[6] * H[7]],
    [0, 0, 0, H[6], H[7], 1, -C[7] * H[6], -C[7] * H[7]]
  ], U = {}, K = determinant(G, 8, 0, 0, 0, U);
  if (K !== 0) {
    for (var W = [], Z = 0; Z < 8; Z++)
      for (var X = 0; X < 8; X++)
        W[X] == null && (W[X] = 0), W[X] += ((Z + X) % 2 ? -1 : 1) * determinant(G, 7, Z === 0 ? 1 : 0, 1 << Z, 1 << X, U) / K * C[Z];
    return function(Q, ee, te) {
      var re = ee * W[6] + te * W[7] + 1;
      Q[0] = (ee * W[0] + te * W[1] + W[2]) / re, Q[1] = (ee * W[3] + te * W[4] + W[5]) / re;
    };
  }
}
var EVENT_SAVED_PROP = "___zrEVENTSAVED", _calcOut$1 = [];
function transformLocalCoord(H, C, G, U, K) {
  return transformCoordWithViewport(_calcOut$1, C, U, K, !0) && transformCoordWithViewport(H, G, _calcOut$1[0], _calcOut$1[1]);
}
function transformCoordWithViewport(H, C, G, U, K) {
  if (C.getBoundingClientRect && env$1.domSupported && !isCanvasEl(C)) {
    var W = C[EVENT_SAVED_PROP] || (C[EVENT_SAVED_PROP] = {}), Z = prepareCoordMarkers(C, W), X = preparePointerTransformer(Z, W, K);
    if (X)
      return X(H, G, U), !0;
  }
  return !1;
}
function prepareCoordMarkers(H, C) {
  var G = C.markers;
  if (G)
    return G;
  G = C.markers = [];
  for (var U = ["left", "right"], K = ["top", "bottom"], W = 0; W < 4; W++) {
    var Z = document.createElement("div"), X = Z.style, Q = W % 2, ee = (W >> 1) % 2;
    X.cssText = [
      "position: absolute",
      "visibility: hidden",
      "padding: 0",
      "margin: 0",
      "border-width: 0",
      "user-select: none",
      "width:0",
      "height:0",
      U[Q] + ":0",
      K[ee] + ":0",
      U[1 - Q] + ":auto",
      K[1 - ee] + ":auto",
      ""
    ].join("!important;"), H.appendChild(Z), G.push(Z);
  }
  return G;
}
function preparePointerTransformer(H, C, G) {
  for (var U = G ? "invTrans" : "trans", K = C[U], W = C.srcCoords, Z = [], X = [], Q = !0, ee = 0; ee < 4; ee++) {
    var te = H[ee].getBoundingClientRect(), re = 2 * ee, ne = te.left, ae = te.top;
    Z.push(ne, ae), Q = Q && W && ne === W[re] && ae === W[re + 1], X.push(H[ee].offsetLeft, H[ee].offsetTop);
  }
  return Q && K ? K : (C.srcCoords = Z, C[U] = G ? buildTransformer(X, Z) : buildTransformer(Z, X));
}
function isCanvasEl(H) {
  return H.nodeName.toUpperCase() === "CANVAS";
}
var replaceReg = /([&<>"'])/g, replaceMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
function encodeHTML(H) {
  return H == null ? "" : (H + "").replace(replaceReg, function(C, G) {
    return replaceMap[G];
  });
}
var MOUSE_EVENT_REG = /^(?:mouse|pointer|contextmenu|drag|drop)|click/, _calcOut = [], firefoxNotSupportOffsetXY = env$1.browser.firefox && +env$1.browser.version.split(".")[0] < 39;
function clientToLocal(H, C, G, U) {
  return G = G || {}, U ? calculateZrXY(H, C, G) : firefoxNotSupportOffsetXY && C.layerX != null && C.layerX !== C.offsetX ? (G.zrX = C.layerX, G.zrY = C.layerY) : C.offsetX != null ? (G.zrX = C.offsetX, G.zrY = C.offsetY) : calculateZrXY(H, C, G), G;
}
function calculateZrXY(H, C, G) {
  if (env$1.domSupported && H.getBoundingClientRect) {
    var U = C.clientX, K = C.clientY;
    if (isCanvasEl(H)) {
      var W = H.getBoundingClientRect();
      G.zrX = U - W.left, G.zrY = K - W.top;
      return;
    } else if (transformCoordWithViewport(_calcOut, H, U, K)) {
      G.zrX = _calcOut[0], G.zrY = _calcOut[1];
      return;
    }
  }
  G.zrX = G.zrY = 0;
}
function getNativeEvent(H) {
  return H || window.event;
}
function normalizeEvent(H, C, G) {
  if (C = getNativeEvent(C), C.zrX != null)
    return C;
  var U = C.type, K = U && U.indexOf("touch") >= 0;
  if (K) {
    var Z = U !== "touchend" ? C.targetTouches[0] : C.changedTouches[0];
    Z && clientToLocal(H, Z, C, G);
  } else {
    clientToLocal(H, C, C, G);
    var W = getWheelDeltaMayPolyfill(C);
    C.zrDelta = W ? W / 120 : -(C.detail || 0) / 3;
  }
  var X = C.button;
  return C.which == null && X !== void 0 && MOUSE_EVENT_REG.test(C.type) && (C.which = X & 1 ? 1 : X & 2 ? 3 : X & 4 ? 2 : 0), C;
}
function getWheelDeltaMayPolyfill(H) {
  var C = H.wheelDelta;
  if (C)
    return C;
  var G = H.deltaX, U = H.deltaY;
  if (G == null || U == null)
    return C;
  var K = Math.abs(U !== 0 ? U : G), W = U > 0 ? -1 : U < 0 ? 1 : G > 0 ? -1 : 1;
  return 3 * K * W;
}
function addEventListener(H, C, G, U) {
  H.addEventListener(C, G, U);
}
function removeEventListener(H, C, G, U) {
  H.removeEventListener(C, G, U);
}
var stop = function(H) {
  H.preventDefault(), H.stopPropagation(), H.cancelBubble = !0;
};
function isMiddleOrRightButtonOnMouseUpDown(H) {
  return H.which === 2 || H.which === 3;
}
var GestureMgr = function() {
  function H() {
    this._track = [];
  }
  return H.prototype.recognize = function(C, G, U) {
    return this._doTrack(C, G, U), this._recognize(C);
  }, H.prototype.clear = function() {
    return this._track.length = 0, this;
  }, H.prototype._doTrack = function(C, G, U) {
    var K = C.touches;
    if (K) {
      for (var W = {
        points: [],
        touches: [],
        target: G,
        event: C
      }, Z = 0, X = K.length; Z < X; Z++) {
        var Q = K[Z], ee = clientToLocal(U, Q, {});
        W.points.push([ee.zrX, ee.zrY]), W.touches.push(Q);
      }
      this._track.push(W);
    }
  }, H.prototype._recognize = function(C) {
    for (var G in recognizers)
      if (recognizers.hasOwnProperty(G)) {
        var U = recognizers[G](this._track, C);
        if (U)
          return U;
      }
  }, H;
}();
function dist(H) {
  var C = H[1][0] - H[0][0], G = H[1][1] - H[0][1];
  return Math.sqrt(C * C + G * G);
}
function center$1(H) {
  return [
    (H[0][0] + H[1][0]) / 2,
    (H[0][1] + H[1][1]) / 2
  ];
}
var recognizers = {
  pinch: function(H, C) {
    var G = H.length;
    if (G) {
      var U = (H[G - 1] || {}).points, K = (H[G - 2] || {}).points || U;
      if (K && K.length > 1 && U && U.length > 1) {
        var W = dist(U) / dist(K);
        !isFinite(W) && (W = 1), C.pinchScale = W;
        var Z = center$1(U);
        return C.pinchX = Z[0], C.pinchY = Z[1], {
          type: "pinch",
          target: H[0].target,
          event: C
        };
      }
    }
  }
};
function create$1() {
  return [1, 0, 0, 1, 0, 0];
}
function identity(H) {
  return H[0] = 1, H[1] = 0, H[2] = 0, H[3] = 1, H[4] = 0, H[5] = 0, H;
}
function copy(H, C) {
  return H[0] = C[0], H[1] = C[1], H[2] = C[2], H[3] = C[3], H[4] = C[4], H[5] = C[5], H;
}
function mul(H, C, G) {
  var U = C[0] * G[0] + C[2] * G[1], K = C[1] * G[0] + C[3] * G[1], W = C[0] * G[2] + C[2] * G[3], Z = C[1] * G[2] + C[3] * G[3], X = C[0] * G[4] + C[2] * G[5] + C[4], Q = C[1] * G[4] + C[3] * G[5] + C[5];
  return H[0] = U, H[1] = K, H[2] = W, H[3] = Z, H[4] = X, H[5] = Q, H;
}
function translate(H, C, G) {
  return H[0] = C[0], H[1] = C[1], H[2] = C[2], H[3] = C[3], H[4] = C[4] + G[0], H[5] = C[5] + G[1], H;
}
function rotate(H, C, G) {
  var U = C[0], K = C[2], W = C[4], Z = C[1], X = C[3], Q = C[5], ee = Math.sin(G), te = Math.cos(G);
  return H[0] = U * te + Z * ee, H[1] = -U * ee + Z * te, H[2] = K * te + X * ee, H[3] = -K * ee + te * X, H[4] = te * W + ee * Q, H[5] = te * Q - ee * W, H;
}
function scale$1(H, C, G) {
  var U = G[0], K = G[1];
  return H[0] = C[0] * U, H[1] = C[1] * K, H[2] = C[2] * U, H[3] = C[3] * K, H[4] = C[4] * U, H[5] = C[5] * K, H;
}
function invert(H, C) {
  var G = C[0], U = C[2], K = C[4], W = C[1], Z = C[3], X = C[5], Q = G * Z - W * U;
  return Q ? (Q = 1 / Q, H[0] = Z * Q, H[1] = -W * Q, H[2] = -U * Q, H[3] = G * Q, H[4] = (U * X - Z * K) * Q, H[5] = (W * K - G * X) * Q, H) : null;
}
function clone$2(H) {
  var C = create$1();
  return copy(C, H), C;
}
var Point = function() {
  function H(C, G) {
    this.x = C || 0, this.y = G || 0;
  }
  return H.prototype.copy = function(C) {
    return this.x = C.x, this.y = C.y, this;
  }, H.prototype.clone = function() {
    return new H(this.x, this.y);
  }, H.prototype.set = function(C, G) {
    return this.x = C, this.y = G, this;
  }, H.prototype.equal = function(C) {
    return C.x === this.x && C.y === this.y;
  }, H.prototype.add = function(C) {
    return this.x += C.x, this.y += C.y, this;
  }, H.prototype.scale = function(C) {
    this.x *= C, this.y *= C;
  }, H.prototype.scaleAndAdd = function(C, G) {
    this.x += C.x * G, this.y += C.y * G;
  }, H.prototype.sub = function(C) {
    return this.x -= C.x, this.y -= C.y, this;
  }, H.prototype.dot = function(C) {
    return this.x * C.x + this.y * C.y;
  }, H.prototype.len = function() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }, H.prototype.lenSquare = function() {
    return this.x * this.x + this.y * this.y;
  }, H.prototype.normalize = function() {
    var C = this.len();
    return this.x /= C, this.y /= C, this;
  }, H.prototype.distance = function(C) {
    var G = this.x - C.x, U = this.y - C.y;
    return Math.sqrt(G * G + U * U);
  }, H.prototype.distanceSquare = function(C) {
    var G = this.x - C.x, U = this.y - C.y;
    return G * G + U * U;
  }, H.prototype.negate = function() {
    return this.x = -this.x, this.y = -this.y, this;
  }, H.prototype.transform = function(C) {
    if (C) {
      var G = this.x, U = this.y;
      return this.x = C[0] * G + C[2] * U + C[4], this.y = C[1] * G + C[3] * U + C[5], this;
    }
  }, H.prototype.toArray = function(C) {
    return C[0] = this.x, C[1] = this.y, C;
  }, H.prototype.fromArray = function(C) {
    this.x = C[0], this.y = C[1];
  }, H.set = function(C, G, U) {
    C.x = G, C.y = U;
  }, H.copy = function(C, G) {
    C.x = G.x, C.y = G.y;
  }, H.len = function(C) {
    return Math.sqrt(C.x * C.x + C.y * C.y);
  }, H.lenSquare = function(C) {
    return C.x * C.x + C.y * C.y;
  }, H.dot = function(C, G) {
    return C.x * G.x + C.y * G.y;
  }, H.add = function(C, G, U) {
    C.x = G.x + U.x, C.y = G.y + U.y;
  }, H.sub = function(C, G, U) {
    C.x = G.x - U.x, C.y = G.y - U.y;
  }, H.scale = function(C, G, U) {
    C.x = G.x * U, C.y = G.y * U;
  }, H.scaleAndAdd = function(C, G, U, K) {
    C.x = G.x + U.x * K, C.y = G.y + U.y * K;
  }, H.lerp = function(C, G, U, K) {
    var W = 1 - K;
    C.x = W * G.x + K * U.x, C.y = W * G.y + K * U.y;
  }, H;
}();
const Point$1 = Point;
var mathMin$a = Math.min, mathMax$a = Math.max, lt = new Point$1(), rb = new Point$1(), lb = new Point$1(), rt = new Point$1(), minTv$1 = new Point$1(), maxTv$1 = new Point$1(), BoundingRect = function() {
  function H(C, G, U, K) {
    U < 0 && (C = C + U, U = -U), K < 0 && (G = G + K, K = -K), this.x = C, this.y = G, this.width = U, this.height = K;
  }
  return H.prototype.union = function(C) {
    var G = mathMin$a(C.x, this.x), U = mathMin$a(C.y, this.y);
    isFinite(this.x) && isFinite(this.width) ? this.width = mathMax$a(C.x + C.width, this.x + this.width) - G : this.width = C.width, isFinite(this.y) && isFinite(this.height) ? this.height = mathMax$a(C.y + C.height, this.y + this.height) - U : this.height = C.height, this.x = G, this.y = U;
  }, H.prototype.applyTransform = function(C) {
    H.applyTransform(this, this, C);
  }, H.prototype.calculateTransform = function(C) {
    var G = this, U = C.width / G.width, K = C.height / G.height, W = create$1();
    return translate(W, W, [-G.x, -G.y]), scale$1(W, W, [U, K]), translate(W, W, [C.x, C.y]), W;
  }, H.prototype.intersect = function(C, G) {
    if (!C)
      return !1;
    C instanceof H || (C = H.create(C));
    var U = this, K = U.x, W = U.x + U.width, Z = U.y, X = U.y + U.height, Q = C.x, ee = C.x + C.width, te = C.y, re = C.y + C.height, ne = !(W < Q || ee < K || X < te || re < Z);
    if (G) {
      var ae = 1 / 0, ie = 0, se = Math.abs(W - Q), oe = Math.abs(ee - K), le = Math.abs(X - te), ue = Math.abs(re - Z), ce = Math.min(se, oe), de = Math.min(le, ue);
      W < Q || ee < K ? ce > ie && (ie = ce, se < oe ? Point$1.set(maxTv$1, -se, 0) : Point$1.set(maxTv$1, oe, 0)) : ce < ae && (ae = ce, se < oe ? Point$1.set(minTv$1, se, 0) : Point$1.set(minTv$1, -oe, 0)), X < te || re < Z ? de > ie && (ie = de, le < ue ? Point$1.set(maxTv$1, 0, -le) : Point$1.set(maxTv$1, 0, ue)) : ce < ae && (ae = ce, le < ue ? Point$1.set(minTv$1, 0, le) : Point$1.set(minTv$1, 0, -ue));
    }
    return G && Point$1.copy(G, ne ? minTv$1 : maxTv$1), ne;
  }, H.prototype.contain = function(C, G) {
    var U = this;
    return C >= U.x && C <= U.x + U.width && G >= U.y && G <= U.y + U.height;
  }, H.prototype.clone = function() {
    return new H(this.x, this.y, this.width, this.height);
  }, H.prototype.copy = function(C) {
    H.copy(this, C);
  }, H.prototype.plain = function() {
    return {
      x: this.x,
      y: this.y,
      width: this.width,
      height: this.height
    };
  }, H.prototype.isFinite = function() {
    return isFinite(this.x) && isFinite(this.y) && isFinite(this.width) && isFinite(this.height);
  }, H.prototype.isZero = function() {
    return this.width === 0 || this.height === 0;
  }, H.create = function(C) {
    return new H(C.x, C.y, C.width, C.height);
  }, H.copy = function(C, G) {
    C.x = G.x, C.y = G.y, C.width = G.width, C.height = G.height;
  }, H.applyTransform = function(C, G, U) {
    if (!U) {
      C !== G && H.copy(C, G);
      return;
    }
    if (U[1] < 1e-5 && U[1] > -1e-5 && U[2] < 1e-5 && U[2] > -1e-5) {
      var K = U[0], W = U[3], Z = U[4], X = U[5];
      C.x = G.x * K + Z, C.y = G.y * W + X, C.width = G.width * K, C.height = G.height * W, C.width < 0 && (C.x += C.width, C.width = -C.width), C.height < 0 && (C.y += C.height, C.height = -C.height);
      return;
    }
    lt.x = lb.x = G.x, lt.y = rt.y = G.y, rb.x = rt.x = G.x + G.width, rb.y = lb.y = G.y + G.height, lt.transform(U), rt.transform(U), rb.transform(U), lb.transform(U), C.x = mathMin$a(lt.x, rb.x, lb.x, rt.x), C.y = mathMin$a(lt.y, rb.y, lb.y, rt.y);
    var Q = mathMax$a(lt.x, rb.x, lb.x, rt.x), ee = mathMax$a(lt.y, rb.y, lb.y, rt.y);
    C.width = Q - C.x, C.height = ee - C.y;
  }, H;
}();
const BoundingRect$1 = BoundingRect;
var SILENT = "silent";
function makeEventPacket(H, C, G) {
  return {
    type: H,
    event: G,
    target: C.target,
    topTarget: C.topTarget,
    cancelBubble: !1,
    offsetX: G.zrX,
    offsetY: G.zrY,
    gestureEvent: G.gestureEvent,
    pinchX: G.pinchX,
    pinchY: G.pinchY,
    pinchScale: G.pinchScale,
    wheelDelta: G.zrDelta,
    zrByTouch: G.zrByTouch,
    which: G.which,
    stop: stopEvent
  };
}
function stopEvent() {
  stop(this.event);
}
var EmptyProxy = function(H) {
  __extends(C, H);
  function C() {
    var G = H !== null && H.apply(this, arguments) || this;
    return G.handler = null, G;
  }
  return C.prototype.dispose = function() {
  }, C.prototype.setCursor = function() {
  }, C;
}(Eventful$1), HoveredResult = function() {
  function H(C, G) {
    this.x = C, this.y = G;
  }
  return H;
}(), handlerNames = [
  "click",
  "dblclick",
  "mousewheel",
  "mouseout",
  "mouseup",
  "mousedown",
  "mousemove",
  "contextmenu"
], tmpRect$1 = new BoundingRect$1(0, 0, 0, 0), Handler = function(H) {
  __extends(C, H);
  function C(G, U, K, W, Z) {
    var X = H.call(this) || this;
    return X._hovered = new HoveredResult(0, 0), X.storage = G, X.painter = U, X.painterRoot = W, X._pointerSize = Z, K = K || new EmptyProxy(), X.proxy = null, X.setHandlerProxy(K), X._draggingMgr = new Draggable$1(X), X;
  }
  return C.prototype.setHandlerProxy = function(G) {
    this.proxy && this.proxy.dispose(), G && (each$f(handlerNames, function(U) {
      G.on && G.on(U, this[U], this);
    }, this), G.handler = this), this.proxy = G;
  }, C.prototype.mousemove = function(G) {
    var U = G.zrX, K = G.zrY, W = isOutsideBoundary(this, U, K), Z = this._hovered, X = Z.target;
    X && !X.__zr && (Z = this.findHover(Z.x, Z.y), X = Z.target);
    var Q = this._hovered = W ? new HoveredResult(U, K) : this.findHover(U, K), ee = Q.target, te = this.proxy;
    te.setCursor && te.setCursor(ee ? ee.cursor : "default"), X && ee !== X && this.dispatchToElement(Z, "mouseout", G), this.dispatchToElement(Q, "mousemove", G), ee && ee !== X && this.dispatchToElement(Q, "mouseover", G);
  }, C.prototype.mouseout = function(G) {
    var U = G.zrEventControl;
    U !== "only_globalout" && this.dispatchToElement(this._hovered, "mouseout", G), U !== "no_globalout" && this.trigger("globalout", { type: "globalout", event: G });
  }, C.prototype.resize = function() {
    this._hovered = new HoveredResult(0, 0);
  }, C.prototype.dispatch = function(G, U) {
    var K = this[G];
    K && K.call(this, U);
  }, C.prototype.dispose = function() {
    this.proxy.dispose(), this.storage = null, this.proxy = null, this.painter = null;
  }, C.prototype.setCursorStyle = function(G) {
    var U = this.proxy;
    U.setCursor && U.setCursor(G);
  }, C.prototype.dispatchToElement = function(G, U, K) {
    G = G || {};
    var W = G.target;
    if (!(W && W.silent)) {
      for (var Z = "on" + U, X = makeEventPacket(U, G, K); W && (W[Z] && (X.cancelBubble = !!W[Z].call(W, X)), W.trigger(U, X), W = W.__hostTarget ? W.__hostTarget : W.parent, !X.cancelBubble); )
        ;
      X.cancelBubble || (this.trigger(U, X), this.painter && this.painter.eachOtherLayer && this.painter.eachOtherLayer(function(Q) {
        typeof Q[Z] == "function" && Q[Z].call(Q, X), Q.trigger && Q.trigger(U, X);
      }));
    }
  }, C.prototype.findHover = function(G, U, K) {
    var W = this.storage.getDisplayList(), Z = new HoveredResult(G, U);
    if (setHoverTarget(W, Z, G, U, K), this._pointerSize && !Z.target) {
      for (var X = [], Q = this._pointerSize, ee = Q / 2, te = new BoundingRect$1(G - ee, U - ee, Q, Q), re = W.length - 1; re >= 0; re--) {
        var ne = W[re];
        ne !== K && !ne.ignore && !ne.ignoreCoarsePointer && (!ne.parent || !ne.parent.ignoreCoarsePointer) && (tmpRect$1.copy(ne.getBoundingRect()), ne.transform && tmpRect$1.applyTransform(ne.transform), tmpRect$1.intersect(te) && X.push(ne));
      }
      if (X.length)
        for (var ae = 4, ie = Math.PI / 12, se = Math.PI * 2, oe = 0; oe < ee; oe += ae)
          for (var le = 0; le < se; le += ie) {
            var ue = G + oe * Math.cos(le), ce = U + oe * Math.sin(le);
            if (setHoverTarget(X, Z, ue, ce, K), Z.target)
              return Z;
          }
    }
    return Z;
  }, C.prototype.processGesture = function(G, U) {
    this._gestureMgr || (this._gestureMgr = new GestureMgr());
    var K = this._gestureMgr;
    U === "start" && K.clear();
    var W = K.recognize(G, this.findHover(G.zrX, G.zrY, null).target, this.proxy.dom);
    if (U === "end" && K.clear(), W) {
      var Z = W.type;
      G.gestureEvent = Z;
      var X = new HoveredResult();
      X.target = W.target, this.dispatchToElement(X, Z, W.event);
    }
  }, C;
}(Eventful$1);
each$f(["click", "mousedown", "mouseup", "mousewheel", "dblclick", "contextmenu"], function(H) {
  Handler.prototype[H] = function(C) {
    var G = C.zrX, U = C.zrY, K = isOutsideBoundary(this, G, U), W, Z;
    if ((H !== "mouseup" || !K) && (W = this.findHover(G, U), Z = W.target), H === "mousedown")
      this._downEl = Z, this._downPoint = [C.zrX, C.zrY], this._upEl = Z;
    else if (H === "mouseup")
      this._upEl = Z;
    else if (H === "click") {
      if (this._downEl !== this._upEl || !this._downPoint || dist$1(this._downPoint, [C.zrX, C.zrY]) > 4)
        return;
      this._downPoint = null;
    }
    this.dispatchToElement(W, H, C);
  };
});
function isHover(H, C, G) {
  if (H[H.rectHover ? "rectContain" : "contain"](C, G)) {
    for (var U = H, K = void 0, W = !1; U; ) {
      if (U.ignoreClip && (W = !0), !W) {
        var Z = U.getClipPath();
        if (Z && !Z.contain(C, G))
          return !1;
        U.silent && (K = !0);
      }
      var X = U.__hostTarget;
      U = X || U.parent;
    }
    return K ? SILENT : !0;
  }
  return !1;
}
function setHoverTarget(H, C, G, U, K) {
  for (var W = H.length - 1; W >= 0; W--) {
    var Z = H[W], X = void 0;
    if (Z !== K && !Z.ignore && (X = isHover(Z, G, U)) && (!C.topTarget && (C.topTarget = Z), X !== SILENT)) {
      C.target = Z;
      break;
    }
  }
}
function isOutsideBoundary(H, C, G) {
  var U = H.painter;
  return C < 0 || C > U.getWidth() || G < 0 || G > U.getHeight();
}
const Handler$1 = Handler;
var DEFAULT_MIN_MERGE = 32, DEFAULT_MIN_GALLOPING = 7;
function minRunLength(H) {
  for (var C = 0; H >= DEFAULT_MIN_MERGE; )
    C |= H & 1, H >>= 1;
  return H + C;
}
function makeAscendingRun(H, C, G, U) {
  var K = C + 1;
  if (K === G)
    return 1;
  if (U(H[K++], H[C]) < 0) {
    for (; K < G && U(H[K], H[K - 1]) < 0; )
      K++;
    reverseRun(H, C, K);
  } else
    for (; K < G && U(H[K], H[K - 1]) >= 0; )
      K++;
  return K - C;
}
function reverseRun(H, C, G) {
  for (G--; C < G; ) {
    var U = H[C];
    H[C++] = H[G], H[G--] = U;
  }
}
function binaryInsertionSort(H, C, G, U, K) {
  for (U === C && U++; U < G; U++) {
    for (var W = H[U], Z = C, X = U, Q; Z < X; )
      Q = Z + X >>> 1, K(W, H[Q]) < 0 ? X = Q : Z = Q + 1;
    var ee = U - Z;
    switch (ee) {
      case 3:
        H[Z + 3] = H[Z + 2];
      case 2:
        H[Z + 2] = H[Z + 1];
      case 1:
        H[Z + 1] = H[Z];
        break;
      default:
        for (; ee > 0; )
          H[Z + ee] = H[Z + ee - 1], ee--;
    }
    H[Z] = W;
  }
}
function gallopLeft(H, C, G, U, K, W) {
  var Z = 0, X = 0, Q = 1;
  if (W(H, C[G + K]) > 0) {
    for (X = U - K; Q < X && W(H, C[G + K + Q]) > 0; )
      Z = Q, Q = (Q << 1) + 1, Q <= 0 && (Q = X);
    Q > X && (Q = X), Z += K, Q += K;
  } else {
    for (X = K + 1; Q < X && W(H, C[G + K - Q]) <= 0; )
      Z = Q, Q = (Q << 1) + 1, Q <= 0 && (Q = X);
    Q > X && (Q = X);
    var ee = Z;
    Z = K - Q, Q = K - ee;
  }
  for (Z++; Z < Q; ) {
    var te = Z + (Q - Z >>> 1);
    W(H, C[G + te]) > 0 ? Z = te + 1 : Q = te;
  }
  return Q;
}
function gallopRight(H, C, G, U, K, W) {
  var Z = 0, X = 0, Q = 1;
  if (W(H, C[G + K]) < 0) {
    for (X = K + 1; Q < X && W(H, C[G + K - Q]) < 0; )
      Z = Q, Q = (Q << 1) + 1, Q <= 0 && (Q = X);
    Q > X && (Q = X);
    var ee = Z;
    Z = K - Q, Q = K - ee;
  } else {
    for (X = U - K; Q < X && W(H, C[G + K + Q]) >= 0; )
      Z = Q, Q = (Q << 1) + 1, Q <= 0 && (Q = X);
    Q > X && (Q = X), Z += K, Q += K;
  }
  for (Z++; Z < Q; ) {
    var te = Z + (Q - Z >>> 1);
    W(H, C[G + te]) < 0 ? Q = te : Z = te + 1;
  }
  return Q;
}
function TimSort(H, C) {
  var G = DEFAULT_MIN_GALLOPING, U, K, W = 0;
  H.length;
  var Z = [];
  U = [], K = [];
  function X(ae, ie) {
    U[W] = ae, K[W] = ie, W += 1;
  }
  function Q() {
    for (; W > 1; ) {
      var ae = W - 2;
      if (ae >= 1 && K[ae - 1] <= K[ae] + K[ae + 1] || ae >= 2 && K[ae - 2] <= K[ae] + K[ae - 1])
        K[ae - 1] < K[ae + 1] && ae--;
      else if (K[ae] > K[ae + 1])
        break;
      te(ae);
    }
  }
  function ee() {
    for (; W > 1; ) {
      var ae = W - 2;
      ae > 0 && K[ae - 1] < K[ae + 1] && ae--, te(ae);
    }
  }
  function te(ae) {
    var ie = U[ae], se = K[ae], oe = U[ae + 1], le = K[ae + 1];
    K[ae] = se + le, ae === W - 3 && (U[ae + 1] = U[ae + 2], K[ae + 1] = K[ae + 2]), W--;
    var ue = gallopRight(H[oe], H, ie, se, 0, C);
    ie += ue, se -= ue, se !== 0 && (le = gallopLeft(H[ie + se - 1], H, oe, le, le - 1, C), le !== 0 && (se <= le ? re(ie, se, oe, le) : ne(ie, se, oe, le)));
  }
  function re(ae, ie, se, oe) {
    var le = 0;
    for (le = 0; le < ie; le++)
      Z[le] = H[ae + le];
    var ue = 0, ce = se, de = ae;
    if (H[de++] = H[ce++], --oe === 0) {
      for (le = 0; le < ie; le++)
        H[de + le] = Z[ue + le];
      return;
    }
    if (ie === 1) {
      for (le = 0; le < oe; le++)
        H[de + le] = H[ce + le];
      H[de + oe] = Z[ue];
      return;
    }
    for (var ge = G, fe, ve, pe; ; ) {
      fe = 0, ve = 0, pe = !1;
      do
        if (C(H[ce], Z[ue]) < 0) {
          if (H[de++] = H[ce++], ve++, fe = 0, --oe === 0) {
            pe = !0;
            break;
          }
        } else if (H[de++] = Z[ue++], fe++, ve = 0, --ie === 1) {
          pe = !0;
          break;
        }
      while ((fe | ve) < ge);
      if (pe)
        break;
      do {
        if (fe = gallopRight(H[ce], Z, ue, ie, 0, C), fe !== 0) {
          for (le = 0; le < fe; le++)
            H[de + le] = Z[ue + le];
          if (de += fe, ue += fe, ie -= fe, ie <= 1) {
            pe = !0;
            break;
          }
        }
        if (H[de++] = H[ce++], --oe === 0) {
          pe = !0;
          break;
        }
        if (ve = gallopLeft(Z[ue], H, ce, oe, 0, C), ve !== 0) {
          for (le = 0; le < ve; le++)
            H[de + le] = H[ce + le];
          if (de += ve, ce += ve, oe -= ve, oe === 0) {
            pe = !0;
            break;
          }
        }
        if (H[de++] = Z[ue++], --ie === 1) {
          pe = !0;
          break;
        }
        ge--;
      } while (fe >= DEFAULT_MIN_GALLOPING || ve >= DEFAULT_MIN_GALLOPING);
      if (pe)
        break;
      ge < 0 && (ge = 0), ge += 2;
    }
    if (G = ge, G < 1 && (G = 1), ie === 1) {
      for (le = 0; le < oe; le++)
        H[de + le] = H[ce + le];
      H[de + oe] = Z[ue];
    } else {
      if (ie === 0)
        throw new Error();
      for (le = 0; le < ie; le++)
        H[de + le] = Z[ue + le];
    }
  }
  function ne(ae, ie, se, oe) {
    var le = 0;
    for (le = 0; le < oe; le++)
      Z[le] = H[se + le];
    var ue = ae + ie - 1, ce = oe - 1, de = se + oe - 1, ge = 0, fe = 0;
    if (H[de--] = H[ue--], --ie === 0) {
      for (ge = de - (oe - 1), le = 0; le < oe; le++)
        H[ge + le] = Z[le];
      return;
    }
    if (oe === 1) {
      for (de -= ie, ue -= ie, fe = de + 1, ge = ue + 1, le = ie - 1; le >= 0; le--)
        H[fe + le] = H[ge + le];
      H[de] = Z[ce];
      return;
    }
    for (var ve = G; ; ) {
      var pe = 0, he = 0, me = !1;
      do
        if (C(Z[ce], H[ue]) < 0) {
          if (H[de--] = H[ue--], pe++, he = 0, --ie === 0) {
            me = !0;
            break;
          }
        } else if (H[de--] = Z[ce--], he++, pe = 0, --oe === 1) {
          me = !0;
          break;
        }
      while ((pe | he) < ve);
      if (me)
        break;
      do {
        if (pe = ie - gallopRight(Z[ce], H, ae, ie, ie - 1, C), pe !== 0) {
          for (de -= pe, ue -= pe, ie -= pe, fe = de + 1, ge = ue + 1, le = pe - 1; le >= 0; le--)
            H[fe + le] = H[ge + le];
          if (ie === 0) {
            me = !0;
            break;
          }
        }
        if (H[de--] = Z[ce--], --oe === 1) {
          me = !0;
          break;
        }
        if (he = oe - gallopLeft(H[ue], Z, 0, oe, oe - 1, C), he !== 0) {
          for (de -= he, ce -= he, oe -= he, fe = de + 1, ge = ce + 1, le = 0; le < he; le++)
            H[fe + le] = Z[ge + le];
          if (oe <= 1) {
            me = !0;
            break;
          }
        }
        if (H[de--] = H[ue--], --ie === 0) {
          me = !0;
          break;
        }
        ve--;
      } while (pe >= DEFAULT_MIN_GALLOPING || he >= DEFAULT_MIN_GALLOPING);
      if (me)
        break;
      ve < 0 && (ve = 0), ve += 2;
    }
    if (G = ve, G < 1 && (G = 1), oe === 1) {
      for (de -= ie, ue -= ie, fe = de + 1, ge = ue + 1, le = ie - 1; le >= 0; le--)
        H[fe + le] = H[ge + le];
      H[de] = Z[ce];
    } else {
      if (oe === 0)
        throw new Error();
      for (ge = de - (oe - 1), le = 0; le < oe; le++)
        H[ge + le] = Z[le];
    }
  }
  return {
    mergeRuns: Q,
    forceMergeRuns: ee,
    pushRun: X
  };
}
function sort$2(H, C, G, U) {
  G || (G = 0), U || (U = H.length);
  var K = U - G;
  if (!(K < 2)) {
    var W = 0;
    if (K < DEFAULT_MIN_MERGE) {
      W = makeAscendingRun(H, G, U, C), binaryInsertionSort(H, G, U, G + W, C);
      return;
    }
    var Z = TimSort(H, C), X = minRunLength(K);
    do {
      if (W = makeAscendingRun(H, G, U, C), W < X) {
        var Q = K;
        Q > X && (Q = X), binaryInsertionSort(H, G, G + Q, G + W, C), W = Q;
      }
      Z.pushRun(G, W), Z.mergeRuns(), K -= W, G += W;
    } while (K !== 0);
    Z.forceMergeRuns();
  }
}
var REDRAW_BIT = 1, STYLE_CHANGED_BIT = 2, SHAPE_CHANGED_BIT = 4, invalidZErrorLogged = !1;
function logInvalidZError() {
  invalidZErrorLogged || (invalidZErrorLogged = !0, console.warn("z / z2 / zlevel of displayable is invalid, which may cause unexpected errors"));
}
function shapeCompareFunc(H, C) {
  return H.zlevel === C.zlevel ? H.z === C.z ? H.z2 - C.z2 : H.z - C.z : H.zlevel - C.zlevel;
}
var Storage = function() {
  function H() {
    this._roots = [], this._displayList = [], this._displayListLen = 0, this.displayableSortFunc = shapeCompareFunc;
  }
  return H.prototype.traverse = function(C, G) {
    for (var U = 0; U < this._roots.length; U++)
      this._roots[U].traverse(C, G);
  }, H.prototype.getDisplayList = function(C, G) {
    G = G || !1;
    var U = this._displayList;
    return (C || !U.length) && this.updateDisplayList(G), U;
  }, H.prototype.updateDisplayList = function(C) {
    this._displayListLen = 0;
    for (var G = this._roots, U = this._displayList, K = 0, W = G.length; K < W; K++)
      this._updateAndAddDisplayable(G[K], null, C);
    U.length = this._displayListLen, sort$2(U, shapeCompareFunc);
  }, H.prototype._updateAndAddDisplayable = function(C, G, U) {
    if (!(C.ignore && !U)) {
      C.beforeUpdate(), C.update(), C.afterUpdate();
      var K = C.getClipPath();
      if (C.ignoreClip)
        G = null;
      else if (K) {
        G ? G = G.slice() : G = [];
        for (var W = K, Z = C; W; )
          W.parent = Z, W.updateTransform(), G.push(W), Z = W, W = W.getClipPath();
      }
      if (C.childrenRef) {
        for (var X = C.childrenRef(), Q = 0; Q < X.length; Q++) {
          var ee = X[Q];
          C.__dirty && (ee.__dirty |= REDRAW_BIT), this._updateAndAddDisplayable(ee, G, U);
        }
        C.__dirty = 0;
      } else {
        var te = C;
        G && G.length ? te.__clipPaths = G : te.__clipPaths && te.__clipPaths.length > 0 && (te.__clipPaths = []), isNaN(te.z) && (logInvalidZError(), te.z = 0), isNaN(te.z2) && (logInvalidZError(), te.z2 = 0), isNaN(te.zlevel) && (logInvalidZError(), te.zlevel = 0), this._displayList[this._displayListLen++] = te;
      }
      var re = C.getDecalElement && C.getDecalElement();
      re && this._updateAndAddDisplayable(re, G, U);
      var ne = C.getTextGuideLine();
      ne && this._updateAndAddDisplayable(ne, G, U);
      var ae = C.getTextContent();
      ae && this._updateAndAddDisplayable(ae, G, U);
    }
  }, H.prototype.addRoot = function(C) {
    C.__zr && C.__zr.storage === this || this._roots.push(C);
  }, H.prototype.delRoot = function(C) {
    if (C instanceof Array) {
      for (var G = 0, U = C.length; G < U; G++)
        this.delRoot(C[G]);
      return;
    }
    var K = indexOf(this._roots, C);
    K >= 0 && this._roots.splice(K, 1);
  }, H.prototype.delAllRoots = function() {
    this._roots = [], this._displayList = [], this._displayListLen = 0;
  }, H.prototype.getRoots = function() {
    return this._roots;
  }, H.prototype.dispose = function() {
    this._displayList = null, this._roots = null;
  }, H;
}();
const Storage$1 = Storage;
var requestAnimationFrame$1;
requestAnimationFrame$1 = env$1.hasGlobalWindow && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function(H) {
  return setTimeout(H, 16);
};
const requestAnimationFrame$2 = requestAnimationFrame$1;
var easingFuncs = {
  linear: function(H) {
    return H;
  },
  quadraticIn: function(H) {
    return H * H;
  },
  quadraticOut: function(H) {
    return H * (2 - H);
  },
  quadraticInOut: function(H) {
    return (H *= 2) < 1 ? 0.5 * H * H : -0.5 * (--H * (H - 2) - 1);
  },
  cubicIn: function(H) {
    return H * H * H;
  },
  cubicOut: function(H) {
    return --H * H * H + 1;
  },
  cubicInOut: function(H) {
    return (H *= 2) < 1 ? 0.5 * H * H * H : 0.5 * ((H -= 2) * H * H + 2);
  },
  quarticIn: function(H) {
    return H * H * H * H;
  },
  quarticOut: function(H) {
    return 1 - --H * H * H * H;
  },
  quarticInOut: function(H) {
    return (H *= 2) < 1 ? 0.5 * H * H * H * H : -0.5 * ((H -= 2) * H * H * H - 2);
  },
  quinticIn: function(H) {
    return H * H * H * H * H;
  },
  quinticOut: function(H) {
    return --H * H * H * H * H + 1;
  },
  quinticInOut: function(H) {
    return (H *= 2) < 1 ? 0.5 * H * H * H * H * H : 0.5 * ((H -= 2) * H * H * H * H + 2);
  },
  sinusoidalIn: function(H) {
    return 1 - Math.cos(H * Math.PI / 2);
  },
  sinusoidalOut: function(H) {
    return Math.sin(H * Math.PI / 2);
  },
  sinusoidalInOut: function(H) {
    return 0.5 * (1 - Math.cos(Math.PI * H));
  },
  exponentialIn: function(H) {
    return H === 0 ? 0 : Math.pow(1024, H - 1);
  },
  exponentialOut: function(H) {
    return H === 1 ? 1 : 1 - Math.pow(2, -10 * H);
  },
  exponentialInOut: function(H) {
    return H === 0 ? 0 : H === 1 ? 1 : (H *= 2) < 1 ? 0.5 * Math.pow(1024, H - 1) : 0.5 * (-Math.pow(2, -10 * (H - 1)) + 2);
  },
  circularIn: function(H) {
    return 1 - Math.sqrt(1 - H * H);
  },
  circularOut: function(H) {
    return Math.sqrt(1 - --H * H);
  },
  circularInOut: function(H) {
    return (H *= 2) < 1 ? -0.5 * (Math.sqrt(1 - H * H) - 1) : 0.5 * (Math.sqrt(1 - (H -= 2) * H) + 1);
  },
  elasticIn: function(H) {
    var C, G = 0.1, U = 0.4;
    return H === 0 ? 0 : H === 1 ? 1 : (!G || G < 1 ? (G = 1, C = U / 4) : C = U * Math.asin(1 / G) / (2 * Math.PI), -(G * Math.pow(2, 10 * (H -= 1)) * Math.sin((H - C) * (2 * Math.PI) / U)));
  },
  elasticOut: function(H) {
    var C, G = 0.1, U = 0.4;
    return H === 0 ? 0 : H === 1 ? 1 : (!G || G < 1 ? (G = 1, C = U / 4) : C = U * Math.asin(1 / G) / (2 * Math.PI), G * Math.pow(2, -10 * H) * Math.sin((H - C) * (2 * Math.PI) / U) + 1);
  },
  elasticInOut: function(H) {
    var C, G = 0.1, U = 0.4;
    return H === 0 ? 0 : H === 1 ? 1 : (!G || G < 1 ? (G = 1, C = U / 4) : C = U * Math.asin(1 / G) / (2 * Math.PI), (H *= 2) < 1 ? -0.5 * (G * Math.pow(2, 10 * (H -= 1)) * Math.sin((H - C) * (2 * Math.PI) / U)) : G * Math.pow(2, -10 * (H -= 1)) * Math.sin((H - C) * (2 * Math.PI) / U) * 0.5 + 1);
  },
  backIn: function(H) {
    var C = 1.70158;
    return H * H * ((C + 1) * H - C);
  },
  backOut: function(H) {
    var C = 1.70158;
    return --H * H * ((C + 1) * H + C) + 1;
  },
  backInOut: function(H) {
    var C = 2.5949095;
    return (H *= 2) < 1 ? 0.5 * (H * H * ((C + 1) * H - C)) : 0.5 * ((H -= 2) * H * ((C + 1) * H + C) + 2);
  },
  bounceIn: function(H) {
    return 1 - easingFuncs.bounceOut(1 - H);
  },
  bounceOut: function(H) {
    return H < 1 / 2.75 ? 7.5625 * H * H : H < 2 / 2.75 ? 7.5625 * (H -= 1.5 / 2.75) * H + 0.75 : H < 2.5 / 2.75 ? 7.5625 * (H -= 2.25 / 2.75) * H + 0.9375 : 7.5625 * (H -= 2.625 / 2.75) * H + 0.984375;
  },
  bounceInOut: function(H) {
    return H < 0.5 ? easingFuncs.bounceIn(H * 2) * 0.5 : easingFuncs.bounceOut(H * 2 - 1) * 0.5 + 0.5;
  }
};
const easingFuncs$1 = easingFuncs;
var mathPow$2 = Math.pow, mathSqrt$3 = Math.sqrt, EPSILON$4 = 1e-8, EPSILON_NUMERIC = 1e-4, THREE_SQRT = mathSqrt$3(3), ONE_THIRD = 1 / 3, _v0 = create$2(), _v1 = create$2(), _v2 = create$2();
function isAroundZero$1(H) {
  return H > -EPSILON$4 && H < EPSILON$4;
}
function isNotAroundZero$1(H) {
  return H > EPSILON$4 || H < -EPSILON$4;
}
function cubicAt(H, C, G, U, K) {
  var W = 1 - K;
  return W * W * (W * H + 3 * K * C) + K * K * (K * U + 3 * W * G);
}
function cubicDerivativeAt(H, C, G, U, K) {
  var W = 1 - K;
  return 3 * (((C - H) * W + 2 * (G - C) * K) * W + (U - G) * K * K);
}
function cubicRootAt(H, C, G, U, K, W) {
  var Z = U + 3 * (C - G) - H, X = 3 * (G - C * 2 + H), Q = 3 * (C - H), ee = H - K, te = X * X - 3 * Z * Q, re = X * Q - 9 * Z * ee, ne = Q * Q - 3 * X * ee, ae = 0;
  if (isAroundZero$1(te) && isAroundZero$1(re))
    if (isAroundZero$1(X))
      W[0] = 0;
    else {
      var ie = -Q / X;
      ie >= 0 && ie <= 1 && (W[ae++] = ie);
    }
  else {
    var se = re * re - 4 * te * ne;
    if (isAroundZero$1(se)) {
      var oe = re / te, ie = -X / Z + oe, le = -oe / 2;
      ie >= 0 && ie <= 1 && (W[ae++] = ie), le >= 0 && le <= 1 && (W[ae++] = le);
    } else if (se > 0) {
      var ue = mathSqrt$3(se), ce = te * X + 1.5 * Z * (-re + ue), de = te * X + 1.5 * Z * (-re - ue);
      ce < 0 ? ce = -mathPow$2(-ce, ONE_THIRD) : ce = mathPow$2(ce, ONE_THIRD), de < 0 ? de = -mathPow$2(-de, ONE_THIRD) : de = mathPow$2(de, ONE_THIRD);
      var ie = (-X - (ce + de)) / (3 * Z);
      ie >= 0 && ie <= 1 && (W[ae++] = ie);
    } else {
      var ge = (2 * te * X - 3 * Z * re) / (2 * mathSqrt$3(te * te * te)), fe = Math.acos(ge) / 3, ve = mathSqrt$3(te), pe = Math.cos(fe), ie = (-X - 2 * ve * pe) / (3 * Z), le = (-X + ve * (pe + THREE_SQRT * Math.sin(fe))) / (3 * Z), he = (-X + ve * (pe - THREE_SQRT * Math.sin(fe))) / (3 * Z);
      ie >= 0 && ie <= 1 && (W[ae++] = ie), le >= 0 && le <= 1 && (W[ae++] = le), he >= 0 && he <= 1 && (W[ae++] = he);
    }
  }
  return ae;
}
function cubicExtrema(H, C, G, U, K) {
  var W = 6 * G - 12 * C + 6 * H, Z = 9 * C + 3 * U - 3 * H - 9 * G, X = 3 * C - 3 * H, Q = 0;
  if (isAroundZero$1(Z)) {
    if (isNotAroundZero$1(W)) {
      var ee = -X / W;
      ee >= 0 && ee <= 1 && (K[Q++] = ee);
    }
  } else {
    var te = W * W - 4 * Z * X;
    if (isAroundZero$1(te))
      K[0] = -W / (2 * Z);
    else if (te > 0) {
      var re = mathSqrt$3(te), ee = (-W + re) / (2 * Z), ne = (-W - re) / (2 * Z);
      ee >= 0 && ee <= 1 && (K[Q++] = ee), ne >= 0 && ne <= 1 && (K[Q++] = ne);
    }
  }
  return Q;
}
function cubicSubdivide(H, C, G, U, K, W) {
  var Z = (C - H) * K + H, X = (G - C) * K + C, Q = (U - G) * K + G, ee = (X - Z) * K + Z, te = (Q - X) * K + X, re = (te - ee) * K + ee;
  W[0] = H, W[1] = Z, W[2] = ee, W[3] = re, W[4] = re, W[5] = te, W[6] = Q, W[7] = U;
}
function cubicProjectPoint(H, C, G, U, K, W, Z, X, Q, ee, te) {
  var re, ne = 5e-3, ae = 1 / 0, ie, se, oe, le;
  _v0[0] = Q, _v0[1] = ee;
  for (var ue = 0; ue < 1; ue += 0.05)
    _v1[0] = cubicAt(H, G, K, Z, ue), _v1[1] = cubicAt(C, U, W, X, ue), oe = distSquare(_v0, _v1), oe < ae && (re = ue, ae = oe);
  ae = 1 / 0;
  for (var ce = 0; ce < 32 && !(ne < EPSILON_NUMERIC); ce++)
    ie = re - ne, se = re + ne, _v1[0] = cubicAt(H, G, K, Z, ie), _v1[1] = cubicAt(C, U, W, X, ie), oe = distSquare(_v1, _v0), ie >= 0 && oe < ae ? (re = ie, ae = oe) : (_v2[0] = cubicAt(H, G, K, Z, se), _v2[1] = cubicAt(C, U, W, X, se), le = distSquare(_v2, _v0), se <= 1 && le < ae ? (re = se, ae = le) : ne *= 0.5);
  return te && (te[0] = cubicAt(H, G, K, Z, re), te[1] = cubicAt(C, U, W, X, re)), mathSqrt$3(ae);
}
function cubicLength(H, C, G, U, K, W, Z, X, Q) {
  for (var ee = H, te = C, re = 0, ne = 1 / Q, ae = 1; ae <= Q; ae++) {
    var ie = ae * ne, se = cubicAt(H, G, K, Z, ie), oe = cubicAt(C, U, W, X, ie), le = se - ee, ue = oe - te;
    re += Math.sqrt(le * le + ue * ue), ee = se, te = oe;
  }
  return re;
}
function quadraticAt$1(H, C, G, U) {
  var K = 1 - U;
  return K * (K * H + 2 * U * C) + U * U * G;
}
function quadraticDerivativeAt(H, C, G, U) {
  return 2 * ((1 - U) * (C - H) + U * (G - C));
}
function quadraticRootAt(H, C, G, U, K) {
  var W = H - 2 * C + G, Z = 2 * (C - H), X = H - U, Q = 0;
  if (isAroundZero$1(W)) {
    if (isNotAroundZero$1(Z)) {
      var ee = -X / Z;
      ee >= 0 && ee <= 1 && (K[Q++] = ee);
    }
  } else {
    var te = Z * Z - 4 * W * X;
    if (isAroundZero$1(te)) {
      var ee = -Z / (2 * W);
      ee >= 0 && ee <= 1 && (K[Q++] = ee);
    } else if (te > 0) {
      var re = mathSqrt$3(te), ee = (-Z + re) / (2 * W), ne = (-Z - re) / (2 * W);
      ee >= 0 && ee <= 1 && (K[Q++] = ee), ne >= 0 && ne <= 1 && (K[Q++] = ne);
    }
  }
  return Q;
}
function quadraticExtremum(H, C, G) {
  var U = H + G - 2 * C;
  return U === 0 ? 0.5 : (H - C) / U;
}
function quadraticSubdivide(H, C, G, U, K) {
  var W = (C - H) * U + H, Z = (G - C) * U + C, X = (Z - W) * U + W;
  K[0] = H, K[1] = W, K[2] = X, K[3] = X, K[4] = Z, K[5] = G;
}
function quadraticProjectPoint(H, C, G, U, K, W, Z, X, Q) {
  var ee, te = 5e-3, re = 1 / 0;
  _v0[0] = Z, _v0[1] = X;
  for (var ne = 0; ne < 1; ne += 0.05) {
    _v1[0] = quadraticAt$1(H, G, K, ne), _v1[1] = quadraticAt$1(C, U, W, ne);
    var ae = distSquare(_v0, _v1);
    ae < re && (ee = ne, re = ae);
  }
  re = 1 / 0;
  for (var ie = 0; ie < 32 && !(te < EPSILON_NUMERIC); ie++) {
    var se = ee - te, oe = ee + te;
    _v1[0] = quadraticAt$1(H, G, K, se), _v1[1] = quadraticAt$1(C, U, W, se);
    var ae = distSquare(_v1, _v0);
    if (se >= 0 && ae < re)
      ee = se, re = ae;
    else {
      _v2[0] = quadraticAt$1(H, G, K, oe), _v2[1] = quadraticAt$1(C, U, W, oe);
      var le = distSquare(_v2, _v0);
      oe <= 1 && le < re ? (ee = oe, re = le) : te *= 0.5;
    }
  }
  return Q && (Q[0] = quadraticAt$1(H, G, K, ee), Q[1] = quadraticAt$1(C, U, W, ee)), mathSqrt$3(re);
}
function quadraticLength(H, C, G, U, K, W, Z) {
  for (var X = H, Q = C, ee = 0, te = 1 / Z, re = 1; re <= Z; re++) {
    var ne = re * te, ae = quadraticAt$1(H, G, K, ne), ie = quadraticAt$1(C, U, W, ne), se = ae - X, oe = ie - Q;
    ee += Math.sqrt(se * se + oe * oe), X = ae, Q = ie;
  }
  return ee;
}
var regexp = /cubic-bezier\(([0-9,\.e ]+)\)/;
function createCubicEasingFunc(H) {
  var C = H && regexp.exec(H);
  if (C) {
    var G = C[1].split(","), U = +trim$1(G[0]), K = +trim$1(G[1]), W = +trim$1(G[2]), Z = +trim$1(G[3]);
    if (isNaN(U + K + W + Z))
      return;
    var X = [];
    return function(Q) {
      return Q <= 0 ? 0 : Q >= 1 ? 1 : cubicRootAt(0, U, W, 1, Q, X) && cubicAt(0, K, Z, 1, X[0]);
    };
  }
}
var Clip = function() {
  function H(C) {
    this._inited = !1, this._startTime = 0, this._pausedTime = 0, this._paused = !1, this._life = C.life || 1e3, this._delay = C.delay || 0, this.loop = C.loop || !1, this.onframe = C.onframe || noop, this.ondestroy = C.ondestroy || noop, this.onrestart = C.onrestart || noop, C.easing && this.setEasing(C.easing);
  }
  return H.prototype.step = function(C, G) {
    if (this._inited || (this._startTime = C + this._delay, this._inited = !0), this._paused) {
      this._pausedTime += G;
      return;
    }
    var U = this._life, K = C - this._startTime - this._pausedTime, W = K / U;
    W < 0 && (W = 0), W = Math.min(W, 1);
    var Z = this.easingFunc, X = Z ? Z(W) : W;
    if (this.onframe(X), W === 1)
      if (this.loop) {
        var Q = K % U;
        this._startTime = C - Q, this._pausedTime = 0, this.onrestart();
      } else
        return !0;
    return !1;
  }, H.prototype.pause = function() {
    this._paused = !0;
  }, H.prototype.resume = function() {
    this._paused = !1;
  }, H.prototype.setEasing = function(C) {
    this.easing = C, this.easingFunc = isFunction(C) ? C : easingFuncs$1[C] || createCubicEasingFunc(C);
  }, H;
}();
const Clip$1 = Clip;
var Entry = function() {
  function H(C) {
    this.value = C;
  }
  return H;
}(), LinkedList = function() {
  function H() {
    this._len = 0;
  }
  return H.prototype.insert = function(C) {
    var G = new Entry(C);
    return this.insertEntry(G), G;
  }, H.prototype.insertEntry = function(C) {
    this.head ? (this.tail.next = C, C.prev = this.tail, C.next = null, this.tail = C) : this.head = this.tail = C, this._len++;
  }, H.prototype.remove = function(C) {
    var G = C.prev, U = C.next;
    G ? G.next = U : this.head = U, U ? U.prev = G : this.tail = G, C.next = C.prev = null, this._len--;
  }, H.prototype.len = function() {
    return this._len;
  }, H.prototype.clear = function() {
    this.head = this.tail = null, this._len = 0;
  }, H;
}(), LRU = function() {
  function H(C) {
    this._list = new LinkedList(), this._maxSize = 10, this._map = {}, this._maxSize = C;
  }
  return H.prototype.put = function(C, G) {
    var U = this._list, K = this._map, W = null;
    if (K[C] == null) {
      var Z = U.len(), X = this._lastRemovedEntry;
      if (Z >= this._maxSize && Z > 0) {
        var Q = U.head;
        U.remove(Q), delete K[Q.key], W = Q.value, this._lastRemovedEntry = Q;
      }
      X ? X.value = G : X = new Entry(G), X.key = C, U.insertEntry(X), K[C] = X;
    }
    return W;
  }, H.prototype.get = function(C) {
    var G = this._map[C], U = this._list;
    if (G != null)
      return G !== U.tail && (U.remove(G), U.insertEntry(G)), G.value;
  }, H.prototype.clear = function() {
    this._list.clear(), this._map = {};
  }, H.prototype.len = function() {
    return this._list.len();
  }, H;
}();
const LRU$1 = LRU;
var kCSSColorTable = {
  transparent: [0, 0, 0, 0],
  aliceblue: [240, 248, 255, 1],
  antiquewhite: [250, 235, 215, 1],
  aqua: [0, 255, 255, 1],
  aquamarine: [127, 255, 212, 1],
  azure: [240, 255, 255, 1],
  beige: [245, 245, 220, 1],
  bisque: [255, 228, 196, 1],
  black: [0, 0, 0, 1],
  blanchedalmond: [255, 235, 205, 1],
  blue: [0, 0, 255, 1],
  blueviolet: [138, 43, 226, 1],
  brown: [165, 42, 42, 1],
  burlywood: [222, 184, 135, 1],
  cadetblue: [95, 158, 160, 1],
  chartreuse: [127, 255, 0, 1],
  chocolate: [210, 105, 30, 1],
  coral: [255, 127, 80, 1],
  cornflowerblue: [100, 149, 237, 1],
  cornsilk: [255, 248, 220, 1],
  crimson: [220, 20, 60, 1],
  cyan: [0, 255, 255, 1],
  darkblue: [0, 0, 139, 1],
  darkcyan: [0, 139, 139, 1],
  darkgoldenrod: [184, 134, 11, 1],
  darkgray: [169, 169, 169, 1],
  darkgreen: [0, 100, 0, 1],
  darkgrey: [169, 169, 169, 1],
  darkkhaki: [189, 183, 107, 1],
  darkmagenta: [139, 0, 139, 1],
  darkolivegreen: [85, 107, 47, 1],
  darkorange: [255, 140, 0, 1],
  darkorchid: [153, 50, 204, 1],
  darkred: [139, 0, 0, 1],
  darksalmon: [233, 150, 122, 1],
  darkseagreen: [143, 188, 143, 1],
  darkslateblue: [72, 61, 139, 1],
  darkslategray: [47, 79, 79, 1],
  darkslategrey: [47, 79, 79, 1],
  darkturquoise: [0, 206, 209, 1],
  darkviolet: [148, 0, 211, 1],
  deeppink: [255, 20, 147, 1],
  deepskyblue: [0, 191, 255, 1],
  dimgray: [105, 105, 105, 1],
  dimgrey: [105, 105, 105, 1],
  dodgerblue: [30, 144, 255, 1],
  firebrick: [178, 34, 34, 1],
  floralwhite: [255, 250, 240, 1],
  forestgreen: [34, 139, 34, 1],
  fuchsia: [255, 0, 255, 1],
  gainsboro: [220, 220, 220, 1],
  ghostwhite: [248, 248, 255, 1],
  gold: [255, 215, 0, 1],
  goldenrod: [218, 165, 32, 1],
  gray: [128, 128, 128, 1],
  green: [0, 128, 0, 1],
  greenyellow: [173, 255, 47, 1],
  grey: [128, 128, 128, 1],
  honeydew: [240, 255, 240, 1],
  hotpink: [255, 105, 180, 1],
  indianred: [205, 92, 92, 1],
  indigo: [75, 0, 130, 1],
  ivory: [255, 255, 240, 1],
  khaki: [240, 230, 140, 1],
  lavender: [230, 230, 250, 1],
  lavenderblush: [255, 240, 245, 1],
  lawngreen: [124, 252, 0, 1],
  lemonchiffon: [255, 250, 205, 1],
  lightblue: [173, 216, 230, 1],
  lightcoral: [240, 128, 128, 1],
  lightcyan: [224, 255, 255, 1],
  lightgoldenrodyellow: [250, 250, 210, 1],
  lightgray: [211, 211, 211, 1],
  lightgreen: [144, 238, 144, 1],
  lightgrey: [211, 211, 211, 1],
  lightpink: [255, 182, 193, 1],
  lightsalmon: [255, 160, 122, 1],
  lightseagreen: [32, 178, 170, 1],
  lightskyblue: [135, 206, 250, 1],
  lightslategray: [119, 136, 153, 1],
  lightslategrey: [119, 136, 153, 1],
  lightsteelblue: [176, 196, 222, 1],
  lightyellow: [255, 255, 224, 1],
  lime: [0, 255, 0, 1],
  limegreen: [50, 205, 50, 1],
  linen: [250, 240, 230, 1],
  magenta: [255, 0, 255, 1],
  maroon: [128, 0, 0, 1],
  mediumaquamarine: [102, 205, 170, 1],
  mediumblue: [0, 0, 205, 1],
  mediumorchid: [186, 85, 211, 1],
  mediumpurple: [147, 112, 219, 1],
  mediumseagreen: [60, 179, 113, 1],
  mediumslateblue: [123, 104, 238, 1],
  mediumspringgreen: [0, 250, 154, 1],
  mediumturquoise: [72, 209, 204, 1],
  mediumvioletred: [199, 21, 133, 1],
  midnightblue: [25, 25, 112, 1],
  mintcream: [245, 255, 250, 1],
  mistyrose: [255, 228, 225, 1],
  moccasin: [255, 228, 181, 1],
  navajowhite: [255, 222, 173, 1],
  navy: [0, 0, 128, 1],
  oldlace: [253, 245, 230, 1],
  olive: [128, 128, 0, 1],
  olivedrab: [107, 142, 35, 1],
  orange: [255, 165, 0, 1],
  orangered: [255, 69, 0, 1],
  orchid: [218, 112, 214, 1],
  palegoldenrod: [238, 232, 170, 1],
  palegreen: [152, 251, 152, 1],
  paleturquoise: [175, 238, 238, 1],
  palevioletred: [219, 112, 147, 1],
  papayawhip: [255, 239, 213, 1],
  peachpuff: [255, 218, 185, 1],
  peru: [205, 133, 63, 1],
  pink: [255, 192, 203, 1],
  plum: [221, 160, 221, 1],
  powderblue: [176, 224, 230, 1],
  purple: [128, 0, 128, 1],
  red: [255, 0, 0, 1],
  rosybrown: [188, 143, 143, 1],
  royalblue: [65, 105, 225, 1],
  saddlebrown: [139, 69, 19, 1],
  salmon: [250, 128, 114, 1],
  sandybrown: [244, 164, 96, 1],
  seagreen: [46, 139, 87, 1],
  seashell: [255, 245, 238, 1],
  sienna: [160, 82, 45, 1],
  silver: [192, 192, 192, 1],
  skyblue: [135, 206, 235, 1],
  slateblue: [106, 90, 205, 1],
  slategray: [112, 128, 144, 1],
  slategrey: [112, 128, 144, 1],
  snow: [255, 250, 250, 1],
  springgreen: [0, 255, 127, 1],
  steelblue: [70, 130, 180, 1],
  tan: [210, 180, 140, 1],
  teal: [0, 128, 128, 1],
  thistle: [216, 191, 216, 1],
  tomato: [255, 99, 71, 1],
  turquoise: [64, 224, 208, 1],
  violet: [238, 130, 238, 1],
  wheat: [245, 222, 179, 1],
  white: [255, 255, 255, 1],
  whitesmoke: [245, 245, 245, 1],
  yellow: [255, 255, 0, 1],
  yellowgreen: [154, 205, 50, 1]
};
function clampCssByte(H) {
  return H = Math.round(H), H < 0 ? 0 : H > 255 ? 255 : H;
}
function clampCssAngle(H) {
  return H = Math.round(H), H < 0 ? 0 : H > 360 ? 360 : H;
}
function clampCssFloat(H) {
  return H < 0 ? 0 : H > 1 ? 1 : H;
}
function parseCssInt(H) {
  var C = H;
  return C.length && C.charAt(C.length - 1) === "%" ? clampCssByte(parseFloat(C) / 100 * 255) : clampCssByte(parseInt(C, 10));
}
function parseCssFloat(H) {
  var C = H;
  return C.length && C.charAt(C.length - 1) === "%" ? clampCssFloat(parseFloat(C) / 100) : clampCssFloat(parseFloat(C));
}
function cssHueToRgb(H, C, G) {
  return G < 0 ? G += 1 : G > 1 && (G -= 1), G * 6 < 1 ? H + (C - H) * G * 6 : G * 2 < 1 ? C : G * 3 < 2 ? H + (C - H) * (2 / 3 - G) * 6 : H;
}
function lerpNumber(H, C, G) {
  return H + (C - H) * G;
}
function setRgba(H, C, G, U, K) {
  return H[0] = C, H[1] = G, H[2] = U, H[3] = K, H;
}
function copyRgba(H, C) {
  return H[0] = C[0], H[1] = C[1], H[2] = C[2], H[3] = C[3], H;
}
var colorCache = new LRU$1(20), lastRemovedArr = null;
function putToCache(H, C) {
  lastRemovedArr && copyRgba(lastRemovedArr, C), lastRemovedArr = colorCache.put(H, lastRemovedArr || C.slice());
}
function parse(H, C) {
  if (H) {
    C = C || [];
    var G = colorCache.get(H);
    if (G)
      return copyRgba(C, G);
    H = H + "";
    var U = H.replace(/ /g, "").toLowerCase();
    if (U in kCSSColorTable)
      return copyRgba(C, kCSSColorTable[U]), putToCache(H, C), C;
    var K = U.length;
    if (U.charAt(0) === "#") {
      if (K === 4 || K === 5) {
        var W = parseInt(U.slice(1, 4), 16);
        if (!(W >= 0 && W <= 4095)) {
          setRgba(C, 0, 0, 0, 1);
          return;
        }
        return setRgba(C, (W & 3840) >> 4 | (W & 3840) >> 8, W & 240 | (W & 240) >> 4, W & 15 | (W & 15) << 4, K === 5 ? parseInt(U.slice(4), 16) / 15 : 1), putToCache(H, C), C;
      } else if (K === 7 || K === 9) {
        var W = parseInt(U.slice(1, 7), 16);
        if (!(W >= 0 && W <= 16777215)) {
          setRgba(C, 0, 0, 0, 1);
          return;
        }
        return setRgba(C, (W & 16711680) >> 16, (W & 65280) >> 8, W & 255, K === 9 ? parseInt(U.slice(7), 16) / 255 : 1), putToCache(H, C), C;
      }
      return;
    }
    var Z = U.indexOf("("), X = U.indexOf(")");
    if (Z !== -1 && X + 1 === K) {
      var Q = U.substr(0, Z), ee = U.substr(Z + 1, X - (Z + 1)).split(","), te = 1;
      switch (Q) {
        case "rgba":
          if (ee.length !== 4)
            return ee.length === 3 ? setRgba(C, +ee[0], +ee[1], +ee[2], 1) : setRgba(C, 0, 0, 0, 1);
          te = parseCssFloat(ee.pop());
        case "rgb":
          if (ee.length >= 3)
            return setRgba(C, parseCssInt(ee[0]), parseCssInt(ee[1]), parseCssInt(ee[2]), ee.length === 3 ? te : parseCssFloat(ee[3])), putToCache(H, C), C;
          setRgba(C, 0, 0, 0, 1);
          return;
        case "hsla":
          if (ee.length !== 4) {
            setRgba(C, 0, 0, 0, 1);
            return;
          }
          return ee[3] = parseCssFloat(ee[3]), hsla2rgba(ee, C), putToCache(H, C), C;
        case "hsl":
          if (ee.length !== 3) {
            setRgba(C, 0, 0, 0, 1);
            return;
          }
          return hsla2rgba(ee, C), putToCache(H, C), C;
        default:
          return;
      }
    }
    setRgba(C, 0, 0, 0, 1);
  }
}
function hsla2rgba(H, C) {
  var G = (parseFloat(H[0]) % 360 + 360) % 360 / 360, U = parseCssFloat(H[1]), K = parseCssFloat(H[2]), W = K <= 0.5 ? K * (U + 1) : K + U - K * U, Z = K * 2 - W;
  return C = C || [], setRgba(C, clampCssByte(cssHueToRgb(Z, W, G + 1 / 3) * 255), clampCssByte(cssHueToRgb(Z, W, G) * 255), clampCssByte(cssHueToRgb(Z, W, G - 1 / 3) * 255), 1), H.length === 4 && (C[3] = H[3]), C;
}
function rgba2hsla(H) {
  if (H) {
    var C = H[0] / 255, G = H[1] / 255, U = H[2] / 255, K = Math.min(C, G, U), W = Math.max(C, G, U), Z = W - K, X = (W + K) / 2, Q, ee;
    if (Z === 0)
      Q = 0, ee = 0;
    else {
      X < 0.5 ? ee = Z / (W + K) : ee = Z / (2 - W - K);
      var te = ((W - C) / 6 + Z / 2) / Z, re = ((W - G) / 6 + Z / 2) / Z, ne = ((W - U) / 6 + Z / 2) / Z;
      C === W ? Q = ne - re : G === W ? Q = 1 / 3 + te - ne : U === W && (Q = 2 / 3 + re - te), Q < 0 && (Q += 1), Q > 1 && (Q -= 1);
    }
    var ae = [Q * 360, ee, X];
    return H[3] != null && ae.push(H[3]), ae;
  }
}
function lift(H, C) {
  var G = parse(H);
  if (G) {
    for (var U = 0; U < 3; U++)
      C < 0 ? G[U] = G[U] * (1 - C) | 0 : G[U] = (255 - G[U]) * C + G[U] | 0, G[U] > 255 ? G[U] = 255 : G[U] < 0 && (G[U] = 0);
    return stringify(G, G.length === 4 ? "rgba" : "rgb");
  }
}
function fastLerp(H, C, G) {
  if (!(!(C && C.length) || !(H >= 0 && H <= 1))) {
    G = G || [];
    var U = H * (C.length - 1), K = Math.floor(U), W = Math.ceil(U), Z = C[K], X = C[W], Q = U - K;
    return G[0] = clampCssByte(lerpNumber(Z[0], X[0], Q)), G[1] = clampCssByte(lerpNumber(Z[1], X[1], Q)), G[2] = clampCssByte(lerpNumber(Z[2], X[2], Q)), G[3] = clampCssFloat(lerpNumber(Z[3], X[3], Q)), G;
  }
}
function lerp(H, C, G) {
  if (!(!(C && C.length) || !(H >= 0 && H <= 1))) {
    var U = H * (C.length - 1), K = Math.floor(U), W = Math.ceil(U), Z = parse(C[K]), X = parse(C[W]), Q = U - K, ee = stringify([
      clampCssByte(lerpNumber(Z[0], X[0], Q)),
      clampCssByte(lerpNumber(Z[1], X[1], Q)),
      clampCssByte(lerpNumber(Z[2], X[2], Q)),
      clampCssFloat(lerpNumber(Z[3], X[3], Q))
    ], "rgba");
    return G ? {
      color: ee,
      leftIndex: K,
      rightIndex: W,
      value: U
    } : ee;
  }
}
function modifyHSL(H, C, G, U) {
  var K = parse(H);
  if (H)
    return K = rgba2hsla(K), C != null && (K[0] = clampCssAngle(C)), G != null && (K[1] = parseCssFloat(G)), U != null && (K[2] = parseCssFloat(U)), stringify(hsla2rgba(K), "rgba");
}
function modifyAlpha(H, C) {
  var G = parse(H);
  if (G && C != null)
    return G[3] = clampCssFloat(C), stringify(G, "rgba");
}
function stringify(H, C) {
  if (!(!H || !H.length)) {
    var G = H[0] + "," + H[1] + "," + H[2];
    return (C === "rgba" || C === "hsva" || C === "hsla") && (G += "," + H[3]), C + "(" + G + ")";
  }
}
function lum(H, C) {
  var G = parse(H);
  return G ? (0.299 * G[0] + 0.587 * G[1] + 0.114 * G[2]) * G[3] / 255 + (1 - G[3]) * C : 0;
}
var mathRound$1 = Math.round;
function normalizeColor(H) {
  var C;
  if (!H || H === "transparent")
    H = "none";
  else if (typeof H == "string" && H.indexOf("rgba") > -1) {
    var G = parse(H);
    G && (H = "rgb(" + G[0] + "," + G[1] + "," + G[2] + ")", C = G[3]);
  }
  return {
    color: H,
    opacity: C ?? 1
  };
}
var EPSILON$3 = 1e-4;
function isAroundZero(H) {
  return H < EPSILON$3 && H > -EPSILON$3;
}
function round3(H) {
  return mathRound$1(H * 1e3) / 1e3;
}
function round4(H) {
  return mathRound$1(H * 1e4) / 1e4;
}
function getMatrixStr(H) {
  return "matrix(" + round3(H[0]) + "," + round3(H[1]) + "," + round3(H[2]) + "," + round3(H[3]) + "," + round4(H[4]) + "," + round4(H[5]) + ")";
}
var TEXT_ALIGN_TO_ANCHOR = {
  left: "start",
  right: "end",
  center: "middle",
  middle: "middle"
};
function adjustTextY$1(H, C, G) {
  return G === "top" ? H += C / 2 : G === "bottom" && (H -= C / 2), H;
}
function hasShadow(H) {
  return H && (H.shadowBlur || H.shadowOffsetX || H.shadowOffsetY);
}
function getShadowKey(H) {
  var C = H.style, G = H.getGlobalScale();
  return [
    C.shadowColor,
    (C.shadowBlur || 0).toFixed(2),
    (C.shadowOffsetX || 0).toFixed(2),
    (C.shadowOffsetY || 0).toFixed(2),
    G[0],
    G[1]
  ].join(",");
}
function isImagePattern(H) {
  return H && !!H.image;
}
function isSVGPattern(H) {
  return H && !!H.svgElement;
}
function isPattern(H) {
  return isImagePattern(H) || isSVGPattern(H);
}
function isLinearGradient(H) {
  return H.type === "linear";
}
function isRadialGradient(H) {
  return H.type === "radial";
}
function isGradient(H) {
  return H && (H.type === "linear" || H.type === "radial");
}
function getIdURL(H) {
  return "url(#" + H + ")";
}
function getPathPrecision(H) {
  var C = H.getGlobalScale(), G = Math.max(C[0], C[1]);
  return Math.max(Math.ceil(Math.log(G) / Math.log(10)), 1);
}
function getSRTTransformString(H) {
  var C = H.x || 0, G = H.y || 0, U = (H.rotation || 0) * RADIAN_TO_DEGREE, K = retrieve2(H.scaleX, 1), W = retrieve2(H.scaleY, 1), Z = H.skewX || 0, X = H.skewY || 0, Q = [];
  return (C || G) && Q.push("translate(" + C + "px," + G + "px)"), U && Q.push("rotate(" + U + ")"), (K !== 1 || W !== 1) && Q.push("scale(" + K + "," + W + ")"), (Z || X) && Q.push("skew(" + mathRound$1(Z * RADIAN_TO_DEGREE) + "deg, " + mathRound$1(X * RADIAN_TO_DEGREE) + "deg)"), Q.join(" ");
}
var encodeBase64 = function() {
  return env$1.hasGlobalWindow && isFunction(window.btoa) ? function(H) {
    return window.btoa(unescape(encodeURIComponent(H)));
  } : typeof Buffer < "u" ? function(H) {
    return Buffer.from(H).toString("base64");
  } : function(H) {
    return process.env.NODE_ENV !== "production" && logError("Base64 isn't natively supported in the current environment."), null;
  };
}(), arraySlice = Array.prototype.slice;
function interpolateNumber$1(H, C, G) {
  return (C - H) * G + H;
}
function interpolate1DArray(H, C, G, U) {
  for (var K = C.length, W = 0; W < K; W++)
    H[W] = interpolateNumber$1(C[W], G[W], U);
  return H;
}
function interpolate2DArray(H, C, G, U) {
  for (var K = C.length, W = K && C[0].length, Z = 0; Z < K; Z++) {
    H[Z] || (H[Z] = []);
    for (var X = 0; X < W; X++)
      H[Z][X] = interpolateNumber$1(C[Z][X], G[Z][X], U);
  }
  return H;
}
function add1DArray(H, C, G, U) {
  for (var K = C.length, W = 0; W < K; W++)
    H[W] = C[W] + G[W] * U;
  return H;
}
function add2DArray(H, C, G, U) {
  for (var K = C.length, W = K && C[0].length, Z = 0; Z < K; Z++) {
    H[Z] || (H[Z] = []);
    for (var X = 0; X < W; X++)
      H[Z][X] = C[Z][X] + G[Z][X] * U;
  }
  return H;
}
function fillColorStops(H, C) {
  for (var G = H.length, U = C.length, K = G > U ? C : H, W = Math.min(G, U), Z = K[W - 1] || { color: [0, 0, 0, 0], offset: 0 }, X = W; X < Math.max(G, U); X++)
    K.push({
      offset: Z.offset,
      color: Z.color.slice()
    });
}
function fillArray(H, C, G) {
  var U = H, K = C;
  if (!(!U.push || !K.push)) {
    var W = U.length, Z = K.length;
    if (W !== Z) {
      var X = W > Z;
      if (X)
        U.length = Z;
      else
        for (var Q = W; Q < Z; Q++)
          U.push(G === 1 ? K[Q] : arraySlice.call(K[Q]));
    }
    for (var ee = U[0] && U[0].length, Q = 0; Q < U.length; Q++)
      if (G === 1)
        isNaN(U[Q]) && (U[Q] = K[Q]);
      else
        for (var te = 0; te < ee; te++)
          isNaN(U[Q][te]) && (U[Q][te] = K[Q][te]);
  }
}
function cloneValue(H) {
  if (isArrayLike(H)) {
    var C = H.length;
    if (isArrayLike(H[0])) {
      for (var G = [], U = 0; U < C; U++)
        G.push(arraySlice.call(H[U]));
      return G;
    }
    return arraySlice.call(H);
  }
  return H;
}
function rgba2String(H) {
  return H[0] = Math.floor(H[0]) || 0, H[1] = Math.floor(H[1]) || 0, H[2] = Math.floor(H[2]) || 0, H[3] = H[3] == null ? 1 : H[3], "rgba(" + H.join(",") + ")";
}
function guessArrayDim(H) {
  return isArrayLike(H && H[0]) ? 2 : 1;
}
var VALUE_TYPE_NUMBER = 0, VALUE_TYPE_1D_ARRAY = 1, VALUE_TYPE_2D_ARRAY = 2, VALUE_TYPE_COLOR = 3, VALUE_TYPE_LINEAR_GRADIENT = 4, VALUE_TYPE_RADIAL_GRADIENT = 5, VALUE_TYPE_UNKOWN = 6;
function isGradientValueType(H) {
  return H === VALUE_TYPE_LINEAR_GRADIENT || H === VALUE_TYPE_RADIAL_GRADIENT;
}
function isArrayValueType(H) {
  return H === VALUE_TYPE_1D_ARRAY || H === VALUE_TYPE_2D_ARRAY;
}
var tmpRgba = [0, 0, 0, 0], Track = function() {
  function H(C) {
    this.keyframes = [], this.discrete = !1, this._invalid = !1, this._needsSort = !1, this._lastFr = 0, this._lastFrP = 0, this.propName = C;
  }
  return H.prototype.isFinished = function() {
    return this._finished;
  }, H.prototype.setFinished = function() {
    this._finished = !0, this._additiveTrack && this._additiveTrack.setFinished();
  }, H.prototype.needsAnimate = function() {
    return this.keyframes.length >= 1;
  }, H.prototype.getAdditiveTrack = function() {
    return this._additiveTrack;
  }, H.prototype.addKeyframe = function(C, G, U) {
    this._needsSort = !0;
    var K = this.keyframes, W = K.length, Z = !1, X = VALUE_TYPE_UNKOWN, Q = G;
    if (isArrayLike(G)) {
      var ee = guessArrayDim(G);
      X = ee, (ee === 1 && !isNumber(G[0]) || ee === 2 && !isNumber(G[0][0])) && (Z = !0);
    } else if (isNumber(G) && !eqNaN(G))
      X = VALUE_TYPE_NUMBER;
    else if (isString(G))
      if (!isNaN(+G))
        X = VALUE_TYPE_NUMBER;
      else {
        var te = parse(G);
        te && (Q = te, X = VALUE_TYPE_COLOR);
      }
    else if (isGradientObject(G)) {
      var re = extend({}, Q);
      re.colorStops = map$1(G.colorStops, function(ae) {
        return {
          offset: ae.offset,
          color: parse(ae.color)
        };
      }), isLinearGradient(G) ? X = VALUE_TYPE_LINEAR_GRADIENT : isRadialGradient(G) && (X = VALUE_TYPE_RADIAL_GRADIENT), Q = re;
    }
    W === 0 ? this.valType = X : (X !== this.valType || X === VALUE_TYPE_UNKOWN) && (Z = !0), this.discrete = this.discrete || Z;
    var ne = {
      time: C,
      value: Q,
      rawValue: G,
      percent: 0
    };
    return U && (ne.easing = U, ne.easingFunc = isFunction(U) ? U : easingFuncs$1[U] || createCubicEasingFunc(U)), K.push(ne), ne;
  }, H.prototype.prepare = function(C, G) {
    var U = this.keyframes;
    this._needsSort && U.sort(function(se, oe) {
      return se.time - oe.time;
    });
    for (var K = this.valType, W = U.length, Z = U[W - 1], X = this.discrete, Q = isArrayValueType(K), ee = isGradientValueType(K), te = 0; te < W; te++) {
      var re = U[te], ne = re.value, ae = Z.value;
      re.percent = re.time / C, X || (Q && te !== W - 1 ? fillArray(ne, ae, K) : ee && fillColorStops(ne.colorStops, ae.colorStops));
    }
    if (!X && K !== VALUE_TYPE_RADIAL_GRADIENT && G && this.needsAnimate() && G.needsAnimate() && K === G.valType && !G._finished) {
      this._additiveTrack = G;
      for (var ie = U[0].value, te = 0; te < W; te++)
        K === VALUE_TYPE_NUMBER ? U[te].additiveValue = U[te].value - ie : K === VALUE_TYPE_COLOR ? U[te].additiveValue = add1DArray([], U[te].value, ie, -1) : isArrayValueType(K) && (U[te].additiveValue = K === VALUE_TYPE_1D_ARRAY ? add1DArray([], U[te].value, ie, -1) : add2DArray([], U[te].value, ie, -1));
    }
  }, H.prototype.step = function(C, G) {
    if (!this._finished) {
      this._additiveTrack && this._additiveTrack._finished && (this._additiveTrack = null);
      var U = this._additiveTrack != null, K = U ? "additiveValue" : "value", W = this.valType, Z = this.keyframes, X = Z.length, Q = this.propName, ee = W === VALUE_TYPE_COLOR, te, re = this._lastFr, ne = Math.min, ae, ie;
      if (X === 1)
        ae = ie = Z[0];
      else {
        if (G < 0)
          te = 0;
        else if (G < this._lastFrP) {
          var se = ne(re + 1, X - 1);
          for (te = se; te >= 0 && !(Z[te].percent <= G); te--)
            ;
          te = ne(te, X - 2);
        } else {
          for (te = re; te < X && !(Z[te].percent > G); te++)
            ;
          te = ne(te - 1, X - 2);
        }
        ie = Z[te + 1], ae = Z[te];
      }
      if (ae && ie) {
        this._lastFr = te, this._lastFrP = G;
        var oe = ie.percent - ae.percent, le = oe === 0 ? 1 : ne((G - ae.percent) / oe, 1);
        ie.easingFunc && (le = ie.easingFunc(le));
        var ue = U ? this._additiveValue : ee ? tmpRgba : C[Q];
        if ((isArrayValueType(W) || ee) && !ue && (ue = this._additiveValue = []), this.discrete)
          C[Q] = le < 1 ? ae.rawValue : ie.rawValue;
        else if (isArrayValueType(W))
          W === VALUE_TYPE_1D_ARRAY ? interpolate1DArray(ue, ae[K], ie[K], le) : interpolate2DArray(ue, ae[K], ie[K], le);
        else if (isGradientValueType(W)) {
          var ce = ae[K], de = ie[K], ge = W === VALUE_TYPE_LINEAR_GRADIENT;
          C[Q] = {
            type: ge ? "linear" : "radial",
            x: interpolateNumber$1(ce.x, de.x, le),
            y: interpolateNumber$1(ce.y, de.y, le),
            colorStops: map$1(ce.colorStops, function(ve, pe) {
              var he = de.colorStops[pe];
              return {
                offset: interpolateNumber$1(ve.offset, he.offset, le),
                color: rgba2String(interpolate1DArray([], ve.color, he.color, le))
              };
            }),
            global: de.global
          }, ge ? (C[Q].x2 = interpolateNumber$1(ce.x2, de.x2, le), C[Q].y2 = interpolateNumber$1(ce.y2, de.y2, le)) : C[Q].r = interpolateNumber$1(ce.r, de.r, le);
        } else if (ee)
          interpolate1DArray(ue, ae[K], ie[K], le), U || (C[Q] = rgba2String(ue));
        else {
          var fe = interpolateNumber$1(ae[K], ie[K], le);
          U ? this._additiveValue = fe : C[Q] = fe;
        }
        U && this._addToTarget(C);
      }
    }
  }, H.prototype._addToTarget = function(C) {
    var G = this.valType, U = this.propName, K = this._additiveValue;
    G === VALUE_TYPE_NUMBER ? C[U] = C[U] + K : G === VALUE_TYPE_COLOR ? (parse(C[U], tmpRgba), add1DArray(tmpRgba, tmpRgba, K, 1), C[U] = rgba2String(tmpRgba)) : G === VALUE_TYPE_1D_ARRAY ? add1DArray(C[U], C[U], K, 1) : G === VALUE_TYPE_2D_ARRAY && add2DArray(C[U], C[U], K, 1);
  }, H;
}(), Animator = function() {
  function H(C, G, U, K) {
    if (this._tracks = {}, this._trackKeys = [], this._maxTime = 0, this._started = 0, this._clip = null, this._target = C, this._loop = G, G && K) {
      logError("Can' use additive animation on looped animation.");
      return;
    }
    this._additiveAnimators = K, this._allowDiscrete = U;
  }
  return H.prototype.getMaxTime = function() {
    return this._maxTime;
  }, H.prototype.getDelay = function() {
    return this._delay;
  }, H.prototype.getLoop = function() {
    return this._loop;
  }, H.prototype.getTarget = function() {
    return this._target;
  }, H.prototype.changeTarget = function(C) {
    this._target = C;
  }, H.prototype.when = function(C, G, U) {
    return this.whenWithKeys(C, G, keys(G), U);
  }, H.prototype.whenWithKeys = function(C, G, U, K) {
    for (var W = this._tracks, Z = 0; Z < U.length; Z++) {
      var X = U[Z], Q = W[X];
      if (!Q) {
        Q = W[X] = new Track(X);
        var ee = void 0, te = this._getAdditiveTrack(X);
        if (te) {
          var re = te.keyframes, ne = re[re.length - 1];
          ee = ne && ne.value, te.valType === VALUE_TYPE_COLOR && ee && (ee = rgba2String(ee));
        } else
          ee = this._target[X];
        if (ee == null)
          continue;
        C > 0 && Q.addKeyframe(0, cloneValue(ee), K), this._trackKeys.push(X);
      }
      Q.addKeyframe(C, cloneValue(G[X]), K);
    }
    return this._maxTime = Math.max(this._maxTime, C), this;
  }, H.prototype.pause = function() {
    this._clip.pause(), this._paused = !0;
  }, H.prototype.resume = function() {
    this._clip.resume(), this._paused = !1;
  }, H.prototype.isPaused = function() {
    return !!this._paused;
  }, H.prototype.duration = function(C) {
    return this._maxTime = C, this._force = !0, this;
  }, H.prototype._doneCallback = function() {
    this._setTracksFinished(), this._clip = null;
    var C = this._doneCbs;
    if (C)
      for (var G = C.length, U = 0; U < G; U++)
        C[U].call(this);
  }, H.prototype._abortedCallback = function() {
    this._setTracksFinished();
    var C = this.animation, G = this._abortedCbs;
    if (C && C.removeClip(this._clip), this._clip = null, G)
      for (var U = 0; U < G.length; U++)
        G[U].call(this);
  }, H.prototype._setTracksFinished = function() {
    for (var C = this._tracks, G = this._trackKeys, U = 0; U < G.length; U++)
      C[G[U]].setFinished();
  }, H.prototype._getAdditiveTrack = function(C) {
    var G, U = this._additiveAnimators;
    if (U)
      for (var K = 0; K < U.length; K++) {
        var W = U[K].getTrack(C);
        W && (G = W);
      }
    return G;
  }, H.prototype.start = function(C) {
    if (!(this._started > 0)) {
      this._started = 1;
      for (var G = this, U = [], K = this._maxTime || 0, W = 0; W < this._trackKeys.length; W++) {
        var Z = this._trackKeys[W], X = this._tracks[Z], Q = this._getAdditiveTrack(Z), ee = X.keyframes, te = ee.length;
        if (X.prepare(K, Q), X.needsAnimate())
          if (!this._allowDiscrete && X.discrete) {
            var re = ee[te - 1];
            re && (G._target[X.propName] = re.rawValue), X.setFinished();
          } else
            U.push(X);
      }
      if (U.length || this._force) {
        var ne = new Clip$1({
          life: K,
          loop: this._loop,
          delay: this._delay || 0,
          onframe: function(ae) {
            G._started = 2;
            var ie = G._additiveAnimators;
            if (ie) {
              for (var se = !1, oe = 0; oe < ie.length; oe++)
                if (ie[oe]._clip) {
                  se = !0;
                  break;
                }
              se || (G._additiveAnimators = null);
            }
            for (var oe = 0; oe < U.length; oe++)
              U[oe].step(G._target, ae);
            var le = G._onframeCbs;
            if (le)
              for (var oe = 0; oe < le.length; oe++)
                le[oe](G._target, ae);
          },
          ondestroy: function() {
            G._doneCallback();
          }
        });
        this._clip = ne, this.animation && this.animation.addClip(ne), C && ne.setEasing(C);
      } else
        this._doneCallback();
      return this;
    }
  }, H.prototype.stop = function(C) {
    if (this._clip) {
      var G = this._clip;
      C && G.onframe(1), this._abortedCallback();
    }
  }, H.prototype.delay = function(C) {
    return this._delay = C, this;
  }, H.prototype.during = function(C) {
    return C && (this._onframeCbs || (this._onframeCbs = []), this._onframeCbs.push(C)), this;
  }, H.prototype.done = function(C) {
    return C && (this._doneCbs || (this._doneCbs = []), this._doneCbs.push(C)), this;
  }, H.prototype.aborted = function(C) {
    return C && (this._abortedCbs || (this._abortedCbs = []), this._abortedCbs.push(C)), this;
  }, H.prototype.getClip = function() {
    return this._clip;
  }, H.prototype.getTrack = function(C) {
    return this._tracks[C];
  }, H.prototype.getTracks = function() {
    var C = this;
    return map$1(this._trackKeys, function(G) {
      return C._tracks[G];
    });
  }, H.prototype.stopTracks = function(C, G) {
    if (!C.length || !this._clip)
      return !0;
    for (var U = this._tracks, K = this._trackKeys, W = 0; W < C.length; W++) {
      var Z = U[C[W]];
      Z && !Z.isFinished() && (G ? Z.step(this._target, 1) : this._started === 1 && Z.step(this._target, 0), Z.setFinished());
    }
    for (var X = !0, W = 0; W < K.length; W++)
      if (!U[K[W]].isFinished()) {
        X = !1;
        break;
      }
    return X && this._abortedCallback(), X;
  }, H.prototype.saveTo = function(C, G, U) {
    if (C) {
      G = G || this._trackKeys;
      for (var K = 0; K < G.length; K++) {
        var W = G[K], Z = this._tracks[W];
        if (!(!Z || Z.isFinished())) {
          var X = Z.keyframes, Q = X[U ? 0 : X.length - 1];
          Q && (C[W] = cloneValue(Q.rawValue));
        }
      }
    }
  }, H.prototype.__changeFinalValue = function(C, G) {
    G = G || keys(C);
    for (var U = 0; U < G.length; U++) {
      var K = G[U], W = this._tracks[K];
      if (W) {
        var Z = W.keyframes;
        if (Z.length > 1) {
          var X = Z.pop();
          W.addKeyframe(X.time, C[K]), W.prepare(this._maxTime, W.getAdditiveTrack());
        }
      }
    }
  }, H;
}();
const Animator$1 = Animator;
function getTime() {
  return new Date().getTime();
}
var Animation = function(H) {
  __extends(C, H);
  function C(G) {
    var U = H.call(this) || this;
    return U._running = !1, U._time = 0, U._pausedTime = 0, U._pauseStart = 0, U._paused = !1, G = G || {}, U.stage = G.stage || {}, U;
  }
  return C.prototype.addClip = function(G) {
    G.animation && this.removeClip(G), this._head ? (this._tail.next = G, G.prev = this._tail, G.next = null, this._tail = G) : this._head = this._tail = G, G.animation = this;
  }, C.prototype.addAnimator = function(G) {
    G.animation = this;
    var U = G.getClip();
    U && this.addClip(U);
  }, C.prototype.removeClip = function(G) {
    if (G.animation) {
      var U = G.prev, K = G.next;
      U ? U.next = K : this._head = K, K ? K.prev = U : this._tail = U, G.next = G.prev = G.animation = null;
    }
  }, C.prototype.removeAnimator = function(G) {
    var U = G.getClip();
    U && this.removeClip(U), G.animation = null;
  }, C.prototype.update = function(G) {
    for (var U = getTime() - this._pausedTime, K = U - this._time, W = this._head; W; ) {
      var Z = W.next, X = W.step(U, K);
      X && (W.ondestroy(), this.removeClip(W)), W = Z;
    }
    this._time = U, G || (this.trigger("frame", K), this.stage.update && this.stage.update());
  }, C.prototype._startLoop = function() {
    var G = this;
    this._running = !0;
    function U() {
      G._running && (requestAnimationFrame$2(U), !G._paused && G.update());
    }
    requestAnimationFrame$2(U);
  }, C.prototype.start = function() {
    this._running || (this._time = getTime(), this._pausedTime = 0, this._startLoop());
  }, C.prototype.stop = function() {
    this._running = !1;
  }, C.prototype.pause = function() {
    this._paused || (this._pauseStart = getTime(), this._paused = !0);
  }, C.prototype.resume = function() {
    this._paused && (this._pausedTime += getTime() - this._pauseStart, this._paused = !1);
  }, C.prototype.clear = function() {
    for (var G = this._head; G; ) {
      var U = G.next;
      G.prev = G.next = G.animation = null, G = U;
    }
    this._head = this._tail = null;
  }, C.prototype.isFinished = function() {
    return this._head == null;
  }, C.prototype.animate = function(G, U) {
    U = U || {}, this.start();
    var K = new Animator$1(G, U.loop);
    return this.addAnimator(K), K;
  }, C;
}(Eventful$1);
const Animation$1 = Animation;
var TOUCH_CLICK_DELAY = 300, globalEventSupported = env$1.domSupported, localNativeListenerNames = function() {
  var H = [
    "click",
    "dblclick",
    "mousewheel",
    "wheel",
    "mouseout",
    "mouseup",
    "mousedown",
    "mousemove",
    "contextmenu"
  ], C = [
    "touchstart",
    "touchend",
    "touchmove"
  ], G = {
    pointerdown: 1,
    pointerup: 1,
    pointermove: 1,
    pointerout: 1
  }, U = map$1(H, function(K) {
    var W = K.replace("mouse", "pointer");
    return G.hasOwnProperty(W) ? W : K;
  });
  return {
    mouse: H,
    touch: C,
    pointer: U
  };
}(), globalNativeListenerNames = {
  mouse: ["mousemove", "mouseup"],
  pointer: ["pointermove", "pointerup"]
}, wheelEventSupported = !1;
function isPointerFromTouch(H) {
  var C = H.pointerType;
  return C === "pen" || C === "touch";
}
function setTouchTimer(H) {
  H.touching = !0, H.touchTimer != null && (clearTimeout(H.touchTimer), H.touchTimer = null), H.touchTimer = setTimeout(function() {
    H.touching = !1, H.touchTimer = null;
  }, 700);
}
function markTouch(H) {
  H && (H.zrByTouch = !0);
}
function normalizeGlobalEvent(H, C) {
  return normalizeEvent(H.dom, new FakeGlobalEvent(H, C), !0);
}
function isLocalEl(H, C) {
  for (var G = C, U = !1; G && G.nodeType !== 9 && !(U = G.domBelongToZr || G !== C && G === H.painterRoot); )
    G = G.parentNode;
  return U;
}
var FakeGlobalEvent = function() {
  function H(C, G) {
    this.stopPropagation = noop, this.stopImmediatePropagation = noop, this.preventDefault = noop, this.type = G.type, this.target = this.currentTarget = C.dom, this.pointerType = G.pointerType, this.clientX = G.clientX, this.clientY = G.clientY;
  }
  return H;
}(), localDOMHandlers = {
  mousedown: function(H) {
    H = normalizeEvent(this.dom, H), this.__mayPointerCapture = [H.zrX, H.zrY], this.trigger("mousedown", H);
  },
  mousemove: function(H) {
    H = normalizeEvent(this.dom, H);
    var C = this.__mayPointerCapture;
    C && (H.zrX !== C[0] || H.zrY !== C[1]) && this.__togglePointerCapture(!0), this.trigger("mousemove", H);
  },
  mouseup: function(H) {
    H = normalizeEvent(this.dom, H), this.__togglePointerCapture(!1), this.trigger("mouseup", H);
  },
  mouseout: function(H) {
    H = normalizeEvent(this.dom, H);
    var C = H.toElement || H.relatedTarget;
    isLocalEl(this, C) || (this.__pointerCapturing && (H.zrEventControl = "no_globalout"), this.trigger("mouseout", H));
  },
  wheel: function(H) {
    wheelEventSupported = !0, H = normalizeEvent(this.dom, H), this.trigger("mousewheel", H);
  },
  mousewheel: function(H) {
    wheelEventSupported || (H = normalizeEvent(this.dom, H), this.trigger("mousewheel", H));
  },
  touchstart: function(H) {
    H = normalizeEvent(this.dom, H), markTouch(H), this.__lastTouchMoment = new Date(), this.handler.processGesture(H, "start"), localDOMHandlers.mousemove.call(this, H), localDOMHandlers.mousedown.call(this, H);
  },
  touchmove: function(H) {
    H = normalizeEvent(this.dom, H), markTouch(H), this.handler.processGesture(H, "change"), localDOMHandlers.mousemove.call(this, H);
  },
  touchend: function(H) {
    H = normalizeEvent(this.dom, H), markTouch(H), this.handler.processGesture(H, "end"), localDOMHandlers.mouseup.call(this, H), +new Date() - +this.__lastTouchMoment < TOUCH_CLICK_DELAY && localDOMHandlers.click.call(this, H);
  },
  pointerdown: function(H) {
    localDOMHandlers.mousedown.call(this, H);
  },
  pointermove: function(H) {
    isPointerFromTouch(H) || localDOMHandlers.mousemove.call(this, H);
  },
  pointerup: function(H) {
    localDOMHandlers.mouseup.call(this, H);
  },
  pointerout: function(H) {
    isPointerFromTouch(H) || localDOMHandlers.mouseout.call(this, H);
  }
};
each$f(["click", "dblclick", "contextmenu"], function(H) {
  localDOMHandlers[H] = function(C) {
    C = normalizeEvent(this.dom, C), this.trigger(H, C);
  };
});
var globalDOMHandlers = {
  pointermove: function(H) {
    isPointerFromTouch(H) || globalDOMHandlers.mousemove.call(this, H);
  },
  pointerup: function(H) {
    globalDOMHandlers.mouseup.call(this, H);
  },
  mousemove: function(H) {
    this.trigger("mousemove", H);
  },
  mouseup: function(H) {
    var C = this.__pointerCapturing;
    this.__togglePointerCapture(!1), this.trigger("mouseup", H), C && (H.zrEventControl = "only_globalout", this.trigger("mouseout", H));
  }
};
function mountLocalDOMEventListeners(H, C) {
  var G = C.domHandlers;
  env$1.pointerEventsSupported ? each$f(localNativeListenerNames.pointer, function(U) {
    mountSingleDOMEventListener(C, U, function(K) {
      G[U].call(H, K);
    });
  }) : (env$1.touchEventsSupported && each$f(localNativeListenerNames.touch, function(U) {
    mountSingleDOMEventListener(C, U, function(K) {
      G[U].call(H, K), setTouchTimer(C);
    });
  }), each$f(localNativeListenerNames.mouse, function(U) {
    mountSingleDOMEventListener(C, U, function(K) {
      K = getNativeEvent(K), C.touching || G[U].call(H, K);
    });
  }));
}
function mountGlobalDOMEventListeners(H, C) {
  env$1.pointerEventsSupported ? each$f(globalNativeListenerNames.pointer, G) : env$1.touchEventsSupported || each$f(globalNativeListenerNames.mouse, G);
  function G(U) {
    function K(W) {
      W = getNativeEvent(W), isLocalEl(H, W.target) || (W = normalizeGlobalEvent(H, W), C.domHandlers[U].call(H, W));
    }
    mountSingleDOMEventListener(C, U, K, { capture: !0 });
  }
}
function mountSingleDOMEventListener(H, C, G, U) {
  H.mounted[C] = G, H.listenerOpts[C] = U, addEventListener(H.domTarget, C, G, U);
}
function unmountDOMEventListeners(H) {
  var C = H.mounted;
  for (var G in C)
    C.hasOwnProperty(G) && removeEventListener(H.domTarget, G, C[G], H.listenerOpts[G]);
  H.mounted = {};
}
var DOMHandlerScope = function() {
  function H(C, G) {
    this.mounted = {}, this.listenerOpts = {}, this.touching = !1, this.domTarget = C, this.domHandlers = G;
  }
  return H;
}(), HandlerDomProxy = function(H) {
  __extends(C, H);
  function C(G, U) {
    var K = H.call(this) || this;
    return K.__pointerCapturing = !1, K.dom = G, K.painterRoot = U, K._localHandlerScope = new DOMHandlerScope(G, localDOMHandlers), globalEventSupported && (K._globalHandlerScope = new DOMHandlerScope(document, globalDOMHandlers)), mountLocalDOMEventListeners(K, K._localHandlerScope), K;
  }
  return C.prototype.dispose = function() {
    unmountDOMEventListeners(this._localHandlerScope), globalEventSupported && unmountDOMEventListeners(this._globalHandlerScope);
  }, C.prototype.setCursor = function(G) {
    this.dom.style && (this.dom.style.cursor = G || "default");
  }, C.prototype.__togglePointerCapture = function(G) {
    if (this.__mayPointerCapture = null, globalEventSupported && +this.__pointerCapturing ^ +G) {
      this.__pointerCapturing = G;
      var U = this._globalHandlerScope;
      G ? mountGlobalDOMEventListeners(this, U) : unmountDOMEventListeners(U);
    }
  }, C;
}(Eventful$1);
const HandlerProxy = HandlerDomProxy;
var dpr = 1;
env$1.hasGlobalWindow && (dpr = Math.max(window.devicePixelRatio || window.screen && window.screen.deviceXDPI / window.screen.logicalXDPI || 1, 1));
var devicePixelRatio = dpr, DARK_MODE_THRESHOLD = 0.4, DARK_LABEL_COLOR = "#333", LIGHT_LABEL_COLOR = "#ccc", LIGHTER_LABEL_COLOR = "#eee", mIdentity = identity, EPSILON$2 = 5e-5;
function isNotAroundZero(H) {
  return H > EPSILON$2 || H < -EPSILON$2;
}
var scaleTmp = [], tmpTransform = [], originTransform = create$1(), abs = Math.abs, Transformable = function() {
  function H() {
  }
  return H.prototype.getLocalTransform = function(C) {
    return H.getLocalTransform(this, C);
  }, H.prototype.setPosition = function(C) {
    this.x = C[0], this.y = C[1];
  }, H.prototype.setScale = function(C) {
    this.scaleX = C[0], this.scaleY = C[1];
  }, H.prototype.setSkew = function(C) {
    this.skewX = C[0], this.skewY = C[1];
  }, H.prototype.setOrigin = function(C) {
    this.originX = C[0], this.originY = C[1];
  }, H.prototype.needLocalTransform = function() {
    return isNotAroundZero(this.rotation) || isNotAroundZero(this.x) || isNotAroundZero(this.y) || isNotAroundZero(this.scaleX - 1) || isNotAroundZero(this.scaleY - 1) || isNotAroundZero(this.skewX) || isNotAroundZero(this.skewY);
  }, H.prototype.updateTransform = function() {
    var C = this.parent && this.parent.transform, G = this.needLocalTransform(), U = this.transform;
    if (!(G || C)) {
      U && mIdentity(U);
      return;
    }
    U = U || create$1(), G ? this.getLocalTransform(U) : mIdentity(U), C && (G ? mul(U, C, U) : copy(U, C)), this.transform = U, this._resolveGlobalScaleRatio(U);
  }, H.prototype._resolveGlobalScaleRatio = function(C) {
    var G = this.globalScaleRatio;
    if (G != null && G !== 1) {
      this.getGlobalScale(scaleTmp);
      var U = scaleTmp[0] < 0 ? -1 : 1, K = scaleTmp[1] < 0 ? -1 : 1, W = ((scaleTmp[0] - U) * G + U) / scaleTmp[0] || 0, Z = ((scaleTmp[1] - K) * G + K) / scaleTmp[1] || 0;
      C[0] *= W, C[1] *= W, C[2] *= Z, C[3] *= Z;
    }
    this.invTransform = this.invTransform || create$1(), invert(this.invTransform, C);
  }, H.prototype.getComputedTransform = function() {
    for (var C = this, G = []; C; )
      G.push(C), C = C.parent;
    for (; C = G.pop(); )
      C.updateTransform();
    return this.transform;
  }, H.prototype.setLocalTransform = function(C) {
    if (C) {
      var G = C[0] * C[0] + C[1] * C[1], U = C[2] * C[2] + C[3] * C[3], K = Math.atan2(C[1], C[0]), W = Math.PI / 2 + K - Math.atan2(C[3], C[2]);
      U = Math.sqrt(U) * Math.cos(W), G = Math.sqrt(G), this.skewX = W, this.skewY = 0, this.rotation = -K, this.x = +C[4], this.y = +C[5], this.scaleX = G, this.scaleY = U, this.originX = 0, this.originY = 0;
    }
  }, H.prototype.decomposeTransform = function() {
    if (this.transform) {
      var C = this.parent, G = this.transform;
      C && C.transform && (mul(tmpTransform, C.invTransform, G), G = tmpTransform);
      var U = this.originX, K = this.originY;
      (U || K) && (originTransform[4] = U, originTransform[5] = K, mul(tmpTransform, G, originTransform), tmpTransform[4] -= U, tmpTransform[5] -= K, G = tmpTransform), this.setLocalTransform(G);
    }
  }, H.prototype.getGlobalScale = function(C) {
    var G = this.transform;
    return C = C || [], G ? (C[0] = Math.sqrt(G[0] * G[0] + G[1] * G[1]), C[1] = Math.sqrt(G[2] * G[2] + G[3] * G[3]), G[0] < 0 && (C[0] = -C[0]), G[3] < 0 && (C[1] = -C[1]), C) : (C[0] = 1, C[1] = 1, C);
  }, H.prototype.transformCoordToLocal = function(C, G) {
    var U = [C, G], K = this.invTransform;
    return K && applyTransform$1(U, U, K), U;
  }, H.prototype.transformCoordToGlobal = function(C, G) {
    var U = [C, G], K = this.transform;
    return K && applyTransform$1(U, U, K), U;
  }, H.prototype.getLineScale = function() {
    var C = this.transform;
    return C && abs(C[0] - 1) > 1e-10 && abs(C[3] - 1) > 1e-10 ? Math.sqrt(abs(C[0] * C[3] - C[2] * C[1])) : 1;
  }, H.prototype.copyTransform = function(C) {
    copyTransform(this, C);
  }, H.getLocalTransform = function(C, G) {
    G = G || [];
    var U = C.originX || 0, K = C.originY || 0, W = C.scaleX, Z = C.scaleY, X = C.anchorX, Q = C.anchorY, ee = C.rotation || 0, te = C.x, re = C.y, ne = C.skewX ? Math.tan(C.skewX) : 0, ae = C.skewY ? Math.tan(-C.skewY) : 0;
    if (U || K || X || Q) {
      var ie = U + X, se = K + Q;
      G[4] = -ie * W - ne * se * Z, G[5] = -se * Z - ae * ie * W;
    } else
      G[4] = G[5] = 0;
    return G[0] = W, G[3] = Z, G[1] = ae * W, G[2] = ne * Z, ee && rotate(G, G, ee), G[4] += U + te, G[5] += K + re, G;
  }, H.initDefaultProps = function() {
    var C = H.prototype;
    C.scaleX = C.scaleY = C.globalScaleRatio = 1, C.x = C.y = C.originX = C.originY = C.skewX = C.skewY = C.rotation = C.anchorX = C.anchorY = 0;
  }(), H;
}(), TRANSFORMABLE_PROPS = [
  "x",
  "y",
  "originX",
  "originY",
  "anchorX",
  "anchorY",
  "rotation",
  "scaleX",
  "scaleY",
  "skewX",
  "skewY"
];
function copyTransform(H, C) {
  for (var G = 0; G < TRANSFORMABLE_PROPS.length; G++) {
    var U = TRANSFORMABLE_PROPS[G];
    H[U] = C[U];
  }
}
var textWidthCache = {};
function getWidth(H, C) {
  C = C || DEFAULT_FONT;
  var G = textWidthCache[C];
  G || (G = textWidthCache[C] = new LRU$1(500));
  var U = G.get(H);
  return U == null && (U = platformApi.measureText(H, C).width, G.put(H, U)), U;
}
function innerGetBoundingRect(H, C, G, U) {
  var K = getWidth(H, C), W = getLineHeight(C), Z = adjustTextX(0, K, G), X = adjustTextY(0, W, U), Q = new BoundingRect$1(Z, X, K, W);
  return Q;
}
function getBoundingRect(H, C, G, U) {
  var K = ((H || "") + "").split(`
`), W = K.length;
  if (W === 1)
    return innerGetBoundingRect(K[0], C, G, U);
  for (var Z = new BoundingRect$1(0, 0, 0, 0), X = 0; X < K.length; X++) {
    var Q = innerGetBoundingRect(K[X], C, G, U);
    X === 0 ? Z.copy(Q) : Z.union(Q);
  }
  return Z;
}
function adjustTextX(H, C, G) {
  return G === "right" ? H -= C : G === "center" && (H -= C / 2), H;
}
function adjustTextY(H, C, G) {
  return G === "middle" ? H -= C / 2 : G === "bottom" && (H -= C), H;
}
function getLineHeight(H) {
  return getWidth("国", H);
}
function parsePercent$1(H, C) {
  return typeof H == "string" ? H.lastIndexOf("%") >= 0 ? parseFloat(H) / 100 * C : parseFloat(H) : H;
}
function calculateTextPosition(H, C, G) {
  var U = C.position || "inside", K = C.distance != null ? C.distance : 5, W = G.height, Z = G.width, X = W / 2, Q = G.x, ee = G.y, te = "left", re = "top";
  if (U instanceof Array)
    Q += parsePercent$1(U[0], G.width), ee += parsePercent$1(U[1], G.height), te = null, re = null;
  else
    switch (U) {
      case "left":
        Q -= K, ee += X, te = "right", re = "middle";
        break;
      case "right":
        Q += K + Z, ee += X, re = "middle";
        break;
      case "top":
        Q += Z / 2, ee -= K, te = "center", re = "bottom";
        break;
      case "bottom":
        Q += Z / 2, ee += W + K, te = "center";
        break;
      case "inside":
        Q += Z / 2, ee += X, te = "center", re = "middle";
        break;
      case "insideLeft":
        Q += K, ee += X, re = "middle";
        break;
      case "insideRight":
        Q += Z - K, ee += X, te = "right", re = "middle";
        break;
      case "insideTop":
        Q += Z / 2, ee += K, te = "center";
        break;
      case "insideBottom":
        Q += Z / 2, ee += W - K, te = "center", re = "bottom";
        break;
      case "insideTopLeft":
        Q += K, ee += K;
        break;
      case "insideTopRight":
        Q += Z - K, ee += K, te = "right";
        break;
      case "insideBottomLeft":
        Q += K, ee += W - K, re = "bottom";
        break;
      case "insideBottomRight":
        Q += Z - K, ee += W - K, te = "right", re = "bottom";
        break;
    }
  return H = H || {}, H.x = Q, H.y = ee, H.align = te, H.verticalAlign = re, H;
}
var PRESERVED_NORMAL_STATE = "__zr_normal__", PRIMARY_STATES_KEYS$1 = TRANSFORMABLE_PROPS.concat(["ignore"]), DEFAULT_ANIMATABLE_MAP = reduce(TRANSFORMABLE_PROPS, function(H, C) {
  return H[C] = !0, H;
}, { ignore: !1 }), tmpTextPosCalcRes = {}, tmpBoundingRect = new BoundingRect$1(0, 0, 0, 0), Element$1 = function() {
  function H(C) {
    this.id = guid(), this.animators = [], this.currentStates = [], this.states = {}, this._init(C);
  }
  return H.prototype._init = function(C) {
    this.attr(C);
  }, H.prototype.drift = function(C, G, U) {
    switch (this.draggable) {
      case "horizontal":
        G = 0;
        break;
      case "vertical":
        C = 0;
        break;
    }
    var K = this.transform;
    K || (K = this.transform = [1, 0, 0, 1, 0, 0]), K[4] += C, K[5] += G, this.decomposeTransform(), this.markRedraw();
  }, H.prototype.beforeUpdate = function() {
  }, H.prototype.afterUpdate = function() {
  }, H.prototype.update = function() {
    this.updateTransform(), this.__dirty && this.updateInnerText();
  }, H.prototype.updateInnerText = function(C) {
    var G = this._textContent;
    if (G && (!G.ignore || C)) {
      this.textConfig || (this.textConfig = {});
      var U = this.textConfig, K = U.local, W = G.innerTransformable, Z = void 0, X = void 0, Q = !1;
      W.parent = K ? this : null;
      var ee = !1;
      if (W.copyTransform(G), U.position != null) {
        var te = tmpBoundingRect;
        U.layoutRect ? te.copy(U.layoutRect) : te.copy(this.getBoundingRect()), K || te.applyTransform(this.transform), this.calculateTextPosition ? this.calculateTextPosition(tmpTextPosCalcRes, U, te) : calculateTextPosition(tmpTextPosCalcRes, U, te), W.x = tmpTextPosCalcRes.x, W.y = tmpTextPosCalcRes.y, Z = tmpTextPosCalcRes.align, X = tmpTextPosCalcRes.verticalAlign;
        var re = U.origin;
        if (re && U.rotation != null) {
          var ne = void 0, ae = void 0;
          re === "center" ? (ne = te.width * 0.5, ae = te.height * 0.5) : (ne = parsePercent$1(re[0], te.width), ae = parsePercent$1(re[1], te.height)), ee = !0, W.originX = -W.x + ne + (K ? 0 : te.x), W.originY = -W.y + ae + (K ? 0 : te.y);
        }
      }
      U.rotation != null && (W.rotation = U.rotation);
      var ie = U.offset;
      ie && (W.x += ie[0], W.y += ie[1], ee || (W.originX = -ie[0], W.originY = -ie[1]));
      var se = U.inside == null ? typeof U.position == "string" && U.position.indexOf("inside") >= 0 : U.inside, oe = this._innerTextDefaultStyle || (this._innerTextDefaultStyle = {}), le = void 0, ue = void 0, ce = void 0;
      se && this.canBeInsideText() ? (le = U.insideFill, ue = U.insideStroke, (le == null || le === "auto") && (le = this.getInsideTextFill()), (ue == null || ue === "auto") && (ue = this.getInsideTextStroke(le), ce = !0)) : (le = U.outsideFill, ue = U.outsideStroke, (le == null || le === "auto") && (le = this.getOutsideFill()), (ue == null || ue === "auto") && (ue = this.getOutsideStroke(le), ce = !0)), le = le || "#000", (le !== oe.fill || ue !== oe.stroke || ce !== oe.autoStroke || Z !== oe.align || X !== oe.verticalAlign) && (Q = !0, oe.fill = le, oe.stroke = ue, oe.autoStroke = ce, oe.align = Z, oe.verticalAlign = X, G.setDefaultTextStyle(oe)), G.__dirty |= REDRAW_BIT, Q && G.dirtyStyle(!0);
    }
  }, H.prototype.canBeInsideText = function() {
    return !0;
  }, H.prototype.getInsideTextFill = function() {
    return "#fff";
  }, H.prototype.getInsideTextStroke = function(C) {
    return "#000";
  }, H.prototype.getOutsideFill = function() {
    return this.__zr && this.__zr.isDarkMode() ? LIGHT_LABEL_COLOR : DARK_LABEL_COLOR;
  }, H.prototype.getOutsideStroke = function(C) {
    var G = this.__zr && this.__zr.getBackgroundColor(), U = typeof G == "string" && parse(G);
    U || (U = [255, 255, 255, 1]);
    for (var K = U[3], W = this.__zr.isDarkMode(), Z = 0; Z < 3; Z++)
      U[Z] = U[Z] * K + (W ? 0 : 255) * (1 - K);
    return U[3] = 1, stringify(U, "rgba");
  }, H.prototype.traverse = function(C, G) {
  }, H.prototype.attrKV = function(C, G) {
    C === "textConfig" ? this.setTextConfig(G) : C === "textContent" ? this.setTextContent(G) : C === "clipPath" ? this.setClipPath(G) : C === "extra" ? (this.extra = this.extra || {}, extend(this.extra, G)) : this[C] = G;
  }, H.prototype.hide = function() {
    this.ignore = !0, this.markRedraw();
  }, H.prototype.show = function() {
    this.ignore = !1, this.markRedraw();
  }, H.prototype.attr = function(C, G) {
    if (typeof C == "string")
      this.attrKV(C, G);
    else if (isObject$3(C))
      for (var U = C, K = keys(U), W = 0; W < K.length; W++) {
        var Z = K[W];
        this.attrKV(Z, C[Z]);
      }
    return this.markRedraw(), this;
  }, H.prototype.saveCurrentToNormalState = function(C) {
    this._innerSaveToNormal(C);
    for (var G = this._normalState, U = 0; U < this.animators.length; U++) {
      var K = this.animators[U], W = K.__fromStateTransition;
      if (!(K.getLoop() || W && W !== PRESERVED_NORMAL_STATE)) {
        var Z = K.targetName, X = Z ? G[Z] : G;
        K.saveTo(X);
      }
    }
  }, H.prototype._innerSaveToNormal = function(C) {
    var G = this._normalState;
    G || (G = this._normalState = {}), C.textConfig && !G.textConfig && (G.textConfig = this.textConfig), this._savePrimaryToNormal(C, G, PRIMARY_STATES_KEYS$1);
  }, H.prototype._savePrimaryToNormal = function(C, G, U) {
    for (var K = 0; K < U.length; K++) {
      var W = U[K];
      C[W] != null && !(W in G) && (G[W] = this[W]);
    }
  }, H.prototype.hasState = function() {
    return this.currentStates.length > 0;
  }, H.prototype.getState = function(C) {
    return this.states[C];
  }, H.prototype.ensureState = function(C) {
    var G = this.states;
    return G[C] || (G[C] = {}), G[C];
  }, H.prototype.clearStates = function(C) {
    this.useState(PRESERVED_NORMAL_STATE, !1, C);
  }, H.prototype.useState = function(C, G, U, K) {
    var W = C === PRESERVED_NORMAL_STATE, Z = this.hasState();
    if (!(!Z && W)) {
      var X = this.currentStates, Q = this.stateTransition;
      if (!(indexOf(X, C) >= 0 && (G || X.length === 1))) {
        var ee;
        if (this.stateProxy && !W && (ee = this.stateProxy(C)), ee || (ee = this.states && this.states[C]), !ee && !W) {
          logError("State " + C + " not exists.");
          return;
        }
        W || this.saveCurrentToNormalState(ee);
        var te = !!(ee && ee.hoverLayer || K);
        te && this._toggleHoverLayerFlag(!0), this._applyStateObj(C, ee, this._normalState, G, !U && !this.__inHover && Q && Q.duration > 0, Q);
        var re = this._textContent, ne = this._textGuide;
        return re && re.useState(C, G, U, te), ne && ne.useState(C, G, U, te), W ? (this.currentStates = [], this._normalState = {}) : G ? this.currentStates.push(C) : this.currentStates = [C], this._updateAnimationTargets(), this.markRedraw(), !te && this.__inHover && (this._toggleHoverLayerFlag(!1), this.__dirty &= ~REDRAW_BIT), ee;
      }
    }
  }, H.prototype.useStates = function(C, G, U) {
    if (!C.length)
      this.clearStates();
    else {
      var K = [], W = this.currentStates, Z = C.length, X = Z === W.length;
      if (X) {
        for (var Q = 0; Q < Z; Q++)
          if (C[Q] !== W[Q]) {
            X = !1;
            break;
          }
      }
      if (X)
        return;
      for (var Q = 0; Q < Z; Q++) {
        var ee = C[Q], te = void 0;
        this.stateProxy && (te = this.stateProxy(ee, C)), te || (te = this.states[ee]), te && K.push(te);
      }
      var re = K[Z - 1], ne = !!(re && re.hoverLayer || U);
      ne && this._toggleHoverLayerFlag(!0);
      var ae = this._mergeStates(K), ie = this.stateTransition;
      this.saveCurrentToNormalState(ae), this._applyStateObj(C.join(","), ae, this._normalState, !1, !G && !this.__inHover && ie && ie.duration > 0, ie);
      var se = this._textContent, oe = this._textGuide;
      se && se.useStates(C, G, ne), oe && oe.useStates(C, G, ne), this._updateAnimationTargets(), this.currentStates = C.slice(), this.markRedraw(), !ne && this.__inHover && (this._toggleHoverLayerFlag(!1), this.__dirty &= ~REDRAW_BIT);
    }
  }, H.prototype._updateAnimationTargets = function() {
    for (var C = 0; C < this.animators.length; C++) {
      var G = this.animators[C];
      G.targetName && G.changeTarget(this[G.targetName]);
    }
  }, H.prototype.removeState = function(C) {
    var G = indexOf(this.currentStates, C);
    if (G >= 0) {
      var U = this.currentStates.slice();
      U.splice(G, 1), this.useStates(U);
    }
  }, H.prototype.replaceState = function(C, G, U) {
    var K = this.currentStates.slice(), W = indexOf(K, C), Z = indexOf(K, G) >= 0;
    W >= 0 ? Z ? K.splice(W, 1) : K[W] = G : U && !Z && K.push(G), this.useStates(K);
  }, H.prototype.toggleState = function(C, G) {
    G ? this.useState(C, !0) : this.removeState(C);
  }, H.prototype._mergeStates = function(C) {
    for (var G = {}, U, K = 0; K < C.length; K++) {
      var W = C[K];
      extend(G, W), W.textConfig && (U = U || {}, extend(U, W.textConfig));
    }
    return U && (G.textConfig = U), G;
  }, H.prototype._applyStateObj = function(C, G, U, K, W, Z) {
    var X = !(G && K);
    G && G.textConfig ? (this.textConfig = extend({}, K ? this.textConfig : U.textConfig), extend(this.textConfig, G.textConfig)) : X && U.textConfig && (this.textConfig = U.textConfig);
    for (var Q = {}, ee = !1, te = 0; te < PRIMARY_STATES_KEYS$1.length; te++) {
      var re = PRIMARY_STATES_KEYS$1[te], ne = W && DEFAULT_ANIMATABLE_MAP[re];
      G && G[re] != null ? ne ? (ee = !0, Q[re] = G[re]) : this[re] = G[re] : X && U[re] != null && (ne ? (ee = !0, Q[re] = U[re]) : this[re] = U[re]);
    }
    if (!W)
      for (var te = 0; te < this.animators.length; te++) {
        var ae = this.animators[te], ie = ae.targetName;
        ae.getLoop() || ae.__changeFinalValue(ie ? (G || U)[ie] : G || U);
      }
    ee && this._transitionState(C, Q, Z);
  }, H.prototype._attachComponent = function(C) {
    if (C.__zr && !C.__hostTarget) {
      if (process.env.NODE_ENV !== "production")
        throw new Error("Text element has been added to zrender.");
      return;
    }
    if (C === this) {
      if (process.env.NODE_ENV !== "production")
        throw new Error("Recursive component attachment.");
      return;
    }
    var G = this.__zr;
    G && C.addSelfToZr(G), C.__zr = G, C.__hostTarget = this;
  }, H.prototype._detachComponent = function(C) {
    C.__zr && C.removeSelfFromZr(C.__zr), C.__zr = null, C.__hostTarget = null;
  }, H.prototype.getClipPath = function() {
    return this._clipPath;
  }, H.prototype.setClipPath = function(C) {
    this._clipPath && this._clipPath !== C && this.removeClipPath(), this._attachComponent(C), this._clipPath = C, this.markRedraw();
  }, H.prototype.removeClipPath = function() {
    var C = this._clipPath;
    C && (this._detachComponent(C), this._clipPath = null, this.markRedraw());
  }, H.prototype.getTextContent = function() {
    return this._textContent;
  }, H.prototype.setTextContent = function(C) {
    var G = this._textContent;
    if (G !== C) {
      if (G && G !== C && this.removeTextContent(), process.env.NODE_ENV !== "production" && C.__zr && !C.__hostTarget)
        throw new Error("Text element has been added to zrender.");
      C.innerTransformable = new Transformable(), this._attachComponent(C), this._textContent = C, this.markRedraw();
    }
  }, H.prototype.setTextConfig = function(C) {
    this.textConfig || (this.textConfig = {}), extend(this.textConfig, C), this.markRedraw();
  }, H.prototype.removeTextConfig = function() {
    this.textConfig = null, this.markRedraw();
  }, H.prototype.removeTextContent = function() {
    var C = this._textContent;
    C && (C.innerTransformable = null, this._detachComponent(C), this._textContent = null, this._innerTextDefaultStyle = null, this.markRedraw());
  }, H.prototype.getTextGuideLine = function() {
    return this._textGuide;
  }, H.prototype.setTextGuideLine = function(C) {
    this._textGuide && this._textGuide !== C && this.removeTextGuideLine(), this._attachComponent(C), this._textGuide = C, this.markRedraw();
  }, H.prototype.removeTextGuideLine = function() {
    var C = this._textGuide;
    C && (this._detachComponent(C), this._textGuide = null, this.markRedraw());
  }, H.prototype.markRedraw = function() {
    this.__dirty |= REDRAW_BIT;
    var C = this.__zr;
    C && (this.__inHover ? C.refreshHover() : C.refresh()), this.__hostTarget && this.__hostTarget.markRedraw();
  }, H.prototype.dirty = function() {
    this.markRedraw();
  }, H.prototype._toggleHoverLayerFlag = function(C) {
    this.__inHover = C;
    var G = this._textContent, U = this._textGuide;
    G && (G.__inHover = C), U && (U.__inHover = C);
  }, H.prototype.addSelfToZr = function(C) {
    if (this.__zr !== C) {
      this.__zr = C;
      var G = this.animators;
      if (G)
        for (var U = 0; U < G.length; U++)
          C.animation.addAnimator(G[U]);
      this._clipPath && this._clipPath.addSelfToZr(C), this._textContent && this._textContent.addSelfToZr(C), this._textGuide && this._textGuide.addSelfToZr(C);
    }
  }, H.prototype.removeSelfFromZr = function(C) {
    if (this.__zr) {
      this.__zr = null;
      var G = this.animators;
      if (G)
        for (var U = 0; U < G.length; U++)
          C.animation.removeAnimator(G[U]);
      this._clipPath && this._clipPath.removeSelfFromZr(C), this._textContent && this._textContent.removeSelfFromZr(C), this._textGuide && this._textGuide.removeSelfFromZr(C);
    }
  }, H.prototype.animate = function(C, G, U) {
    var K = C ? this[C] : this;
    if (process.env.NODE_ENV !== "production" && !K) {
      logError('Property "' + C + '" is not existed in element ' + this.id);
      return;
    }
    var W = new Animator$1(K, G, U);
    return C && (W.targetName = C), this.addAnimator(W, C), W;
  }, H.prototype.addAnimator = function(C, G) {
    var U = this.__zr, K = this;
    C.during(function() {
      K.updateDuringAnimation(G);
    }).done(function() {
      var W = K.animators, Z = indexOf(W, C);
      Z >= 0 && W.splice(Z, 1);
    }), this.animators.push(C), U && U.animation.addAnimator(C), U && U.wakeUp();
  }, H.prototype.updateDuringAnimation = function(C) {
    this.markRedraw();
  }, H.prototype.stopAnimation = function(C, G) {
    for (var U = this.animators, K = U.length, W = [], Z = 0; Z < K; Z++) {
      var X = U[Z];
      !C || C === X.scope ? X.stop(G) : W.push(X);
    }
    return this.animators = W, this;
  }, H.prototype.animateTo = function(C, G, U) {
    animateTo(this, C, G, U);
  }, H.prototype.animateFrom = function(C, G, U) {
    animateTo(this, C, G, U, !0);
  }, H.prototype._transitionState = function(C, G, U, K) {
    for (var W = animateTo(this, G, U, K), Z = 0; Z < W.length; Z++)
      W[Z].__fromStateTransition = C;
  }, H.prototype.getBoundingRect = function() {
    return null;
  }, H.prototype.getPaintRect = function() {
    return null;
  }, H.initDefaultProps = function() {
    var C = H.prototype;
    C.type = "element", C.name = "", C.ignore = C.silent = C.isGroup = C.draggable = C.dragging = C.ignoreClip = C.__inHover = !1, C.__dirty = REDRAW_BIT;
    var G = {};
    function U(W, Z, X) {
      G[W + Z + X] || (console.warn("DEPRECATED: '" + W + "' has been deprecated. use '" + Z + "', '" + X + "' instead"), G[W + Z + X] = !0);
    }
    function K(W, Z, X, Q) {
      Object.defineProperty(C, W, {
        get: function() {
          if (process.env.NODE_ENV !== "production" && U(W, X, Q), !this[Z]) {
            var te = this[Z] = [];
            ee(this, te);
          }
          return this[Z];
        },
        set: function(te) {
          process.env.NODE_ENV !== "production" && U(W, X, Q), this[X] = te[0], this[Q] = te[1], this[Z] = te, ee(this, te);
        }
      });
      function ee(te, re) {
        Object.defineProperty(re, 0, {
          get: function() {
            return te[X];
          },
          set: function(ne) {
            te[X] = ne;
          }
        }), Object.defineProperty(re, 1, {
          get: function() {
            return te[Q];
          },
          set: function(ne) {
            te[Q] = ne;
          }
        });
      }
    }
    Object.defineProperty && (K("position", "_legacyPos", "x", "y"), K("scale", "_legacyScale", "scaleX", "scaleY"), K("origin", "_legacyOrigin", "originX", "originY"));
  }(), H;
}();
mixin(Element$1, Eventful$1);
mixin(Element$1, Transformable);
function animateTo(H, C, G, U, K) {
  G = G || {};
  var W = [];
  animateToShallow(H, "", H, C, G, U, W, K);
  var Z = W.length, X = !1, Q = G.done, ee = G.aborted, te = function() {
    X = !0, Z--, Z <= 0 && (X ? Q && Q() : ee && ee());
  }, re = function() {
    Z--, Z <= 0 && (X ? Q && Q() : ee && ee());
  };
  Z || Q && Q(), W.length > 0 && G.during && W[0].during(function(ie, se) {
    G.during(se);
  });
  for (var ne = 0; ne < W.length; ne++) {
    var ae = W[ne];
    te && ae.done(te), re && ae.aborted(re), G.force && ae.duration(G.duration), ae.start(G.easing);
  }
  return W;
}
function copyArrShallow(H, C, G) {
  for (var U = 0; U < G; U++)
    H[U] = C[U];
}
function is2DArray(H) {
  return isArrayLike(H[0]);
}
function copyValue(H, C, G) {
  if (isArrayLike(C[G]))
    if (isArrayLike(H[G]) || (H[G] = []), isTypedArray(C[G])) {
      var U = C[G].length;
      H[G].length !== U && (H[G] = new C[G].constructor(U), copyArrShallow(H[G], C[G], U));
    } else {
      var K = C[G], W = H[G], Z = K.length;
      if (is2DArray(K))
        for (var X = K[0].length, Q = 0; Q < Z; Q++)
          W[Q] ? copyArrShallow(W[Q], K[Q], X) : W[Q] = Array.prototype.slice.call(K[Q]);
      else
        copyArrShallow(W, K, Z);
      W.length = K.length;
    }
  else
    H[G] = C[G];
}
function isValueSame(H, C) {
  return H === C || isArrayLike(H) && isArrayLike(C) && is1DArraySame(H, C);
}
function is1DArraySame(H, C) {
  var G = H.length;
  if (G !== C.length)
    return !1;
  for (var U = 0; U < G; U++)
    if (H[U] !== C[U])
      return !1;
  return !0;
}
function animateToShallow(H, C, G, U, K, W, Z, X) {
  for (var Q = keys(U), ee = K.duration, te = K.delay, re = K.additive, ne = K.setToFinal, ae = !isObject$3(W), ie = H.animators, se = [], oe = 0; oe < Q.length; oe++) {
    var le = Q[oe], ue = U[le];
    if (ue != null && G[le] != null && (ae || W[le]))
      if (isObject$3(ue) && !isArrayLike(ue) && !isGradientObject(ue)) {
        if (C) {
          X || (G[le] = ue, H.updateDuringAnimation(C));
          continue;
        }
        animateToShallow(H, le, G[le], ue, K, W && W[le], Z, X);
      } else
        se.push(le);
    else
      X || (G[le] = ue, H.updateDuringAnimation(C), se.push(le));
  }
  var ce = se.length;
  if (!re && ce)
    for (var de = 0; de < ie.length; de++) {
      var ge = ie[de];
      if (ge.targetName === C) {
        var fe = ge.stopTracks(se);
        if (fe) {
          var ve = indexOf(ie, ge);
          ie.splice(ve, 1);
        }
      }
    }
  if (K.force || (se = filter(se, function(ye) {
    return !isValueSame(U[ye], G[ye]);
  }), ce = se.length), ce > 0 || K.force && !Z.length) {
    var pe = void 0, he = void 0, me = void 0;
    if (X) {
      he = {}, ne && (pe = {});
      for (var de = 0; de < ce; de++) {
        var le = se[de];
        he[le] = G[le], ne ? pe[le] = U[le] : G[le] = U[le];
      }
    } else if (ne) {
      me = {};
      for (var de = 0; de < ce; de++) {
        var le = se[de];
        me[le] = cloneValue(G[le]), copyValue(G, U, le);
      }
    }
    var ge = new Animator$1(G, !1, !1, re ? filter(ie, function(Ce) {
      return Ce.targetName === C;
    }) : null);
    ge.targetName = C, K.scope && (ge.scope = K.scope), ne && pe && ge.whenWithKeys(0, pe, se), me && ge.whenWithKeys(0, me, se), ge.whenWithKeys(ee ?? 500, X ? he : U, se).delay(te || 0), H.addAnimator(ge, C), Z.push(ge);
  }
}
const Element$2 = Element$1;
var Group$3 = function(H) {
  __extends(C, H);
  function C(G) {
    var U = H.call(this) || this;
    return U.isGroup = !0, U._children = [], U.attr(G), U;
  }
  return C.prototype.childrenRef = function() {
    return this._children;
  }, C.prototype.children = function() {
    return this._children.slice();
  }, C.prototype.childAt = function(G) {
    return this._children[G];
  }, C.prototype.childOfName = function(G) {
    for (var U = this._children, K = 0; K < U.length; K++)
      if (U[K].name === G)
        return U[K];
  }, C.prototype.childCount = function() {
    return this._children.length;
  }, C.prototype.add = function(G) {
    if (G && (G !== this && G.parent !== this && (this._children.push(G), this._doAdd(G)), process.env.NODE_ENV !== "production" && G.__hostTarget))
      throw "This elemenet has been used as an attachment";
    return this;
  }, C.prototype.addBefore = function(G, U) {
    if (G && G !== this && G.parent !== this && U && U.parent === this) {
      var K = this._children, W = K.indexOf(U);
      W >= 0 && (K.splice(W, 0, G), this._doAdd(G));
    }
    return this;
  }, C.prototype.replace = function(G, U) {
    var K = indexOf(this._children, G);
    return K >= 0 && this.replaceAt(U, K), this;
  }, C.prototype.replaceAt = function(G, U) {
    var K = this._children, W = K[U];
    if (G && G !== this && G.parent !== this && G !== W) {
      K[U] = G, W.parent = null;
      var Z = this.__zr;
      Z && W.removeSelfFromZr(Z), this._doAdd(G);
    }
    return this;
  }, C.prototype._doAdd = function(G) {
    G.parent && G.parent.remove(G), G.parent = this;
    var U = this.__zr;
    U && U !== G.__zr && G.addSelfToZr(U), U && U.refresh();
  }, C.prototype.remove = function(G) {
    var U = this.__zr, K = this._children, W = indexOf(K, G);
    return W < 0 ? this : (K.splice(W, 1), G.parent = null, U && G.removeSelfFromZr(U), U && U.refresh(), this);
  }, C.prototype.removeAll = function() {
    for (var G = this._children, U = this.__zr, K = 0; K < G.length; K++) {
      var W = G[K];
      U && W.removeSelfFromZr(U), W.parent = null;
    }
    return G.length = 0, this;
  }, C.prototype.eachChild = function(G, U) {
    for (var K = this._children, W = 0; W < K.length; W++) {
      var Z = K[W];
      G.call(U, Z, W);
    }
    return this;
  }, C.prototype.traverse = function(G, U) {
    for (var K = 0; K < this._children.length; K++) {
      var W = this._children[K], Z = G.call(U, W);
      W.isGroup && !Z && W.traverse(G, U);
    }
    return this;
  }, C.prototype.addSelfToZr = function(G) {
    H.prototype.addSelfToZr.call(this, G);
    for (var U = 0; U < this._children.length; U++) {
      var K = this._children[U];
      K.addSelfToZr(G);
    }
  }, C.prototype.removeSelfFromZr = function(G) {
    H.prototype.removeSelfFromZr.call(this, G);
    for (var U = 0; U < this._children.length; U++) {
      var K = this._children[U];
      K.removeSelfFromZr(G);
    }
  }, C.prototype.getBoundingRect = function(G) {
    for (var U = new BoundingRect$1(0, 0, 0, 0), K = G || this._children, W = [], Z = null, X = 0; X < K.length; X++) {
      var Q = K[X];
      if (!(Q.ignore || Q.invisible)) {
        var ee = Q.getBoundingRect(), te = Q.getLocalTransform(W);
        te ? (BoundingRect$1.applyTransform(U, ee, te), Z = Z || U.clone(), Z.union(U)) : (Z = Z || ee.clone(), Z.union(ee));
      }
    }
    return Z || U;
  }, C;
}(Element$2);
Group$3.prototype.type = "group";
const Group$4 = Group$3;
/*!
* ZRender, a high performance 2d drawing library.
*
* Copyright (c) 2013, Baidu Inc.
* All rights reserved.
*
* LICENSE
* https://github.com/ecomfe/zrender/blob/master/LICENSE.txt
*/
var painterCtors = {}, instances$1 = {};
function delInstance(H) {
  delete instances$1[H];
}
function isDarkMode(H) {
  if (!H)
    return !1;
  if (typeof H == "string")
    return lum(H, 1) < DARK_MODE_THRESHOLD;
  if (H.colorStops) {
    for (var C = H.colorStops, G = 0, U = C.length, K = 0; K < U; K++)
      G += lum(C[K].color, 1);
    return G /= U, G < DARK_MODE_THRESHOLD;
  }
  return !1;
}
var ZRender = function() {
  function H(C, G, U) {
    var K = this;
    this._sleepAfterStill = 10, this._stillFrameAccum = 0, this._needsRefresh = !0, this._needsRefreshHover = !0, this._darkMode = !1, U = U || {}, this.dom = G, this.id = C;
    var W = new Storage$1(), Z = U.renderer || "canvas";
    if (painterCtors[Z] || (Z = keys(painterCtors)[0]), process.env.NODE_ENV !== "production" && !painterCtors[Z])
      throw new Error("Renderer '" + Z + "' is not imported. Please import it first.");
    U.useDirtyRect = U.useDirtyRect == null ? !1 : U.useDirtyRect;
    var X = new painterCtors[Z](G, W, U, C), Q = U.ssr || X.ssrOnly;
    this.storage = W, this.painter = X;
    var ee = !env$1.node && !env$1.worker && !Q ? new HandlerProxy(X.getViewportRoot(), X.root) : null, te = U.useCoarsePointer, re = te == null || te === "auto" ? env$1.touchEventsSupported : !!te, ne = 44, ae;
    re && (ae = retrieve2(U.pointerSize, ne)), this.handler = new Handler$1(W, X, ee, X.root, ae), this.animation = new Animation$1({
      stage: {
        update: Q ? null : function() {
          return K._flush(!0);
        }
      }
    }), Q || this.animation.start();
  }
  return H.prototype.add = function(C) {
    C && (this.storage.addRoot(C), C.addSelfToZr(this), this.refresh());
  }, H.prototype.remove = function(C) {
    C && (this.storage.delRoot(C), C.removeSelfFromZr(this), this.refresh());
  }, H.prototype.configLayer = function(C, G) {
    this.painter.configLayer && this.painter.configLayer(C, G), this.refresh();
  }, H.prototype.setBackgroundColor = function(C) {
    this.painter.setBackgroundColor && this.painter.setBackgroundColor(C), this.refresh(), this._backgroundColor = C, this._darkMode = isDarkMode(C);
  }, H.prototype.getBackgroundColor = function() {
    return this._backgroundColor;
  }, H.prototype.setDarkMode = function(C) {
    this._darkMode = C;
  }, H.prototype.isDarkMode = function() {
    return this._darkMode;
  }, H.prototype.refreshImmediately = function(C) {
    C || this.animation.update(!0), this._needsRefresh = !1, this.painter.refresh(), this._needsRefresh = !1;
  }, H.prototype.refresh = function() {
    this._needsRefresh = !0, this.animation.start();
  }, H.prototype.flush = function() {
    this._flush(!1);
  }, H.prototype._flush = function(C) {
    var G, U = getTime();
    this._needsRefresh && (G = !0, this.refreshImmediately(C)), this._needsRefreshHover && (G = !0, this.refreshHoverImmediately());
    var K = getTime();
    G ? (this._stillFrameAccum = 0, this.trigger("rendered", {
      elapsedTime: K - U
    })) : this._sleepAfterStill > 0 && (this._stillFrameAccum++, this._stillFrameAccum > this._sleepAfterStill && this.animation.stop());
  }, H.prototype.setSleepAfterStill = function(C) {
    this._sleepAfterStill = C;
  }, H.prototype.wakeUp = function() {
    this.animation.start(), this._stillFrameAccum = 0;
  }, H.prototype.refreshHover = function() {
    this._needsRefreshHover = !0;
  }, H.prototype.refreshHoverImmediately = function() {
    this._needsRefreshHover = !1, this.painter.refreshHover && this.painter.getType() === "canvas" && this.painter.refreshHover();
  }, H.prototype.resize = function(C) {
    C = C || {}, this.painter.resize(C.width, C.height), this.handler.resize();
  }, H.prototype.clearAnimation = function() {
    this.animation.clear();
  }, H.prototype.getWidth = function() {
    return this.painter.getWidth();
  }, H.prototype.getHeight = function() {
    return this.painter.getHeight();
  }, H.prototype.setCursorStyle = function(C) {
    this.handler.setCursorStyle(C);
  }, H.prototype.findHover = function(C, G) {
    return this.handler.findHover(C, G);
  }, H.prototype.on = function(C, G, U) {
    return this.handler.on(C, G, U), this;
  }, H.prototype.off = function(C, G) {
    this.handler.off(C, G);
  }, H.prototype.trigger = function(C, G) {
    this.handler.trigger(C, G);
  }, H.prototype.clear = function() {
    for (var C = this.storage.getRoots(), G = 0; G < C.length; G++)
      C[G] instanceof Group$4 && C[G].removeSelfFromZr(this);
    this.storage.delAllRoots(), this.painter.clear();
  }, H.prototype.dispose = function() {
    this.animation.stop(), this.clear(), this.storage.dispose(), this.painter.dispose(), this.handler.dispose(), this.animation = this.storage = this.painter = this.handler = null, delInstance(this.id);
  }, H;
}();
function init$2(H, C) {
  var G = new ZRender(guid(), H, C);
  return instances$1[G.id] = G, G;
}
function registerPainter(H, C) {
  painterCtors[H] = C;
}
var RADIAN_EPSILON = 1e-4, ROUND_SUPPORTED_PRECISION_MAX = 20;
function _trim(H) {
  return H.replace(/^\s+|\s+$/g, "");
}
function linearMap$2(H, C, G, U) {
  var K = C[0], W = C[1], Z = G[0], X = G[1], Q = W - K, ee = X - Z;
  if (Q === 0)
    return ee === 0 ? Z : (Z + X) / 2;
  if (U)
    if (Q > 0) {
      if (H <= K)
        return Z;
      if (H >= W)
        return X;
    } else {
      if (H >= K)
        return Z;
      if (H <= W)
        return X;
    }
  else {
    if (H === K)
      return Z;
    if (H === W)
      return X;
  }
  return (H - K) / Q * ee + Z;
}
function parsePercent(H, C) {
  switch (H) {
    case "center":
    case "middle":
      H = "50%";
      break;
    case "left":
    case "top":
      H = "0%";
      break;
    case "right":
    case "bottom":
      H = "100%";
      break;
  }
  return isString(H) ? _trim(H).match(/%$/) ? parseFloat(H) / 100 * C : parseFloat(H) : H == null ? NaN : +H;
}
function round$3(H, C, G) {
  return C == null && (C = 10), C = Math.min(Math.max(0, C), ROUND_SUPPORTED_PRECISION_MAX), H = (+H).toFixed(C), G ? H : +H;
}
function asc$2(H) {
  return H.sort(function(C, G) {
    return C - G;
  }), H;
}
function getPrecision(H) {
  if (H = +H, isNaN(H))
    return 0;
  if (H > 1e-14) {
    for (var C = 1, G = 0; G < 15; G++, C *= 10)
      if (Math.round(H * C) / C === H)
        return G;
  }
  return getPrecisionSafe(H);
}
function getPrecisionSafe(H) {
  var C = H.toString().toLowerCase(), G = C.indexOf("e"), U = G > 0 ? +C.slice(G + 1) : 0, K = G > 0 ? G : C.length, W = C.indexOf("."), Z = W < 0 ? 0 : K - 1 - W;
  return Math.max(0, Z - U);
}
function getPixelPrecision(H, C) {
  var G = Math.log, U = Math.LN10, K = Math.floor(G(H[1] - H[0]) / U), W = Math.round(G(Math.abs(C[1] - C[0])) / U), Z = Math.min(Math.max(-K + W, 0), 20);
  return isFinite(Z) ? Z : 20;
}
function getPercentSeats(H, C) {
  var G = reduce(H, function(ae, ie) {
    return ae + (isNaN(ie) ? 0 : ie);
  }, 0);
  if (G === 0)
    return [];
  for (var U = Math.pow(10, C), K = map$1(H, function(ae) {
    return (isNaN(ae) ? 0 : ae) / G * U * 100;
  }), W = U * 100, Z = map$1(K, function(ae) {
    return Math.floor(ae);
  }), X = reduce(Z, function(ae, ie) {
    return ae + ie;
  }, 0), Q = map$1(K, function(ae, ie) {
    return ae - Z[ie];
  }); X < W; ) {
    for (var ee = Number.NEGATIVE_INFINITY, te = null, re = 0, ne = Q.length; re < ne; ++re)
      Q[re] > ee && (ee = Q[re], te = re);
    ++Z[te], Q[te] = 0, ++X;
  }
  return map$1(Z, function(ae) {
    return ae / U;
  });
}
function addSafe(H, C) {
  var G = Math.max(getPrecision(H), getPrecision(C)), U = H + C;
  return G > ROUND_SUPPORTED_PRECISION_MAX ? U : round$3(U, G);
}
var MAX_SAFE_INTEGER = 9007199254740991;
function remRadian(H) {
  var C = Math.PI * 2;
  return (H % C + C) % C;
}
function isRadianAroundZero(H) {
  return H > -RADIAN_EPSILON && H < RADIAN_EPSILON;
}
var TIME_REG = /^(?:(\d{4})(?:[-\/](\d{1,2})(?:[-\/](\d{1,2})(?:[T ](\d{1,2})(?::(\d{1,2})(?::(\d{1,2})(?:[.,](\d+))?)?)?(Z|[\+\-]\d\d:?\d\d)?)?)?)?)?$/;
function parseDate(H) {
  if (H instanceof Date)
    return H;
  if (isString(H)) {
    var C = TIME_REG.exec(H);
    if (!C)
      return new Date(NaN);
    if (C[8]) {
      var G = +C[4] || 0;
      return C[8].toUpperCase() !== "Z" && (G -= +C[8].slice(0, 3)), new Date(Date.UTC(+C[1], +(C[2] || 1) - 1, +C[3] || 1, G, +(C[5] || 0), +C[6] || 0, C[7] ? +C[7].substring(0, 3) : 0));
    } else
      return new Date(+C[1], +(C[2] || 1) - 1, +C[3] || 1, +C[4] || 0, +(C[5] || 0), +C[6] || 0, C[7] ? +C[7].substring(0, 3) : 0);
  } else if (H == null)
    return new Date(NaN);
  return new Date(Math.round(H));
}
function quantity(H) {
  return Math.pow(10, quantityExponent(H));
}
function quantityExponent(H) {
  if (H === 0)
    return 0;
  var C = Math.floor(Math.log(H) / Math.LN10);
  return H / Math.pow(10, C) >= 10 && C++, C;
}
function nice(H, C) {
  var G = quantityExponent(H), U = Math.pow(10, G), K = H / U, W;
  return C ? K < 1.5 ? W = 1 : K < 2.5 ? W = 2 : K < 4 ? W = 3 : K < 7 ? W = 5 : W = 10 : K < 1 ? W = 1 : K < 2 ? W = 2 : K < 3 ? W = 3 : K < 5 ? W = 5 : W = 10, H = W * U, G >= -20 ? +H.toFixed(G < 0 ? -G : 0) : H;
}
function quantile(H, C) {
  var G = (H.length - 1) * C + 1, U = Math.floor(G), K = +H[U - 1], W = G - U;
  return W ? K + W * (H[U] - K) : K;
}
function reformIntervals(H) {
  H.sort(function(Q, ee) {
    return X(Q, ee, 0) ? -1 : 1;
  });
  for (var C = -1 / 0, G = 1, U = 0; U < H.length; ) {
    for (var K = H[U].interval, W = H[U].close, Z = 0; Z < 2; Z++)
      K[Z] <= C && (K[Z] = C, W[Z] = Z ? 1 : 1 - G), C = K[Z], G = W[Z];
    K[0] === K[1] && W[0] * W[1] !== 1 ? H.splice(U, 1) : U++;
  }
  return H;
  function X(Q, ee, te) {
    return Q.interval[te] < ee.interval[te] || Q.interval[te] === ee.interval[te] && (Q.close[te] - ee.close[te] === (te ? -1 : 1) || !te && X(Q, ee, 1));
  }
}
function numericToNumber(H) {
  var C = parseFloat(H);
  return C == H && (C !== 0 || !isString(H) || H.indexOf("x") <= 0) ? C : NaN;
}
function isNumeric(H) {
  return !isNaN(numericToNumber(H));
}
function getRandomIdBase() {
  return Math.round(Math.random() * 9);
}
function getGreatestCommonDividor(H, C) {
  return C === 0 ? H : getGreatestCommonDividor(C, H % C);
}
function getLeastCommonMultiple(H, C) {
  return H == null ? C : C == null ? H : H * C / getGreatestCommonDividor(H, C);
}
var ECHARTS_PREFIX = "[ECharts] ", storedLogs = {}, hasConsole = typeof console < "u" && console.warn && console.log;
function outputLog(H, C, G) {
  if (hasConsole) {
    if (G) {
      if (storedLogs[C])
        return;
      storedLogs[C] = !0;
    }
    console[H](ECHARTS_PREFIX + C);
  }
}
function log(H, C) {
  outputLog("log", H, C);
}
function warn(H, C) {
  outputLog("warn", H, C);
}
function error(H, C) {
  outputLog("error", H, C);
}
function deprecateLog(H) {
  process.env.NODE_ENV !== "production" && outputLog("warn", "DEPRECATED: " + H, !0);
}
function deprecateReplaceLog(H, C, G) {
  process.env.NODE_ENV !== "production" && deprecateLog((G ? "[" + G + "]" : "") + (H + " is deprecated, use " + C + " instead."));
}
function makePrintable() {
  for (var H = [], C = 0; C < arguments.length; C++)
    H[C] = arguments[C];
  var G = "";
  if (process.env.NODE_ENV !== "production") {
    var U = function(K) {
      return K === void 0 ? "undefined" : K === 1 / 0 ? "Infinity" : K === -1 / 0 ? "-Infinity" : eqNaN(K) ? "NaN" : K instanceof Date ? "Date(" + K.toISOString() + ")" : isFunction(K) ? "function () { ... }" : isRegExp(K) ? K + "" : null;
    };
    G = map$1(H, function(K) {
      if (isString(K))
        return K;
      var W = U(K);
      if (W != null)
        return W;
      if (typeof JSON < "u" && JSON.stringify)
        try {
          return JSON.stringify(K, function(Z, X) {
            var Q = U(X);
            return Q ?? X;
          });
        } catch {
          return "?";
        }
      else
        return "?";
    }).join(" ");
  }
  return G;
}
function throwError(H) {
  throw new Error(H);
}
function interpolateNumber(H, C, G) {
  return (C - H) * G + H;
}
var DUMMY_COMPONENT_NAME_PREFIX = "series\0", INTERNAL_COMPONENT_ID_PREFIX = "\0_ec_\0";
function normalizeToArray(H) {
  return H instanceof Array ? H : H == null ? [] : [H];
}
function defaultEmphasis(H, C, G) {
  if (H) {
    H[C] = H[C] || {}, H.emphasis = H.emphasis || {}, H.emphasis[C] = H.emphasis[C] || {};
    for (var U = 0, K = G.length; U < K; U++) {
      var W = G[U];
      !H.emphasis[C].hasOwnProperty(W) && H[C].hasOwnProperty(W) && (H.emphasis[C][W] = H[C][W]);
    }
  }
}
var TEXT_STYLE_OPTIONS = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "rich", "tag", "color", "textBorderColor", "textBorderWidth", "width", "height", "lineHeight", "align", "verticalAlign", "baseline", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY", "textShadowColor", "textShadowBlur", "textShadowOffsetX", "textShadowOffsetY", "backgroundColor", "borderColor", "borderWidth", "borderRadius", "padding"];
function getDataItemValue(H) {
  return isObject$3(H) && !isArray$1(H) && !(H instanceof Date) ? H.value : H;
}
function isDataItemOption(H) {
  return isObject$3(H) && !(H instanceof Array);
}
function mappingToExists(H, C, G) {
  var U = G === "normalMerge", K = G === "replaceMerge", W = G === "replaceAll";
  H = H || [], C = (C || []).slice();
  var Z = createHashMap();
  each$f(C, function(Q, ee) {
    if (!isObject$3(Q)) {
      C[ee] = null;
      return;
    }
    process.env.NODE_ENV !== "production" && (Q.id != null && !isValidIdOrName(Q.id) && warnInvalidateIdOrName(Q.id), Q.name != null && !isValidIdOrName(Q.name) && warnInvalidateIdOrName(Q.name));
  });
  var X = prepareResult(H, Z, G);
  return (U || K) && mappingById(X, H, Z, C), U && mappingByName(X, C), U || K ? mappingByIndex(X, C, K) : W && mappingInReplaceAllMode(X, C), makeIdAndName(X), X;
}
function prepareResult(H, C, G) {
  var U = [];
  if (G === "replaceAll")
    return U;
  for (var K = 0; K < H.length; K++) {
    var W = H[K];
    W && W.id != null && C.set(W.id, K), U.push({
      existing: G === "replaceMerge" || isComponentIdInternal(W) ? null : W,
      newOption: null,
      keyInfo: null,
      brandNew: null
    });
  }
  return U;
}
function mappingById(H, C, G, U) {
  each$f(U, function(K, W) {
    if (!(!K || K.id == null)) {
      var Z = makeComparableKey(K.id), X = G.get(Z);
      if (X != null) {
        var Q = H[X];
        assert(!Q.newOption, 'Duplicated option on id "' + Z + '".'), Q.newOption = K, Q.existing = C[X], U[W] = null;
      }
    }
  });
}
function mappingByName(H, C) {
  each$f(C, function(G, U) {
    if (!(!G || G.name == null))
      for (var K = 0; K < H.length; K++) {
        var W = H[K].existing;
        if (!H[K].newOption && W && (W.id == null || G.id == null) && !isComponentIdInternal(G) && !isComponentIdInternal(W) && keyExistAndEqual("name", W, G)) {
          H[K].newOption = G, C[U] = null;
          return;
        }
      }
  });
}
function mappingByIndex(H, C, G) {
  each$f(C, function(U) {
    if (U) {
      for (var K, W = 0; (K = H[W]) && // (1) Existing models that already have id should be able to mapped to. Because
      // after mapping performed, model will always be assigned with an id if user not given.
      // After that all models have id.
      // (2) If new option has id, it can only set to a hole or append to the last. It should
      // not be merged to the existings with different id. Because id should not be overwritten.
      // (3) Name can be overwritten, because axis use name as 'show label text'.
      (K.newOption || isComponentIdInternal(K.existing) || // In mode "replaceMerge", here no not-mapped-non-internal-existing.
      K.existing && U.id != null && !keyExistAndEqual("id", U, K.existing)); )
        W++;
      K ? (K.newOption = U, K.brandNew = G) : H.push({
        newOption: U,
        brandNew: G,
        existing: null,
        keyInfo: null
      }), W++;
    }
  });
}
function mappingInReplaceAllMode(H, C) {
  each$f(C, function(G) {
    H.push({
      newOption: G,
      brandNew: !0,
      existing: null,
      keyInfo: null
    });
  });
}
function makeIdAndName(H) {
  var C = createHashMap();
  each$f(H, function(G) {
    var U = G.existing;
    U && C.set(U.id, G);
  }), each$f(H, function(G) {
    var U = G.newOption;
    assert(!U || U.id == null || !C.get(U.id) || C.get(U.id) === G, "id duplicates: " + (U && U.id)), U && U.id != null && C.set(U.id, G), !G.keyInfo && (G.keyInfo = {});
  }), each$f(H, function(G, U) {
    var K = G.existing, W = G.newOption, Z = G.keyInfo;
    if (isObject$3(W)) {
      if (Z.name = W.name != null ? makeComparableKey(W.name) : K ? K.name : DUMMY_COMPONENT_NAME_PREFIX + U, K)
        Z.id = makeComparableKey(K.id);
      else if (W.id != null)
        Z.id = makeComparableKey(W.id);
      else {
        var X = 0;
        do
          Z.id = "\0" + Z.name + "\0" + X++;
        while (C.get(Z.id));
      }
      C.set(Z.id, G);
    }
  });
}
function keyExistAndEqual(H, C, G) {
  var U = convertOptionIdName(C[H], null), K = convertOptionIdName(G[H], null);
  return U != null && K != null && U === K;
}
function makeComparableKey(H) {
  if (process.env.NODE_ENV !== "production" && H == null)
    throw new Error();
  return convertOptionIdName(H, "");
}
function convertOptionIdName(H, C) {
  return H == null ? C : isString(H) ? H : isNumber(H) || isStringSafe(H) ? H + "" : C;
}
function warnInvalidateIdOrName(H) {
  process.env.NODE_ENV !== "production" && warn("`" + H + "` is invalid id or name. Must be a string or number.");
}
function isValidIdOrName(H) {
  return isStringSafe(H) || isNumeric(H);
}
function isNameSpecified(H) {
  var C = H.name;
  return !!(C && C.indexOf(DUMMY_COMPONENT_NAME_PREFIX));
}
function isComponentIdInternal(H) {
  return H && H.id != null && makeComparableKey(H.id).indexOf(INTERNAL_COMPONENT_ID_PREFIX) === 0;
}
function makeInternalComponentId(H) {
  return INTERNAL_COMPONENT_ID_PREFIX + H;
}
function setComponentTypeToKeyInfo(H, C, G) {
  each$f(H, function(U) {
    var K = U.newOption;
    isObject$3(K) && (U.keyInfo.mainType = C, U.keyInfo.subType = determineSubType(C, K, U.existing, G));
  });
}
function determineSubType(H, C, G, U) {
  var K = C.type ? C.type : G ? G.subType : U.determineSubType(H, C);
  return K;
}
function compressBatches(H, C) {
  var G = {}, U = {};
  return K(H || [], G), K(C || [], U, G), [W(G), W(U)];
  function K(Z, X, Q) {
    for (var ee = 0, te = Z.length; ee < te; ee++) {
      var re = convertOptionIdName(Z[ee].seriesId, null);
      if (re == null)
        return;
      for (var ne = normalizeToArray(Z[ee].dataIndex), ae = Q && Q[re], ie = 0, se = ne.length; ie < se; ie++) {
        var oe = ne[ie];
        ae && ae[oe] ? ae[oe] = null : (X[re] || (X[re] = {}))[oe] = 1;
      }
    }
  }
  function W(Z, X) {
    var Q = [];
    for (var ee in Z)
      if (Z.hasOwnProperty(ee) && Z[ee] != null)
        if (X)
          Q.push(+ee);
        else {
          var te = W(Z[ee], !0);
          te.length && Q.push({
            seriesId: ee,
            dataIndex: te
          });
        }
    return Q;
  }
}
function queryDataIndex(H, C) {
  if (C.dataIndexInside != null)
    return C.dataIndexInside;
  if (C.dataIndex != null)
    return isArray$1(C.dataIndex) ? map$1(C.dataIndex, function(G) {
      return H.indexOfRawIndex(G);
    }) : H.indexOfRawIndex(C.dataIndex);
  if (C.name != null)
    return isArray$1(C.name) ? map$1(C.name, function(G) {
      return H.indexOfName(G);
    }) : H.indexOfName(C.name);
}
function makeInner() {
  var H = "__ec_inner_" + innerUniqueIndex++;
  return function(C) {
    return C[H] || (C[H] = {});
  };
}
var innerUniqueIndex = getRandomIdBase();
function parseFinder$1(H, C, G) {
  var U = preParseFinder(C, G), K = U.mainTypeSpecified, W = U.queryOptionMap, Z = U.others, X = Z, Q = G ? G.defaultMainType : null;
  return !K && Q && W.set(Q, {}), W.each(function(ee, te) {
    var re = queryReferringComponents(H, te, ee, {
      useDefault: Q === te,
      enableAll: G && G.enableAll != null ? G.enableAll : !0,
      enableNone: G && G.enableNone != null ? G.enableNone : !0
    });
    X[te + "Models"] = re.models, X[te + "Model"] = re.models[0];
  }), X;
}
function preParseFinder(H, C) {
  var G;
  if (isString(H)) {
    var U = {};
    U[H + "Index"] = 0, G = U;
  } else
    G = H;
  var K = createHashMap(), W = {}, Z = !1;
  return each$f(G, function(X, Q) {
    if (Q === "dataIndex" || Q === "dataIndexInside") {
      W[Q] = X;
      return;
    }
    var ee = Q.match(/^(\w+)(Index|Id|Name)$/) || [], te = ee[1], re = (ee[2] || "").toLowerCase();
    if (!(!te || !re || C && C.includeMainTypes && indexOf(C.includeMainTypes, te) < 0)) {
      Z = Z || !!te;
      var ne = K.get(te) || K.set(te, {});
      ne[re] = X;
    }
  }), {
    mainTypeSpecified: Z,
    queryOptionMap: K,
    others: W
  };
}
var SINGLE_REFERRING = {
  useDefault: !0,
  enableAll: !1,
  enableNone: !1
}, MULTIPLE_REFERRING = {
  useDefault: !1,
  enableAll: !0,
  enableNone: !0
};
function queryReferringComponents(H, C, G, U) {
  U = U || SINGLE_REFERRING;
  var K = G.index, W = G.id, Z = G.name, X = {
    models: null,
    specified: K != null || W != null || Z != null
  };
  if (!X.specified) {
    var Q = void 0;
    return X.models = U.useDefault && (Q = H.getComponent(C)) ? [Q] : [], X;
  }
  return K === "none" || K === !1 ? (assert(U.enableNone, '`"none"` or `false` is not a valid value on index option.'), X.models = [], X) : (K === "all" && (assert(U.enableAll, '`"all"` is not a valid value on index option.'), K = W = Z = null), X.models = H.queryComponents({
    mainType: C,
    index: K,
    id: W,
    name: Z
  }), X);
}
function setAttribute(H, C, G) {
  H.setAttribute ? H.setAttribute(C, G) : H[C] = G;
}
function getAttribute(H, C) {
  return H.getAttribute ? H.getAttribute(C) : H[C];
}
function getTooltipRenderMode(H) {
  return H === "auto" ? env$1.domSupported ? "html" : "richText" : H || "html";
}
function groupData(H, C) {
  var G = createHashMap(), U = [];
  return each$f(H, function(K) {
    var W = C(K);
    (G.get(W) || (U.push(W), G.set(W, []))).push(K);
  }), {
    keys: U,
    buckets: G
  };
}
function interpolateRawValues(H, C, G, U, K) {
  var W = C == null || C === "auto";
  if (U == null)
    return U;
  if (isNumber(U)) {
    var Z = interpolateNumber(G || 0, U, K);
    return round$3(Z, W ? Math.max(getPrecision(G || 0), getPrecision(U)) : C);
  } else {
    if (isString(U))
      return K < 1 ? G : U;
    for (var X = [], Q = G, ee = U, te = Math.max(Q ? Q.length : 0, ee.length), re = 0; re < te; ++re) {
      var ne = H.getDimensionInfo(re);
      if (ne && ne.type === "ordinal")
        X[re] = (K < 1 && Q ? Q : ee)[re];
      else {
        var ae = Q && Q[re] ? Q[re] : 0, ie = ee[re], Z = interpolateNumber(ae, ie, K);
        X[re] = round$3(Z, W ? Math.max(getPrecision(ae), getPrecision(ie)) : C);
      }
    }
    return X;
  }
}
var TYPE_DELIMITER = ".", IS_CONTAINER = "___EC__COMPONENT__CONTAINER___", IS_EXTENDED_CLASS = "___EC__EXTENDED_CLASS___";
function parseClassType(H) {
  var C = {
    main: "",
    sub: ""
  };
  if (H) {
    var G = H.split(TYPE_DELIMITER);
    C.main = G[0] || "", C.sub = G[1] || "";
  }
  return C;
}
function checkClassType(H) {
  assert(/^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(H), 'componentType "' + H + '" illegal');
}
function isExtendedClass(H) {
  return !!(H && H[IS_EXTENDED_CLASS]);
}
function enableClassExtend(H, C) {
  H.$constructor = H, H.extend = function(G) {
    process.env.NODE_ENV !== "production" && each$f(C, function(W) {
      G[W] || console.warn("Method `" + W + "` should be implemented" + (G.type ? " in " + G.type : "") + ".");
    });
    var U = this, K;
    return isESClass(U) ? K = /** @class */
    function(W) {
      __extends$1(Z, W);
      function Z() {
        return W.apply(this, arguments) || this;
      }
      return Z;
    }(U) : (K = function() {
      (G.$constructor || U).apply(this, arguments);
    }, inherits(K, this)), extend(K.prototype, G), K[IS_EXTENDED_CLASS] = !0, K.extend = this.extend, K.superCall = superCall, K.superApply = superApply, K.superClass = U, K;
  };
}
function isESClass(H) {
  return isFunction(H) && /^class\s/.test(Function.prototype.toString.call(H));
}
function mountExtend(H, C) {
  H.extend = C.extend;
}
var classBase = Math.round(Math.random() * 10);
function enableClassCheck(H) {
  var C = ["__\0is_clz", classBase++].join("_");
  H.prototype[C] = !0, process.env.NODE_ENV !== "production" && assert(!H.isInstance, 'The method "is" can not be defined.'), H.isInstance = function(G) {
    return !!(G && G[C]);
  };
}
function superCall(H, C) {
  for (var G = [], U = 2; U < arguments.length; U++)
    G[U - 2] = arguments[U];
  return this.superClass.prototype[C].apply(H, G);
}
function superApply(H, C, G) {
  return this.superClass.prototype[C].apply(H, G);
}
function enableClassManagement(H) {
  var C = {};
  H.registerClass = function(U) {
    var K = U.type || U.prototype.type;
    if (K) {
      checkClassType(K), U.prototype.type = K;
      var W = parseClassType(K);
      if (!W.sub)
        process.env.NODE_ENV !== "production" && C[W.main] && console.warn(W.main + " exists."), C[W.main] = U;
      else if (W.sub !== IS_CONTAINER) {
        var Z = G(W);
        Z[W.sub] = U;
      }
    }
    return U;
  }, H.getClass = function(U, K, W) {
    var Z = C[U];
    if (Z && Z[IS_CONTAINER] && (Z = K ? Z[K] : null), W && !Z)
      throw new Error(K ? "Component " + U + "." + (K || "") + " is used but not imported." : U + ".type should be specified.");
    return Z;
  }, H.getClassesByMainType = function(U) {
    var K = parseClassType(U), W = [], Z = C[K.main];
    return Z && Z[IS_CONTAINER] ? each$f(Z, function(X, Q) {
      Q !== IS_CONTAINER && W.push(X);
    }) : W.push(Z), W;
  }, H.hasClass = function(U) {
    var K = parseClassType(U);
    return !!C[K.main];
  }, H.getAllClassMainTypes = function() {
    var U = [];
    return each$f(C, function(K, W) {
      U.push(W);
    }), U;
  }, H.hasSubTypes = function(U) {
    var K = parseClassType(U), W = C[K.main];
    return W && W[IS_CONTAINER];
  };
  function G(U) {
    var K = C[U.main];
    return (!K || !K[IS_CONTAINER]) && (K = C[U.main] = {}, K[IS_CONTAINER] = !0), K;
  }
}
function makeStyleMapper(H, C) {
  for (var G = 0; G < H.length; G++)
    H[G][1] || (H[G][1] = H[G][0]);
  return C = C || !1, function(U, K, W) {
    for (var Z = {}, X = 0; X < H.length; X++) {
      var Q = H[X][1];
      if (!(K && indexOf(K, Q) >= 0 || W && indexOf(W, Q) < 0)) {
        var ee = U.getShallow(Q, C);
        ee != null && (Z[H[X][0]] = ee);
      }
    }
    return Z;
  };
}
var AREA_STYLE_KEY_MAP = [
  ["fill", "color"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["opacity"],
  ["shadowColor"]
  // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
  // So do not transfer decal directly.
], getAreaStyle = makeStyleMapper(AREA_STYLE_KEY_MAP), AreaStyleMixin = (
  /** @class */
  function() {
    function H() {
    }
    return H.prototype.getAreaStyle = function(C, G) {
      return getAreaStyle(this, C, G);
    }, H;
  }()
), globalImageCache = new LRU$1(50);
function findExistImage(H) {
  if (typeof H == "string") {
    var C = globalImageCache.get(H);
    return C && C.image;
  } else
    return H;
}
function createOrUpdateImage(H, C, G, U, K) {
  if (H)
    if (typeof H == "string") {
      if (C && C.__zrImageSrc === H || !G)
        return C;
      var W = globalImageCache.get(H), Z = { hostEl: G, cb: U, cbPayload: K };
      return W ? (C = W.image, !isImageReady(C) && W.pending.push(Z)) : (C = platformApi.loadImage(H, imageOnLoad, imageOnLoad), C.__zrImageSrc = H, globalImageCache.put(H, C.__cachedImgObj = {
        image: C,
        pending: [Z]
      })), C;
    } else
      return H;
  else
    return C;
}
function imageOnLoad() {
  var H = this.__cachedImgObj;
  this.onload = this.onerror = this.__cachedImgObj = null;
  for (var C = 0; C < H.pending.length; C++) {
    var G = H.pending[C], U = G.cb;
    U && U(this, G.cbPayload), G.hostEl.dirty();
  }
  H.pending.length = 0;
}
function isImageReady(H) {
  return H && H.width && H.height;
}
var STYLE_REG = /\{([a-zA-Z0-9_]+)\|([^}]*)\}/g;
function truncateText(H, C, G, U, K) {
  if (!C)
    return "";
  var W = (H + "").split(`
`);
  K = prepareTruncateOptions(C, G, U, K);
  for (var Z = 0, X = W.length; Z < X; Z++)
    W[Z] = truncateSingleLine(W[Z], K);
  return W.join(`
`);
}
function prepareTruncateOptions(H, C, G, U) {
  U = U || {};
  var K = extend({}, U);
  K.font = C, G = retrieve2(G, "..."), K.maxIterations = retrieve2(U.maxIterations, 2);
  var W = K.minChar = retrieve2(U.minChar, 0);
  K.cnCharWidth = getWidth("国", C);
  var Z = K.ascCharWidth = getWidth("a", C);
  K.placeholder = retrieve2(U.placeholder, "");
  for (var X = H = Math.max(0, H - 1), Q = 0; Q < W && X >= Z; Q++)
    X -= Z;
  var ee = getWidth(G, C);
  return ee > X && (G = "", ee = 0), X = H - ee, K.ellipsis = G, K.ellipsisWidth = ee, K.contentWidth = X, K.containerWidth = H, K;
}
function truncateSingleLine(H, C) {
  var G = C.containerWidth, U = C.font, K = C.contentWidth;
  if (!G)
    return "";
  var W = getWidth(H, U);
  if (W <= G)
    return H;
  for (var Z = 0; ; Z++) {
    if (W <= K || Z >= C.maxIterations) {
      H += C.ellipsis;
      break;
    }
    var X = Z === 0 ? estimateLength(H, K, C.ascCharWidth, C.cnCharWidth) : W > 0 ? Math.floor(H.length * K / W) : 0;
    H = H.substr(0, X), W = getWidth(H, U);
  }
  return H === "" && (H = C.placeholder), H;
}
function estimateLength(H, C, G, U) {
  for (var K = 0, W = 0, Z = H.length; W < Z && K < C; W++) {
    var X = H.charCodeAt(W);
    K += 0 <= X && X <= 127 ? G : U;
  }
  return W;
}
function parsePlainText(H, C) {
  H != null && (H += "");
  var G = C.overflow, U = C.padding, K = C.font, W = G === "truncate", Z = getLineHeight(K), X = retrieve2(C.lineHeight, Z), Q = !!C.backgroundColor, ee = C.lineOverflow === "truncate", te = C.width, re;
  te != null && (G === "break" || G === "breakAll") ? re = H ? wrapText(H, C.font, te, G === "breakAll", 0).lines : [] : re = H ? H.split(`
`) : [];
  var ne = re.length * X, ae = retrieve2(C.height, ne);
  if (ne > ae && ee) {
    var ie = Math.floor(ae / X);
    re = re.slice(0, ie);
  }
  if (H && W && te != null)
    for (var se = prepareTruncateOptions(te, K, C.ellipsis, {
      minChar: C.truncateMinChar,
      placeholder: C.placeholder
    }), oe = 0; oe < re.length; oe++)
      re[oe] = truncateSingleLine(re[oe], se);
  for (var le = ae, ue = 0, oe = 0; oe < re.length; oe++)
    ue = Math.max(getWidth(re[oe], K), ue);
  te == null && (te = ue);
  var ce = ue;
  return U && (le += U[0] + U[2], ce += U[1] + U[3], te += U[1] + U[3]), Q && (ce = te), {
    lines: re,
    height: ae,
    outerWidth: ce,
    outerHeight: le,
    lineHeight: X,
    calculatedLineHeight: Z,
    contentWidth: ue,
    contentHeight: ne,
    width: te
  };
}
var RichTextToken = function() {
  function H() {
  }
  return H;
}(), RichTextLine = function() {
  function H(C) {
    this.tokens = [], C && (this.tokens = C);
  }
  return H;
}(), RichTextContentBlock = function() {
  function H() {
    this.width = 0, this.height = 0, this.contentWidth = 0, this.contentHeight = 0, this.outerWidth = 0, this.outerHeight = 0, this.lines = [];
  }
  return H;
}();
function parseRichText(H, C) {
  var G = new RichTextContentBlock();
  if (H != null && (H += ""), !H)
    return G;
  for (var U = C.width, K = C.height, W = C.overflow, Z = (W === "break" || W === "breakAll") && U != null ? { width: U, accumWidth: 0, breakAll: W === "breakAll" } : null, X = STYLE_REG.lastIndex = 0, Q; (Q = STYLE_REG.exec(H)) != null; ) {
    var ee = Q.index;
    ee > X && pushTokens(G, H.substring(X, ee), C, Z), pushTokens(G, Q[2], C, Z, Q[1]), X = STYLE_REG.lastIndex;
  }
  X < H.length && pushTokens(G, H.substring(X, H.length), C, Z);
  var te = [], re = 0, ne = 0, ae = C.padding, ie = W === "truncate", se = C.lineOverflow === "truncate";
  function oe(xe, Te, Pe) {
    xe.width = Te, xe.lineHeight = Pe, re += Pe, ne = Math.max(ne, Te);
  }
  e:
    for (var le = 0; le < G.lines.length; le++) {
      for (var ue = G.lines[le], ce = 0, de = 0, ge = 0; ge < ue.tokens.length; ge++) {
        var fe = ue.tokens[ge], ve = fe.styleName && C.rich[fe.styleName] || {}, pe = fe.textPadding = ve.padding, he = pe ? pe[1] + pe[3] : 0, me = fe.font = ve.font || C.font;
        fe.contentHeight = getLineHeight(me);
        var ye = retrieve2(ve.height, fe.contentHeight);
        if (fe.innerHeight = ye, pe && (ye += pe[0] + pe[2]), fe.height = ye, fe.lineHeight = retrieve3(ve.lineHeight, C.lineHeight, ye), fe.align = ve && ve.align || C.align, fe.verticalAlign = ve && ve.verticalAlign || "middle", se && K != null && re + fe.lineHeight > K) {
          ge > 0 ? (ue.tokens = ue.tokens.slice(0, ge), oe(ue, de, ce), G.lines = G.lines.slice(0, le + 1)) : G.lines = G.lines.slice(0, le);
          break e;
        }
        var Ce = ve.width, Ie = Ce == null || Ce === "auto";
        if (typeof Ce == "string" && Ce.charAt(Ce.length - 1) === "%")
          fe.percentWidth = Ce, te.push(fe), fe.contentWidth = getWidth(fe.text, me);
        else {
          if (Ie) {
            var be = ve.backgroundColor, Se = be && be.image;
            Se && (Se = findExistImage(Se), isImageReady(Se) && (fe.width = Math.max(fe.width, Se.width * ye / Se.height)));
          }
          var Ae = ie && U != null ? U - de : null;
          Ae != null && Ae < fe.width ? !Ie || Ae < he ? (fe.text = "", fe.width = fe.contentWidth = 0) : (fe.text = truncateText(fe.text, Ae - he, me, C.ellipsis, { minChar: C.truncateMinChar }), fe.width = fe.contentWidth = getWidth(fe.text, me)) : fe.contentWidth = getWidth(fe.text, me);
        }
        fe.width += he, de += fe.width, ve && (ce = Math.max(ce, fe.lineHeight));
      }
      oe(ue, de, ce);
    }
  G.outerWidth = G.width = retrieve2(U, ne), G.outerHeight = G.height = retrieve2(K, re), G.contentHeight = re, G.contentWidth = ne, ae && (G.outerWidth += ae[1] + ae[3], G.outerHeight += ae[0] + ae[2]);
  for (var le = 0; le < te.length; le++) {
    var fe = te[le], _e = fe.percentWidth;
    fe.width = parseInt(_e, 10) / 100 * G.width;
  }
  return G;
}
function pushTokens(H, C, G, U, K) {
  var W = C === "", Z = K && G.rich[K] || {}, X = H.lines, Q = Z.font || G.font, ee = !1, te, re;
  if (U) {
    var ne = Z.padding, ae = ne ? ne[1] + ne[3] : 0;
    if (Z.width != null && Z.width !== "auto") {
      var ie = parsePercent$1(Z.width, U.width) + ae;
      X.length > 0 && ie + U.accumWidth > U.width && (te = C.split(`
`), ee = !0), U.accumWidth = ie;
    } else {
      var se = wrapText(C, Q, U.width, U.breakAll, U.accumWidth);
      U.accumWidth = se.accumWidth + ae, re = se.linesWidths, te = se.lines;
    }
  } else
    te = C.split(`
`);
  for (var oe = 0; oe < te.length; oe++) {
    var le = te[oe], ue = new RichTextToken();
    if (ue.styleName = K, ue.text = le, ue.isLineHolder = !le && !W, typeof Z.width == "number" ? ue.width = Z.width : ue.width = re ? re[oe] : getWidth(le, Q), !oe && !ee) {
      var ce = (X[X.length - 1] || (X[0] = new RichTextLine())).tokens, de = ce.length;
      de === 1 && ce[0].isLineHolder ? ce[0] = ue : (le || !de || W) && ce.push(ue);
    } else
      X.push(new RichTextLine([ue]));
  }
}
function isLatin(H) {
  var C = H.charCodeAt(0);
  return C >= 33 && C <= 383;
}
var breakCharMap = reduce(",&?/;] ".split(""), function(H, C) {
  return H[C] = !0, H;
}, {});
function isWordBreakChar(H) {
  return isLatin(H) ? !!breakCharMap[H] : !0;
}
function wrapText(H, C, G, U, K) {
  for (var W = [], Z = [], X = "", Q = "", ee = 0, te = 0, re = 0; re < H.length; re++) {
    var ne = H.charAt(re);
    if (ne === `
`) {
      Q && (X += Q, te += ee), W.push(X), Z.push(te), X = "", Q = "", ee = 0, te = 0;
      continue;
    }
    var ae = getWidth(ne, C), ie = U ? !1 : !isWordBreakChar(ne);
    if (W.length ? te + ae > G : K + te + ae > G) {
      te ? (X || Q) && (ie ? (X || (X = Q, Q = "", ee = 0, te = ee), W.push(X), Z.push(te - ee), Q += ne, ee += ae, X = "", te = ee) : (Q && (X += Q, Q = "", ee = 0), W.push(X), Z.push(te), X = ne, te = ae)) : ie ? (W.push(Q), Z.push(ee), Q = ne, ee = ae) : (W.push(ne), Z.push(ae));
      continue;
    }
    te += ae, ie ? (Q += ne, ee += ae) : (Q && (X += Q, Q = "", ee = 0), X += ne);
  }
  return !W.length && !X && (X = H, Q = "", ee = 0), Q && (X += Q), X && (W.push(X), Z.push(te)), W.length === 1 && (te += K), {
    accumWidth: te,
    lines: W,
    linesWidths: Z
  };
}
var STYLE_MAGIC_KEY = "__zr_style_" + Math.round(Math.random() * 10), DEFAULT_COMMON_STYLE = {
  shadowBlur: 0,
  shadowOffsetX: 0,
  shadowOffsetY: 0,
  shadowColor: "#000",
  opacity: 1,
  blend: "source-over"
}, DEFAULT_COMMON_ANIMATION_PROPS = {
  style: {
    shadowBlur: !0,
    shadowOffsetX: !0,
    shadowOffsetY: !0,
    shadowColor: !0,
    opacity: !0
  }
};
DEFAULT_COMMON_STYLE[STYLE_MAGIC_KEY] = !0;
var PRIMARY_STATES_KEYS = ["z", "z2", "invisible"], PRIMARY_STATES_KEYS_IN_HOVER_LAYER = ["invisible"], Displayable = function(H) {
  __extends(C, H);
  function C(G) {
    return H.call(this, G) || this;
  }
  return C.prototype._init = function(G) {
    for (var U = keys(G), K = 0; K < U.length; K++) {
      var W = U[K];
      W === "style" ? this.useStyle(G[W]) : H.prototype.attrKV.call(this, W, G[W]);
    }
    this.style || this.useStyle({});
  }, C.prototype.beforeBrush = function() {
  }, C.prototype.afterBrush = function() {
  }, C.prototype.innerBeforeBrush = function() {
  }, C.prototype.innerAfterBrush = function() {
  }, C.prototype.shouldBePainted = function(G, U, K, W) {
    var Z = this.transform;
    if (this.ignore || this.invisible || this.style.opacity === 0 || this.culling && isDisplayableCulled(this, G, U) || Z && !Z[0] && !Z[3])
      return !1;
    if (K && this.__clipPaths) {
      for (var X = 0; X < this.__clipPaths.length; ++X)
        if (this.__clipPaths[X].isZeroArea())
          return !1;
    }
    if (W && this.parent)
      for (var Q = this.parent; Q; ) {
        if (Q.ignore)
          return !1;
        Q = Q.parent;
      }
    return !0;
  }, C.prototype.contain = function(G, U) {
    return this.rectContain(G, U);
  }, C.prototype.traverse = function(G, U) {
    G.call(U, this);
  }, C.prototype.rectContain = function(G, U) {
    var K = this.transformCoordToLocal(G, U), W = this.getBoundingRect();
    return W.contain(K[0], K[1]);
  }, C.prototype.getPaintRect = function() {
    var G = this._paintRect;
    if (!this._paintRect || this.__dirty) {
      var U = this.transform, K = this.getBoundingRect(), W = this.style, Z = W.shadowBlur || 0, X = W.shadowOffsetX || 0, Q = W.shadowOffsetY || 0;
      G = this._paintRect || (this._paintRect = new BoundingRect$1(0, 0, 0, 0)), U ? BoundingRect$1.applyTransform(G, K, U) : G.copy(K), (Z || X || Q) && (G.width += Z * 2 + Math.abs(X), G.height += Z * 2 + Math.abs(Q), G.x = Math.min(G.x, G.x + X - Z), G.y = Math.min(G.y, G.y + Q - Z));
      var ee = this.dirtyRectTolerance;
      G.isZero() || (G.x = Math.floor(G.x - ee), G.y = Math.floor(G.y - ee), G.width = Math.ceil(G.width + 1 + ee * 2), G.height = Math.ceil(G.height + 1 + ee * 2));
    }
    return G;
  }, C.prototype.setPrevPaintRect = function(G) {
    G ? (this._prevPaintRect = this._prevPaintRect || new BoundingRect$1(0, 0, 0, 0), this._prevPaintRect.copy(G)) : this._prevPaintRect = null;
  }, C.prototype.getPrevPaintRect = function() {
    return this._prevPaintRect;
  }, C.prototype.animateStyle = function(G) {
    return this.animate("style", G);
  }, C.prototype.updateDuringAnimation = function(G) {
    G === "style" ? this.dirtyStyle() : this.markRedraw();
  }, C.prototype.attrKV = function(G, U) {
    G !== "style" ? H.prototype.attrKV.call(this, G, U) : this.style ? this.setStyle(U) : this.useStyle(U);
  }, C.prototype.setStyle = function(G, U) {
    return typeof G == "string" ? this.style[G] = U : extend(this.style, G), this.dirtyStyle(), this;
  }, C.prototype.dirtyStyle = function(G) {
    G || this.markRedraw(), this.__dirty |= STYLE_CHANGED_BIT, this._rect && (this._rect = null);
  }, C.prototype.dirty = function() {
    this.dirtyStyle();
  }, C.prototype.styleChanged = function() {
    return !!(this.__dirty & STYLE_CHANGED_BIT);
  }, C.prototype.styleUpdated = function() {
    this.__dirty &= ~STYLE_CHANGED_BIT;
  }, C.prototype.createStyle = function(G) {
    return createObject(DEFAULT_COMMON_STYLE, G);
  }, C.prototype.useStyle = function(G) {
    G[STYLE_MAGIC_KEY] || (G = this.createStyle(G)), this.__inHover ? this.__hoverStyle = G : this.style = G, this.dirtyStyle();
  }, C.prototype.isStyleObject = function(G) {
    return G[STYLE_MAGIC_KEY];
  }, C.prototype._innerSaveToNormal = function(G) {
    H.prototype._innerSaveToNormal.call(this, G);
    var U = this._normalState;
    G.style && !U.style && (U.style = this._mergeStyle(this.createStyle(), this.style)), this._savePrimaryToNormal(G, U, PRIMARY_STATES_KEYS);
  }, C.prototype._applyStateObj = function(G, U, K, W, Z, X) {
    H.prototype._applyStateObj.call(this, G, U, K, W, Z, X);
    var Q = !(U && W), ee;
    if (U && U.style ? Z ? W ? ee = U.style : (ee = this._mergeStyle(this.createStyle(), K.style), this._mergeStyle(ee, U.style)) : (ee = this._mergeStyle(this.createStyle(), W ? this.style : K.style), this._mergeStyle(ee, U.style)) : Q && (ee = K.style), ee)
      if (Z) {
        var te = this.style;
        if (this.style = this.createStyle(Q ? {} : te), Q)
          for (var re = keys(te), ne = 0; ne < re.length; ne++) {
            var ae = re[ne];
            ae in ee && (ee[ae] = ee[ae], this.style[ae] = te[ae]);
          }
        for (var ie = keys(ee), ne = 0; ne < ie.length; ne++) {
          var ae = ie[ne];
          this.style[ae] = this.style[ae];
        }
        this._transitionState(G, {
          style: ee
        }, X, this.getAnimationStyleProps());
      } else
        this.useStyle(ee);
    for (var se = this.__inHover ? PRIMARY_STATES_KEYS_IN_HOVER_LAYER : PRIMARY_STATES_KEYS, ne = 0; ne < se.length; ne++) {
      var ae = se[ne];
      U && U[ae] != null ? this[ae] = U[ae] : Q && K[ae] != null && (this[ae] = K[ae]);
    }
  }, C.prototype._mergeStates = function(G) {
    for (var U = H.prototype._mergeStates.call(this, G), K, W = 0; W < G.length; W++) {
      var Z = G[W];
      Z.style && (K = K || {}, this._mergeStyle(K, Z.style));
    }
    return K && (U.style = K), U;
  }, C.prototype._mergeStyle = function(G, U) {
    return extend(G, U), G;
  }, C.prototype.getAnimationStyleProps = function() {
    return DEFAULT_COMMON_ANIMATION_PROPS;
  }, C.initDefaultProps = function() {
    var G = C.prototype;
    G.type = "displayable", G.invisible = !1, G.z = 0, G.z2 = 0, G.zlevel = 0, G.culling = !1, G.cursor = "pointer", G.rectHover = !1, G.incremental = !1, G._rect = null, G.dirtyRectTolerance = 0, G.__dirty = REDRAW_BIT | STYLE_CHANGED_BIT;
  }(), C;
}(Element$2), tmpRect = new BoundingRect$1(0, 0, 0, 0), viewRect = new BoundingRect$1(0, 0, 0, 0);
function isDisplayableCulled(H, C, G) {
  return tmpRect.copy(H.getBoundingRect()), H.transform && tmpRect.applyTransform(H.transform), viewRect.width = C, viewRect.height = G, !tmpRect.intersect(viewRect);
}
const Displayable$1 = Displayable;
var mathMin$9 = Math.min, mathMax$9 = Math.max, mathSin$4 = Math.sin, mathCos$4 = Math.cos, PI2$8 = Math.PI * 2, start = create$2(), end = create$2(), extremity = create$2();
function fromPoints(H, C, G) {
  if (H.length !== 0) {
    for (var U = H[0], K = U[0], W = U[0], Z = U[1], X = U[1], Q = 1; Q < H.length; Q++)
      U = H[Q], K = mathMin$9(K, U[0]), W = mathMax$9(W, U[0]), Z = mathMin$9(Z, U[1]), X = mathMax$9(X, U[1]);
    C[0] = K, C[1] = Z, G[0] = W, G[1] = X;
  }
}
function fromLine(H, C, G, U, K, W) {
  K[0] = mathMin$9(H, G), K[1] = mathMin$9(C, U), W[0] = mathMax$9(H, G), W[1] = mathMax$9(C, U);
}
var xDim = [], yDim = [];
function fromCubic(H, C, G, U, K, W, Z, X, Q, ee) {
  var te = cubicExtrema, re = cubicAt, ne = te(H, G, K, Z, xDim);
  Q[0] = 1 / 0, Q[1] = 1 / 0, ee[0] = -1 / 0, ee[1] = -1 / 0;
  for (var ae = 0; ae < ne; ae++) {
    var ie = re(H, G, K, Z, xDim[ae]);
    Q[0] = mathMin$9(ie, Q[0]), ee[0] = mathMax$9(ie, ee[0]);
  }
  ne = te(C, U, W, X, yDim);
  for (var ae = 0; ae < ne; ae++) {
    var se = re(C, U, W, X, yDim[ae]);
    Q[1] = mathMin$9(se, Q[1]), ee[1] = mathMax$9(se, ee[1]);
  }
  Q[0] = mathMin$9(H, Q[0]), ee[0] = mathMax$9(H, ee[0]), Q[0] = mathMin$9(Z, Q[0]), ee[0] = mathMax$9(Z, ee[0]), Q[1] = mathMin$9(C, Q[1]), ee[1] = mathMax$9(C, ee[1]), Q[1] = mathMin$9(X, Q[1]), ee[1] = mathMax$9(X, ee[1]);
}
function fromQuadratic(H, C, G, U, K, W, Z, X) {
  var Q = quadraticExtremum, ee = quadraticAt$1, te = mathMax$9(mathMin$9(Q(H, G, K), 1), 0), re = mathMax$9(mathMin$9(Q(C, U, W), 1), 0), ne = ee(H, G, K, te), ae = ee(C, U, W, re);
  Z[0] = mathMin$9(H, K, ne), Z[1] = mathMin$9(C, W, ae), X[0] = mathMax$9(H, K, ne), X[1] = mathMax$9(C, W, ae);
}
function fromArc(H, C, G, U, K, W, Z, X, Q) {
  var ee = min$1, te = max$1, re = Math.abs(K - W);
  if (re % PI2$8 < 1e-4 && re > 1e-4) {
    X[0] = H - G, X[1] = C - U, Q[0] = H + G, Q[1] = C + U;
    return;
  }
  if (start[0] = mathCos$4(K) * G + H, start[1] = mathSin$4(K) * U + C, end[0] = mathCos$4(W) * G + H, end[1] = mathSin$4(W) * U + C, ee(X, start, end), te(Q, start, end), K = K % PI2$8, K < 0 && (K = K + PI2$8), W = W % PI2$8, W < 0 && (W = W + PI2$8), K > W && !Z ? W += PI2$8 : K < W && Z && (K += PI2$8), Z) {
    var ne = W;
    W = K, K = ne;
  }
  for (var ae = 0; ae < W; ae += Math.PI / 2)
    ae > K && (extremity[0] = mathCos$4(ae) * G + H, extremity[1] = mathSin$4(ae) * U + C, ee(X, extremity, X), te(Q, extremity, Q));
}
var CMD$4 = {
  M: 1,
  L: 2,
  C: 3,
  Q: 4,
  A: 5,
  Z: 6,
  R: 7
}, tmpOutX = [], tmpOutY = [], min = [], max = [], min2 = [], max2 = [], mathMin$8 = Math.min, mathMax$8 = Math.max, mathCos$3 = Math.cos, mathSin$3 = Math.sin, mathAbs$2 = Math.abs, PI$8 = Math.PI, PI2$7 = PI$8 * 2, hasTypedArray = typeof Float32Array < "u", tmpAngles = [];
function modPI2(H) {
  var C = Math.round(H / PI$8 * 1e8) / 1e8;
  return C % 2 * PI$8;
}
function normalizeArcAngles(H, C) {
  var G = modPI2(H[0]);
  G < 0 && (G += PI2$7);
  var U = G - H[0], K = H[1];
  K += U, !C && K - G >= PI2$7 ? K = G + PI2$7 : C && G - K >= PI2$7 ? K = G - PI2$7 : !C && G > K ? K = G + (PI2$7 - modPI2(G - K)) : C && G < K && (K = G - (PI2$7 - modPI2(K - G))), H[0] = G, H[1] = K;
}
var PathProxy = function() {
  function H(C) {
    this.dpr = 1, this._xi = 0, this._yi = 0, this._x0 = 0, this._y0 = 0, this._len = 0, C && (this._saveData = !1), this._saveData && (this.data = []);
  }
  return H.prototype.increaseVersion = function() {
    this._version++;
  }, H.prototype.getVersion = function() {
    return this._version;
  }, H.prototype.setScale = function(C, G, U) {
    U = U || 0, U > 0 && (this._ux = mathAbs$2(U / devicePixelRatio / C) || 0, this._uy = mathAbs$2(U / devicePixelRatio / G) || 0);
  }, H.prototype.setDPR = function(C) {
    this.dpr = C;
  }, H.prototype.setContext = function(C) {
    this._ctx = C;
  }, H.prototype.getContext = function() {
    return this._ctx;
  }, H.prototype.beginPath = function() {
    return this._ctx && this._ctx.beginPath(), this.reset(), this;
  }, H.prototype.reset = function() {
    this._saveData && (this._len = 0), this._pathSegLen && (this._pathSegLen = null, this._pathLen = 0), this._version++;
  }, H.prototype.moveTo = function(C, G) {
    return this._drawPendingPt(), this.addData(CMD$4.M, C, G), this._ctx && this._ctx.moveTo(C, G), this._x0 = C, this._y0 = G, this._xi = C, this._yi = G, this;
  }, H.prototype.lineTo = function(C, G) {
    var U = mathAbs$2(C - this._xi), K = mathAbs$2(G - this._yi), W = U > this._ux || K > this._uy;
    if (this.addData(CMD$4.L, C, G), this._ctx && W && this._ctx.lineTo(C, G), W)
      this._xi = C, this._yi = G, this._pendingPtDist = 0;
    else {
      var Z = U * U + K * K;
      Z > this._pendingPtDist && (this._pendingPtX = C, this._pendingPtY = G, this._pendingPtDist = Z);
    }
    return this;
  }, H.prototype.bezierCurveTo = function(C, G, U, K, W, Z) {
    return this._drawPendingPt(), this.addData(CMD$4.C, C, G, U, K, W, Z), this._ctx && this._ctx.bezierCurveTo(C, G, U, K, W, Z), this._xi = W, this._yi = Z, this;
  }, H.prototype.quadraticCurveTo = function(C, G, U, K) {
    return this._drawPendingPt(), this.addData(CMD$4.Q, C, G, U, K), this._ctx && this._ctx.quadraticCurveTo(C, G, U, K), this._xi = U, this._yi = K, this;
  }, H.prototype.arc = function(C, G, U, K, W, Z) {
    this._drawPendingPt(), tmpAngles[0] = K, tmpAngles[1] = W, normalizeArcAngles(tmpAngles, Z), K = tmpAngles[0], W = tmpAngles[1];
    var X = W - K;
    return this.addData(CMD$4.A, C, G, U, U, K, X, 0, Z ? 0 : 1), this._ctx && this._ctx.arc(C, G, U, K, W, Z), this._xi = mathCos$3(W) * U + C, this._yi = mathSin$3(W) * U + G, this;
  }, H.prototype.arcTo = function(C, G, U, K, W) {
    return this._drawPendingPt(), this._ctx && this._ctx.arcTo(C, G, U, K, W), this;
  }, H.prototype.rect = function(C, G, U, K) {
    return this._drawPendingPt(), this._ctx && this._ctx.rect(C, G, U, K), this.addData(CMD$4.R, C, G, U, K), this;
  }, H.prototype.closePath = function() {
    this._drawPendingPt(), this.addData(CMD$4.Z);
    var C = this._ctx, G = this._x0, U = this._y0;
    return C && C.closePath(), this._xi = G, this._yi = U, this;
  }, H.prototype.fill = function(C) {
    C && C.fill(), this.toStatic();
  }, H.prototype.stroke = function(C) {
    C && C.stroke(), this.toStatic();
  }, H.prototype.len = function() {
    return this._len;
  }, H.prototype.setData = function(C) {
    var G = C.length;
    !(this.data && this.data.length === G) && hasTypedArray && (this.data = new Float32Array(G));
    for (var U = 0; U < G; U++)
      this.data[U] = C[U];
    this._len = G;
  }, H.prototype.appendPath = function(C) {
    C instanceof Array || (C = [C]);
    for (var G = C.length, U = 0, K = this._len, W = 0; W < G; W++)
      U += C[W].len();
    hasTypedArray && this.data instanceof Float32Array && (this.data = new Float32Array(K + U));
    for (var W = 0; W < G; W++)
      for (var Z = C[W].data, X = 0; X < Z.length; X++)
        this.data[K++] = Z[X];
    this._len = K;
  }, H.prototype.addData = function(C, G, U, K, W, Z, X, Q, ee) {
    if (this._saveData) {
      var te = this.data;
      this._len + arguments.length > te.length && (this._expandData(), te = this.data);
      for (var re = 0; re < arguments.length; re++)
        te[this._len++] = arguments[re];
    }
  }, H.prototype._drawPendingPt = function() {
    this._pendingPtDist > 0 && (this._ctx && this._ctx.lineTo(this._pendingPtX, this._pendingPtY), this._pendingPtDist = 0);
  }, H.prototype._expandData = function() {
    if (!(this.data instanceof Array)) {
      for (var C = [], G = 0; G < this._len; G++)
        C[G] = this.data[G];
      this.data = C;
    }
  }, H.prototype.toStatic = function() {
    if (this._saveData) {
      this._drawPendingPt();
      var C = this.data;
      C instanceof Array && (C.length = this._len, hasTypedArray && this._len > 11 && (this.data = new Float32Array(C)));
    }
  }, H.prototype.getBoundingRect = function() {
    min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE, max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;
    var C = this.data, G = 0, U = 0, K = 0, W = 0, Z;
    for (Z = 0; Z < this._len; ) {
      var X = C[Z++], Q = Z === 1;
      switch (Q && (G = C[Z], U = C[Z + 1], K = G, W = U), X) {
        case CMD$4.M:
          G = K = C[Z++], U = W = C[Z++], min2[0] = K, min2[1] = W, max2[0] = K, max2[1] = W;
          break;
        case CMD$4.L:
          fromLine(G, U, C[Z], C[Z + 1], min2, max2), G = C[Z++], U = C[Z++];
          break;
        case CMD$4.C:
          fromCubic(G, U, C[Z++], C[Z++], C[Z++], C[Z++], C[Z], C[Z + 1], min2, max2), G = C[Z++], U = C[Z++];
          break;
        case CMD$4.Q:
          fromQuadratic(G, U, C[Z++], C[Z++], C[Z], C[Z + 1], min2, max2), G = C[Z++], U = C[Z++];
          break;
        case CMD$4.A:
          var ee = C[Z++], te = C[Z++], re = C[Z++], ne = C[Z++], ae = C[Z++], ie = C[Z++] + ae;
          Z += 1;
          var se = !C[Z++];
          Q && (K = mathCos$3(ae) * re + ee, W = mathSin$3(ae) * ne + te), fromArc(ee, te, re, ne, ae, ie, se, min2, max2), G = mathCos$3(ie) * re + ee, U = mathSin$3(ie) * ne + te;
          break;
        case CMD$4.R:
          K = G = C[Z++], W = U = C[Z++];
          var oe = C[Z++], le = C[Z++];
          fromLine(K, W, K + oe, W + le, min2, max2);
          break;
        case CMD$4.Z:
          G = K, U = W;
          break;
      }
      min$1(min, min, min2), max$1(max, max, max2);
    }
    return Z === 0 && (min[0] = min[1] = max[0] = max[1] = 0), new BoundingRect$1(min[0], min[1], max[0] - min[0], max[1] - min[1]);
  }, H.prototype._calculateLength = function() {
    var C = this.data, G = this._len, U = this._ux, K = this._uy, W = 0, Z = 0, X = 0, Q = 0;
    this._pathSegLen || (this._pathSegLen = []);
    for (var ee = this._pathSegLen, te = 0, re = 0, ne = 0; ne < G; ) {
      var ae = C[ne++], ie = ne === 1;
      ie && (W = C[ne], Z = C[ne + 1], X = W, Q = Z);
      var se = -1;
      switch (ae) {
        case CMD$4.M:
          W = X = C[ne++], Z = Q = C[ne++];
          break;
        case CMD$4.L: {
          var oe = C[ne++], le = C[ne++], ue = oe - W, ce = le - Z;
          (mathAbs$2(ue) > U || mathAbs$2(ce) > K || ne === G - 1) && (se = Math.sqrt(ue * ue + ce * ce), W = oe, Z = le);
          break;
        }
        case CMD$4.C: {
          var de = C[ne++], ge = C[ne++], oe = C[ne++], le = C[ne++], fe = C[ne++], ve = C[ne++];
          se = cubicLength(W, Z, de, ge, oe, le, fe, ve, 10), W = fe, Z = ve;
          break;
        }
        case CMD$4.Q: {
          var de = C[ne++], ge = C[ne++], oe = C[ne++], le = C[ne++];
          se = quadraticLength(W, Z, de, ge, oe, le, 10), W = oe, Z = le;
          break;
        }
        case CMD$4.A:
          var pe = C[ne++], he = C[ne++], me = C[ne++], ye = C[ne++], Ce = C[ne++], Ie = C[ne++], be = Ie + Ce;
          ne += 1, C[ne++], ie && (X = mathCos$3(Ce) * me + pe, Q = mathSin$3(Ce) * ye + he), se = mathMax$8(me, ye) * mathMin$8(PI2$7, Math.abs(Ie)), W = mathCos$3(be) * me + pe, Z = mathSin$3(be) * ye + he;
          break;
        case CMD$4.R: {
          X = W = C[ne++], Q = Z = C[ne++];
          var Se = C[ne++], Ae = C[ne++];
          se = Se * 2 + Ae * 2;
          break;
        }
        case CMD$4.Z: {
          var ue = X - W, ce = Q - Z;
          se = Math.sqrt(ue * ue + ce * ce), W = X, Z = Q;
          break;
        }
      }
      se >= 0 && (ee[re++] = se, te += se);
    }
    return this._pathLen = te, te;
  }, H.prototype.rebuildPath = function(C, G) {
    var U = this.data, K = this._ux, W = this._uy, Z = this._len, X, Q, ee, te, re, ne, ae = G < 1, ie, se, oe = 0, le = 0, ue, ce = 0, de, ge;
    if (ae && (this._pathSegLen || this._calculateLength(), ie = this._pathSegLen, se = this._pathLen, ue = G * se, !ue))
      return;
    e:
      for (var fe = 0; fe < Z; ) {
        var ve = U[fe++], pe = fe === 1;
        switch (pe && (ee = U[fe], te = U[fe + 1], X = ee, Q = te), ve !== CMD$4.L && ce > 0 && (C.lineTo(de, ge), ce = 0), ve) {
          case CMD$4.M:
            X = ee = U[fe++], Q = te = U[fe++], C.moveTo(ee, te);
            break;
          case CMD$4.L: {
            re = U[fe++], ne = U[fe++];
            var he = mathAbs$2(re - ee), me = mathAbs$2(ne - te);
            if (he > K || me > W) {
              if (ae) {
                var ye = ie[le++];
                if (oe + ye > ue) {
                  var Ce = (ue - oe) / ye;
                  C.lineTo(ee * (1 - Ce) + re * Ce, te * (1 - Ce) + ne * Ce);
                  break e;
                }
                oe += ye;
              }
              C.lineTo(re, ne), ee = re, te = ne, ce = 0;
            } else {
              var Ie = he * he + me * me;
              Ie > ce && (de = re, ge = ne, ce = Ie);
            }
            break;
          }
          case CMD$4.C: {
            var be = U[fe++], Se = U[fe++], Ae = U[fe++], _e = U[fe++], xe = U[fe++], Te = U[fe++];
            if (ae) {
              var ye = ie[le++];
              if (oe + ye > ue) {
                var Ce = (ue - oe) / ye;
                cubicSubdivide(ee, be, Ae, xe, Ce, tmpOutX), cubicSubdivide(te, Se, _e, Te, Ce, tmpOutY), C.bezierCurveTo(tmpOutX[1], tmpOutY[1], tmpOutX[2], tmpOutY[2], tmpOutX[3], tmpOutY[3]);
                break e;
              }
              oe += ye;
            }
            C.bezierCurveTo(be, Se, Ae, _e, xe, Te), ee = xe, te = Te;
            break;
          }
          case CMD$4.Q: {
            var be = U[fe++], Se = U[fe++], Ae = U[fe++], _e = U[fe++];
            if (ae) {
              var ye = ie[le++];
              if (oe + ye > ue) {
                var Ce = (ue - oe) / ye;
                quadraticSubdivide(ee, be, Ae, Ce, tmpOutX), quadraticSubdivide(te, Se, _e, Ce, tmpOutY), C.quadraticCurveTo(tmpOutX[1], tmpOutY[1], tmpOutX[2], tmpOutY[2]);
                break e;
              }
              oe += ye;
            }
            C.quadraticCurveTo(be, Se, Ae, _e), ee = Ae, te = _e;
            break;
          }
          case CMD$4.A:
            var Pe = U[fe++], $e = U[fe++], Me = U[fe++], Ee = U[fe++], we = U[fe++], Oe = U[fe++], Ne = U[fe++], ke = !U[fe++], ze = Me > Ee ? Me : Ee, He = mathAbs$2(Me - Ee) > 1e-3, We = we + Oe, Re = !1;
            if (ae) {
              var ye = ie[le++];
              oe + ye > ue && (We = we + Oe * (ue - oe) / ye, Re = !0), oe += ye;
            }
            if (He && C.ellipse ? C.ellipse(Pe, $e, Me, Ee, Ne, we, We, ke) : C.arc(Pe, $e, ze, we, We, ke), Re)
              break e;
            pe && (X = mathCos$3(we) * Me + Pe, Q = mathSin$3(we) * Ee + $e), ee = mathCos$3(We) * Me + Pe, te = mathSin$3(We) * Ee + $e;
            break;
          case CMD$4.R:
            X = ee = U[fe], Q = te = U[fe + 1], re = U[fe++], ne = U[fe++];
            var Le = U[fe++], De = U[fe++];
            if (ae) {
              var ye = ie[le++];
              if (oe + ye > ue) {
                var Ue = ue - oe;
                C.moveTo(re, ne), C.lineTo(re + mathMin$8(Ue, Le), ne), Ue -= Le, Ue > 0 && C.lineTo(re + Le, ne + mathMin$8(Ue, De)), Ue -= De, Ue > 0 && C.lineTo(re + mathMax$8(Le - Ue, 0), ne + De), Ue -= Le, Ue > 0 && C.lineTo(re, ne + mathMax$8(De - Ue, 0));
                break e;
              }
              oe += ye;
            }
            C.rect(re, ne, Le, De);
            break;
          case CMD$4.Z:
            if (ae) {
              var ye = ie[le++];
              if (oe + ye > ue) {
                var Ce = (ue - oe) / ye;
                C.lineTo(ee * (1 - Ce) + X * Ce, te * (1 - Ce) + Q * Ce);
                break e;
              }
              oe += ye;
            }
            C.closePath(), ee = X, te = Q;
        }
      }
  }, H.prototype.clone = function() {
    var C = new H(), G = this.data;
    return C.data = G.slice ? G.slice() : Array.prototype.slice.call(G), C._len = this._len, C;
  }, H.CMD = CMD$4, H.initDefaultProps = function() {
    var C = H.prototype;
    C._saveData = !0, C._ux = 0, C._uy = 0, C._pendingPtDist = 0, C._version = 0;
  }(), H;
}();
const PathProxy$1 = PathProxy;
function containStroke$4(H, C, G, U, K, W, Z) {
  if (K === 0)
    return !1;
  var X = K, Q = 0, ee = H;
  if (Z > C + X && Z > U + X || Z < C - X && Z < U - X || W > H + X && W > G + X || W < H - X && W < G - X)
    return !1;
  if (H !== G)
    Q = (C - U) / (H - G), ee = (H * U - G * C) / (H - G);
  else
    return Math.abs(W - H) <= X / 2;
  var te = Q * W - Z + ee, re = te * te / (Q * Q + 1);
  return re <= X / 2 * X / 2;
}
function containStroke$3(H, C, G, U, K, W, Z, X, Q, ee, te) {
  if (Q === 0)
    return !1;
  var re = Q;
  if (te > C + re && te > U + re && te > W + re && te > X + re || te < C - re && te < U - re && te < W - re && te < X - re || ee > H + re && ee > G + re && ee > K + re && ee > Z + re || ee < H - re && ee < G - re && ee < K - re && ee < Z - re)
    return !1;
  var ne = cubicProjectPoint(H, C, G, U, K, W, Z, X, ee, te, null);
  return ne <= re / 2;
}
function containStroke$2(H, C, G, U, K, W, Z, X, Q) {
  if (Z === 0)
    return !1;
  var ee = Z;
  if (Q > C + ee && Q > U + ee && Q > W + ee || Q < C - ee && Q < U - ee && Q < W - ee || X > H + ee && X > G + ee && X > K + ee || X < H - ee && X < G - ee && X < K - ee)
    return !1;
  var te = quadraticProjectPoint(H, C, G, U, K, W, X, Q, null);
  return te <= ee / 2;
}
var PI2$6 = Math.PI * 2;
function normalizeRadian(H) {
  return H %= PI2$6, H < 0 && (H += PI2$6), H;
}
var PI2$5 = Math.PI * 2;
function containStroke$1(H, C, G, U, K, W, Z, X, Q) {
  if (Z === 0)
    return !1;
  var ee = Z;
  X -= H, Q -= C;
  var te = Math.sqrt(X * X + Q * Q);
  if (te - ee > G || te + ee < G)
    return !1;
  if (Math.abs(U - K) % PI2$5 < 1e-4)
    return !0;
  if (W) {
    var re = U;
    U = normalizeRadian(K), K = normalizeRadian(re);
  } else
    U = normalizeRadian(U), K = normalizeRadian(K);
  U > K && (K += PI2$5);
  var ne = Math.atan2(Q, X);
  return ne < 0 && (ne += PI2$5), ne >= U && ne <= K || ne + PI2$5 >= U && ne + PI2$5 <= K;
}
function windingLine(H, C, G, U, K, W) {
  if (W > C && W > U || W < C && W < U || U === C)
    return 0;
  var Z = (W - C) / (U - C), X = U < C ? 1 : -1;
  (Z === 1 || Z === 0) && (X = U < C ? 0.5 : -0.5);
  var Q = Z * (G - H) + H;
  return Q === K ? 1 / 0 : Q > K ? X : 0;
}
var CMD$3 = PathProxy$1.CMD, PI2$4 = Math.PI * 2, EPSILON$1 = 1e-4;
function isAroundEqual$1(H, C) {
  return Math.abs(H - C) < EPSILON$1;
}
var roots = [-1, -1, -1], extrema = [-1, -1];
function swapExtrema() {
  var H = extrema[0];
  extrema[0] = extrema[1], extrema[1] = H;
}
function windingCubic(H, C, G, U, K, W, Z, X, Q, ee) {
  if (ee > C && ee > U && ee > W && ee > X || ee < C && ee < U && ee < W && ee < X)
    return 0;
  var te = cubicRootAt(C, U, W, X, ee, roots);
  if (te === 0)
    return 0;
  for (var re = 0, ne = -1, ae = void 0, ie = void 0, se = 0; se < te; se++) {
    var oe = roots[se], le = oe === 0 || oe === 1 ? 0.5 : 1, ue = cubicAt(H, G, K, Z, oe);
    ue < Q || (ne < 0 && (ne = cubicExtrema(C, U, W, X, extrema), extrema[1] < extrema[0] && ne > 1 && swapExtrema(), ae = cubicAt(C, U, W, X, extrema[0]), ne > 1 && (ie = cubicAt(C, U, W, X, extrema[1]))), ne === 2 ? oe < extrema[0] ? re += ae < C ? le : -le : oe < extrema[1] ? re += ie < ae ? le : -le : re += X < ie ? le : -le : oe < extrema[0] ? re += ae < C ? le : -le : re += X < ae ? le : -le);
  }
  return re;
}
function windingQuadratic(H, C, G, U, K, W, Z, X) {
  if (X > C && X > U && X > W || X < C && X < U && X < W)
    return 0;
  var Q = quadraticRootAt(C, U, W, X, roots);
  if (Q === 0)
    return 0;
  var ee = quadraticExtremum(C, U, W);
  if (ee >= 0 && ee <= 1) {
    for (var te = 0, re = quadraticAt$1(C, U, W, ee), ne = 0; ne < Q; ne++) {
      var ae = roots[ne] === 0 || roots[ne] === 1 ? 0.5 : 1, ie = quadraticAt$1(H, G, K, roots[ne]);
      ie < Z || (roots[ne] < ee ? te += re < C ? ae : -ae : te += W < re ? ae : -ae);
    }
    return te;
  } else {
    var ae = roots[0] === 0 || roots[0] === 1 ? 0.5 : 1, ie = quadraticAt$1(H, G, K, roots[0]);
    return ie < Z ? 0 : W < C ? ae : -ae;
  }
}
function windingArc(H, C, G, U, K, W, Z, X) {
  if (X -= C, X > G || X < -G)
    return 0;
  var Q = Math.sqrt(G * G - X * X);
  roots[0] = -Q, roots[1] = Q;
  var ee = Math.abs(U - K);
  if (ee < 1e-4)
    return 0;
  if (ee >= PI2$4 - 1e-4) {
    U = 0, K = PI2$4;
    var te = W ? 1 : -1;
    return Z >= roots[0] + H && Z <= roots[1] + H ? te : 0;
  }
  if (U > K) {
    var re = U;
    U = K, K = re;
  }
  U < 0 && (U += PI2$4, K += PI2$4);
  for (var ne = 0, ae = 0; ae < 2; ae++) {
    var ie = roots[ae];
    if (ie + H > Z) {
      var se = Math.atan2(X, ie), te = W ? 1 : -1;
      se < 0 && (se = PI2$4 + se), (se >= U && se <= K || se + PI2$4 >= U && se + PI2$4 <= K) && (se > Math.PI / 2 && se < Math.PI * 1.5 && (te = -te), ne += te);
    }
  }
  return ne;
}
function containPath(H, C, G, U, K) {
  for (var W = H.data, Z = H.len(), X = 0, Q = 0, ee = 0, te = 0, re = 0, ne, ae, ie = 0; ie < Z; ) {
    var se = W[ie++], oe = ie === 1;
    switch (se === CMD$3.M && ie > 1 && (G || (X += windingLine(Q, ee, te, re, U, K))), oe && (Q = W[ie], ee = W[ie + 1], te = Q, re = ee), se) {
      case CMD$3.M:
        te = W[ie++], re = W[ie++], Q = te, ee = re;
        break;
      case CMD$3.L:
        if (G) {
          if (containStroke$4(Q, ee, W[ie], W[ie + 1], C, U, K))
            return !0;
        } else
          X += windingLine(Q, ee, W[ie], W[ie + 1], U, K) || 0;
        Q = W[ie++], ee = W[ie++];
        break;
      case CMD$3.C:
        if (G) {
          if (containStroke$3(Q, ee, W[ie++], W[ie++], W[ie++], W[ie++], W[ie], W[ie + 1], C, U, K))
            return !0;
        } else
          X += windingCubic(Q, ee, W[ie++], W[ie++], W[ie++], W[ie++], W[ie], W[ie + 1], U, K) || 0;
        Q = W[ie++], ee = W[ie++];
        break;
      case CMD$3.Q:
        if (G) {
          if (containStroke$2(Q, ee, W[ie++], W[ie++], W[ie], W[ie + 1], C, U, K))
            return !0;
        } else
          X += windingQuadratic(Q, ee, W[ie++], W[ie++], W[ie], W[ie + 1], U, K) || 0;
        Q = W[ie++], ee = W[ie++];
        break;
      case CMD$3.A:
        var le = W[ie++], ue = W[ie++], ce = W[ie++], de = W[ie++], ge = W[ie++], fe = W[ie++];
        ie += 1;
        var ve = !!(1 - W[ie++]);
        ne = Math.cos(ge) * ce + le, ae = Math.sin(ge) * de + ue, oe ? (te = ne, re = ae) : X += windingLine(Q, ee, ne, ae, U, K);
        var pe = (U - le) * de / ce + le;
        if (G) {
          if (containStroke$1(le, ue, de, ge, ge + fe, ve, C, pe, K))
            return !0;
        } else
          X += windingArc(le, ue, de, ge, ge + fe, ve, pe, K);
        Q = Math.cos(ge + fe) * ce + le, ee = Math.sin(ge + fe) * de + ue;
        break;
      case CMD$3.R:
        te = Q = W[ie++], re = ee = W[ie++];
        var he = W[ie++], me = W[ie++];
        if (ne = te + he, ae = re + me, G) {
          if (containStroke$4(te, re, ne, re, C, U, K) || containStroke$4(ne, re, ne, ae, C, U, K) || containStroke$4(ne, ae, te, ae, C, U, K) || containStroke$4(te, ae, te, re, C, U, K))
            return !0;
        } else
          X += windingLine(ne, re, ne, ae, U, K), X += windingLine(te, ae, te, re, U, K);
        break;
      case CMD$3.Z:
        if (G) {
          if (containStroke$4(Q, ee, te, re, C, U, K))
            return !0;
        } else
          X += windingLine(Q, ee, te, re, U, K);
        Q = te, ee = re;
        break;
    }
  }
  return !G && !isAroundEqual$1(ee, re) && (X += windingLine(Q, ee, te, re, U, K) || 0), X !== 0;
}
function contain$2(H, C, G) {
  return containPath(H, 0, !1, C, G);
}
function containStroke(H, C, G, U) {
  return containPath(H, C, !0, G, U);
}
var DEFAULT_PATH_STYLE = defaults({
  fill: "#000",
  stroke: null,
  strokePercent: 1,
  fillOpacity: 1,
  strokeOpacity: 1,
  lineDashOffset: 0,
  lineWidth: 1,
  lineCap: "butt",
  miterLimit: 10,
  strokeNoScale: !1,
  strokeFirst: !1
}, DEFAULT_COMMON_STYLE), DEFAULT_PATH_ANIMATION_PROPS = {
  style: defaults({
    fill: !0,
    stroke: !0,
    strokePercent: !0,
    fillOpacity: !0,
    strokeOpacity: !0,
    lineDashOffset: !0,
    lineWidth: !0,
    miterLimit: !0
  }, DEFAULT_COMMON_ANIMATION_PROPS.style)
}, pathCopyParams = TRANSFORMABLE_PROPS.concat([
  "invisible",
  "culling",
  "z",
  "z2",
  "zlevel",
  "parent"
]), Path = function(H) {
  __extends(C, H);
  function C(G) {
    return H.call(this, G) || this;
  }
  return C.prototype.update = function() {
    var G = this;
    H.prototype.update.call(this);
    var U = this.style;
    if (U.decal) {
      var K = this._decalEl = this._decalEl || new C();
      K.buildPath === C.prototype.buildPath && (K.buildPath = function(Q) {
        G.buildPath(Q, G.shape);
      }), K.silent = !0;
      var W = K.style;
      for (var Z in U)
        W[Z] !== U[Z] && (W[Z] = U[Z]);
      W.fill = U.fill ? U.decal : null, W.decal = null, W.shadowColor = null, U.strokeFirst && (W.stroke = null);
      for (var X = 0; X < pathCopyParams.length; ++X)
        K[pathCopyParams[X]] = this[pathCopyParams[X]];
      K.__dirty |= REDRAW_BIT;
    } else
      this._decalEl && (this._decalEl = null);
  }, C.prototype.getDecalElement = function() {
    return this._decalEl;
  }, C.prototype._init = function(G) {
    var U = keys(G);
    this.shape = this.getDefaultShape();
    var K = this.getDefaultStyle();
    K && this.useStyle(K);
    for (var W = 0; W < U.length; W++) {
      var Z = U[W], X = G[Z];
      Z === "style" ? this.style ? extend(this.style, X) : this.useStyle(X) : Z === "shape" ? extend(this.shape, X) : H.prototype.attrKV.call(this, Z, X);
    }
    this.style || this.useStyle({});
  }, C.prototype.getDefaultStyle = function() {
    return null;
  }, C.prototype.getDefaultShape = function() {
    return {};
  }, C.prototype.canBeInsideText = function() {
    return this.hasFill();
  }, C.prototype.getInsideTextFill = function() {
    var G = this.style.fill;
    if (G !== "none") {
      if (isString(G)) {
        var U = lum(G, 0);
        return U > 0.5 ? DARK_LABEL_COLOR : U > 0.2 ? LIGHTER_LABEL_COLOR : LIGHT_LABEL_COLOR;
      } else if (G)
        return LIGHT_LABEL_COLOR;
    }
    return DARK_LABEL_COLOR;
  }, C.prototype.getInsideTextStroke = function(G) {
    var U = this.style.fill;
    if (isString(U)) {
      var K = this.__zr, W = !!(K && K.isDarkMode()), Z = lum(G, 0) < DARK_MODE_THRESHOLD;
      if (W === Z)
        return U;
    }
  }, C.prototype.buildPath = function(G, U, K) {
  }, C.prototype.pathUpdated = function() {
    this.__dirty &= ~SHAPE_CHANGED_BIT;
  }, C.prototype.getUpdatedPathProxy = function(G) {
    return !this.path && this.createPathProxy(), this.path.beginPath(), this.buildPath(this.path, this.shape, G), this.path;
  }, C.prototype.createPathProxy = function() {
    this.path = new PathProxy$1(!1);
  }, C.prototype.hasStroke = function() {
    var G = this.style, U = G.stroke;
    return !(U == null || U === "none" || !(G.lineWidth > 0));
  }, C.prototype.hasFill = function() {
    var G = this.style, U = G.fill;
    return U != null && U !== "none";
  }, C.prototype.getBoundingRect = function() {
    var G = this._rect, U = this.style, K = !G;
    if (K) {
      var W = !1;
      this.path || (W = !0, this.createPathProxy());
      var Z = this.path;
      (W || this.__dirty & SHAPE_CHANGED_BIT) && (Z.beginPath(), this.buildPath(Z, this.shape, !1), this.pathUpdated()), G = Z.getBoundingRect();
    }
    if (this._rect = G, this.hasStroke() && this.path && this.path.len() > 0) {
      var X = this._rectStroke || (this._rectStroke = G.clone());
      if (this.__dirty || K) {
        X.copy(G);
        var Q = U.strokeNoScale ? this.getLineScale() : 1, ee = U.lineWidth;
        if (!this.hasFill()) {
          var te = this.strokeContainThreshold;
          ee = Math.max(ee, te ?? 4);
        }
        Q > 1e-10 && (X.width += ee / Q, X.height += ee / Q, X.x -= ee / Q / 2, X.y -= ee / Q / 2);
      }
      return X;
    }
    return G;
  }, C.prototype.contain = function(G, U) {
    var K = this.transformCoordToLocal(G, U), W = this.getBoundingRect(), Z = this.style;
    if (G = K[0], U = K[1], W.contain(G, U)) {
      var X = this.path;
      if (this.hasStroke()) {
        var Q = Z.lineWidth, ee = Z.strokeNoScale ? this.getLineScale() : 1;
        if (ee > 1e-10 && (this.hasFill() || (Q = Math.max(Q, this.strokeContainThreshold)), containStroke(X, Q / ee, G, U)))
          return !0;
      }
      if (this.hasFill())
        return contain$2(X, G, U);
    }
    return !1;
  }, C.prototype.dirtyShape = function() {
    this.__dirty |= SHAPE_CHANGED_BIT, this._rect && (this._rect = null), this._decalEl && this._decalEl.dirtyShape(), this.markRedraw();
  }, C.prototype.dirty = function() {
    this.dirtyStyle(), this.dirtyShape();
  }, C.prototype.animateShape = function(G) {
    return this.animate("shape", G);
  }, C.prototype.updateDuringAnimation = function(G) {
    G === "style" ? this.dirtyStyle() : G === "shape" ? this.dirtyShape() : this.markRedraw();
  }, C.prototype.attrKV = function(G, U) {
    G === "shape" ? this.setShape(U) : H.prototype.attrKV.call(this, G, U);
  }, C.prototype.setShape = function(G, U) {
    var K = this.shape;
    return K || (K = this.shape = {}), typeof G == "string" ? K[G] = U : extend(K, G), this.dirtyShape(), this;
  }, C.prototype.shapeChanged = function() {
    return !!(this.__dirty & SHAPE_CHANGED_BIT);
  }, C.prototype.createStyle = function(G) {
    return createObject(DEFAULT_PATH_STYLE, G);
  }, C.prototype._innerSaveToNormal = function(G) {
    H.prototype._innerSaveToNormal.call(this, G);
    var U = this._normalState;
    G.shape && !U.shape && (U.shape = extend({}, this.shape));
  }, C.prototype._applyStateObj = function(G, U, K, W, Z, X) {
    H.prototype._applyStateObj.call(this, G, U, K, W, Z, X);
    var Q = !(U && W), ee;
    if (U && U.shape ? Z ? W ? ee = U.shape : (ee = extend({}, K.shape), extend(ee, U.shape)) : (ee = extend({}, W ? this.shape : K.shape), extend(ee, U.shape)) : Q && (ee = K.shape), ee)
      if (Z) {
        this.shape = extend({}, this.shape);
        for (var te = {}, re = keys(ee), ne = 0; ne < re.length; ne++) {
          var ae = re[ne];
          typeof ee[ae] == "object" ? this.shape[ae] = ee[ae] : te[ae] = ee[ae];
        }
        this._transitionState(G, {
          shape: te
        }, X);
      } else
        this.shape = ee, this.dirtyShape();
  }, C.prototype._mergeStates = function(G) {
    for (var U = H.prototype._mergeStates.call(this, G), K, W = 0; W < G.length; W++) {
      var Z = G[W];
      Z.shape && (K = K || {}, this._mergeStyle(K, Z.shape));
    }
    return K && (U.shape = K), U;
  }, C.prototype.getAnimationStyleProps = function() {
    return DEFAULT_PATH_ANIMATION_PROPS;
  }, C.prototype.isZeroArea = function() {
    return !1;
  }, C.extend = function(G) {
    var U = function(W) {
      __extends(Z, W);
      function Z(X) {
        var Q = W.call(this, X) || this;
        return G.init && G.init.call(Q, X), Q;
      }
      return Z.prototype.getDefaultStyle = function() {
        return clone$4(G.style);
      }, Z.prototype.getDefaultShape = function() {
        return clone$4(G.shape);
      }, Z;
    }(C);
    for (var K in G)
      typeof G[K] == "function" && (U.prototype[K] = G[K]);
    return U;
  }, C.initDefaultProps = function() {
    var G = C.prototype;
    G.type = "path", G.strokeContainThreshold = 5, G.segmentIgnoreThreshold = 0, G.subPixelOptimize = !1, G.autoBatch = !1, G.__dirty = REDRAW_BIT | STYLE_CHANGED_BIT | SHAPE_CHANGED_BIT;
  }(), C;
}(Displayable$1);
const Path$1 = Path;
var DEFAULT_TSPAN_STYLE = defaults({
  strokeFirst: !0,
  font: DEFAULT_FONT,
  x: 0,
  y: 0,
  textAlign: "left",
  textBaseline: "top",
  miterLimit: 2
}, DEFAULT_PATH_STYLE), TSpan = function(H) {
  __extends(C, H);
  function C() {
    return H !== null && H.apply(this, arguments) || this;
  }
  return C.prototype.hasStroke = function() {
    var G = this.style, U = G.stroke;
    return U != null && U !== "none" && G.lineWidth > 0;
  }, C.prototype.hasFill = function() {
    var G = this.style, U = G.fill;
    return U != null && U !== "none";
  }, C.prototype.createStyle = function(G) {
    return createObject(DEFAULT_TSPAN_STYLE, G);
  }, C.prototype.setBoundingRect = function(G) {
    this._rect = G;
  }, C.prototype.getBoundingRect = function() {
    var G = this.style;
    if (!this._rect) {
      var U = G.text;
      U != null ? U += "" : U = "";
      var K = getBoundingRect(U, G.font, G.textAlign, G.textBaseline);
      if (K.x += G.x || 0, K.y += G.y || 0, this.hasStroke()) {
        var W = G.lineWidth;
        K.x -= W / 2, K.y -= W / 2, K.width += W, K.height += W;
      }
      this._rect = K;
    }
    return this._rect;
  }, C.initDefaultProps = function() {
    var G = C.prototype;
    G.dirtyRectTolerance = 10;
  }(), C;
}(Displayable$1);
TSpan.prototype.type = "tspan";
const TSpan$1 = TSpan;
var DEFAULT_IMAGE_STYLE = defaults({
  x: 0,
  y: 0
}, DEFAULT_COMMON_STYLE), DEFAULT_IMAGE_ANIMATION_PROPS = {
  style: defaults({
    x: !0,
    y: !0,
    width: !0,
    height: !0,
    sx: !0,
    sy: !0,
    sWidth: !0,
    sHeight: !0
  }, DEFAULT_COMMON_ANIMATION_PROPS.style)
};
function isImageLike$1(H) {
  return !!(H && typeof H != "string" && H.width && H.height);
}
var ZRImage = function(H) {
  __extends(C, H);
  function C() {
    return H !== null && H.apply(this, arguments) || this;
  }
  return C.prototype.createStyle = function(G) {
    return createObject(DEFAULT_IMAGE_STYLE, G);
  }, C.prototype._getSize = function(G) {
    var U = this.style, K = U[G];
    if (K != null)
      return K;
    var W = isImageLike$1(U.image) ? U.image : this.__image;
    if (!W)
      return 0;
    var Z = G === "width" ? "height" : "width", X = U[Z];
    return X == null ? W[G] : W[G] / W[Z] * X;
  }, C.prototype.getWidth = function() {
    return this._getSize("width");
  }, C.prototype.getHeight = function() {
    return this._getSize("height");
  }, C.prototype.getAnimationStyleProps = function() {
    return DEFAULT_IMAGE_ANIMATION_PROPS;
  }, C.prototype.getBoundingRect = function() {
    var G = this.style;
    return this._rect || (this._rect = new BoundingRect$1(G.x || 0, G.y || 0, this.getWidth(), this.getHeight())), this._rect;
  }, C;
}(Displayable$1);
ZRImage.prototype.type = "image";
const ZRImage$1 = ZRImage;
function buildPath$2(H, C) {
  var G = C.x, U = C.y, K = C.width, W = C.height, Z = C.r, X, Q, ee, te;
  K < 0 && (G = G + K, K = -K), W < 0 && (U = U + W, W = -W), typeof Z == "number" ? X = Q = ee = te = Z : Z instanceof Array ? Z.length === 1 ? X = Q = ee = te = Z[0] : Z.length === 2 ? (X = ee = Z[0], Q = te = Z[1]) : Z.length === 3 ? (X = Z[0], Q = te = Z[1], ee = Z[2]) : (X = Z[0], Q = Z[1], ee = Z[2], te = Z[3]) : X = Q = ee = te = 0;
  var re;
  X + Q > K && (re = X + Q, X *= K / re, Q *= K / re), ee + te > K && (re = ee + te, ee *= K / re, te *= K / re), Q + ee > W && (re = Q + ee, Q *= W / re, ee *= W / re), X + te > W && (re = X + te, X *= W / re, te *= W / re), H.moveTo(G + X, U), H.lineTo(G + K - Q, U), Q !== 0 && H.arc(G + K - Q, U + Q, Q, -Math.PI / 2, 0), H.lineTo(G + K, U + W - ee), ee !== 0 && H.arc(G + K - ee, U + W - ee, ee, 0, Math.PI / 2), H.lineTo(G + te, U + W), te !== 0 && H.arc(G + te, U + W - te, te, Math.PI / 2, Math.PI), H.lineTo(G, U + X), X !== 0 && H.arc(G + X, U + X, X, Math.PI, Math.PI * 1.5);
}
var round$2 = Math.round;
function subPixelOptimizeLine$1(H, C, G) {
  if (C) {
    var U = C.x1, K = C.x2, W = C.y1, Z = C.y2;
    H.x1 = U, H.x2 = K, H.y1 = W, H.y2 = Z;
    var X = G && G.lineWidth;
    return X && (round$2(U * 2) === round$2(K * 2) && (H.x1 = H.x2 = subPixelOptimize$1(U, X, !0)), round$2(W * 2) === round$2(Z * 2) && (H.y1 = H.y2 = subPixelOptimize$1(W, X, !0))), H;
  }
}
function subPixelOptimizeRect$1(H, C, G) {
  if (C) {
    var U = C.x, K = C.y, W = C.width, Z = C.height;
    H.x = U, H.y = K, H.width = W, H.height = Z;
    var X = G && G.lineWidth;
    return X && (H.x = subPixelOptimize$1(U, X, !0), H.y = subPixelOptimize$1(K, X, !0), H.width = Math.max(subPixelOptimize$1(U + W, X, !1) - H.x, W === 0 ? 0 : 1), H.height = Math.max(subPixelOptimize$1(K + Z, X, !1) - H.y, Z === 0 ? 0 : 1)), H;
  }
}
function subPixelOptimize$1(H, C, G) {
  if (!C)
    return H;
  var U = round$2(H * 2);
  return (U + round$2(C)) % 2 === 0 ? U / 2 : (U + (G ? 1 : -1)) / 2;
}
var RectShape = function() {
  function H() {
    this.x = 0, this.y = 0, this.width = 0, this.height = 0;
  }
  return H;
}(), subPixelOptimizeOutputShape$1 = {}, Rect$2 = function(H) {
  __extends(C, H);
  function C(G) {
    return H.call(this, G) || this;
  }
  return C.prototype.getDefaultShape = function() {
    return new RectShape();
  }, C.prototype.buildPath = function(G, U) {
    var K, W, Z, X;
    if (this.subPixelOptimize) {
      var Q = subPixelOptimizeRect$1(subPixelOptimizeOutputShape$1, U, this.style);
      K = Q.x, W = Q.y, Z = Q.width, X = Q.height, Q.r = U.r, U = Q;
    } else
      K = U.x, W = U.y, Z = U.width, X = U.height;
    U.r ? buildPath$2(G, U) : G.rect(K, W, Z, X);
  }, C.prototype.isZeroArea = function() {
    return !this.shape.width || !this.shape.height;
  }, C;
}(Path$1);
Rect$2.prototype.type = "rect";
const Rect$3 = Rect$2;
var DEFAULT_RICH_TEXT_COLOR = {
  fill: "#000"
}, DEFAULT_STROKE_LINE_WIDTH = 2, DEFAULT_TEXT_ANIMATION_PROPS = {
  style: defaults({
    fill: !0,
    stroke: !0,
    fillOpacity: !0,
    strokeOpacity: !0,
    lineWidth: !0,
    fontSize: !0,
    lineHeight: !0,
    width: !0,
    height: !0,
    textShadowColor: !0,
    textShadowBlur: !0,
    textShadowOffsetX: !0,
    textShadowOffsetY: !0,
    backgroundColor: !0,
    padding: !0,
    borderColor: !0,
    borderWidth: !0,
    borderRadius: !0
  }, DEFAULT_COMMON_ANIMATION_PROPS.style)
}, ZRText = function(H) {
  __extends(C, H);
  function C(G) {
    var U = H.call(this) || this;
    return U.type = "text", U._children = [], U._defaultStyle = DEFAULT_RICH_TEXT_COLOR, U.attr(G), U;
  }
  return C.prototype.childrenRef = function() {
    return this._children;
  }, C.prototype.update = function() {
    H.prototype.update.call(this), this.styleChanged() && this._updateSubTexts();
    for (var G = 0; G < this._children.length; G++) {
      var U = this._children[G];
      U.zlevel = this.zlevel, U.z = this.z, U.z2 = this.z2, U.culling = this.culling, U.cursor = this.cursor, U.invisible = this.invisible;
    }
  }, C.prototype.updateTransform = function() {
    var G = this.innerTransformable;
    G ? (G.updateTransform(), G.transform && (this.transform = G.transform)) : H.prototype.updateTransform.call(this);
  }, C.prototype.getLocalTransform = function(G) {
    var U = this.innerTransformable;
    return U ? U.getLocalTransform(G) : H.prototype.getLocalTransform.call(this, G);
  }, C.prototype.getComputedTransform = function() {
    return this.__hostTarget && (this.__hostTarget.getComputedTransform(), this.__hostTarget.updateInnerText(!0)), H.prototype.getComputedTransform.call(this);
  }, C.prototype._updateSubTexts = function() {
    this._childCursor = 0, normalizeTextStyle(this.style), this.style.rich ? this._updateRichTexts() : this._updatePlainTexts(), this._children.length = this._childCursor, this.styleUpdated();
  }, C.prototype.addSelfToZr = function(G) {
    H.prototype.addSelfToZr.call(this, G);
    for (var U = 0; U < this._children.length; U++)
      this._children[U].__zr = G;
  }, C.prototype.removeSelfFromZr = function(G) {
    H.prototype.removeSelfFromZr.call(this, G);
    for (var U = 0; U < this._children.length; U++)
      this._children[U].__zr = null;
  }, C.prototype.getBoundingRect = function() {
    if (this.styleChanged() && this._updateSubTexts(), !this._rect) {
      for (var G = new BoundingRect$1(0, 0, 0, 0), U = this._children, K = [], W = null, Z = 0; Z < U.length; Z++) {
        var X = U[Z], Q = X.getBoundingRect(), ee = X.getLocalTransform(K);
        ee ? (G.copy(Q), G.applyTransform(ee), W = W || G.clone(), W.union(G)) : (W = W || Q.clone(), W.union(Q));
      }
      this._rect = W || G;
    }
    return this._rect;
  }, C.prototype.setDefaultTextStyle = function(G) {
    this._defaultStyle = G || DEFAULT_RICH_TEXT_COLOR;
  }, C.prototype.setTextContent = function(G) {
    if (process.env.NODE_ENV !== "production")
      throw new Error("Can't attach text on another text");
  }, C.prototype._mergeStyle = function(G, U) {
    if (!U)
      return G;
    var K = U.rich, W = G.rich || K && {};
    return extend(G, U), K && W ? (this._mergeRich(W, K), G.rich = W) : W && (G.rich = W), G;
  }, C.prototype._mergeRich = function(G, U) {
    for (var K = keys(U), W = 0; W < K.length; W++) {
      var Z = K[W];
      G[Z] = G[Z] || {}, extend(G[Z], U[Z]);
    }
  }, C.prototype.getAnimationStyleProps = function() {
    return DEFAULT_TEXT_ANIMATION_PROPS;
  }, C.prototype._getOrCreateChild = function(G) {
    var U = this._children[this._childCursor];
    return (!U || !(U instanceof G)) && (U = new G()), this._children[this._childCursor++] = U, U.__zr = this.__zr, U.parent = this, U;
  }, C.prototype._updatePlainTexts = function() {
    var G = this.style, U = G.font || DEFAULT_FONT, K = G.padding, W = getStyleText(G), Z = parsePlainText(W, G), X = needDrawBackground(G), Q = !!G.backgroundColor, ee = Z.outerHeight, te = Z.outerWidth, re = Z.contentWidth, ne = Z.lines, ae = Z.lineHeight, ie = this._defaultStyle, se = G.x || 0, oe = G.y || 0, le = G.align || ie.align || "left", ue = G.verticalAlign || ie.verticalAlign || "top", ce = se, de = adjustTextY(oe, Z.contentHeight, ue);
    if (X || K) {
      var ge = adjustTextX(se, te, le), fe = adjustTextY(oe, ee, ue);
      X && this._renderBackground(G, G, ge, fe, te, ee);
    }
    de += ae / 2, K && (ce = getTextXForPadding(se, le, K), ue === "top" ? de += K[0] : ue === "bottom" && (de -= K[2]));
    for (var ve = 0, pe = !1, he = getFill("fill" in G ? G.fill : (pe = !0, ie.fill)), me = getStroke("stroke" in G ? G.stroke : !Q && (!ie.autoStroke || pe) ? (ve = DEFAULT_STROKE_LINE_WIDTH, ie.stroke) : null), ye = G.textShadowBlur > 0, Ce = G.width != null && (G.overflow === "truncate" || G.overflow === "break" || G.overflow === "breakAll"), Ie = Z.calculatedLineHeight, be = 0; be < ne.length; be++) {
      var Se = this._getOrCreateChild(TSpan$1), Ae = Se.createStyle();
      Se.useStyle(Ae), Ae.text = ne[be], Ae.x = ce, Ae.y = de, le && (Ae.textAlign = le), Ae.textBaseline = "middle", Ae.opacity = G.opacity, Ae.strokeFirst = !0, ye && (Ae.shadowBlur = G.textShadowBlur || 0, Ae.shadowColor = G.textShadowColor || "transparent", Ae.shadowOffsetX = G.textShadowOffsetX || 0, Ae.shadowOffsetY = G.textShadowOffsetY || 0), Ae.stroke = me, Ae.fill = he, me && (Ae.lineWidth = G.lineWidth || ve, Ae.lineDash = G.lineDash, Ae.lineDashOffset = G.lineDashOffset || 0), Ae.font = U, setSeparateFont(Ae, G), de += ae, Ce && Se.setBoundingRect(new BoundingRect$1(adjustTextX(Ae.x, G.width, Ae.textAlign), adjustTextY(Ae.y, Ie, Ae.textBaseline), re, Ie));
    }
  }, C.prototype._updateRichTexts = function() {
    var G = this.style, U = getStyleText(G), K = parseRichText(U, G), W = K.width, Z = K.outerWidth, X = K.outerHeight, Q = G.padding, ee = G.x || 0, te = G.y || 0, re = this._defaultStyle, ne = G.align || re.align, ae = G.verticalAlign || re.verticalAlign, ie = adjustTextX(ee, Z, ne), se = adjustTextY(te, X, ae), oe = ie, le = se;
    Q && (oe += Q[3], le += Q[0]);
    var ue = oe + W;
    needDrawBackground(G) && this._renderBackground(G, G, ie, se, Z, X);
    for (var ce = !!G.backgroundColor, de = 0; de < K.lines.length; de++) {
      for (var ge = K.lines[de], fe = ge.tokens, ve = fe.length, pe = ge.lineHeight, he = ge.width, me = 0, ye = oe, Ce = ue, Ie = ve - 1, be = void 0; me < ve && (be = fe[me], !be.align || be.align === "left"); )
        this._placeToken(be, G, pe, le, ye, "left", ce), he -= be.width, ye += be.width, me++;
      for (; Ie >= 0 && (be = fe[Ie], be.align === "right"); )
        this._placeToken(be, G, pe, le, Ce, "right", ce), he -= be.width, Ce -= be.width, Ie--;
      for (ye += (W - (ye - oe) - (ue - Ce) - he) / 2; me <= Ie; )
        be = fe[me], this._placeToken(be, G, pe, le, ye + be.width / 2, "center", ce), ye += be.width, me++;
      le += pe;
    }
  }, C.prototype._placeToken = function(G, U, K, W, Z, X, Q) {
    var ee = U.rich[G.styleName] || {};
    ee.text = G.text;
    var te = G.verticalAlign, re = W + K / 2;
    te === "top" ? re = W + G.height / 2 : te === "bottom" && (re = W + K - G.height / 2);
    var ne = !G.isLineHolder && needDrawBackground(ee);
    ne && this._renderBackground(ee, U, X === "right" ? Z - G.width : X === "center" ? Z - G.width / 2 : Z, re - G.height / 2, G.width, G.height);
    var ae = !!ee.backgroundColor, ie = G.textPadding;
    ie && (Z = getTextXForPadding(Z, X, ie), re -= G.height / 2 - ie[0] - G.innerHeight / 2);
    var se = this._getOrCreateChild(TSpan$1), oe = se.createStyle();
    se.useStyle(oe);
    var le = this._defaultStyle, ue = !1, ce = 0, de = getFill("fill" in ee ? ee.fill : "fill" in U ? U.fill : (ue = !0, le.fill)), ge = getStroke("stroke" in ee ? ee.stroke : "stroke" in U ? U.stroke : !ae && !Q && (!le.autoStroke || ue) ? (ce = DEFAULT_STROKE_LINE_WIDTH, le.stroke) : null), fe = ee.textShadowBlur > 0 || U.textShadowBlur > 0;
    oe.text = G.text, oe.x = Z, oe.y = re, fe && (oe.shadowBlur = ee.textShadowBlur || U.textShadowBlur || 0, oe.shadowColor = ee.textShadowColor || U.textShadowColor || "transparent", oe.shadowOffsetX = ee.textShadowOffsetX || U.textShadowOffsetX || 0, oe.shadowOffsetY = ee.textShadowOffsetY || U.textShadowOffsetY || 0), oe.textAlign = X, oe.textBaseline = "middle", oe.font = G.font || DEFAULT_FONT, oe.opacity = retrieve3(ee.opacity, U.opacity, 1), setSeparateFont(oe, ee), ge && (oe.lineWidth = retrieve3(ee.lineWidth, U.lineWidth, ce), oe.lineDash = retrieve2(ee.lineDash, U.lineDash), oe.lineDashOffset = U.lineDashOffset || 0, oe.stroke = ge), de && (oe.fill = de);
    var ve = G.contentWidth, pe = G.contentHeight;
    se.setBoundingRect(new BoundingRect$1(adjustTextX(oe.x, ve, oe.textAlign), adjustTextY(oe.y, pe, oe.textBaseline), ve, pe));
  }, C.prototype._renderBackground = function(G, U, K, W, Z, X) {
    var Q = G.backgroundColor, ee = G.borderWidth, te = G.borderColor, re = Q && Q.image, ne = Q && !re, ae = G.borderRadius, ie = this, se, oe;
    if (ne || G.lineHeight || ee && te) {
      se = this._getOrCreateChild(Rect$3), se.useStyle(se.createStyle()), se.style.fill = null;
      var le = se.shape;
      le.x = K, le.y = W, le.width = Z, le.height = X, le.r = ae, se.dirtyShape();
    }
    if (ne) {
      var ue = se.style;
      ue.fill = Q || null, ue.fillOpacity = retrieve2(G.fillOpacity, 1);
    } else if (re) {
      oe = this._getOrCreateChild(ZRImage$1), oe.onload = function() {
        ie.dirtyStyle();
      };
      var ce = oe.style;
      ce.image = Q.image, ce.x = K, ce.y = W, ce.width = Z, ce.height = X;
    }
    if (ee && te) {
      var ue = se.style;
      ue.lineWidth = ee, ue.stroke = te, ue.strokeOpacity = retrieve2(G.strokeOpacity, 1), ue.lineDash = G.borderDash, ue.lineDashOffset = G.borderDashOffset || 0, se.strokeContainThreshold = 0, se.hasFill() && se.hasStroke() && (ue.strokeFirst = !0, ue.lineWidth *= 2);
    }
    var de = (se || oe).style;
    de.shadowBlur = G.shadowBlur || 0, de.shadowColor = G.shadowColor || "transparent", de.shadowOffsetX = G.shadowOffsetX || 0, de.shadowOffsetY = G.shadowOffsetY || 0, de.opacity = retrieve3(G.opacity, U.opacity, 1);
  }, C.makeFont = function(G) {
    var U = "";
    return hasSeparateFont(G) && (U = [
      G.fontStyle,
      G.fontWeight,
      parseFontSize(G.fontSize),
      G.fontFamily || "sans-serif"
    ].join(" ")), U && trim$1(U) || G.textFont || G.font;
  }, C;
}(Displayable$1), VALID_TEXT_ALIGN = { left: !0, right: 1, center: 1 }, VALID_TEXT_VERTICAL_ALIGN = { top: 1, bottom: 1, middle: 1 }, FONT_PARTS = ["fontStyle", "fontWeight", "fontSize", "fontFamily"];
function parseFontSize(H) {
  return typeof H == "string" && (H.indexOf("px") !== -1 || H.indexOf("rem") !== -1 || H.indexOf("em") !== -1) ? H : isNaN(+H) ? DEFAULT_FONT_SIZE + "px" : H + "px";
}
function setSeparateFont(H, C) {
  for (var G = 0; G < FONT_PARTS.length; G++) {
    var U = FONT_PARTS[G], K = C[U];
    K != null && (H[U] = K);
  }
}
function hasSeparateFont(H) {
  return H.fontSize != null || H.fontFamily || H.fontWeight;
}
function normalizeTextStyle(H) {
  return normalizeStyle(H), each$f(H.rich, normalizeStyle), H;
}
function normalizeStyle(H) {
  if (H) {
    H.font = ZRText.makeFont(H);
    var C = H.align;
    C === "middle" && (C = "center"), H.align = C == null || VALID_TEXT_ALIGN[C] ? C : "left";
    var G = H.verticalAlign;
    G === "center" && (G = "middle"), H.verticalAlign = G == null || VALID_TEXT_VERTICAL_ALIGN[G] ? G : "top";
    var U = H.padding;
    U && (H.padding = normalizeCssArray$1(H.padding));
  }
}
function getStroke(H, C) {
  return H == null || C <= 0 || H === "transparent" || H === "none" ? null : H.image || H.colorStops ? "#000" : H;
}
function getFill(H) {
  return H == null || H === "none" ? null : H.image || H.colorStops ? "#000" : H;
}
function getTextXForPadding(H, C, G) {
  return C === "right" ? H - G[1] : C === "center" ? H + G[3] / 2 - G[1] / 2 : H + G[3];
}
function getStyleText(H) {
  var C = H.text;
  return C != null && (C += ""), C;
}
function needDrawBackground(H) {
  return !!(H.backgroundColor || H.lineHeight || H.borderWidth && H.borderColor);
}
const ZRText$1 = ZRText;
var getECData = makeInner(), setCommonECData = function(H, C, G, U) {
  if (U) {
    var K = getECData(U);
    K.dataIndex = G, K.dataType = C, K.seriesIndex = H, U.type === "group" && U.traverse(function(W) {
      var Z = getECData(W);
      Z.seriesIndex = H, Z.dataIndex = G, Z.dataType = C;
    });
  }
}, _highlightNextDigit = 1, _highlightKeyMap = {}, getSavedStates = makeInner(), getComponentStates = makeInner(), HOVER_STATE_NORMAL = 0, HOVER_STATE_BLUR = 1, HOVER_STATE_EMPHASIS = 2, SPECIAL_STATES = ["emphasis", "blur", "select"], DISPLAY_STATES = ["normal", "emphasis", "blur", "select"], Z2_EMPHASIS_LIFT = 10, Z2_SELECT_LIFT = 9, HIGHLIGHT_ACTION_TYPE = "highlight", DOWNPLAY_ACTION_TYPE = "downplay", SELECT_ACTION_TYPE = "select", UNSELECT_ACTION_TYPE = "unselect", TOGGLE_SELECT_ACTION_TYPE = "toggleSelect";
function hasFillOrStroke(H) {
  return H != null && H !== "none";
}
var liftedColorCache = new LRU$1(100);
function liftColor(H) {
  if (isString(H)) {
    var C = liftedColorCache.get(H);
    return C || (C = lift(H, -0.1), liftedColorCache.put(H, C)), C;
  } else if (isGradientObject(H)) {
    var G = extend({}, H);
    return G.colorStops = map$1(H.colorStops, function(U) {
      return {
        offset: U.offset,
        color: lift(U.color, -0.1)
      };
    }), G;
  }
  return H;
}
function doChangeHoverState(H, C, G) {
  H.onHoverStateChange && (H.hoverState || 0) !== G && H.onHoverStateChange(C), H.hoverState = G;
}
function singleEnterEmphasis(H) {
  doChangeHoverState(H, "emphasis", HOVER_STATE_EMPHASIS);
}
function singleLeaveEmphasis(H) {
  H.hoverState === HOVER_STATE_EMPHASIS && doChangeHoverState(H, "normal", HOVER_STATE_NORMAL);
}
function singleEnterBlur(H) {
  doChangeHoverState(H, "blur", HOVER_STATE_BLUR);
}
function singleLeaveBlur(H) {
  H.hoverState === HOVER_STATE_BLUR && doChangeHoverState(H, "normal", HOVER_STATE_NORMAL);
}
function singleEnterSelect(H) {
  H.selected = !0;
}
function singleLeaveSelect(H) {
  H.selected = !1;
}
function updateElementState(H, C, G) {
  C(H, G);
}
function traverseUpdateState(H, C, G) {
  updateElementState(H, C, G), H.isGroup && H.traverse(function(U) {
    updateElementState(U, C, G);
  });
}
function setStatesFlag(H, C) {
  switch (C) {
    case "emphasis":
      H.hoverState = HOVER_STATE_EMPHASIS;
      break;
    case "normal":
      H.hoverState = HOVER_STATE_NORMAL;
      break;
    case "blur":
      H.hoverState = HOVER_STATE_BLUR;
      break;
    case "select":
      H.selected = !0;
  }
}
function getFromStateStyle(H, C, G, U) {
  for (var K = H.style, W = {}, Z = 0; Z < C.length; Z++) {
    var X = C[Z], Q = K[X];
    W[X] = Q ?? (U && U[X]);
  }
  for (var Z = 0; Z < H.animators.length; Z++) {
    var ee = H.animators[Z];
    ee.__fromStateTransition && ee.__fromStateTransition.indexOf(G) < 0 && ee.targetName === "style" && ee.saveTo(W, C);
  }
  return W;
}
function createEmphasisDefaultState(H, C, G, U) {
  var K = G && indexOf(G, "select") >= 0, W = !1;
  if (H instanceof Path$1) {
    var Z = getSavedStates(H), X = K && Z.selectFill || Z.normalFill, Q = K && Z.selectStroke || Z.normalStroke;
    if (hasFillOrStroke(X) || hasFillOrStroke(Q)) {
      U = U || {};
      var ee = U.style || {};
      ee.fill === "inherit" ? (W = !0, U = extend({}, U), ee = extend({}, ee), ee.fill = X) : !hasFillOrStroke(ee.fill) && hasFillOrStroke(X) ? (W = !0, U = extend({}, U), ee = extend({}, ee), ee.fill = liftColor(X)) : !hasFillOrStroke(ee.stroke) && hasFillOrStroke(Q) && (W || (U = extend({}, U), ee = extend({}, ee)), ee.stroke = liftColor(Q)), U.style = ee;
    }
  }
  if (U && U.z2 == null) {
    W || (U = extend({}, U));
    var te = H.z2EmphasisLift;
    U.z2 = H.z2 + (te ?? Z2_EMPHASIS_LIFT);
  }
  return U;
}
function createSelectDefaultState(H, C, G) {
  if (G && G.z2 == null) {
    G = extend({}, G);
    var U = H.z2SelectLift;
    G.z2 = H.z2 + (U ?? Z2_SELECT_LIFT);
  }
  return G;
}
function createBlurDefaultState(H, C, G) {
  var U = indexOf(H.currentStates, C) >= 0, K = H.style.opacity, W = U ? null : getFromStateStyle(H, ["opacity"], C, {
    opacity: 1
  });
  G = G || {};
  var Z = G.style || {};
  return Z.opacity == null && (G = extend({}, G), Z = extend({
    // Already being applied 'emphasis'. DON'T mul opacity multiple times.
    opacity: U ? K : W.opacity * 0.1
  }, Z), G.style = Z), G;
}
function elementStateProxy(H, C) {
  var G = this.states[H];
  if (this.style) {
    if (H === "emphasis")
      return createEmphasisDefaultState(this, H, C, G);
    if (H === "blur")
      return createBlurDefaultState(this, H, G);
    if (H === "select")
      return createSelectDefaultState(this, H, G);
  }
  return G;
}
function setDefaultStateProxy(H) {
  H.stateProxy = elementStateProxy;
  var C = H.getTextContent(), G = H.getTextGuideLine();
  C && (C.stateProxy = elementStateProxy), G && (G.stateProxy = elementStateProxy);
}
function enterEmphasisWhenMouseOver(H, C) {
  !shouldSilent(H, C) && !H.__highByOuter && traverseUpdateState(H, singleEnterEmphasis);
}
function leaveEmphasisWhenMouseOut(H, C) {
  !shouldSilent(H, C) && !H.__highByOuter && traverseUpdateState(H, singleLeaveEmphasis);
}
function enterEmphasis(H, C) {
  H.__highByOuter |= 1 << (C || 0), traverseUpdateState(H, singleEnterEmphasis);
}
function leaveEmphasis(H, C) {
  !(H.__highByOuter &= ~(1 << (C || 0))) && traverseUpdateState(H, singleLeaveEmphasis);
}
function enterBlur(H) {
  traverseUpdateState(H, singleEnterBlur);
}
function leaveBlur(H) {
  traverseUpdateState(H, singleLeaveBlur);
}
function enterSelect(H) {
  traverseUpdateState(H, singleEnterSelect);
}
function leaveSelect(H) {
  traverseUpdateState(H, singleLeaveSelect);
}
function shouldSilent(H, C) {
  return H.__highDownSilentOnTouch && C.zrByTouch;
}
function allLeaveBlur(H) {
  var C = H.getModel(), G = [], U = [];
  C.eachComponent(function(K, W) {
    var Z = getComponentStates(W), X = K === "series", Q = X ? H.getViewOfSeriesModel(W) : H.getViewOfComponentModel(W);
    !X && U.push(Q), Z.isBlured && (Q.group.traverse(function(ee) {
      singleLeaveBlur(ee);
    }), X && G.push(W)), Z.isBlured = !1;
  }), each$f(U, function(K) {
    K && K.toggleBlurSeries && K.toggleBlurSeries(G, !1, C);
  });
}
function blurSeries(H, C, G, U) {
  var K = U.getModel();
  G = G || "coordinateSystem";
  function W(ee, te) {
    for (var re = 0; re < te.length; re++) {
      var ne = ee.getItemGraphicEl(te[re]);
      ne && leaveBlur(ne);
    }
  }
  if (H != null && !(!C || C === "none")) {
    var Z = K.getSeriesByIndex(H), X = Z.coordinateSystem;
    X && X.master && (X = X.master);
    var Q = [];
    K.eachSeries(function(ee) {
      var te = Z === ee, re = ee.coordinateSystem;
      re && re.master && (re = re.master);
      var ne = re && X ? re === X : te;
      if (!// Not blur other series if blurScope series
      (G === "series" && !te || G === "coordinateSystem" && !ne || C === "series" && te)) {
        var ae = U.getViewOfSeriesModel(ee);
        if (ae.group.traverse(function(oe) {
          singleEnterBlur(oe);
        }), isArrayLike(C))
          W(ee.getData(), C);
        else if (isObject$3(C))
          for (var ie = keys(C), se = 0; se < ie.length; se++)
            W(ee.getData(ie[se]), C[ie[se]]);
        Q.push(ee), getComponentStates(ee).isBlured = !0;
      }
    }), K.eachComponent(function(ee, te) {
      if (ee !== "series") {
        var re = U.getViewOfComponentModel(te);
        re && re.toggleBlurSeries && re.toggleBlurSeries(Q, !0, K);
      }
    });
  }
}
function blurComponent(H, C, G) {
  if (!(H == null || C == null)) {
    var U = G.getModel().getComponent(H, C);
    if (U) {
      getComponentStates(U).isBlured = !0;
      var K = G.getViewOfComponentModel(U);
      !K || !K.focusBlurEnabled || K.group.traverse(function(W) {
        singleEnterBlur(W);
      });
    }
  }
}
function blurSeriesFromHighlightPayload(H, C, G) {
  var U = H.seriesIndex, K = H.getData(C.dataType);
  if (!K) {
    process.env.NODE_ENV !== "production" && error("Unknown dataType " + C.dataType);
    return;
  }
  var W = queryDataIndex(K, C);
  W = (isArray$1(W) ? W[0] : W) || 0;
  var Z = K.getItemGraphicEl(W);
  if (!Z)
    for (var X = K.count(), Q = 0; !Z && Q < X; )
      Z = K.getItemGraphicEl(Q++);
  if (Z) {
    var ee = getECData(Z);
    blurSeries(U, ee.focus, ee.blurScope, G);
  } else {
    var te = H.get(["emphasis", "focus"]), re = H.get(["emphasis", "blurScope"]);
    te != null && blurSeries(U, te, re, G);
  }
}
function findComponentHighDownDispatchers(H, C, G, U) {
  var K = {
    focusSelf: !1,
    dispatchers: null
  };
  if (H == null || H === "series" || C == null || G == null)
    return K;
  var W = U.getModel().getComponent(H, C);
  if (!W)
    return K;
  var Z = U.getViewOfComponentModel(W);
  if (!Z || !Z.findHighDownDispatchers)
    return K;
  for (var X = Z.findHighDownDispatchers(G), Q, ee = 0; ee < X.length; ee++)
    if (process.env.NODE_ENV !== "production" && !isHighDownDispatcher(X[ee]) && error("param should be highDownDispatcher"), getECData(X[ee]).focus === "self") {
      Q = !0;
      break;
    }
  return {
    focusSelf: Q,
    dispatchers: X
  };
}
function handleGlobalMouseOverForHighDown(H, C, G) {
  process.env.NODE_ENV !== "production" && !isHighDownDispatcher(H) && error("param should be highDownDispatcher");
  var U = getECData(H), K = findComponentHighDownDispatchers(U.componentMainType, U.componentIndex, U.componentHighDownName, G), W = K.dispatchers, Z = K.focusSelf;
  W ? (Z && blurComponent(U.componentMainType, U.componentIndex, G), each$f(W, function(X) {
    return enterEmphasisWhenMouseOver(X, C);
  })) : (blurSeries(U.seriesIndex, U.focus, U.blurScope, G), U.focus === "self" && blurComponent(U.componentMainType, U.componentIndex, G), enterEmphasisWhenMouseOver(H, C));
}
function handleGlobalMouseOutForHighDown(H, C, G) {
  process.env.NODE_ENV !== "production" && !isHighDownDispatcher(H) && error("param should be highDownDispatcher"), allLeaveBlur(G);
  var U = getECData(H), K = findComponentHighDownDispatchers(U.componentMainType, U.componentIndex, U.componentHighDownName, G).dispatchers;
  K ? each$f(K, function(W) {
    return leaveEmphasisWhenMouseOut(W, C);
  }) : leaveEmphasisWhenMouseOut(H, C);
}
function toggleSelectionFromPayload(H, C, G) {
  if (isSelectChangePayload(C)) {
    var U = C.dataType, K = H.getData(U), W = queryDataIndex(K, C);
    isArray$1(W) || (W = [W]), H[C.type === TOGGLE_SELECT_ACTION_TYPE ? "toggleSelect" : C.type === SELECT_ACTION_TYPE ? "select" : "unselect"](W, U);
  }
}
function updateSeriesElementSelection(H) {
  var C = H.getAllData();
  each$f(C, function(G) {
    var U = G.data, K = G.type;
    U.eachItemGraphicEl(function(W, Z) {
      H.isSelected(Z, K) ? enterSelect(W) : leaveSelect(W);
    });
  });
}
function getAllSelectedIndices(H) {
  var C = [];
  return H.eachSeries(function(G) {
    var U = G.getAllData();
    each$f(U, function(K) {
      K.data;
      var W = K.type, Z = G.getSelectedDataIndices();
      if (Z.length > 0) {
        var X = {
          dataIndex: Z,
          seriesIndex: G.seriesIndex
        };
        W != null && (X.dataType = W), C.push(X);
      }
    });
  }), C;
}
function enableHoverEmphasis(H, C, G) {
  setAsHighDownDispatcher(H, !0), traverseUpdateState(H, setDefaultStateProxy), enableHoverFocus(H, C, G);
}
function disableHoverEmphasis(H) {
  setAsHighDownDispatcher(H, !1);
}
function toggleHoverEmphasis(H, C, G, U) {
  U ? disableHoverEmphasis(H) : enableHoverEmphasis(H, C, G);
}
function enableHoverFocus(H, C, G) {
  var U = getECData(H);
  C != null ? (U.focus = C, U.blurScope = G) : U.focus && (U.focus = null);
}
var OTHER_STATES = ["emphasis", "blur", "select"], defaultStyleGetterMap = {
  itemStyle: "getItemStyle",
  lineStyle: "getLineStyle",
  areaStyle: "getAreaStyle"
};
function setStatesStylesFromModel(H, C, G, U) {
  G = G || "itemStyle";
  for (var K = 0; K < OTHER_STATES.length; K++) {
    var W = OTHER_STATES[K], Z = C.getModel([W, G]), X = H.ensureState(W);
    X.style = U ? U(Z) : Z[defaultStyleGetterMap[G]]();
  }
}
function setAsHighDownDispatcher(H, C) {
  var G = C === !1, U = H;
  H.highDownSilentOnTouch && (U.__highDownSilentOnTouch = H.highDownSilentOnTouch), (!G || U.__highDownDispatcher) && (U.__highByOuter = U.__highByOuter || 0, U.__highDownDispatcher = !G);
}
function isHighDownDispatcher(H) {
  return !!(H && H.__highDownDispatcher);
}
function enableComponentHighDownFeatures(H, C, G) {
  var U = getECData(H);
  U.componentMainType = C.mainType, U.componentIndex = C.componentIndex, U.componentHighDownName = G;
}
function getHighlightDigit(H) {
  var C = _highlightKeyMap[H];
  return C == null && _highlightNextDigit <= 32 && (C = _highlightKeyMap[H] = _highlightNextDigit++), C;
}
function isSelectChangePayload(H) {
  var C = H.type;
  return C === SELECT_ACTION_TYPE || C === UNSELECT_ACTION_TYPE || C === TOGGLE_SELECT_ACTION_TYPE;
}
function isHighDownPayload(H) {
  var C = H.type;
  return C === HIGHLIGHT_ACTION_TYPE || C === DOWNPLAY_ACTION_TYPE;
}
function savePathStates(H) {
  var C = getSavedStates(H);
  C.normalFill = H.style.fill, C.normalStroke = H.style.stroke;
  var G = H.states.select || {};
  C.selectFill = G.style && G.style.fill || null, C.selectStroke = G.style && G.style.stroke || null;
}
var CMD$2 = PathProxy$1.CMD, points$2 = [[], [], []], mathSqrt$2 = Math.sqrt, mathAtan2 = Math.atan2;
function transformPath(H, C) {
  if (C) {
    var G = H.data, U = H.len(), K, W, Z, X, Q, ee, te = CMD$2.M, re = CMD$2.C, ne = CMD$2.L, ae = CMD$2.R, ie = CMD$2.A, se = CMD$2.Q;
    for (Z = 0, X = 0; Z < U; ) {
      switch (K = G[Z++], X = Z, W = 0, K) {
        case te:
          W = 1;
          break;
        case ne:
          W = 1;
          break;
        case re:
          W = 3;
          break;
        case se:
          W = 2;
          break;
        case ie:
          var oe = C[4], le = C[5], ue = mathSqrt$2(C[0] * C[0] + C[1] * C[1]), ce = mathSqrt$2(C[2] * C[2] + C[3] * C[3]), de = mathAtan2(-C[1] / ce, C[0] / ue);
          G[Z] *= ue, G[Z++] += oe, G[Z] *= ce, G[Z++] += le, G[Z++] *= ue, G[Z++] *= ce, G[Z++] += de, G[Z++] += de, Z += 2, X = Z;
          break;
        case ae:
          ee[0] = G[Z++], ee[1] = G[Z++], applyTransform$1(ee, ee, C), G[X++] = ee[0], G[X++] = ee[1], ee[0] += G[Z++], ee[1] += G[Z++], applyTransform$1(ee, ee, C), G[X++] = ee[0], G[X++] = ee[1];
      }
      for (Q = 0; Q < W; Q++) {
        var ge = points$2[Q];
        ge[0] = G[Z++], ge[1] = G[Z++], applyTransform$1(ge, ge, C), G[X++] = ge[0], G[X++] = ge[1];
      }
    }
    H.increaseVersion();
  }
}
var mathSqrt$1 = Math.sqrt, mathSin$2 = Math.sin, mathCos$2 = Math.cos, PI$7 = Math.PI;
function vMag(H) {
  return Math.sqrt(H[0] * H[0] + H[1] * H[1]);
}
function vRatio(H, C) {
  return (H[0] * C[0] + H[1] * C[1]) / (vMag(H) * vMag(C));
}
function vAngle(H, C) {
  return (H[0] * C[1] < H[1] * C[0] ? -1 : 1) * Math.acos(vRatio(H, C));
}
function processArc(H, C, G, U, K, W, Z, X, Q, ee, te) {
  var re = Q * (PI$7 / 180), ne = mathCos$2(re) * (H - G) / 2 + mathSin$2(re) * (C - U) / 2, ae = -1 * mathSin$2(re) * (H - G) / 2 + mathCos$2(re) * (C - U) / 2, ie = ne * ne / (Z * Z) + ae * ae / (X * X);
  ie > 1 && (Z *= mathSqrt$1(ie), X *= mathSqrt$1(ie));
  var se = (K === W ? -1 : 1) * mathSqrt$1((Z * Z * (X * X) - Z * Z * (ae * ae) - X * X * (ne * ne)) / (Z * Z * (ae * ae) + X * X * (ne * ne))) || 0, oe = se * Z * ae / X, le = se * -X * ne / Z, ue = (H + G) / 2 + mathCos$2(re) * oe - mathSin$2(re) * le, ce = (C + U) / 2 + mathSin$2(re) * oe + mathCos$2(re) * le, de = vAngle([1, 0], [(ne - oe) / Z, (ae - le) / X]), ge = [(ne - oe) / Z, (ae - le) / X], fe = [(-1 * ne - oe) / Z, (-1 * ae - le) / X], ve = vAngle(ge, fe);
  if (vRatio(ge, fe) <= -1 && (ve = PI$7), vRatio(ge, fe) >= 1 && (ve = 0), ve < 0) {
    var pe = Math.round(ve / PI$7 * 1e6) / 1e6;
    ve = PI$7 * 2 + pe % 2 * PI$7;
  }
  te.addData(ee, ue, ce, Z, X, de, ve, re, W);
}
var commandReg = /([mlvhzcqtsa])([^mlvhzcqtsa]*)/ig, numberReg$1 = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g;
function createPathProxyFromString(H) {
  var C = new PathProxy$1();
  if (!H)
    return C;
  var G = 0, U = 0, K = G, W = U, Z, X = PathProxy$1.CMD, Q = H.match(commandReg);
  if (!Q)
    return C;
  for (var ee = 0; ee < Q.length; ee++) {
    for (var te = Q[ee], re = te.charAt(0), ne = void 0, ae = te.match(numberReg$1) || [], ie = ae.length, se = 0; se < ie; se++)
      ae[se] = parseFloat(ae[se]);
    for (var oe = 0; oe < ie; ) {
      var le = void 0, ue = void 0, ce = void 0, de = void 0, ge = void 0, fe = void 0, ve = void 0, pe = G, he = U, me = void 0, ye = void 0;
      switch (re) {
        case "l":
          G += ae[oe++], U += ae[oe++], ne = X.L, C.addData(ne, G, U);
          break;
        case "L":
          G = ae[oe++], U = ae[oe++], ne = X.L, C.addData(ne, G, U);
          break;
        case "m":
          G += ae[oe++], U += ae[oe++], ne = X.M, C.addData(ne, G, U), K = G, W = U, re = "l";
          break;
        case "M":
          G = ae[oe++], U = ae[oe++], ne = X.M, C.addData(ne, G, U), K = G, W = U, re = "L";
          break;
        case "h":
          G += ae[oe++], ne = X.L, C.addData(ne, G, U);
          break;
        case "H":
          G = ae[oe++], ne = X.L, C.addData(ne, G, U);
          break;
        case "v":
          U += ae[oe++], ne = X.L, C.addData(ne, G, U);
          break;
        case "V":
          U = ae[oe++], ne = X.L, C.addData(ne, G, U);
          break;
        case "C":
          ne = X.C, C.addData(ne, ae[oe++], ae[oe++], ae[oe++], ae[oe++], ae[oe++], ae[oe++]), G = ae[oe - 2], U = ae[oe - 1];
          break;
        case "c":
          ne = X.C, C.addData(ne, ae[oe++] + G, ae[oe++] + U, ae[oe++] + G, ae[oe++] + U, ae[oe++] + G, ae[oe++] + U), G += ae[oe - 2], U += ae[oe - 1];
          break;
        case "S":
          le = G, ue = U, me = C.len(), ye = C.data, Z === X.C && (le += G - ye[me - 4], ue += U - ye[me - 3]), ne = X.C, pe = ae[oe++], he = ae[oe++], G = ae[oe++], U = ae[oe++], C.addData(ne, le, ue, pe, he, G, U);
          break;
        case "s":
          le = G, ue = U, me = C.len(), ye = C.data, Z === X.C && (le += G - ye[me - 4], ue += U - ye[me - 3]), ne = X.C, pe = G + ae[oe++], he = U + ae[oe++], G += ae[oe++], U += ae[oe++], C.addData(ne, le, ue, pe, he, G, U);
          break;
        case "Q":
          pe = ae[oe++], he = ae[oe++], G = ae[oe++], U = ae[oe++], ne = X.Q, C.addData(ne, pe, he, G, U);
          break;
        case "q":
          pe = ae[oe++] + G, he = ae[oe++] + U, G += ae[oe++], U += ae[oe++], ne = X.Q, C.addData(ne, pe, he, G, U);
          break;
        case "T":
          le = G, ue = U, me = C.len(), ye = C.data, Z === X.Q && (le += G - ye[me - 4], ue += U - ye[me - 3]), G = ae[oe++], U = ae[oe++], ne = X.Q, C.addData(ne, le, ue, G, U);
          break;
        case "t":
          le = G, ue = U, me = C.len(), ye = C.data, Z === X.Q && (le += G - ye[me - 4], ue += U - ye[me - 3]), G += ae[oe++], U += ae[oe++], ne = X.Q, C.addData(ne, le, ue, G, U);
          break;
        case "A":
          ce = ae[oe++], de = ae[oe++], ge = ae[oe++], fe = ae[oe++], ve = ae[oe++], pe = G, he = U, G = ae[oe++], U = ae[oe++], ne = X.A, processArc(pe, he, G, U, fe, ve, ce, de, ge, ne, C);
          break;
        case "a":
          ce = ae[oe++], de = ae[oe++], ge = ae[oe++], fe = ae[oe++], ve = ae[oe++], pe = G, he = U, G += ae[oe++], U += ae[oe++], ne = X.A, processArc(pe, he, G, U, fe, ve, ce, de, ge, ne, C);
          break;
      }
    }
    (re === "z" || re === "Z") && (ne = X.Z, C.addData(ne), G = K, U = W), Z = ne;
  }
  return C.toStatic(), C;
}
var SVGPath = function(H) {
  __extends(C, H);
  function C() {
    return H !== null && H.apply(this, arguments) || this;
  }
  return C.prototype.applyTransform = function(G) {
  }, C;
}(Path$1);
function isPathProxy(H) {
  return H.setData != null;
}
function createPathOptions(H, C) {
  var G = createPathProxyFromString(H), U = extend({}, C);
  return U.buildPath = function(K) {
    if (isPathProxy(K)) {
      K.setData(G.data);
      var W = K.getContext();
      W && K.rebuildPath(W, 1);
    } else {
      var W = K;
      G.rebuildPath(W, 1);
    }
  }, U.applyTransform = function(K) {
    transformPath(G, K), this.dirtyShape();
  }, U;
}
function createFromString(H, C) {
  return new SVGPath(createPathOptions(H, C));
}
function extendFromString(H, C) {
  var G = createPathOptions(H, C), U = function(K) {
    __extends(W, K);
    function W(Z) {
      var X = K.call(this, Z) || this;
      return X.applyTransform = G.applyTransform, X.buildPath = G.buildPath, X;
    }
    return W;
  }(SVGPath);
  return U;
}
function mergePath$1(H, C) {
  for (var G = [], U = H.length, K = 0; K < U; K++) {
    var W = H[K];
    G.push(W.getUpdatedPathProxy(!0));
  }
  var Z = new Path$1(C);
  return Z.createPathProxy(), Z.buildPath = function(X) {
    if (isPathProxy(X)) {
      X.appendPath(G);
      var Q = X.getContext();
      Q && X.rebuildPath(Q, 1);
    }
  }, Z;
}
function clonePath(H, C) {
  C = C || {};
  var G = new Path$1();
  return H.shape && G.setShape(H.shape), G.setStyle(H.style), C.bakeTransform ? transformPath(G.path, H.getComputedTransform()) : C.toLocal ? G.setLocalTransform(H.getComputedTransform()) : G.copyTransform(H), G.buildPath = H.buildPath, G.applyTransform = G.applyTransform, G.z = H.z, G.z2 = H.z2, G.zlevel = H.zlevel, G;
}
var CircleShape = function() {
  function H() {
    this.cx = 0, this.cy = 0, this.r = 0;
  }
  return H;
}(), Circle = function(H) {
  __extends(C, H);
  function C(G) {
    return H.call(this, G) || this;
  }
  return C.prototype.getDefaultShape = function() {
    return new CircleShape();
  }, C.prototype.buildPath = function(G, U) {
    G.moveTo(U.cx + U.r, U.cy), G.arc(U.cx, U.cy, U.r, 0, Math.PI * 2);
  }, C;
}(Path$1);
Circle.prototype.type = "circle";
const Circle$1 = Circle;
var EllipseShape = function() {
  function H() {
    this.cx = 0, this.cy = 0, this.rx = 0, this.ry = 0;
  }
  return H;
}(), Ellipse = function(H) {
  __extends(C, H);
  function C(G) {
    return H.call(this, G) || this;
  }
  return C.prototype.getDefaultShape = function() {
    return new EllipseShape();
  }, C.prototype.buildPath = function(G, U) {
    var K = 0.5522848, W = U.cx, Z = U.cy, X = U.rx, Q = U.ry, ee = X * K, te = Q * K;
    G.moveTo(W - X, Z), G.bezierCurveTo(W - X, Z - te, W - ee, Z - Q, W, Z - Q), G.bezierCurveTo(W + ee, Z - Q, W + X, Z - te, W + X, Z), G.bezierCurveTo(W + X, Z + te, W + ee, Z + Q, W, Z + Q), G.bezierCurveTo(W - ee, Z + Q, W - X, Z + te, W - X, Z), G.closePath();
  }, C;
}(Path$1);
Ellipse.prototype.type = "ellipse";
const Ellipse$1 = Ellipse;
var PI$6 = Math.PI, PI2$3 = PI$6 * 2, mathSin$1 = Math.sin, mathCos$1 = Math.cos, mathACos = Math.acos, mathATan2 = Math.atan2, mathAbs$1 = Math.abs, mathSqrt = Math.sqrt, mathMax$7 = Math.max, mathMin$7 = Math.min, e = 1e-4;
function intersect(H, C, G, U, K, W, Z, X) {
  var Q = G - H, ee = U - C, te = Z - K, re = X - W, ne = re * Q - te * ee;
  if (!(ne * ne < e))
    return ne = (te * (C - W) - re * (H - K)) / ne, [H + ne * Q, C + ne * ee];
}
function computeCornerTangents(H, C, G, U, K, W, Z) {
  var X = H - G, Q = C - U, ee = (Z ? W : -W) / mathSqrt(X * X + Q * Q), te = ee * Q, re = -ee * X, ne = H + te, ae = C + re, ie = G + te, se = U + re, oe = (ne + ie) / 2, le = (ae + se) / 2, ue = ie - ne, ce = se - ae, de = ue * ue + ce * ce, ge = K - W, fe = ne * se - ie * ae, ve = (ce < 0 ? -1 : 1) * mathSqrt(mathMax$7(0, ge * ge * de - fe * fe)), pe = (fe * ce - ue * ve) / de, he = (-fe * ue - ce * ve) / de, me = (fe * ce + ue * ve) / de, ye = (-fe * ue + ce * ve) / de, Ce = pe - oe, Ie = he - le, be = me - oe, Se = ye - le;
  return Ce * Ce + Ie * Ie > be * be + Se * Se && (pe = me, he = ye), {
    cx: pe,
    cy: he,
    x0: -te,
    y0: -re,
    x1: pe * (K / ge - 1),
    y1: he * (K / ge - 1)
  };
}
function normalizeCornerRadius(H) {
  var C;
  if (isArray$1(H)) {
    var G = H.length;
    if (!G)
      return H;
    G === 1 ? C = [H[0], H[0], 0, 0] : G === 2 ? C = [H[0], H[0], H[1], H[1]] : G === 3 ? C = H.concat(H[2]) : C = H;
  } else
    C = [H, H, H, H];
  return C;
}
function buildPath$1(H, C) {
  var G, U = mathMax$7(C.r, 0), K = mathMax$7(C.r0 || 0, 0), W = U > 0, Z = K > 0;
  if (!(!W && !Z)) {
    if (W || (U = K, K = 0), K > U) {
      var X = U;
      U = K, K = X;
    }
    var Q = C.startAngle, ee = C.endAngle;
    if (!(isNaN(Q) || isNaN(ee))) {
      var te = C.cx, re = C.cy, ne = !!C.clockwise, ae = mathAbs$1(ee - Q), ie = ae > PI2$3 && ae % PI2$3;
      if (ie > e && (ae = ie), !(U > e))
        H.moveTo(te, re);
      else if (ae > PI2$3 - e)
        H.moveTo(te + U * mathCos$1(Q), re + U * mathSin$1(Q)), H.arc(te, re, U, Q, ee, !ne), K > e && (H.moveTo(te + K * mathCos$1(ee), re + K * mathSin$1(ee)), H.arc(te, re, K, ee, Q, ne));
      else {
        var se = void 0, oe = void 0, le = void 0, ue = void 0, ce = void 0, de = void 0, ge = void 0, fe = void 0, ve = void 0, pe = void 0, he = void 0, me = void 0, ye = void 0, Ce = void 0, Ie = void 0, be = void 0, Se = U * mathCos$1(Q), Ae = U * mathSin$1(Q), _e = K * mathCos$1(ee), xe = K * mathSin$1(ee), Te = ae > e;
        if (Te) {
          var Pe = C.cornerRadius;
          Pe && (G = normalizeCornerRadius(Pe), se = G[0], oe = G[1], le = G[2], ue = G[3]);
          var $e = mathAbs$1(U - K) / 2;
          if (ce = mathMin$7($e, le), de = mathMin$7($e, ue), ge = mathMin$7($e, se), fe = mathMin$7($e, oe), he = ve = mathMax$7(ce, de), me = pe = mathMax$7(ge, fe), (ve > e || pe > e) && (ye = U * mathCos$1(ee), Ce = U * mathSin$1(ee), Ie = K * mathCos$1(Q), be = K * mathSin$1(Q), ae < PI$6)) {
            var Me = intersect(Se, Ae, Ie, be, ye, Ce, _e, xe);
            if (Me) {
              var Ee = Se - Me[0], we = Ae - Me[1], Oe = ye - Me[0], Ne = Ce - Me[1], ke = 1 / mathSin$1(mathACos((Ee * Oe + we * Ne) / (mathSqrt(Ee * Ee + we * we) * mathSqrt(Oe * Oe + Ne * Ne))) / 2), ze = mathSqrt(Me[0] * Me[0] + Me[1] * Me[1]);
              he = mathMin$7(ve, (U - ze) / (ke + 1)), me = mathMin$7(pe, (K - ze) / (ke - 1));
            }
          }
        }
        if (!Te)
          H.moveTo(te + Se, re + Ae);
        else if (he > e) {
          var He = mathMin$7(le, he), We = mathMin$7(ue, he), Re = computeCornerTangents(Ie, be, Se, Ae, U, He, ne), Le = computeCornerTangents(ye, Ce, _e, xe, U, We, ne);
          H.moveTo(te + Re.cx + Re.x0, re + Re.cy + Re.y0), he < ve && He === We ? H.arc(te + Re.cx, re + Re.cy, he, mathATan2(Re.y0, Re.x0), mathATan2(Le.y0, Le.x0), !ne) : (He > 0 && H.arc(te + Re.cx, re + Re.cy, He, mathATan2(Re.y0, Re.x0), mathATan2(Re.y1, Re.x1), !ne), H.arc(te, re, U, mathATan2(Re.cy + Re.y1, Re.cx + Re.x1), mathATan2(Le.cy + Le.y1, Le.cx + Le.x1), !ne), We > 0 && H.arc(te + Le.cx, re + Le.cy, We, mathATan2(Le.y1, Le.x1), mathATan2(Le.y0, Le.x0), !ne));
        } else
          H.moveTo(te + Se, re + Ae), H.arc(te, re, U, Q, ee, !ne);
        if (!(K > e) || !Te)
          H.lineTo(te + _e, re + xe);
        else if (me > e) {
          var He = mathMin$7(se, me), We = mathMin$7(oe, me), Re = computeCornerTangents(_e, xe, ye, Ce, K, -We, ne), Le = computeCornerTangents(Se, Ae, Ie, be, K, -He, ne);
          H.lineTo(te + Re.cx + Re.x0, re + Re.cy + Re.y0), me < pe && He === We ? H.arc(te + Re.cx, re + Re.cy, me, mathATan2(Re.y0, Re.x0), mathATan2(Le.y0, Le.x0), !ne) : (We > 0 && H.arc(te + Re.cx, re + Re.cy, We, mathATan2(Re.y0, Re.x0), mathATan2(Re.y1, Re.x1), !ne), H.arc(te, re, K, mathATan2(Re.cy + Re.y1, Re.cx + Re.x1), mathATan2(Le.cy + Le.y1, Le.cx + Le.x1), ne), He > 0 && H.arc(te + Le.cx, re + Le.cy, He, mathATan2(Le.y1, Le.x1), mathATan2(Le.y0, Le.x0), !ne));
        } else
          H.lineTo(te + _e, re + xe), H.arc(te, re, K, ee, Q, ne);
      }
      H.closePath();
    }
  }
}
var SectorShape = function() {
  function H() {
    this.cx = 0, this.cy = 0, this.r0 = 0, this.r = 0, this.startAngle = 0, this.endAngle = Math.PI * 2, this.clockwise = !0, this.cornerRadius = 0;
  }
  return H;
}(), Sector = function(H) {
  __extends(C, H);
  function C(G) {
    return H.call(this, G) || this;
  }
  return C.prototype.getDefaultShape = function() {
    return new SectorShape();
  }, C.prototype.buildPath = function(G, U) {
    buildPath$1(G, U);
  }, C.prototype.isZeroArea = function() {
    return this.shape.startAngle === this.shape.endAngle || this.shape.r === this.shape.r0;
  }, C;
}(Path$1);
Sector.prototype.type = "sector";
const Sector$1 = Sector;
var RingShape = function() {
  function H() {
    this.cx = 0, this.cy = 0, this.r = 0, this.r0 = 0;
  }
  return H;
}(), Ring = function(H) {
  __extends(C, H);
  function C(G) {
    return H.call(this, G) || this;
  }
  return C.prototype.getDefaultShape = function() {
    return new RingShape();
  }, C.prototype.buildPath = function(G, U) {
    var K = U.cx, W = U.cy, Z = Math.PI * 2;
    G.moveTo(K + U.r, W), G.arc(K, W, U.r, 0, Z, !1), G.moveTo(K + U.r0, W), G.arc(K, W, U.r0, 0, Z, !0);
  }, C;
}(Path$1);
Ring.prototype.type = "ring";
const Ring$1 = Ring;
function smoothBezier(H, C, G, U) {
  var K = [], W = [], Z = [], X = [], Q, ee, te, re;
  if (U) {
    te = [1 / 0, 1 / 0], re = [-1 / 0, -1 / 0];
    for (var ne = 0, ae = H.length; ne < ae; ne++)
      min$1(te, te, H[ne]), max$1(re, re, H[ne]);
    min$1(te, te, U[0]), max$1(re, re, U[1]);
  }
  for (var ne = 0, ae = H.length; ne < ae; ne++) {
    var ie = H[ne];
    if (G)
      Q = H[ne ? ne - 1 : ae - 1], ee = H[(ne + 1) % ae];
    else if (ne === 0 || ne === ae - 1) {
      K.push(clone$3(H[ne]));
      continue;
    } else
      Q = H[ne - 1], ee = H[ne + 1];
    sub(W, ee, Q), scale$2(W, W, C);
    var se = distance(ie, Q), oe = distance(ie, ee), le = se + oe;
    le !== 0 && (se /= le, oe /= le), scale$2(Z, W, -se), scale$2(X, W, oe);
    var ue = add([], ie, Z), ce = add([], ie, X);
    U && (max$1(ue, ue, te), min$1(ue, ue, re), max$1(ce, ce, te), min$1(ce, ce, re)), K.push(ue), K.push(ce);
  }
  return G && K.push(K.shift()), K;
}
function buildPath(H, C, G) {
  var U = C.smooth, K = C.points;
  if (K && K.length >= 2) {
    if (U) {
      var W = smoothBezier(K, U, G, C.smoothConstraint);
      H.moveTo(K[0][0], K[0][1]);
      for (var Z = K.length, X = 0; X < (G ? Z : Z - 1); X++) {
        var Q = W[X * 2], ee = W[X * 2 + 1], te = K[(X + 1) % Z];
        H.bezierCurveTo(Q[0], Q[1], ee[0], ee[1], te[0], te[1]);
      }
    } else {
      H.moveTo(K[0][0], K[0][1]);
      for (var X = 1, re = K.length; X < re; X++)
        H.lineTo(K[X][0], K[X][1]);
    }
    G && H.closePath();
  }
}
var PolygonShape = function() {
  function H() {
    this.points = null, this.smooth = 0, this.smoothConstraint = null;
  }
  return H;
}(), Polygon = function(H) {
  __extends(C, H);
  function C(G) {
    return H.call(this, G) || this;
  }
  return C.prototype.getDefaultShape = function() {
    return new PolygonShape();
  }, C.prototype.buildPath = function(G, U) {
    buildPath(G, U, !0);
  }, C;
}(Path$1);
Polygon.prototype.type = "polygon";
const Polygon$1 = Polygon;
var PolylineShape = function() {
  function H() {
    this.points = null, this.percent = 1, this.smooth = 0, this.smoothConstraint = null;
  }
  return H;
}(), Polyline$2 = function(H) {
  __extends(C, H);
  function C(G) {
    return H.call(this, G) || this;
  }
  return C.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  }, C.prototype.getDefaultShape = function() {
    return new PolylineShape();
  }, C.prototype.buildPath = function(G, U) {
    buildPath(G, U, !1);
  }, C;
}(Path$1);
Polyline$2.prototype.type = "polyline";
const Polyline$3 = Polyline$2;
var subPixelOptimizeOutputShape = {}, LineShape = function() {
  function H() {
    this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.percent = 1;
  }
  return H;
}(), Line$2 = function(H) {
  __extends(C, H);
  function C(G) {
    return H.call(this, G) || this;
  }
  return C.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  }, C.prototype.getDefaultShape = function() {
    return new LineShape();
  }, C.prototype.buildPath = function(G, U) {
    var K, W, Z, X;
    if (this.subPixelOptimize) {
      var Q = subPixelOptimizeLine$1(subPixelOptimizeOutputShape, U, this.style);
      K = Q.x1, W = Q.y1, Z = Q.x2, X = Q.y2;
    } else
      K = U.x1, W = U.y1, Z = U.x2, X = U.y2;
    var ee = U.percent;
    ee !== 0 && (G.moveTo(K, W), ee < 1 && (Z = K * (1 - ee) + Z * ee, X = W * (1 - ee) + X * ee), G.lineTo(Z, X));
  }, C.prototype.pointAt = function(G) {
    var U = this.shape;
    return [
      U.x1 * (1 - G) + U.x2 * G,
      U.y1 * (1 - G) + U.y2 * G
    ];
  }, C;
}(Path$1);
Line$2.prototype.type = "line";
const Line$3 = Line$2;
var out = [], BezierCurveShape = function() {
  function H() {
    this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.cpx1 = 0, this.cpy1 = 0, this.percent = 1;
  }
  return H;
}();
function someVectorAt(H, C, G) {
  var U = H.cpx2, K = H.cpy2;
  return U != null || K != null ? [
    (G ? cubicDerivativeAt : cubicAt)(H.x1, H.cpx1, H.cpx2, H.x2, C),
    (G ? cubicDerivativeAt : cubicAt)(H.y1, H.cpy1, H.cpy2, H.y2, C)
  ] : [
    (G ? quadraticDerivativeAt : quadraticAt$1)(H.x1, H.cpx1, H.x2, C),
    (G ? quadraticDerivativeAt : quadraticAt$1)(H.y1, H.cpy1, H.y2, C)
  ];
}
var BezierCurve = function(H) {
  __extends(C, H);
  function C(G) {
    return H.call(this, G) || this;
  }
  return C.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  }, C.prototype.getDefaultShape = function() {
    return new BezierCurveShape();
  }, C.prototype.buildPath = function(G, U) {
    var K = U.x1, W = U.y1, Z = U.x2, X = U.y2, Q = U.cpx1, ee = U.cpy1, te = U.cpx2, re = U.cpy2, ne = U.percent;
    ne !== 0 && (G.moveTo(K, W), te == null || re == null ? (ne < 1 && (quadraticSubdivide(K, Q, Z, ne, out), Q = out[1], Z = out[2], quadraticSubdivide(W, ee, X, ne, out), ee = out[1], X = out[2]), G.quadraticCurveTo(Q, ee, Z, X)) : (ne < 1 && (cubicSubdivide(K, Q, te, Z, ne, out), Q = out[1], te = out[2], Z = out[3], cubicSubdivide(W, ee, re, X, ne, out), ee = out[1], re = out[2], X = out[3]), G.bezierCurveTo(Q, ee, te, re, Z, X)));
  }, C.prototype.pointAt = function(G) {
    return someVectorAt(this.shape, G, !1);
  }, C.prototype.tangentAt = function(G) {
    var U = someVectorAt(this.shape, G, !0);
    return normalize$3(U, U);
  }, C;
}(Path$1);
BezierCurve.prototype.type = "bezier-curve";
const BezierCurve$1 = BezierCurve;
var ArcShape = function() {
  function H() {
    this.cx = 0, this.cy = 0, this.r = 0, this.startAngle = 0, this.endAngle = Math.PI * 2, this.clockwise = !0;
  }
  return H;
}(), Arc = function(H) {
  __extends(C, H);
  function C(G) {
    return H.call(this, G) || this;
  }
  return C.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  }, C.prototype.getDefaultShape = function() {
    return new ArcShape();
  }, C.prototype.buildPath = function(G, U) {
    var K = U.cx, W = U.cy, Z = Math.max(U.r, 0), X = U.startAngle, Q = U.endAngle, ee = U.clockwise, te = Math.cos(X), re = Math.sin(X);
    G.moveTo(te * Z + K, re * Z + W), G.arc(K, W, Z, X, Q, !ee);
  }, C;
}(Path$1);
Arc.prototype.type = "arc";
const Arc$1 = Arc;
var CompoundPath = function(H) {
  __extends(C, H);
  function C() {
    var G = H !== null && H.apply(this, arguments) || this;
    return G.type = "compound", G;
  }
  return C.prototype._updatePathDirty = function() {
    for (var G = this.shape.paths, U = this.shapeChanged(), K = 0; K < G.length; K++)
      U = U || G[K].shapeChanged();
    U && this.dirtyShape();
  }, C.prototype.beforeBrush = function() {
    this._updatePathDirty();
    for (var G = this.shape.paths || [], U = this.getGlobalScale(), K = 0; K < G.length; K++)
      G[K].path || G[K].createPathProxy(), G[K].path.setScale(U[0], U[1], G[K].segmentIgnoreThreshold);
  }, C.prototype.buildPath = function(G, U) {
    for (var K = U.paths || [], W = 0; W < K.length; W++)
      K[W].buildPath(G, K[W].shape, !0);
  }, C.prototype.afterBrush = function() {
    for (var G = this.shape.paths || [], U = 0; U < G.length; U++)
      G[U].pathUpdated();
  }, C.prototype.getBoundingRect = function() {
    return this._updatePathDirty.call(this), Path$1.prototype.getBoundingRect.call(this);
  }, C;
}(Path$1);
const CompoundPath$1 = CompoundPath;
var Gradient = function() {
  function H(C) {
    this.colorStops = C || [];
  }
  return H.prototype.addColorStop = function(C, G) {
    this.colorStops.push({
      offset: C,
      color: G
    });
  }, H;
}();
const Gradient$1 = Gradient;
var LinearGradient = function(H) {
  __extends(C, H);
  function C(G, U, K, W, Z, X) {
    var Q = H.call(this, Z) || this;
    return Q.x = G ?? 0, Q.y = U ?? 0, Q.x2 = K ?? 1, Q.y2 = W ?? 0, Q.type = "linear", Q.global = X || !1, Q;
  }
  return C;
}(Gradient$1);
const LinearGradient$1 = LinearGradient;
var RadialGradient = function(H) {
  __extends(C, H);
  function C(G, U, K, W, Z) {
    var X = H.call(this, W) || this;
    return X.x = G ?? 0.5, X.y = U ?? 0.5, X.r = K ?? 0.5, X.type = "radial", X.global = Z || !1, X;
  }
  return C;
}(Gradient$1);
const RadialGradient$1 = RadialGradient;
var extent = [0, 0], extent2 = [0, 0], minTv = new Point$1(), maxTv = new Point$1(), OrientedBoundingRect = function() {
  function H(C, G) {
    this._corners = [], this._axes = [], this._origin = [0, 0];
    for (var U = 0; U < 4; U++)
      this._corners[U] = new Point$1();
    for (var U = 0; U < 2; U++)
      this._axes[U] = new Point$1();
    C && this.fromBoundingRect(C, G);
  }
  return H.prototype.fromBoundingRect = function(C, G) {
    var U = this._corners, K = this._axes, W = C.x, Z = C.y, X = W + C.width, Q = Z + C.height;
    if (U[0].set(W, Z), U[1].set(X, Z), U[2].set(X, Q), U[3].set(W, Q), G)
      for (var ee = 0; ee < 4; ee++)
        U[ee].transform(G);
    Point$1.sub(K[0], U[1], U[0]), Point$1.sub(K[1], U[3], U[0]), K[0].normalize(), K[1].normalize();
    for (var ee = 0; ee < 2; ee++)
      this._origin[ee] = K[ee].dot(U[0]);
  }, H.prototype.intersect = function(C, G) {
    var U = !0, K = !G;
    return minTv.set(1 / 0, 1 / 0), maxTv.set(0, 0), !this._intersectCheckOneSide(this, C, minTv, maxTv, K, 1) && (U = !1, K) || !this._intersectCheckOneSide(C, this, minTv, maxTv, K, -1) && (U = !1, K) || K || Point$1.copy(G, U ? minTv : maxTv), U;
  }, H.prototype._intersectCheckOneSide = function(C, G, U, K, W, Z) {
    for (var X = !0, Q = 0; Q < 2; Q++) {
      var ee = this._axes[Q];
      if (this._getProjMinMaxOnAxis(Q, C._corners, extent), this._getProjMinMaxOnAxis(Q, G._corners, extent2), extent[1] < extent2[0] || extent[0] > extent2[1]) {
        if (X = !1, W)
          return X;
        var te = Math.abs(extent2[0] - extent[1]), re = Math.abs(extent[0] - extent2[1]);
        Math.min(te, re) > K.len() && (te < re ? Point$1.scale(K, ee, -te * Z) : Point$1.scale(K, ee, re * Z));
      } else if (U) {
        var te = Math.abs(extent2[0] - extent[1]), re = Math.abs(extent[0] - extent2[1]);
        Math.min(te, re) < U.len() && (te < re ? Point$1.scale(U, ee, te * Z) : Point$1.scale(U, ee, -re * Z));
      }
    }
    return X;
  }, H.prototype._getProjMinMaxOnAxis = function(C, G, U) {
    for (var K = this._axes[C], W = this._origin, Z = G[0].dot(K) + W[C], X = Z, Q = Z, ee = 1; ee < G.length; ee++) {
      var te = G[ee].dot(K) + W[C];
      X = Math.min(te, X), Q = Math.max(te, Q);
    }
    U[0] = X, U[1] = Q;
  }, H;
}();
const OrientedBoundingRect$1 = OrientedBoundingRect;
var m = [], IncrementalDisplayable = function(H) {
  __extends(C, H);
  function C() {
    var G = H !== null && H.apply(this, arguments) || this;
    return G.notClear = !0, G.incremental = !0, G._displayables = [], G._temporaryDisplayables = [], G._cursor = 0, G;
  }
  return C.prototype.traverse = function(G, U) {
    G.call(U, this);
  }, C.prototype.useStyle = function() {
    this.style = {};
  }, C.prototype.getCursor = function() {
    return this._cursor;
  }, C.prototype.innerAfterBrush = function() {
    this._cursor = this._displayables.length;
  }, C.prototype.clearDisplaybles = function() {
    this._displayables = [], this._temporaryDisplayables = [], this._cursor = 0, this.markRedraw(), this.notClear = !1;
  }, C.prototype.clearTemporalDisplayables = function() {
    this._temporaryDisplayables = [];
  }, C.prototype.addDisplayable = function(G, U) {
    U ? this._temporaryDisplayables.push(G) : this._displayables.push(G), this.markRedraw();
  }, C.prototype.addDisplayables = function(G, U) {
    U = U || !1;
    for (var K = 0; K < G.length; K++)
      this.addDisplayable(G[K], U);
  }, C.prototype.getDisplayables = function() {
    return this._displayables;
  }, C.prototype.getTemporalDisplayables = function() {
    return this._temporaryDisplayables;
  }, C.prototype.eachPendingDisplayable = function(G) {
    for (var U = this._cursor; U < this._displayables.length; U++)
      G && G(this._displayables[U]);
    for (var U = 0; U < this._temporaryDisplayables.length; U++)
      G && G(this._temporaryDisplayables[U]);
  }, C.prototype.update = function() {
    this.updateTransform();
    for (var G = this._cursor; G < this._displayables.length; G++) {
      var U = this._displayables[G];
      U.parent = this, U.update(), U.parent = null;
    }
    for (var G = 0; G < this._temporaryDisplayables.length; G++) {
      var U = this._temporaryDisplayables[G];
      U.parent = this, U.update(), U.parent = null;
    }
  }, C.prototype.getBoundingRect = function() {
    if (!this._rect) {
      for (var G = new BoundingRect$1(1 / 0, 1 / 0, -1 / 0, -1 / 0), U = 0; U < this._displayables.length; U++) {
        var K = this._displayables[U], W = K.getBoundingRect().clone();
        K.needLocalTransform() && W.applyTransform(K.getLocalTransform(m)), G.union(W);
      }
      this._rect = G;
    }
    return this._rect;
  }, C.prototype.contain = function(G, U) {
    var K = this.transformCoordToLocal(G, U), W = this.getBoundingRect();
    if (W.contain(K[0], K[1]))
      for (var Z = 0; Z < this._displayables.length; Z++) {
        var X = this._displayables[Z];
        if (X.contain(G, U))
          return !0;
      }
    return !1;
  }, C;
}(Displayable$1);
const IncrementalDisplayable$1 = IncrementalDisplayable;
var transitionStore = makeInner();
function getAnimationConfig(H, C, G, U, K) {
  var W;
  if (C && C.ecModel) {
    var Z = C.ecModel.getUpdatePayload();
    W = Z && Z.animation;
  }
  var X = C && C.isAnimationEnabled(), Q = H === "update";
  if (X) {
    var ee = void 0, te = void 0, re = void 0;
    U ? (ee = retrieve2(U.duration, 200), te = retrieve2(U.easing, "cubicOut"), re = 0) : (ee = C.getShallow(Q ? "animationDurationUpdate" : "animationDuration"), te = C.getShallow(Q ? "animationEasingUpdate" : "animationEasing"), re = C.getShallow(Q ? "animationDelayUpdate" : "animationDelay")), W && (W.duration != null && (ee = W.duration), W.easing != null && (te = W.easing), W.delay != null && (re = W.delay)), isFunction(re) && (re = re(G, K)), isFunction(ee) && (ee = ee(G));
    var ne = {
      duration: ee || 0,
      delay: re,
      easing: te
    };
    return ne;
  } else
    return null;
}
function animateOrSetProps(H, C, G, U, K, W, Z) {
  var X = !1, Q;
  isFunction(K) ? (Z = W, W = K, K = null) : isObject$3(K) && (W = K.cb, Z = K.during, X = K.isFrom, Q = K.removeOpt, K = K.dataIndex);
  var ee = H === "leave";
  ee || C.stopAnimation("leave");
  var te = getAnimationConfig(H, U, K, ee ? Q || {} : null, U && U.getAnimationDelayParams ? U.getAnimationDelayParams(C, K) : null);
  if (te && te.duration > 0) {
    var re = te.duration, ne = te.delay, ae = te.easing, ie = {
      duration: re,
      delay: ne || 0,
      easing: ae,
      done: W,
      force: !!W || !!Z,
      // Set to final state in update/init animation.
      // So the post processing based on the path shape can be done correctly.
      setToFinal: !ee,
      scope: H,
      during: Z
    };
    X ? C.animateFrom(G, ie) : C.animateTo(G, ie);
  } else
    C.stopAnimation(), !X && C.attr(G), Z && Z(1), W && W();
}
function updateProps$1(H, C, G, U, K, W) {
  animateOrSetProps("update", H, C, G, U, K, W);
}
function initProps(H, C, G, U, K, W) {
  animateOrSetProps("enter", H, C, G, U, K, W);
}
function isElementRemoved(H) {
  if (!H.__zr)
    return !0;
  for (var C = 0; C < H.animators.length; C++) {
    var G = H.animators[C];
    if (G.scope === "leave")
      return !0;
  }
  return !1;
}
function removeElement(H, C, G, U, K, W) {
  isElementRemoved(H) || animateOrSetProps("leave", H, C, G, U, K, W);
}
function fadeOutDisplayable(H, C, G, U) {
  H.removeTextContent(), H.removeTextGuideLine(), removeElement(H, {
    style: {
      opacity: 0
    }
  }, C, G, U);
}
function removeElementWithFadeOut(H, C, G) {
  function U() {
    H.parent && H.parent.remove(H);
  }
  H.isGroup ? H.traverse(function(K) {
    K.isGroup || fadeOutDisplayable(K, C, G, U);
  }) : fadeOutDisplayable(H, C, G, U);
}
function saveOldStyle(H) {
  transitionStore(H).oldStyle = H.style;
}
function getOldStyle(H) {
  return transitionStore(H).oldStyle;
}
var mathMax$6 = Math.max, mathMin$6 = Math.min, _customShapeMap = {};
function extendShape(H) {
  return Path$1.extend(H);
}
var extendPathFromString = extendFromString;
function extendPath(H, C) {
  return extendPathFromString(H, C);
}
function registerShape(H, C) {
  _customShapeMap[H] = C;
}
function getShapeClass(H) {
  if (_customShapeMap.hasOwnProperty(H))
    return _customShapeMap[H];
}
function makePath(H, C, G, U) {
  var K = createFromString(H, C);
  return G && (U === "center" && (G = centerGraphic(G, K.getBoundingRect())), resizePath(K, G)), K;
}
function makeImage(H, C, G) {
  var U = new ZRImage$1({
    style: {
      image: H,
      x: C.x,
      y: C.y,
      width: C.width,
      height: C.height
    },
    onload: function(K) {
      if (G === "center") {
        var W = {
          width: K.width,
          height: K.height
        };
        U.setStyle(centerGraphic(C, W));
      }
    }
  });
  return U;
}
function centerGraphic(H, C) {
  var G = C.width / C.height, U = H.height * G, K;
  U <= H.width ? K = H.height : (U = H.width, K = U / G);
  var W = H.x + H.width / 2, Z = H.y + H.height / 2;
  return {
    x: W - U / 2,
    y: Z - K / 2,
    width: U,
    height: K
  };
}
var mergePath = mergePath$1;
function resizePath(H, C) {
  if (H.applyTransform) {
    var G = H.getBoundingRect(), U = G.calculateTransform(C);
    H.applyTransform(U);
  }
}
function subPixelOptimizeLine(H, C) {
  return subPixelOptimizeLine$1(H, H, {
    lineWidth: C
  }), H;
}
function subPixelOptimizeRect(H) {
  return subPixelOptimizeRect$1(H.shape, H.shape, H.style), H;
}
var subPixelOptimize = subPixelOptimize$1;
function getTransform$1(H, C) {
  for (var G = identity([]); H && H !== C; )
    mul(G, H.getLocalTransform(), G), H = H.parent;
  return G;
}
function applyTransform(H, C, G) {
  return C && !isArrayLike(C) && (C = Transformable.getLocalTransform(C)), G && (C = invert([], C)), applyTransform$1([], H, C);
}
function transformDirection(H, C, G) {
  var U = C[4] === 0 || C[5] === 0 || C[0] === 0 ? 1 : Math.abs(2 * C[4] / C[0]), K = C[4] === 0 || C[5] === 0 || C[2] === 0 ? 1 : Math.abs(2 * C[4] / C[2]), W = [H === "left" ? -U : H === "right" ? U : 0, H === "top" ? -K : H === "bottom" ? K : 0];
  return W = applyTransform(W, C, G), Math.abs(W[0]) > Math.abs(W[1]) ? W[0] > 0 ? "right" : "left" : W[1] > 0 ? "bottom" : "top";
}
function isNotGroup(H) {
  return !H.isGroup;
}
function isPath$1(H) {
  return H.shape != null;
}
function groupTransition(H, C, G) {
  if (!H || !C)
    return;
  function U(Z) {
    var X = {};
    return Z.traverse(function(Q) {
      isNotGroup(Q) && Q.anid && (X[Q.anid] = Q);
    }), X;
  }
  function K(Z) {
    var X = {
      x: Z.x,
      y: Z.y,
      rotation: Z.rotation
    };
    return isPath$1(Z) && (X.shape = extend({}, Z.shape)), X;
  }
  var W = U(H);
  C.traverse(function(Z) {
    if (isNotGroup(Z) && Z.anid) {
      var X = W[Z.anid];
      if (X) {
        var Q = K(Z);
        Z.attr(K(X)), updateProps$1(Z, Q, G, getECData(Z).dataIndex);
      }
    }
  });
}
function clipPointsByRect(H, C) {
  return map$1(H, function(G) {
    var U = G[0];
    U = mathMax$6(U, C.x), U = mathMin$6(U, C.x + C.width);
    var K = G[1];
    return K = mathMax$6(K, C.y), K = mathMin$6(K, C.y + C.height), [U, K];
  });
}
function clipRectByRect(H, C) {
  var G = mathMax$6(H.x, C.x), U = mathMin$6(H.x + H.width, C.x + C.width), K = mathMax$6(H.y, C.y), W = mathMin$6(H.y + H.height, C.y + C.height);
  if (U >= G && W >= K)
    return {
      x: G,
      y: K,
      width: U - G,
      height: W - K
    };
}
function createIcon(H, C, G) {
  var U = extend({
    rectHover: !0
  }, C), K = U.style = {
    strokeNoScale: !0
  };
  if (G = G || {
    x: -1,
    y: -1,
    width: 2,
    height: 2
  }, H)
    return H.indexOf("image://") === 0 ? (K.image = H.slice(8), defaults(K, G), new ZRImage$1(U)) : makePath(H.replace("path://", ""), U, G, "center");
}
function linePolygonIntersect(H, C, G, U, K) {
  for (var W = 0, Z = K[K.length - 1]; W < K.length; W++) {
    var X = K[W];
    if (lineLineIntersect$1(H, C, G, U, X[0], X[1], Z[0], Z[1]))
      return !0;
    Z = X;
  }
}
function lineLineIntersect$1(H, C, G, U, K, W, Z, X) {
  var Q = G - H, ee = U - C, te = Z - K, re = X - W, ne = crossProduct2d$1(te, re, Q, ee);
  if (nearZero(ne))
    return !1;
  var ae = H - K, ie = C - W, se = crossProduct2d$1(ae, ie, Q, ee) / ne;
  if (se < 0 || se > 1)
    return !1;
  var oe = crossProduct2d$1(ae, ie, te, re) / ne;
  return !(oe < 0 || oe > 1);
}
function crossProduct2d$1(H, C, G, U) {
  return H * U - G * C;
}
function nearZero(H) {
  return H <= 1e-6 && H >= -1e-6;
}
function setTooltipConfig(H) {
  var C = H.itemTooltipOption, G = H.componentModel, U = H.itemName, K = isString(C) ? {
    formatter: C
  } : C, W = G.mainType, Z = G.componentIndex, X = {
    componentType: W,
    name: U,
    $vars: ["name"]
  };
  X[W + "Index"] = Z;
  var Q = H.formatterParamsExtra;
  Q && each$f(keys(Q), function(te) {
    hasOwn(X, te) || (X[te] = Q[te], X.$vars.push(te));
  });
  var ee = getECData(H.el);
  ee.componentMainType = W, ee.componentIndex = Z, ee.tooltipConfig = {
    name: U,
    option: defaults({
      content: U,
      formatterParams: X
    }, K)
  };
}
function traverseElement(H, C) {
  var G;
  H.isGroup && (G = C(H)), G || H.traverse(C);
}
function traverseElements(H, C) {
  if (H)
    if (isArray$1(H))
      for (var G = 0; G < H.length; G++)
        traverseElement(H[G], C);
    else
      traverseElement(H, C);
}
registerShape("circle", Circle$1);
registerShape("ellipse", Ellipse$1);
registerShape("sector", Sector$1);
registerShape("ring", Ring$1);
registerShape("polygon", Polygon$1);
registerShape("polyline", Polyline$3);
registerShape("rect", Rect$3);
registerShape("line", Line$3);
registerShape("bezierCurve", BezierCurve$1);
registerShape("arc", Arc$1);
const graphic = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Arc: Arc$1,
  BezierCurve: BezierCurve$1,
  BoundingRect: BoundingRect$1,
  Circle: Circle$1,
  CompoundPath: CompoundPath$1,
  Ellipse: Ellipse$1,
  Group: Group$4,
  Image: ZRImage$1,
  IncrementalDisplayable: IncrementalDisplayable$1,
  Line: Line$3,
  LinearGradient: LinearGradient$1,
  OrientedBoundingRect: OrientedBoundingRect$1,
  Path: Path$1,
  Point: Point$1,
  Polygon: Polygon$1,
  Polyline: Polyline$3,
  RadialGradient: RadialGradient$1,
  Rect: Rect$3,
  Ring: Ring$1,
  Sector: Sector$1,
  Text: ZRText$1,
  applyTransform,
  clipPointsByRect,
  clipRectByRect,
  createIcon,
  extendPath,
  extendShape,
  getShapeClass,
  getTransform: getTransform$1,
  groupTransition,
  initProps,
  isElementRemoved,
  lineLineIntersect: lineLineIntersect$1,
  linePolygonIntersect,
  makeImage,
  makePath,
  mergePath,
  registerShape,
  removeElement,
  removeElementWithFadeOut,
  resizePath,
  setTooltipConfig,
  subPixelOptimize,
  subPixelOptimizeLine,
  subPixelOptimizeRect,
  transformDirection,
  traverseElements,
  updateProps: updateProps$1
}, Symbol.toStringTag, { value: "Module" }));
var EMPTY_OBJ = {};
function setLabelText(H, C) {
  for (var G = 0; G < SPECIAL_STATES.length; G++) {
    var U = SPECIAL_STATES[G], K = C[U], W = H.ensureState(U);
    W.style = W.style || {}, W.style.text = K;
  }
  var Z = H.currentStates.slice();
  H.clearStates(!0), H.setStyle({
    text: C.normal
  }), H.useStates(Z, !0);
}
function getLabelText(H, C, G) {
  var U = H.labelFetcher, K = H.labelDataIndex, W = H.labelDimIndex, Z = C.normal, X;
  U && (X = U.getFormattedLabel(K, "normal", null, W, Z && Z.get("formatter"), G != null ? {
    interpolatedValue: G
  } : null)), X == null && (X = isFunction(H.defaultText) ? H.defaultText(K, H, G) : H.defaultText);
  for (var Q = {
    normal: X
  }, ee = 0; ee < SPECIAL_STATES.length; ee++) {
    var te = SPECIAL_STATES[ee], re = C[te];
    Q[te] = retrieve2(U ? U.getFormattedLabel(K, te, null, W, re && re.get("formatter")) : null, X);
  }
  return Q;
}
function setLabelStyle(H, C, G, U) {
  G = G || EMPTY_OBJ;
  for (var K = H instanceof ZRText$1, W = !1, Z = 0; Z < DISPLAY_STATES.length; Z++) {
    var X = C[DISPLAY_STATES[Z]];
    if (X && X.getShallow("show")) {
      W = !0;
      break;
    }
  }
  var Q = K ? H : H.getTextContent();
  if (W) {
    K || (Q || (Q = new ZRText$1(), H.setTextContent(Q)), H.stateProxy && (Q.stateProxy = H.stateProxy));
    var ee = getLabelText(G, C), te = C.normal, re = !!te.getShallow("show"), ne = createTextStyle(te, U && U.normal, G, !1, !K);
    ne.text = ee.normal, K || H.setTextConfig(createTextConfig(te, G, !1));
    for (var Z = 0; Z < SPECIAL_STATES.length; Z++) {
      var ae = SPECIAL_STATES[Z], X = C[ae];
      if (X) {
        var ie = Q.ensureState(ae), se = !!retrieve2(X.getShallow("show"), re);
        if (se !== re && (ie.ignore = !se), ie.style = createTextStyle(X, U && U[ae], G, !0, !K), ie.style.text = ee[ae], !K) {
          var oe = H.ensureState(ae);
          oe.textConfig = createTextConfig(X, G, !0);
        }
      }
    }
    Q.silent = !!te.getShallow("silent"), Q.style.x != null && (ne.x = Q.style.x), Q.style.y != null && (ne.y = Q.style.y), Q.ignore = !re, Q.useStyle(ne), Q.dirty(), G.enableTextSetter && (labelInner(Q).setLabelText = function(le) {
      var ue = getLabelText(G, C, le);
      setLabelText(Q, ue);
    });
  } else
    Q && (Q.ignore = !0);
  H.dirty();
}
function getLabelStatesModels(H, C) {
  C = C || "label";
  for (var G = {
    normal: H.getModel(C)
  }, U = 0; U < SPECIAL_STATES.length; U++) {
    var K = SPECIAL_STATES[U];
    G[K] = H.getModel([K, C]);
  }
  return G;
}
function createTextStyle(H, C, G, U, K) {
  var W = {};
  return setTextStyleCommon(W, H, G, U, K), C && extend(W, C), W;
}
function createTextConfig(H, C, G) {
  C = C || {};
  var U = {}, K, W = H.getShallow("rotate"), Z = retrieve2(H.getShallow("distance"), G ? null : 5), X = H.getShallow("offset");
  return K = H.getShallow("position") || (G ? null : "inside"), K === "outside" && (K = C.defaultOutsidePosition || "top"), K != null && (U.position = K), X != null && (U.offset = X), W != null && (W *= Math.PI / 180, U.rotation = W), Z != null && (U.distance = Z), U.outsideFill = H.get("color") === "inherit" ? C.inheritColor || null : "auto", U;
}
function setTextStyleCommon(H, C, G, U, K) {
  G = G || EMPTY_OBJ;
  var W = C.ecModel, Z = W && W.option.textStyle, X = getRichItemNames(C), Q;
  if (X) {
    Q = {};
    for (var ee in X)
      if (X.hasOwnProperty(ee)) {
        var te = C.getModel(["rich", ee]);
        setTokenTextStyle(Q[ee] = {}, te, Z, G, U, K, !1, !0);
      }
  }
  Q && (H.rich = Q);
  var re = C.get("overflow");
  re && (H.overflow = re);
  var ne = C.get("minMargin");
  ne != null && (H.margin = ne), setTokenTextStyle(H, C, Z, G, U, K, !0, !1);
}
function getRichItemNames(H) {
  for (var C; H && H !== H.ecModel; ) {
    var G = (H.option || EMPTY_OBJ).rich;
    if (G) {
      C = C || {};
      for (var U = keys(G), K = 0; K < U.length; K++) {
        var W = U[K];
        C[W] = 1;
      }
    }
    H = H.parentModel;
  }
  return C;
}
var TEXT_PROPS_WITH_GLOBAL = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "textShadowColor", "textShadowBlur", "textShadowOffsetX", "textShadowOffsetY"], TEXT_PROPS_SELF = ["align", "lineHeight", "width", "height", "tag", "verticalAlign"], TEXT_PROPS_BOX = ["padding", "borderWidth", "borderRadius", "borderDashOffset", "backgroundColor", "borderColor", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"];
function setTokenTextStyle(H, C, G, U, K, W, Z, X) {
  G = !K && G || EMPTY_OBJ;
  var Q = U && U.inheritColor, ee = C.getShallow("color"), te = C.getShallow("textBorderColor"), re = retrieve2(C.getShallow("opacity"), G.opacity);
  (ee === "inherit" || ee === "auto") && (process.env.NODE_ENV !== "production" && ee === "auto" && deprecateReplaceLog("color: 'auto'", "color: 'inherit'"), Q ? ee = Q : ee = null), (te === "inherit" || te === "auto") && (process.env.NODE_ENV !== "production" && te === "auto" && deprecateReplaceLog("color: 'auto'", "color: 'inherit'"), Q ? te = Q : te = null), W || (ee = ee || G.color, te = te || G.textBorderColor), ee != null && (H.fill = ee), te != null && (H.stroke = te);
  var ne = retrieve2(C.getShallow("textBorderWidth"), G.textBorderWidth);
  ne != null && (H.lineWidth = ne);
  var ae = retrieve2(C.getShallow("textBorderType"), G.textBorderType);
  ae != null && (H.lineDash = ae);
  var ie = retrieve2(C.getShallow("textBorderDashOffset"), G.textBorderDashOffset);
  ie != null && (H.lineDashOffset = ie), !K && re == null && !X && (re = U && U.defaultOpacity), re != null && (H.opacity = re), !K && !W && H.fill == null && U.inheritColor && (H.fill = U.inheritColor);
  for (var se = 0; se < TEXT_PROPS_WITH_GLOBAL.length; se++) {
    var oe = TEXT_PROPS_WITH_GLOBAL[se], le = retrieve2(C.getShallow(oe), G[oe]);
    le != null && (H[oe] = le);
  }
  for (var se = 0; se < TEXT_PROPS_SELF.length; se++) {
    var oe = TEXT_PROPS_SELF[se], le = C.getShallow(oe);
    le != null && (H[oe] = le);
  }
  if (H.verticalAlign == null) {
    var ue = C.getShallow("baseline");
    ue != null && (H.verticalAlign = ue);
  }
  if (!Z || !U.disableBox) {
    for (var se = 0; se < TEXT_PROPS_BOX.length; se++) {
      var oe = TEXT_PROPS_BOX[se], le = C.getShallow(oe);
      le != null && (H[oe] = le);
    }
    var ce = C.getShallow("borderType");
    ce != null && (H.borderDash = ce), (H.backgroundColor === "auto" || H.backgroundColor === "inherit") && Q && (process.env.NODE_ENV !== "production" && H.backgroundColor === "auto" && deprecateReplaceLog("backgroundColor: 'auto'", "backgroundColor: 'inherit'"), H.backgroundColor = Q), (H.borderColor === "auto" || H.borderColor === "inherit") && Q && (process.env.NODE_ENV !== "production" && H.borderColor === "auto" && deprecateReplaceLog("borderColor: 'auto'", "borderColor: 'inherit'"), H.borderColor = Q);
  }
}
function getFont(H, C) {
  var G = C && C.getModel("textStyle");
  return trim$1([
    // FIXME in node-canvas fontWeight is before fontStyle
    H.fontStyle || G && G.getShallow("fontStyle") || "",
    H.fontWeight || G && G.getShallow("fontWeight") || "",
    (H.fontSize || G && G.getShallow("fontSize") || 12) + "px",
    H.fontFamily || G && G.getShallow("fontFamily") || "sans-serif"
  ].join(" "));
}
var labelInner = makeInner();
function setLabelValueAnimation(H, C, G, U) {
  if (H) {
    var K = labelInner(H);
    K.prevValue = K.value, K.value = G;
    var W = C.normal;
    K.valueAnimation = W.get("valueAnimation"), K.valueAnimation && (K.precision = W.get("precision"), K.defaultInterpolatedText = U, K.statesModels = C);
  }
}
function animateLabelValue(H, C, G, U, K) {
  var W = labelInner(H);
  if (!W.valueAnimation || W.prevValue === W.value)
    return;
  var Z = W.defaultInterpolatedText, X = retrieve2(W.interpolatedValue, W.prevValue), Q = W.value;
  function ee(te) {
    var re = interpolateRawValues(G, W.precision, X, Q, te);
    W.interpolatedValue = te === 1 ? null : re;
    var ne = getLabelText({
      labelDataIndex: C,
      labelFetcher: K,
      defaultText: Z ? Z(re) : re + ""
    }, W.statesModels, re);
    setLabelText(H, ne);
  }
  H.percent = 0, (W.prevValue == null ? initProps : updateProps$1)(H, {
    // percent is used to prevent animation from being aborted #15916
    percent: 1
  }, U, C, null, ee);
}
var PATH_COLOR = ["textStyle", "color"], textStyleParams = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "padding", "lineHeight", "rich", "width", "height", "overflow"], tmpText = new ZRText$1(), TextStyleMixin = (
  /** @class */
  function() {
    function H() {
    }
    return H.prototype.getTextColor = function(C) {
      var G = this.ecModel;
      return this.getShallow("color") || (!C && G ? G.get(PATH_COLOR) : null);
    }, H.prototype.getFont = function() {
      return getFont({
        fontStyle: this.getShallow("fontStyle"),
        fontWeight: this.getShallow("fontWeight"),
        fontSize: this.getShallow("fontSize"),
        fontFamily: this.getShallow("fontFamily")
      }, this.ecModel);
    }, H.prototype.getTextRect = function(C) {
      for (var G = {
        text: C,
        verticalAlign: this.getShallow("verticalAlign") || this.getShallow("baseline")
      }, U = 0; U < textStyleParams.length; U++)
        G[textStyleParams[U]] = this.getShallow(textStyleParams[U]);
      return tmpText.useStyle(G), tmpText.update(), tmpText.getBoundingRect();
    }, H;
  }()
);
const TextStyleMixin$1 = TextStyleMixin;
var LINE_STYLE_KEY_MAP = [
  ["lineWidth", "width"],
  ["stroke", "color"],
  ["opacity"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["shadowColor"],
  ["lineDash", "type"],
  ["lineDashOffset", "dashOffset"],
  ["lineCap", "cap"],
  ["lineJoin", "join"],
  ["miterLimit"]
  // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
  // So do not transfer decal directly.
], getLineStyle = makeStyleMapper(LINE_STYLE_KEY_MAP), LineStyleMixin = (
  /** @class */
  function() {
    function H() {
    }
    return H.prototype.getLineStyle = function(C) {
      return getLineStyle(this, C);
    }, H;
  }()
), ITEM_STYLE_KEY_MAP = [
  ["fill", "color"],
  ["stroke", "borderColor"],
  ["lineWidth", "borderWidth"],
  ["opacity"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["shadowColor"],
  ["lineDash", "borderType"],
  ["lineDashOffset", "borderDashOffset"],
  ["lineCap", "borderCap"],
  ["lineJoin", "borderJoin"],
  ["miterLimit", "borderMiterLimit"]
  // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
  // So do not transfer decal directly.
], getItemStyle = makeStyleMapper(ITEM_STYLE_KEY_MAP), ItemStyleMixin = (
  /** @class */
  function() {
    function H() {
    }
    return H.prototype.getItemStyle = function(C, G) {
      return getItemStyle(this, C, G);
    }, H;
  }()
), Model = (
  /** @class */
  function() {
    function H(C, G, U) {
      this.parentModel = G, this.ecModel = U, this.option = C;
    }
    return H.prototype.init = function(C, G, U) {
    }, H.prototype.mergeOption = function(C, G) {
      merge(this.option, C, !0);
    }, H.prototype.get = function(C, G) {
      return C == null ? this.option : this._doGet(this.parsePath(C), !G && this.parentModel);
    }, H.prototype.getShallow = function(C, G) {
      var U = this.option, K = U == null ? U : U[C];
      if (K == null && !G) {
        var W = this.parentModel;
        W && (K = W.getShallow(C));
      }
      return K;
    }, H.prototype.getModel = function(C, G) {
      var U = C != null, K = U ? this.parsePath(C) : null, W = U ? this._doGet(K) : this.option;
      return G = G || this.parentModel && this.parentModel.getModel(this.resolveParentPath(K)), new H(W, G, this.ecModel);
    }, H.prototype.isEmpty = function() {
      return this.option == null;
    }, H.prototype.restoreData = function() {
    }, H.prototype.clone = function() {
      var C = this.constructor;
      return new C(clone$4(this.option));
    }, H.prototype.parsePath = function(C) {
      return typeof C == "string" ? C.split(".") : C;
    }, H.prototype.resolveParentPath = function(C) {
      return C;
    }, H.prototype.isAnimationEnabled = function() {
      if (!env$1.node && this.option) {
        if (this.option.animation != null)
          return !!this.option.animation;
        if (this.parentModel)
          return this.parentModel.isAnimationEnabled();
      }
    }, H.prototype._doGet = function(C, G) {
      var U = this.option;
      if (!C)
        return U;
      for (var K = 0; K < C.length && !(C[K] && (U = U && typeof U == "object" ? U[C[K]] : null, U == null)); K++)
        ;
      return U == null && G && (U = G._doGet(this.resolveParentPath(C), G.parentModel)), U;
    }, H;
  }()
);
enableClassExtend(Model);
enableClassCheck(Model);
mixin(Model, LineStyleMixin);
mixin(Model, ItemStyleMixin);
mixin(Model, AreaStyleMixin);
mixin(Model, TextStyleMixin$1);
const Model$1 = Model;
var base = Math.round(Math.random() * 10);
function getUID(H) {
  return [H || "", base++].join("_");
}
function enableSubTypeDefaulter(H) {
  var C = {};
  H.registerSubTypeDefaulter = function(G, U) {
    var K = parseClassType(G);
    C[K.main] = U;
  }, H.determineSubType = function(G, U) {
    var K = U.type;
    if (!K) {
      var W = parseClassType(G).main;
      H.hasSubTypes(G) && C[W] && (K = C[W](U));
    }
    return K;
  };
}
function enableTopologicalTravel(H, C) {
  H.topologicalTravel = function(W, Z, X, Q) {
    if (!W.length)
      return;
    var ee = G(Z), te = ee.graph, re = ee.noEntryList, ne = {};
    for (each$f(W, function(ue) {
      ne[ue] = !0;
    }); re.length; ) {
      var ae = re.pop(), ie = te[ae], se = !!ne[ae];
      se && (X.call(Q, ae, ie.originalDeps.slice()), delete ne[ae]), each$f(ie.successor, se ? le : oe);
    }
    each$f(ne, function() {
      var ue = "";
      throw process.env.NODE_ENV !== "production" && (ue = makePrintable("Circular dependency may exists: ", ne, W, Z)), new Error(ue);
    });
    function oe(ue) {
      te[ue].entryCount--, te[ue].entryCount === 0 && re.push(ue);
    }
    function le(ue) {
      ne[ue] = !0, oe(ue);
    }
  };
  function G(W) {
    var Z = {}, X = [];
    return each$f(W, function(Q) {
      var ee = U(Z, Q), te = ee.originalDeps = C(Q), re = K(te, W);
      ee.entryCount = re.length, ee.entryCount === 0 && X.push(Q), each$f(re, function(ne) {
        indexOf(ee.predecessor, ne) < 0 && ee.predecessor.push(ne);
        var ae = U(Z, ne);
        indexOf(ae.successor, ne) < 0 && ae.successor.push(Q);
      });
    }), {
      graph: Z,
      noEntryList: X
    };
  }
  function U(W, Z) {
    return W[Z] || (W[Z] = {
      predecessor: [],
      successor: []
    }), W[Z];
  }
  function K(W, Z) {
    var X = [];
    return each$f(W, function(Q) {
      indexOf(Z, Q) >= 0 && X.push(Q);
    }), X;
  }
}
function inheritDefaultOption(H, C) {
  return merge(merge({}, H, !0), C, !0);
}
const langEN = {
  time: {
    month: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    monthAbbr: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    dayOfWeek: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    dayOfWeekAbbr: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
  },
  legend: {
    selector: {
      all: "All",
      inverse: "Inv"
    }
  },
  toolbox: {
    brush: {
      title: {
        rect: "Box Select",
        polygon: "Lasso Select",
        lineX: "Horizontally Select",
        lineY: "Vertically Select",
        keep: "Keep Selections",
        clear: "Clear Selections"
      }
    },
    dataView: {
      title: "Data View",
      lang: ["Data View", "Close", "Refresh"]
    },
    dataZoom: {
      title: {
        zoom: "Zoom",
        back: "Zoom Reset"
      }
    },
    magicType: {
      title: {
        line: "Switch to Line Chart",
        bar: "Switch to Bar Chart",
        stack: "Stack",
        tiled: "Tile"
      }
    },
    restore: {
      title: "Restore"
    },
    saveAsImage: {
      title: "Save as Image",
      lang: ["Right Click to Save Image"]
    }
  },
  series: {
    typeNames: {
      pie: "Pie chart",
      bar: "Bar chart",
      line: "Line chart",
      scatter: "Scatter plot",
      effectScatter: "Ripple scatter plot",
      radar: "Radar chart",
      tree: "Tree",
      treemap: "Treemap",
      boxplot: "Boxplot",
      candlestick: "Candlestick",
      k: "K line chart",
      heatmap: "Heat map",
      map: "Map",
      parallel: "Parallel coordinate map",
      lines: "Line graph",
      graph: "Relationship graph",
      sankey: "Sankey diagram",
      funnel: "Funnel chart",
      gauge: "Gauge",
      pictorialBar: "Pictorial bar",
      themeRiver: "Theme River Map",
      sunburst: "Sunburst"
    }
  },
  aria: {
    general: {
      withTitle: 'This is a chart about "{title}"',
      withoutTitle: "This is a chart"
    },
    series: {
      single: {
        prefix: "",
        withName: " with type {seriesType} named {seriesName}.",
        withoutName: " with type {seriesType}."
      },
      multiple: {
        prefix: ". It consists of {seriesCount} series count.",
        withName: " The {seriesId} series is a {seriesType} representing {seriesName}.",
        withoutName: " The {seriesId} series is a {seriesType}.",
        separator: {
          middle: "",
          end: ""
        }
      }
    },
    data: {
      allData: "The data is as follows: ",
      partialData: "The first {displayCnt} items are: ",
      withName: "the data for {name} is {value}",
      withoutName: "{value}",
      separator: {
        middle: ", ",
        end: ". "
      }
    }
  }
}, langZH = {
  time: {
    month: ["一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月"],
    monthAbbr: ["1月", "2月", "3月", "4月", "5月", "6月", "7月", "8月", "9月", "10月", "11月", "12月"],
    dayOfWeek: ["星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六"],
    dayOfWeekAbbr: ["日", "一", "二", "三", "四", "五", "六"]
  },
  legend: {
    selector: {
      all: "全选",
      inverse: "反选"
    }
  },
  toolbox: {
    brush: {
      title: {
        rect: "矩形选择",
        polygon: "圈选",
        lineX: "横向选择",
        lineY: "纵向选择",
        keep: "保持选择",
        clear: "清除选择"
      }
    },
    dataView: {
      title: "数据视图",
      lang: ["数据视图", "关闭", "刷新"]
    },
    dataZoom: {
      title: {
        zoom: "区域缩放",
        back: "区域缩放还原"
      }
    },
    magicType: {
      title: {
        line: "切换为折线图",
        bar: "切换为柱状图",
        stack: "切换为堆叠",
        tiled: "切换为平铺"
      }
    },
    restore: {
      title: "还原"
    },
    saveAsImage: {
      title: "保存为图片",
      lang: ["右键另存为图片"]
    }
  },
  series: {
    typeNames: {
      pie: "饼图",
      bar: "柱状图",
      line: "折线图",
      scatter: "散点图",
      effectScatter: "涟漪散点图",
      radar: "雷达图",
      tree: "树图",
      treemap: "矩形树图",
      boxplot: "箱型图",
      candlestick: "K线图",
      k: "K线图",
      heatmap: "热力图",
      map: "地图",
      parallel: "平行坐标图",
      lines: "线图",
      graph: "关系图",
      sankey: "桑基图",
      funnel: "漏斗图",
      gauge: "仪表盘图",
      pictorialBar: "象形柱图",
      themeRiver: "主题河流图",
      sunburst: "旭日图"
    }
  },
  aria: {
    general: {
      withTitle: "这是一个关于“{title}”的图表。",
      withoutTitle: "这是一个图表，"
    },
    series: {
      single: {
        prefix: "",
        withName: "图表类型是{seriesType}，表示{seriesName}。",
        withoutName: "图表类型是{seriesType}。"
      },
      multiple: {
        prefix: "它由{seriesCount}个图表系列组成。",
        withName: "第{seriesId}个系列是一个表示{seriesName}的{seriesType}，",
        withoutName: "第{seriesId}个系列是一个{seriesType}，",
        separator: {
          middle: "；",
          end: "。"
        }
      }
    },
    data: {
      allData: "其数据是——",
      partialData: "其中，前{displayCnt}项是——",
      withName: "{name}的数据是{value}",
      withoutName: "{value}",
      separator: {
        middle: "，",
        end: ""
      }
    }
  }
};
var LOCALE_ZH = "ZH", LOCALE_EN = "EN", DEFAULT_LOCALE = LOCALE_EN, localeStorage = {}, localeModels = {}, SYSTEM_LANG = env$1.domSupported ? function() {
  var H = (
    /* eslint-disable-next-line */
    (document.documentElement.lang || navigator.language || navigator.browserLanguage).toUpperCase()
  );
  return H.indexOf(LOCALE_ZH) > -1 ? LOCALE_ZH : DEFAULT_LOCALE;
}() : DEFAULT_LOCALE;
function registerLocale(H, C) {
  H = H.toUpperCase(), localeModels[H] = new Model$1(C), localeStorage[H] = C;
}
function createLocaleObject(H) {
  if (isString(H)) {
    var C = localeStorage[H.toUpperCase()] || {};
    return H === LOCALE_ZH || H === LOCALE_EN ? clone$4(C) : merge(clone$4(C), clone$4(localeStorage[DEFAULT_LOCALE]), !1);
  } else
    return merge(clone$4(H), clone$4(localeStorage[DEFAULT_LOCALE]), !1);
}
function getLocaleModel(H) {
  return localeModels[H];
}
function getDefaultLocaleModel() {
  return localeModels[DEFAULT_LOCALE];
}
registerLocale(LOCALE_EN, langEN);
registerLocale(LOCALE_ZH, langZH);
var ONE_SECOND = 1e3, ONE_MINUTE = ONE_SECOND * 60, ONE_HOUR = ONE_MINUTE * 60, ONE_DAY = ONE_HOUR * 24, ONE_YEAR = ONE_DAY * 365, defaultLeveledFormatter = {
  year: "{yyyy}",
  month: "{MMM}",
  day: "{d}",
  hour: "{HH}:{mm}",
  minute: "{HH}:{mm}",
  second: "{HH}:{mm}:{ss}",
  millisecond: "{HH}:{mm}:{ss} {SSS}",
  none: "{yyyy}-{MM}-{dd} {HH}:{mm}:{ss} {SSS}"
}, fullDayFormatter = "{yyyy}-{MM}-{dd}", fullLeveledFormatter = {
  year: "{yyyy}",
  month: "{yyyy}-{MM}",
  day: fullDayFormatter,
  hour: fullDayFormatter + " " + defaultLeveledFormatter.hour,
  minute: fullDayFormatter + " " + defaultLeveledFormatter.minute,
  second: fullDayFormatter + " " + defaultLeveledFormatter.second,
  millisecond: defaultLeveledFormatter.none
}, primaryTimeUnits = ["year", "month", "day", "hour", "minute", "second", "millisecond"], timeUnits = ["year", "half-year", "quarter", "month", "week", "half-week", "day", "half-day", "quarter-day", "hour", "minute", "second", "millisecond"];
function pad(H, C) {
  return H += "", "0000".substr(0, C - H.length) + H;
}
function getPrimaryTimeUnit(H) {
  switch (H) {
    case "half-year":
    case "quarter":
      return "month";
    case "week":
    case "half-week":
      return "day";
    case "half-day":
    case "quarter-day":
      return "hour";
    default:
      return H;
  }
}
function isPrimaryTimeUnit(H) {
  return H === getPrimaryTimeUnit(H);
}
function getDefaultFormatPrecisionOfInterval(H) {
  switch (H) {
    case "year":
    case "month":
      return "day";
    case "millisecond":
      return "millisecond";
    default:
      return "second";
  }
}
function format(H, C, G, U) {
  var K = parseDate(H), W = K[fullYearGetterName(G)](), Z = K[monthGetterName(G)]() + 1, X = Math.floor((Z - 1) / 3) + 1, Q = K[dateGetterName(G)](), ee = K["get" + (G ? "UTC" : "") + "Day"](), te = K[hoursGetterName(G)](), re = (te - 1) % 12 + 1, ne = K[minutesGetterName(G)](), ae = K[secondsGetterName(G)](), ie = K[millisecondsGetterName(G)](), se = U instanceof Model$1 ? U : getLocaleModel(U || SYSTEM_LANG) || getDefaultLocaleModel(), oe = se.getModel("time"), le = oe.get("month"), ue = oe.get("monthAbbr"), ce = oe.get("dayOfWeek"), de = oe.get("dayOfWeekAbbr");
  return (C || "").replace(/{yyyy}/g, W + "").replace(/{yy}/g, W % 100 + "").replace(/{Q}/g, X + "").replace(/{MMMM}/g, le[Z - 1]).replace(/{MMM}/g, ue[Z - 1]).replace(/{MM}/g, pad(Z, 2)).replace(/{M}/g, Z + "").replace(/{dd}/g, pad(Q, 2)).replace(/{d}/g, Q + "").replace(/{eeee}/g, ce[ee]).replace(/{ee}/g, de[ee]).replace(/{e}/g, ee + "").replace(/{HH}/g, pad(te, 2)).replace(/{H}/g, te + "").replace(/{hh}/g, pad(re + "", 2)).replace(/{h}/g, re + "").replace(/{mm}/g, pad(ne, 2)).replace(/{m}/g, ne + "").replace(/{ss}/g, pad(ae, 2)).replace(/{s}/g, ae + "").replace(/{SSS}/g, pad(ie, 3)).replace(/{S}/g, ie + "");
}
function leveledFormat(H, C, G, U, K) {
  var W = null;
  if (isString(G))
    W = G;
  else if (isFunction(G))
    W = G(H.value, C, {
      level: H.level
    });
  else {
    var Z = extend({}, defaultLeveledFormatter);
    if (H.level > 0)
      for (var X = 0; X < primaryTimeUnits.length; ++X)
        Z[primaryTimeUnits[X]] = "{primary|" + Z[primaryTimeUnits[X]] + "}";
    var Q = G ? G.inherit === !1 ? G : defaults(G, Z) : Z, ee = getUnitFromValue(H.value, K);
    if (Q[ee])
      W = Q[ee];
    else if (Q.inherit) {
      for (var te = timeUnits.indexOf(ee), X = te - 1; X >= 0; --X)
        if (Q[ee]) {
          W = Q[ee];
          break;
        }
      W = W || Z.none;
    }
    if (isArray$1(W)) {
      var re = H.level == null ? 0 : H.level >= 0 ? H.level : W.length + H.level;
      re = Math.min(re, W.length - 1), W = W[re];
    }
  }
  return format(new Date(H.value), W, K, U);
}
function getUnitFromValue(H, C) {
  var G = parseDate(H), U = G[monthGetterName(C)]() + 1, K = G[dateGetterName(C)](), W = G[hoursGetterName(C)](), Z = G[minutesGetterName(C)](), X = G[secondsGetterName(C)](), Q = G[millisecondsGetterName(C)](), ee = Q === 0, te = ee && X === 0, re = te && Z === 0, ne = re && W === 0, ae = ne && K === 1, ie = ae && U === 1;
  return ie ? "year" : ae ? "month" : ne ? "day" : re ? "hour" : te ? "minute" : ee ? "second" : "millisecond";
}
function getUnitValue(H, C, G) {
  var U = isNumber(H) ? parseDate(H) : H;
  switch (C = C || getUnitFromValue(H, G), C) {
    case "year":
      return U[fullYearGetterName(G)]();
    case "half-year":
      return U[monthGetterName(G)]() >= 6 ? 1 : 0;
    case "quarter":
      return Math.floor((U[monthGetterName(G)]() + 1) / 4);
    case "month":
      return U[monthGetterName(G)]();
    case "day":
      return U[dateGetterName(G)]();
    case "half-day":
      return U[hoursGetterName(G)]() / 24;
    case "hour":
      return U[hoursGetterName(G)]();
    case "minute":
      return U[minutesGetterName(G)]();
    case "second":
      return U[secondsGetterName(G)]();
    case "millisecond":
      return U[millisecondsGetterName(G)]();
  }
}
function fullYearGetterName(H) {
  return H ? "getUTCFullYear" : "getFullYear";
}
function monthGetterName(H) {
  return H ? "getUTCMonth" : "getMonth";
}
function dateGetterName(H) {
  return H ? "getUTCDate" : "getDate";
}
function hoursGetterName(H) {
  return H ? "getUTCHours" : "getHours";
}
function minutesGetterName(H) {
  return H ? "getUTCMinutes" : "getMinutes";
}
function secondsGetterName(H) {
  return H ? "getUTCSeconds" : "getSeconds";
}
function millisecondsGetterName(H) {
  return H ? "getUTCMilliseconds" : "getMilliseconds";
}
function fullYearSetterName(H) {
  return H ? "setUTCFullYear" : "setFullYear";
}
function monthSetterName(H) {
  return H ? "setUTCMonth" : "setMonth";
}
function dateSetterName(H) {
  return H ? "setUTCDate" : "setDate";
}
function hoursSetterName(H) {
  return H ? "setUTCHours" : "setHours";
}
function minutesSetterName(H) {
  return H ? "setUTCMinutes" : "setMinutes";
}
function secondsSetterName(H) {
  return H ? "setUTCSeconds" : "setSeconds";
}
function millisecondsSetterName(H) {
  return H ? "setUTCMilliseconds" : "setMilliseconds";
}
function addCommas(H) {
  if (!isNumeric(H))
    return isString(H) ? H : "-";
  var C = (H + "").split(".");
  return C[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, "$1,") + (C.length > 1 ? "." + C[1] : "");
}
function toCamelCase(H, C) {
  return H = (H || "").toLowerCase().replace(/-(.)/g, function(G, U) {
    return U.toUpperCase();
  }), C && H && (H = H.charAt(0).toUpperCase() + H.slice(1)), H;
}
var normalizeCssArray = normalizeCssArray$1;
function makeValueReadable(H, C, G) {
  var U = "{yyyy}-{MM}-{dd} {HH}:{mm}:{ss}";
  function K(te) {
    return te && trim$1(te) ? te : "-";
  }
  function W(te) {
    return !!(te != null && !isNaN(te) && isFinite(te));
  }
  var Z = C === "time", X = H instanceof Date;
  if (Z || X) {
    var Q = Z ? parseDate(H) : H;
    if (isNaN(+Q)) {
      if (X)
        return "-";
    } else
      return format(Q, U, G);
  }
  if (C === "ordinal")
    return isStringSafe(H) ? K(H) : isNumber(H) && W(H) ? H + "" : "-";
  var ee = numericToNumber(H);
  return W(ee) ? addCommas(ee) : isStringSafe(H) ? K(H) : typeof H == "boolean" ? H + "" : "-";
}
var TPL_VAR_ALIAS = ["a", "b", "c", "d", "e", "f", "g"], wrapVar = function(H, C) {
  return "{" + H + (C ?? "") + "}";
};
function formatTpl(H, C, G) {
  isArray$1(C) || (C = [C]);
  var U = C.length;
  if (!U)
    return "";
  for (var K = C[0].$vars || [], W = 0; W < K.length; W++) {
    var Z = TPL_VAR_ALIAS[W];
    H = H.replace(wrapVar(Z), wrapVar(Z, 0));
  }
  for (var X = 0; X < U; X++)
    for (var Q = 0; Q < K.length; Q++) {
      var ee = C[X][K[Q]];
      H = H.replace(wrapVar(TPL_VAR_ALIAS[Q], X), G ? encodeHTML(ee) : ee);
    }
  return H;
}
function formatTplSimple(H, C, G) {
  return each$f(C, function(U, K) {
    H = H.replace("{" + K + "}", G ? encodeHTML(U) : U);
  }), H;
}
function getTooltipMarker(H, C) {
  var G = isString(H) ? {
    color: H,
    extraCssText: C
  } : H || {}, U = G.color, K = G.type;
  C = G.extraCssText;
  var W = G.renderMode || "html";
  if (!U)
    return "";
  if (W === "html")
    return K === "subItem" ? '<span style="display:inline-block;vertical-align:middle;margin-right:8px;margin-left:3px;border-radius:4px;width:4px;height:4px;background-color:' + encodeHTML(U) + ";" + (C || "") + '"></span>' : '<span style="display:inline-block;margin-right:4px;border-radius:10px;width:10px;height:10px;background-color:' + encodeHTML(U) + ";" + (C || "") + '"></span>';
  var Z = G.markerId || "markerX";
  return {
    renderMode: W,
    content: "{" + Z + "|}  ",
    style: K === "subItem" ? {
      width: 4,
      height: 4,
      borderRadius: 2,
      backgroundColor: U
    } : {
      width: 10,
      height: 10,
      borderRadius: 5,
      backgroundColor: U
    }
  };
}
function convertToColorString(H, C) {
  return C = C || "transparent", isString(H) ? H : isObject$3(H) && H.colorStops && (H.colorStops[0] || {}).color || C;
}
function windowOpen(H, C) {
  if (C === "_blank" || C === "blank") {
    var G = window.open();
    G.opener = null, G.location.href = H;
  } else
    window.open(H, C);
}
var each$e = each$f, LOCATION_PARAMS = ["left", "right", "top", "bottom", "width", "height"], HV_NAMES = [["width", "left", "right"], ["height", "top", "bottom"]];
function boxLayout(H, C, G, U, K) {
  var W = 0, Z = 0;
  U == null && (U = 1 / 0), K == null && (K = 1 / 0);
  var X = 0;
  C.eachChild(function(Q, ee) {
    var te = Q.getBoundingRect(), re = C.childAt(ee + 1), ne = re && re.getBoundingRect(), ae, ie;
    if (H === "horizontal") {
      var se = te.width + (ne ? -ne.x + te.x : 0);
      ae = W + se, ae > U || Q.newline ? (W = 0, ae = se, Z += X + G, X = te.height) : X = Math.max(X, te.height);
    } else {
      var oe = te.height + (ne ? -ne.y + te.y : 0);
      ie = Z + oe, ie > K || Q.newline ? (W += X + G, Z = 0, ie = oe, X = te.width) : X = Math.max(X, te.width);
    }
    Q.newline || (Q.x = W, Q.y = Z, Q.markRedraw(), H === "horizontal" ? W = ae + G : Z = ie + G);
  });
}
var box = boxLayout;
curry$1(boxLayout, "vertical");
curry$1(boxLayout, "horizontal");
function getAvailableSize(H, C, G) {
  var U = C.width, K = C.height, W = parsePercent(H.left, U), Z = parsePercent(H.top, K), X = parsePercent(H.right, U), Q = parsePercent(H.bottom, K);
  return (isNaN(W) || isNaN(parseFloat(H.left))) && (W = 0), (isNaN(X) || isNaN(parseFloat(H.right))) && (X = U), (isNaN(Z) || isNaN(parseFloat(H.top))) && (Z = 0), (isNaN(Q) || isNaN(parseFloat(H.bottom))) && (Q = K), G = normalizeCssArray(G || 0), {
    width: Math.max(X - W - G[1] - G[3], 0),
    height: Math.max(Q - Z - G[0] - G[2], 0)
  };
}
function getLayoutRect(H, C, G) {
  G = normalizeCssArray(G || 0);
  var U = C.width, K = C.height, W = parsePercent(H.left, U), Z = parsePercent(H.top, K), X = parsePercent(H.right, U), Q = parsePercent(H.bottom, K), ee = parsePercent(H.width, U), te = parsePercent(H.height, K), re = G[2] + G[0], ne = G[1] + G[3], ae = H.aspect;
  switch (isNaN(ee) && (ee = U - X - ne - W), isNaN(te) && (te = K - Q - re - Z), ae != null && (isNaN(ee) && isNaN(te) && (ae > U / K ? ee = U * 0.8 : te = K * 0.8), isNaN(ee) && (ee = ae * te), isNaN(te) && (te = ee / ae)), isNaN(W) && (W = U - X - ee - ne), isNaN(Z) && (Z = K - Q - te - re), H.left || H.right) {
    case "center":
      W = U / 2 - ee / 2 - G[3];
      break;
    case "right":
      W = U - ee - ne;
      break;
  }
  switch (H.top || H.bottom) {
    case "middle":
    case "center":
      Z = K / 2 - te / 2 - G[0];
      break;
    case "bottom":
      Z = K - te - re;
      break;
  }
  W = W || 0, Z = Z || 0, isNaN(ee) && (ee = U - ne - W - (X || 0)), isNaN(te) && (te = K - re - Z - (Q || 0));
  var ie = new BoundingRect$1(W + G[3], Z + G[0], ee, te);
  return ie.margin = G, ie;
}
function positionElement(H, C, G, U, K, W) {
  var Z = !K || !K.hv || K.hv[0], X = !K || !K.hv || K.hv[1], Q = K && K.boundingMode || "all";
  if (W = W || H, W.x = H.x, W.y = H.y, !Z && !X)
    return !1;
  var ee;
  if (Q === "raw")
    ee = H.type === "group" ? new BoundingRect$1(0, 0, +C.width || 0, +C.height || 0) : H.getBoundingRect();
  else if (ee = H.getBoundingRect(), H.needLocalTransform()) {
    var te = H.getLocalTransform();
    ee = ee.clone(), ee.applyTransform(te);
  }
  var re = getLayoutRect(defaults({
    width: ee.width,
    height: ee.height
  }, C), G, U), ne = Z ? re.x - ee.x : 0, ae = X ? re.y - ee.y : 0;
  return Q === "raw" ? (W.x = ne, W.y = ae) : (W.x += ne, W.y += ae), W === H && H.markRedraw(), !0;
}
function sizeCalculable(H, C) {
  return H[HV_NAMES[C][0]] != null || H[HV_NAMES[C][1]] != null && H[HV_NAMES[C][2]] != null;
}
function fetchLayoutMode(H) {
  var C = H.layoutMode || H.constructor.layoutMode;
  return isObject$3(C) ? C : C ? {
    type: C
  } : null;
}
function mergeLayoutParam(H, C, G) {
  var U = G && G.ignoreSize;
  !isArray$1(U) && (U = [U, U]);
  var K = Z(HV_NAMES[0], 0), W = Z(HV_NAMES[1], 1);
  ee(HV_NAMES[0], H, K), ee(HV_NAMES[1], H, W);
  function Z(te, re) {
    var ne = {}, ae = 0, ie = {}, se = 0, oe = 2;
    if (each$e(te, function(ce) {
      ie[ce] = H[ce];
    }), each$e(te, function(ce) {
      X(C, ce) && (ne[ce] = ie[ce] = C[ce]), Q(ne, ce) && ae++, Q(ie, ce) && se++;
    }), U[re])
      return Q(C, te[1]) ? ie[te[2]] = null : Q(C, te[2]) && (ie[te[1]] = null), ie;
    if (se === oe || !ae)
      return ie;
    if (ae >= oe)
      return ne;
    for (var le = 0; le < te.length; le++) {
      var ue = te[le];
      if (!X(ne, ue) && X(H, ue)) {
        ne[ue] = H[ue];
        break;
      }
    }
    return ne;
  }
  function X(te, re) {
    return te.hasOwnProperty(re);
  }
  function Q(te, re) {
    return te[re] != null && te[re] !== "auto";
  }
  function ee(te, re, ne) {
    each$e(te, function(ae) {
      re[ae] = ne[ae];
    });
  }
}
function getLayoutParams(H) {
  return copyLayoutParams({}, H);
}
function copyLayoutParams(H, C) {
  return C && H && each$e(LOCATION_PARAMS, function(G) {
    C.hasOwnProperty(G) && (H[G] = C[G]);
  }), H;
}
var inner$l = makeInner(), ComponentModel = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C(G, U, K) {
      var W = H.call(this, G, U, K) || this;
      return W.uid = getUID("ec_cpt_model"), W;
    }
    return C.prototype.init = function(G, U, K) {
      this.mergeDefaultAndTheme(G, K);
    }, C.prototype.mergeDefaultAndTheme = function(G, U) {
      var K = fetchLayoutMode(this), W = K ? getLayoutParams(G) : {}, Z = U.getTheme();
      merge(G, Z.get(this.mainType)), merge(G, this.getDefaultOption()), K && mergeLayoutParam(G, W, K);
    }, C.prototype.mergeOption = function(G, U) {
      merge(this.option, G, !0);
      var K = fetchLayoutMode(this);
      K && mergeLayoutParam(this.option, G, K);
    }, C.prototype.optionUpdated = function(G, U) {
    }, C.prototype.getDefaultOption = function() {
      var G = this.constructor;
      if (!isExtendedClass(G))
        return G.defaultOption;
      var U = inner$l(this);
      if (!U.defaultOption) {
        for (var K = [], W = G; W; ) {
          var Z = W.prototype.defaultOption;
          Z && K.push(Z), W = W.superClass;
        }
        for (var X = {}, Q = K.length - 1; Q >= 0; Q--)
          X = merge(X, K[Q], !0);
        U.defaultOption = X;
      }
      return U.defaultOption;
    }, C.prototype.getReferringComponents = function(G, U) {
      var K = G + "Index", W = G + "Id";
      return queryReferringComponents(this.ecModel, G, {
        index: this.get(K, !0),
        id: this.get(W, !0)
      }, U);
    }, C.prototype.getBoxLayoutParams = function() {
      var G = this;
      return {
        left: G.get("left"),
        top: G.get("top"),
        right: G.get("right"),
        bottom: G.get("bottom"),
        width: G.get("width"),
        height: G.get("height")
      };
    }, C.prototype.getZLevelKey = function() {
      return "";
    }, C.prototype.setZLevel = function(G) {
      this.option.zlevel = G;
    }, C.protoInitialize = function() {
      var G = C.prototype;
      G.type = "component", G.id = "", G.name = "", G.mainType = "", G.subType = "", G.componentIndex = 0;
    }(), C;
  }(Model$1)
);
mountExtend(ComponentModel, Model$1);
enableClassManagement(ComponentModel);
enableSubTypeDefaulter(ComponentModel);
enableTopologicalTravel(ComponentModel, getDependencies);
function getDependencies(H) {
  var C = [];
  return each$f(ComponentModel.getClassesByMainType(H), function(G) {
    C = C.concat(G.dependencies || G.prototype.dependencies || []);
  }), C = map$1(C, function(G) {
    return parseClassType(G).main;
  }), H !== "dataset" && indexOf(C, "dataset") <= 0 && C.unshift("dataset"), C;
}
const ComponentModel$1 = ComponentModel;
var platform = "";
typeof navigator < "u" && (platform = navigator.platform || "");
var decalColor = "rgba(0, 0, 0, 0.2)";
const globalDefault = {
  darkMode: "auto",
  // backgroundColor: 'rgba(0,0,0,0)',
  colorBy: "series",
  color: ["#5470c6", "#91cc75", "#fac858", "#ee6666", "#73c0de", "#3ba272", "#fc8452", "#9a60b4", "#ea7ccc"],
  gradientColor: ["#f6efa6", "#d88273", "#bf444c"],
  aria: {
    decal: {
      decals: [{
        color: decalColor,
        dashArrayX: [1, 0],
        dashArrayY: [2, 5],
        symbolSize: 1,
        rotation: Math.PI / 6
      }, {
        color: decalColor,
        symbol: "circle",
        dashArrayX: [[8, 8], [0, 8, 8, 0]],
        dashArrayY: [6, 0],
        symbolSize: 0.8
      }, {
        color: decalColor,
        dashArrayX: [1, 0],
        dashArrayY: [4, 3],
        rotation: -Math.PI / 4
      }, {
        color: decalColor,
        dashArrayX: [[6, 6], [0, 6, 6, 0]],
        dashArrayY: [6, 0]
      }, {
        color: decalColor,
        dashArrayX: [[1, 0], [1, 6]],
        dashArrayY: [1, 0, 6, 0],
        rotation: Math.PI / 4
      }, {
        color: decalColor,
        symbol: "triangle",
        dashArrayX: [[9, 9], [0, 9, 9, 0]],
        dashArrayY: [7, 2],
        symbolSize: 0.75
      }]
    }
  },
  // If xAxis and yAxis declared, grid is created by default.
  // grid: {},
  textStyle: {
    // color: '#000',
    // decoration: 'none',
    // PENDING
    fontFamily: platform.match(/^Win/) ? "Microsoft YaHei" : "sans-serif",
    // fontFamily: 'Arial, Verdana, sans-serif',
    fontSize: 12,
    fontStyle: "normal",
    fontWeight: "normal"
  },
  // http://blogs.adobe.com/webplatform/2014/02/24/using-blend-modes-in-html-canvas/
  // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation
  // Default is source-over
  blendMode: null,
  stateAnimation: {
    duration: 300,
    easing: "cubicOut"
  },
  animation: "auto",
  animationDuration: 1e3,
  animationDurationUpdate: 500,
  animationEasing: "cubicInOut",
  animationEasingUpdate: "cubicInOut",
  animationThreshold: 2e3,
  // Configuration for progressive/incremental rendering
  progressiveThreshold: 3e3,
  progressive: 400,
  // Threshold of if use single hover layer to optimize.
  // It is recommended that `hoverLayerThreshold` is equivalent to or less than
  // `progressiveThreshold`, otherwise hover will cause restart of progressive,
  // which is unexpected.
  // see example <echarts/test/heatmap-large.html>.
  hoverLayerThreshold: 3e3,
  // See: module:echarts/scale/Time
  useUTC: !1
};
var VISUAL_DIMENSIONS = createHashMap(["tooltip", "label", "itemName", "itemId", "itemGroupId", "seriesName"]), SOURCE_FORMAT_ORIGINAL = "original", SOURCE_FORMAT_ARRAY_ROWS = "arrayRows", SOURCE_FORMAT_OBJECT_ROWS = "objectRows", SOURCE_FORMAT_KEYED_COLUMNS = "keyedColumns", SOURCE_FORMAT_TYPED_ARRAY = "typedArray", SOURCE_FORMAT_UNKNOWN = "unknown", SERIES_LAYOUT_BY_COLUMN = "column", SERIES_LAYOUT_BY_ROW = "row", BE_ORDINAL = {
  Must: 1,
  Might: 2,
  Not: 3
  // Other cases
}, innerGlobalModel = makeInner();
function resetSourceDefaulter(H) {
  innerGlobalModel(H).datasetMap = createHashMap();
}
function makeSeriesEncodeForAxisCoordSys(H, C, G) {
  var U = {}, K = querySeriesUpstreamDatasetModel(C);
  if (!K || !H)
    return U;
  var W = [], Z = [], X = C.ecModel, Q = innerGlobalModel(X).datasetMap, ee = K.uid + "_" + G.seriesLayoutBy, te, re;
  H = H.slice(), each$f(H, function(se, oe) {
    var le = isObject$3(se) ? se : H[oe] = {
      name: se
    };
    le.type === "ordinal" && te == null && (te = oe, re = ie(le)), U[le.name] = [];
  });
  var ne = Q.get(ee) || Q.set(ee, {
    categoryWayDim: re,
    valueWayDim: 0
  });
  each$f(H, function(se, oe) {
    var le = se.name, ue = ie(se);
    if (te == null) {
      var ce = ne.valueWayDim;
      ae(U[le], ce, ue), ae(Z, ce, ue), ne.valueWayDim += ue;
    } else if (te === oe)
      ae(U[le], 0, ue), ae(W, 0, ue);
    else {
      var ce = ne.categoryWayDim;
      ae(U[le], ce, ue), ae(Z, ce, ue), ne.categoryWayDim += ue;
    }
  });
  function ae(se, oe, le) {
    for (var ue = 0; ue < le; ue++)
      se.push(oe + ue);
  }
  function ie(se) {
    var oe = se.dimsDef;
    return oe ? oe.length : 1;
  }
  return W.length && (U.itemName = W), Z.length && (U.seriesName = Z), U;
}
function makeSeriesEncodeForNameBased(H, C, G) {
  var U = {}, K = querySeriesUpstreamDatasetModel(H);
  if (!K)
    return U;
  var W = C.sourceFormat, Z = C.dimensionsDefine, X;
  (W === SOURCE_FORMAT_OBJECT_ROWS || W === SOURCE_FORMAT_KEYED_COLUMNS) && each$f(Z, function(te, re) {
    (isObject$3(te) ? te.name : te) === "name" && (X = re);
  });
  var Q = function() {
    for (var te = {}, re = {}, ne = [], ae = 0, ie = Math.min(5, G); ae < ie; ae++) {
      var se = doGuessOrdinal(C.data, W, C.seriesLayoutBy, Z, C.startIndex, ae);
      ne.push(se);
      var oe = se === BE_ORDINAL.Not;
      if (oe && te.v == null && ae !== X && (te.v = ae), (te.n == null || te.n === te.v || !oe && ne[te.n] === BE_ORDINAL.Not) && (te.n = ae), le(te) && ne[te.n] !== BE_ORDINAL.Not)
        return te;
      oe || (se === BE_ORDINAL.Might && re.v == null && ae !== X && (re.v = ae), (re.n == null || re.n === re.v) && (re.n = ae));
    }
    function le(ue) {
      return ue.v != null && ue.n != null;
    }
    return le(te) ? te : le(re) ? re : null;
  }();
  if (Q) {
    U.value = [Q.v];
    var ee = X ?? Q.n;
    U.itemName = [ee], U.seriesName = [ee];
  }
  return U;
}
function querySeriesUpstreamDatasetModel(H) {
  var C = H.get("data", !0);
  if (!C)
    return queryReferringComponents(H.ecModel, "dataset", {
      index: H.get("datasetIndex", !0),
      id: H.get("datasetId", !0)
    }, SINGLE_REFERRING).models[0];
}
function queryDatasetUpstreamDatasetModels(H) {
  return !H.get("transform", !0) && !H.get("fromTransformResult", !0) ? [] : queryReferringComponents(H.ecModel, "dataset", {
    index: H.get("fromDatasetIndex", !0),
    id: H.get("fromDatasetId", !0)
  }, SINGLE_REFERRING).models;
}
function guessOrdinal(H, C) {
  return doGuessOrdinal(H.data, H.sourceFormat, H.seriesLayoutBy, H.dimensionsDefine, H.startIndex, C);
}
function doGuessOrdinal(H, C, G, U, K, W) {
  var Z, X = 5;
  if (isTypedArray(H))
    return BE_ORDINAL.Not;
  var Q, ee;
  if (U) {
    var te = U[W];
    isObject$3(te) ? (Q = te.name, ee = te.type) : isString(te) && (Q = te);
  }
  if (ee != null)
    return ee === "ordinal" ? BE_ORDINAL.Must : BE_ORDINAL.Not;
  if (C === SOURCE_FORMAT_ARRAY_ROWS) {
    var re = H;
    if (G === SERIES_LAYOUT_BY_ROW) {
      for (var ne = re[W], ae = 0; ae < (ne || []).length && ae < X; ae++)
        if ((Z = de(ne[K + ae])) != null)
          return Z;
    } else
      for (var ae = 0; ae < re.length && ae < X; ae++) {
        var ie = re[K + ae];
        if (ie && (Z = de(ie[W])) != null)
          return Z;
      }
  } else if (C === SOURCE_FORMAT_OBJECT_ROWS) {
    var se = H;
    if (!Q)
      return BE_ORDINAL.Not;
    for (var ae = 0; ae < se.length && ae < X; ae++) {
      var oe = se[ae];
      if (oe && (Z = de(oe[Q])) != null)
        return Z;
    }
  } else if (C === SOURCE_FORMAT_KEYED_COLUMNS) {
    var le = H;
    if (!Q)
      return BE_ORDINAL.Not;
    var ne = le[Q];
    if (!ne || isTypedArray(ne))
      return BE_ORDINAL.Not;
    for (var ae = 0; ae < ne.length && ae < X; ae++)
      if ((Z = de(ne[ae])) != null)
        return Z;
  } else if (C === SOURCE_FORMAT_ORIGINAL)
    for (var ue = H, ae = 0; ae < ue.length && ae < X; ae++) {
      var oe = ue[ae], ce = getDataItemValue(oe);
      if (!isArray$1(ce))
        return BE_ORDINAL.Not;
      if ((Z = de(ce[W])) != null)
        return Z;
    }
  function de(ge) {
    var fe = isString(ge);
    if (ge != null && isFinite(ge) && ge !== "")
      return fe ? BE_ORDINAL.Might : BE_ORDINAL.Not;
    if (fe && ge !== "-")
      return BE_ORDINAL.Must;
  }
  return BE_ORDINAL.Not;
}
var internalOptionCreatorMap = createHashMap();
function registerInternalOptionCreator(H, C) {
  assert(internalOptionCreatorMap.get(H) == null && C), internalOptionCreatorMap.set(H, C);
}
function concatInternalOptions(H, C, G) {
  var U = internalOptionCreatorMap.get(C);
  if (!U)
    return G;
  var K = U(H);
  if (!K)
    return G;
  if (process.env.NODE_ENV !== "production")
    for (var W = 0; W < K.length; W++)
      assert(isComponentIdInternal(K[W]));
  return G.concat(K);
}
var innerColor = makeInner(), innerDecal = makeInner(), PaletteMixin = (
  /** @class */
  function() {
    function H() {
    }
    return H.prototype.getColorFromPalette = function(C, G, U) {
      var K = normalizeToArray(this.get("color", !0)), W = this.get("colorLayer", !0);
      return getFromPalette(this, innerColor, K, W, C, G, U);
    }, H.prototype.clearColorPalette = function() {
      clearPalette(this, innerColor);
    }, H;
  }()
);
function getDecalFromPalette(H, C, G, U) {
  var K = normalizeToArray(H.get(["aria", "decal", "decals"]));
  return getFromPalette(H, innerDecal, K, null, C, G, U);
}
function getNearestPalette(H, C) {
  for (var G = H.length, U = 0; U < G; U++)
    if (H[U].length > C)
      return H[U];
  return H[G - 1];
}
function getFromPalette(H, C, G, U, K, W, Z) {
  W = W || H;
  var X = C(W), Q = X.paletteIdx || 0, ee = X.paletteNameMap = X.paletteNameMap || {};
  if (ee.hasOwnProperty(K))
    return ee[K];
  var te = Z == null || !U ? G : getNearestPalette(U, Z);
  if (te = te || G, !(!te || !te.length)) {
    var re = te[Q];
    return K && (ee[K] = re), X.paletteIdx = (Q + 1) % te.length, re;
  }
}
function clearPalette(H, C) {
  C(H).paletteIdx = 0, C(H).paletteNameMap = {};
}
var reCreateSeriesIndices, assertSeriesInitialized, initBase, OPTION_INNER_KEY = "\0_ec_inner", OPTION_INNER_VALUE = 1, BUITIN_COMPONENTS_MAP = {
  grid: "GridComponent",
  polar: "PolarComponent",
  geo: "GeoComponent",
  singleAxis: "SingleAxisComponent",
  parallel: "ParallelComponent",
  calendar: "CalendarComponent",
  graphic: "GraphicComponent",
  toolbox: "ToolboxComponent",
  tooltip: "TooltipComponent",
  axisPointer: "AxisPointerComponent",
  brush: "BrushComponent",
  title: "TitleComponent",
  timeline: "TimelineComponent",
  markPoint: "MarkPointComponent",
  markLine: "MarkLineComponent",
  markArea: "MarkAreaComponent",
  legend: "LegendComponent",
  dataZoom: "DataZoomComponent",
  visualMap: "VisualMapComponent",
  // aria: 'AriaComponent',
  // dataset: 'DatasetComponent',
  // Dependencies
  xAxis: "GridComponent",
  yAxis: "GridComponent",
  angleAxis: "PolarComponent",
  radiusAxis: "PolarComponent"
}, BUILTIN_CHARTS_MAP = {
  line: "LineChart",
  bar: "BarChart",
  pie: "PieChart",
  scatter: "ScatterChart",
  radar: "RadarChart",
  map: "MapChart",
  tree: "TreeChart",
  treemap: "TreemapChart",
  graph: "GraphChart",
  gauge: "GaugeChart",
  funnel: "FunnelChart",
  parallel: "ParallelChart",
  sankey: "SankeyChart",
  boxplot: "BoxplotChart",
  candlestick: "CandlestickChart",
  effectScatter: "EffectScatterChart",
  lines: "LinesChart",
  heatmap: "HeatmapChart",
  pictorialBar: "PictorialBarChart",
  themeRiver: "ThemeRiverChart",
  sunburst: "SunburstChart",
  custom: "CustomChart"
}, componetsMissingLogPrinted = {};
function checkMissingComponents(H) {
  each$f(H, function(C, G) {
    if (!ComponentModel$1.hasClass(G)) {
      var U = BUITIN_COMPONENTS_MAP[G];
      U && !componetsMissingLogPrinted[U] && (error("Component " + G + ` is used but not imported.
import { ` + U + ` } from 'echarts/components';
echarts.use([` + U + "]);"), componetsMissingLogPrinted[U] = !0);
    }
  });
}
var GlobalModel = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      return H !== null && H.apply(this, arguments) || this;
    }
    return C.prototype.init = function(G, U, K, W, Z, X) {
      W = W || {}, this.option = null, this._theme = new Model$1(W), this._locale = new Model$1(Z), this._optionManager = X;
    }, C.prototype.setOption = function(G, U, K) {
      process.env.NODE_ENV !== "production" && (assert(G != null, "option is null/undefined"), assert(G[OPTION_INNER_KEY] !== OPTION_INNER_VALUE, "please use chart.getOption()"));
      var W = normalizeSetOptionInput(U);
      this._optionManager.setOption(G, K, W), this._resetOption(null, W);
    }, C.prototype.resetOption = function(G, U) {
      return this._resetOption(G, normalizeSetOptionInput(U));
    }, C.prototype._resetOption = function(G, U) {
      var K = !1, W = this._optionManager;
      if (!G || G === "recreate") {
        var Z = W.mountOption(G === "recreate");
        process.env.NODE_ENV !== "production" && checkMissingComponents(Z), !this.option || G === "recreate" ? initBase(this, Z) : (this.restoreData(), this._mergeOption(Z, U)), K = !0;
      }
      if ((G === "timeline" || G === "media") && this.restoreData(), !G || G === "recreate" || G === "timeline") {
        var X = W.getTimelineOption(this);
        X && (K = !0, this._mergeOption(X, U));
      }
      if (!G || G === "recreate" || G === "media") {
        var Q = W.getMediaOption(this);
        Q.length && each$f(Q, function(ee) {
          K = !0, this._mergeOption(ee, U);
        }, this);
      }
      return K;
    }, C.prototype.mergeOption = function(G) {
      this._mergeOption(G, null);
    }, C.prototype._mergeOption = function(G, U) {
      var K = this.option, W = this._componentsMap, Z = this._componentsCount, X = [], Q = createHashMap(), ee = U && U.replaceMergeMainTypeMap;
      resetSourceDefaulter(this), each$f(G, function(re, ne) {
        re != null && (ComponentModel$1.hasClass(ne) ? ne && (X.push(ne), Q.set(ne, !0)) : K[ne] = K[ne] == null ? clone$4(re) : merge(K[ne], re, !0));
      }), ee && ee.each(function(re, ne) {
        ComponentModel$1.hasClass(ne) && !Q.get(ne) && (X.push(ne), Q.set(ne, !0));
      }), ComponentModel$1.topologicalTravel(X, ComponentModel$1.getAllClassMainTypes(), te, this);
      function te(re) {
        var ne = concatInternalOptions(this, re, normalizeToArray(G[re])), ae = W.get(re), ie = (
          // `!oldCmptList` means init. See the comment in `mappingToExists`
          ae ? ee && ee.get(re) ? "replaceMerge" : "normalMerge" : "replaceAll"
        ), se = mappingToExists(ae, ne, ie);
        setComponentTypeToKeyInfo(se, re, ComponentModel$1), K[re] = null, W.set(re, null), Z.set(re, 0);
        var oe = [], le = [], ue = 0, ce, de;
        each$f(se, function(ge, fe) {
          var ve = ge.existing, pe = ge.newOption;
          if (!pe)
            ve && (ve.mergeOption({}, this), ve.optionUpdated({}, !1));
          else {
            var he = re === "series", me = ComponentModel$1.getClass(
              re,
              ge.keyInfo.subType,
              !he
              // Give a more detailed warn later if series don't exists
            );
            if (!me) {
              if (process.env.NODE_ENV !== "production") {
                var ye = ge.keyInfo.subType, Ce = BUILTIN_CHARTS_MAP[ye];
                componetsMissingLogPrinted[ye] || (componetsMissingLogPrinted[ye] = !0, error(Ce ? "Series " + ye + ` is used but not imported.
import { ` + Ce + ` } from 'echarts/charts';
echarts.use([` + Ce + "]);" : "Unknown series " + ye));
              }
              return;
            }
            if (re === "tooltip") {
              if (ce) {
                process.env.NODE_ENV !== "production" && (de || (warn("Currently only one tooltip component is allowed."), de = !0));
                return;
              }
              ce = !0;
            }
            if (ve && ve.constructor === me)
              ve.name = ge.keyInfo.name, ve.mergeOption(pe, this), ve.optionUpdated(pe, !1);
            else {
              var Ie = extend({
                componentIndex: fe
              }, ge.keyInfo);
              ve = new me(pe, this, this, Ie), extend(ve, Ie), ge.brandNew && (ve.__requireNewView = !0), ve.init(pe, this, this), ve.optionUpdated(null, !0);
            }
          }
          ve ? (oe.push(ve.option), le.push(ve), ue++) : (oe.push(void 0), le.push(void 0));
        }, this), K[re] = oe, W.set(re, le), Z.set(re, ue), re === "series" && reCreateSeriesIndices(this);
      }
      this._seriesIndices || reCreateSeriesIndices(this);
    }, C.prototype.getOption = function() {
      var G = clone$4(this.option);
      return each$f(G, function(U, K) {
        if (ComponentModel$1.hasClass(K)) {
          for (var W = normalizeToArray(U), Z = W.length, X = !1, Q = Z - 1; Q >= 0; Q--)
            W[Q] && !isComponentIdInternal(W[Q]) ? X = !0 : (W[Q] = null, !X && Z--);
          W.length = Z, G[K] = W;
        }
      }), delete G[OPTION_INNER_KEY], G;
    }, C.prototype.getTheme = function() {
      return this._theme;
    }, C.prototype.getLocaleModel = function() {
      return this._locale;
    }, C.prototype.setUpdatePayload = function(G) {
      this._payload = G;
    }, C.prototype.getUpdatePayload = function() {
      return this._payload;
    }, C.prototype.getComponent = function(G, U) {
      var K = this._componentsMap.get(G);
      if (K) {
        var W = K[U || 0];
        if (W)
          return W;
        if (U == null) {
          for (var Z = 0; Z < K.length; Z++)
            if (K[Z])
              return K[Z];
        }
      }
    }, C.prototype.queryComponents = function(G) {
      var U = G.mainType;
      if (!U)
        return [];
      var K = G.index, W = G.id, Z = G.name, X = this._componentsMap.get(U);
      if (!X || !X.length)
        return [];
      var Q;
      return K != null ? (Q = [], each$f(normalizeToArray(K), function(ee) {
        X[ee] && Q.push(X[ee]);
      })) : W != null ? Q = queryByIdOrName("id", W, X) : Z != null ? Q = queryByIdOrName("name", Z, X) : Q = filter(X, function(ee) {
        return !!ee;
      }), filterBySubType(Q, G);
    }, C.prototype.findComponents = function(G) {
      var U = G.query, K = G.mainType, W = X(U), Z = W ? this.queryComponents(W) : filter(this._componentsMap.get(K), function(ee) {
        return !!ee;
      });
      return Q(filterBySubType(Z, G));
      function X(ee) {
        var te = K + "Index", re = K + "Id", ne = K + "Name";
        return ee && (ee[te] != null || ee[re] != null || ee[ne] != null) ? {
          mainType: K,
          // subType will be filtered finally.
          index: ee[te],
          id: ee[re],
          name: ee[ne]
        } : null;
      }
      function Q(ee) {
        return G.filter ? filter(ee, G.filter) : ee;
      }
    }, C.prototype.eachComponent = function(G, U, K) {
      var W = this._componentsMap;
      if (isFunction(G)) {
        var Z = U, X = G;
        W.each(function(re, ne) {
          for (var ae = 0; re && ae < re.length; ae++) {
            var ie = re[ae];
            ie && X.call(Z, ne, ie, ie.componentIndex);
          }
        });
      } else
        for (var Q = isString(G) ? W.get(G) : isObject$3(G) ? this.findComponents(G) : null, ee = 0; Q && ee < Q.length; ee++) {
          var te = Q[ee];
          te && U.call(K, te, te.componentIndex);
        }
    }, C.prototype.getSeriesByName = function(G) {
      var U = convertOptionIdName(G, null);
      return filter(this._componentsMap.get("series"), function(K) {
        return !!K && U != null && K.name === U;
      });
    }, C.prototype.getSeriesByIndex = function(G) {
      return this._componentsMap.get("series")[G];
    }, C.prototype.getSeriesByType = function(G) {
      return filter(this._componentsMap.get("series"), function(U) {
        return !!U && U.subType === G;
      });
    }, C.prototype.getSeries = function() {
      return filter(this._componentsMap.get("series"), function(G) {
        return !!G;
      });
    }, C.prototype.getSeriesCount = function() {
      return this._componentsCount.get("series");
    }, C.prototype.eachSeries = function(G, U) {
      assertSeriesInitialized(this), each$f(this._seriesIndices, function(K) {
        var W = this._componentsMap.get("series")[K];
        G.call(U, W, K);
      }, this);
    }, C.prototype.eachRawSeries = function(G, U) {
      each$f(this._componentsMap.get("series"), function(K) {
        K && G.call(U, K, K.componentIndex);
      });
    }, C.prototype.eachSeriesByType = function(G, U, K) {
      assertSeriesInitialized(this), each$f(this._seriesIndices, function(W) {
        var Z = this._componentsMap.get("series")[W];
        Z.subType === G && U.call(K, Z, W);
      }, this);
    }, C.prototype.eachRawSeriesByType = function(G, U, K) {
      return each$f(this.getSeriesByType(G), U, K);
    }, C.prototype.isSeriesFiltered = function(G) {
      return assertSeriesInitialized(this), this._seriesIndicesMap.get(G.componentIndex) == null;
    }, C.prototype.getCurrentSeriesIndices = function() {
      return (this._seriesIndices || []).slice();
    }, C.prototype.filterSeries = function(G, U) {
      assertSeriesInitialized(this);
      var K = [];
      each$f(this._seriesIndices, function(W) {
        var Z = this._componentsMap.get("series")[W];
        G.call(U, Z, W) && K.push(W);
      }, this), this._seriesIndices = K, this._seriesIndicesMap = createHashMap(K);
    }, C.prototype.restoreData = function(G) {
      reCreateSeriesIndices(this);
      var U = this._componentsMap, K = [];
      U.each(function(W, Z) {
        ComponentModel$1.hasClass(Z) && K.push(Z);
      }), ComponentModel$1.topologicalTravel(K, ComponentModel$1.getAllClassMainTypes(), function(W) {
        each$f(U.get(W), function(Z) {
          Z && (W !== "series" || !isNotTargetSeries(Z, G)) && Z.restoreData();
        });
      });
    }, C.internalField = function() {
      reCreateSeriesIndices = function(G) {
        var U = G._seriesIndices = [];
        each$f(G._componentsMap.get("series"), function(K) {
          K && U.push(K.componentIndex);
        }), G._seriesIndicesMap = createHashMap(U);
      }, assertSeriesInitialized = function(G) {
        if (process.env.NODE_ENV !== "production" && !G._seriesIndices)
          throw new Error("Option should contains series.");
      }, initBase = function(G, U) {
        G.option = {}, G.option[OPTION_INNER_KEY] = OPTION_INNER_VALUE, G._componentsMap = createHashMap({
          series: []
        }), G._componentsCount = createHashMap();
        var K = U.aria;
        isObject$3(K) && K.enabled == null && (K.enabled = !0), mergeTheme(U, G._theme.option), merge(U, globalDefault, !1), G._mergeOption(U, null);
      };
    }(), C;
  }(Model$1)
);
function isNotTargetSeries(H, C) {
  if (C) {
    var G = C.seriesIndex, U = C.seriesId, K = C.seriesName;
    return G != null && H.componentIndex !== G || U != null && H.id !== U || K != null && H.name !== K;
  }
}
function mergeTheme(H, C) {
  var G = H.color && !H.colorLayer;
  each$f(C, function(U, K) {
    K === "colorLayer" && G || ComponentModel$1.hasClass(K) || (typeof U == "object" ? H[K] = H[K] ? merge(H[K], U, !1) : clone$4(U) : H[K] == null && (H[K] = U));
  });
}
function queryByIdOrName(H, C, G) {
  if (isArray$1(C)) {
    var U = createHashMap();
    return each$f(C, function(W) {
      if (W != null) {
        var Z = convertOptionIdName(W, null);
        Z != null && U.set(W, !0);
      }
    }), filter(G, function(W) {
      return W && U.get(W[H]);
    });
  } else {
    var K = convertOptionIdName(C, null);
    return filter(G, function(W) {
      return W && K != null && W[H] === K;
    });
  }
}
function filterBySubType(H, C) {
  return C.hasOwnProperty("subType") ? filter(H, function(G) {
    return G && G.subType === C.subType;
  }) : H;
}
function normalizeSetOptionInput(H) {
  var C = createHashMap();
  return H && each$f(normalizeToArray(H.replaceMerge), function(G) {
    process.env.NODE_ENV !== "production" && assert(ComponentModel$1.hasClass(G), '"' + G + '" is not valid component main type in "replaceMerge"'), C.set(G, !0);
  }), {
    replaceMergeMainTypeMap: C
  };
}
mixin(GlobalModel, PaletteMixin);
const GlobalModel$1 = GlobalModel;
var availableMethods = [
  "getDom",
  "getZr",
  "getWidth",
  "getHeight",
  "getDevicePixelRatio",
  "dispatchAction",
  "isSSR",
  "isDisposed",
  "on",
  "off",
  "getDataURL",
  "getConnectedDataURL",
  // 'getModel',
  "getOption",
  // 'getViewOfComponentModel',
  // 'getViewOfSeriesModel',
  "getId",
  "updateLabelLayout"
], ExtensionAPI = (
  /** @class */
  function() {
    function H(C) {
      each$f(availableMethods, function(G) {
        this[G] = bind$1(C[G], C);
      }, this);
    }
    return H;
  }()
);
const ExtensionAPI$1 = ExtensionAPI;
var coordinateSystemCreators = {}, CoordinateSystemManager = (
  /** @class */
  function() {
    function H() {
      this._coordinateSystems = [];
    }
    return H.prototype.create = function(C, G) {
      var U = [];
      each$f(coordinateSystemCreators, function(K, W) {
        var Z = K.create(C, G);
        U = U.concat(Z || []);
      }), this._coordinateSystems = U;
    }, H.prototype.update = function(C, G) {
      each$f(this._coordinateSystems, function(U) {
        U.update && U.update(C, G);
      });
    }, H.prototype.getCoordinateSystems = function() {
      return this._coordinateSystems.slice();
    }, H.register = function(C, G) {
      coordinateSystemCreators[C] = G;
    }, H.get = function(C) {
      return coordinateSystemCreators[C];
    }, H;
  }()
);
const CoordinateSystem = CoordinateSystemManager;
var QUERY_REG = /^(min|max)?(.+)$/, OptionManager = (
  /** @class */
  function() {
    function H(C) {
      this._timelineOptions = [], this._mediaList = [], this._currentMediaIndices = [], this._api = C;
    }
    return H.prototype.setOption = function(C, G, U) {
      C && (each$f(normalizeToArray(C.series), function(Z) {
        Z && Z.data && isTypedArray(Z.data) && setAsPrimitive(Z.data);
      }), each$f(normalizeToArray(C.dataset), function(Z) {
        Z && Z.source && isTypedArray(Z.source) && setAsPrimitive(Z.source);
      })), C = clone$4(C);
      var K = this._optionBackup, W = parseRawOption(C, G, !K);
      this._newBaseOption = W.baseOption, K ? (W.timelineOptions.length && (K.timelineOptions = W.timelineOptions), W.mediaList.length && (K.mediaList = W.mediaList), W.mediaDefault && (K.mediaDefault = W.mediaDefault)) : this._optionBackup = W;
    }, H.prototype.mountOption = function(C) {
      var G = this._optionBackup;
      return this._timelineOptions = G.timelineOptions, this._mediaList = G.mediaList, this._mediaDefault = G.mediaDefault, this._currentMediaIndices = [], clone$4(C ? G.baseOption : this._newBaseOption);
    }, H.prototype.getTimelineOption = function(C) {
      var G, U = this._timelineOptions;
      if (U.length) {
        var K = C.getComponent("timeline");
        K && (G = clone$4(
          // FIXME:TS as TimelineModel or quivlant interface
          U[K.getCurrentIndex()]
        ));
      }
      return G;
    }, H.prototype.getMediaOption = function(C) {
      var G = this._api.getWidth(), U = this._api.getHeight(), K = this._mediaList, W = this._mediaDefault, Z = [], X = [];
      if (!K.length && !W)
        return X;
      for (var Q = 0, ee = K.length; Q < ee; Q++)
        applyMediaQuery(K[Q].query, G, U) && Z.push(Q);
      return !Z.length && W && (Z = [-1]), Z.length && !indicesEquals(Z, this._currentMediaIndices) && (X = map$1(Z, function(te) {
        return clone$4(te === -1 ? W.option : K[te].option);
      })), this._currentMediaIndices = Z, X;
    }, H;
  }()
);
function parseRawOption(H, C, G) {
  var U = [], K, W, Z = H.baseOption, X = H.timeline, Q = H.options, ee = H.media, te = !!H.media, re = !!(Q || X || Z && Z.timeline);
  Z ? (W = Z, W.timeline || (W.timeline = X)) : ((re || te) && (H.options = H.media = null), W = H), te && (isArray$1(ee) ? each$f(ee, function(ae) {
    process.env.NODE_ENV !== "production" && ae && !ae.option && isObject$3(ae.query) && isObject$3(ae.query.option) && error("Illegal media option. Must be like { media: [ { query: {}, option: {} } ] }"), ae && ae.option && (ae.query ? U.push(ae) : K || (K = ae));
  }) : process.env.NODE_ENV !== "production" && error("Illegal media option. Must be an array. Like { media: [ {...}, {...} ] }")), ne(W), each$f(Q, function(ae) {
    return ne(ae);
  }), each$f(U, function(ae) {
    return ne(ae.option);
  });
  function ne(ae) {
    each$f(C, function(ie) {
      ie(ae, G);
    });
  }
  return {
    baseOption: W,
    timelineOptions: Q || [],
    mediaDefault: K,
    mediaList: U
  };
}
function applyMediaQuery(H, C, G) {
  var U = {
    width: C,
    height: G,
    aspectratio: C / G
    // lower case for convenience.
  }, K = !0;
  return each$f(H, function(W, Z) {
    var X = Z.match(QUERY_REG);
    if (!(!X || !X[1] || !X[2])) {
      var Q = X[1], ee = X[2].toLowerCase();
      compare(U[ee], W, Q) || (K = !1);
    }
  }), K;
}
function compare(H, C, G) {
  return G === "min" ? H >= C : G === "max" ? H <= C : H === C;
}
function indicesEquals(H, C) {
  return H.join(",") === C.join(",");
}
const OptionManager$1 = OptionManager;
var each$d = each$f, isObject$2 = isObject$3, POSSIBLE_STYLES = ["areaStyle", "lineStyle", "nodeStyle", "linkStyle", "chordStyle", "label", "labelLine"];
function compatEC2ItemStyle(H) {
  var C = H && H.itemStyle;
  if (C)
    for (var G = 0, U = POSSIBLE_STYLES.length; G < U; G++) {
      var K = POSSIBLE_STYLES[G], W = C.normal, Z = C.emphasis;
      W && W[K] && (process.env.NODE_ENV !== "production" && deprecateReplaceLog("itemStyle.normal." + K, K), H[K] = H[K] || {}, H[K].normal ? merge(H[K].normal, W[K]) : H[K].normal = W[K], W[K] = null), Z && Z[K] && (process.env.NODE_ENV !== "production" && deprecateReplaceLog("itemStyle.emphasis." + K, "emphasis." + K), H[K] = H[K] || {}, H[K].emphasis ? merge(H[K].emphasis, Z[K]) : H[K].emphasis = Z[K], Z[K] = null);
    }
}
function convertNormalEmphasis(H, C, G) {
  if (H && H[C] && (H[C].normal || H[C].emphasis)) {
    var U = H[C].normal, K = H[C].emphasis;
    U && (process.env.NODE_ENV !== "production" && deprecateLog("'normal' hierarchy in " + C + " has been removed since 4.0. All style properties are configured in " + C + " directly now."), G ? (H[C].normal = H[C].emphasis = null, defaults(H[C], U)) : H[C] = U), K && (process.env.NODE_ENV !== "production" && deprecateLog(C + ".emphasis has been changed to emphasis." + C + " since 4.0"), H.emphasis = H.emphasis || {}, H.emphasis[C] = K, K.focus && (H.emphasis.focus = K.focus), K.blurScope && (H.emphasis.blurScope = K.blurScope));
  }
}
function removeEC3NormalStatus(H) {
  convertNormalEmphasis(H, "itemStyle"), convertNormalEmphasis(H, "lineStyle"), convertNormalEmphasis(H, "areaStyle"), convertNormalEmphasis(H, "label"), convertNormalEmphasis(H, "labelLine"), convertNormalEmphasis(H, "upperLabel"), convertNormalEmphasis(H, "edgeLabel");
}
function compatTextStyle(H, C) {
  var G = isObject$2(H) && H[C], U = isObject$2(G) && G.textStyle;
  if (U) {
    process.env.NODE_ENV !== "production" && deprecateLog("textStyle hierarchy in " + C + " has been removed since 4.0. All textStyle properties are configured in " + C + " directly now.");
    for (var K = 0, W = TEXT_STYLE_OPTIONS.length; K < W; K++) {
      var Z = TEXT_STYLE_OPTIONS[K];
      U.hasOwnProperty(Z) && (G[Z] = U[Z]);
    }
  }
}
function compatEC3CommonStyles(H) {
  H && (removeEC3NormalStatus(H), compatTextStyle(H, "label"), H.emphasis && compatTextStyle(H.emphasis, "label"));
}
function processSeries(H) {
  if (isObject$2(H)) {
    compatEC2ItemStyle(H), removeEC3NormalStatus(H), compatTextStyle(H, "label"), compatTextStyle(H, "upperLabel"), compatTextStyle(H, "edgeLabel"), H.emphasis && (compatTextStyle(H.emphasis, "label"), compatTextStyle(H.emphasis, "upperLabel"), compatTextStyle(H.emphasis, "edgeLabel"));
    var C = H.markPoint;
    C && (compatEC2ItemStyle(C), compatEC3CommonStyles(C));
    var G = H.markLine;
    G && (compatEC2ItemStyle(G), compatEC3CommonStyles(G));
    var U = H.markArea;
    U && compatEC3CommonStyles(U);
    var K = H.data;
    if (H.type === "graph") {
      K = K || H.nodes;
      var W = H.links || H.edges;
      if (W && !isTypedArray(W))
        for (var Z = 0; Z < W.length; Z++)
          compatEC3CommonStyles(W[Z]);
      each$f(H.categories, function(ee) {
        removeEC3NormalStatus(ee);
      });
    }
    if (K && !isTypedArray(K))
      for (var Z = 0; Z < K.length; Z++)
        compatEC3CommonStyles(K[Z]);
    if (C = H.markPoint, C && C.data)
      for (var X = C.data, Z = 0; Z < X.length; Z++)
        compatEC3CommonStyles(X[Z]);
    if (G = H.markLine, G && G.data)
      for (var Q = G.data, Z = 0; Z < Q.length; Z++)
        isArray$1(Q[Z]) ? (compatEC3CommonStyles(Q[Z][0]), compatEC3CommonStyles(Q[Z][1])) : compatEC3CommonStyles(Q[Z]);
    H.type === "gauge" ? (compatTextStyle(H, "axisLabel"), compatTextStyle(H, "title"), compatTextStyle(H, "detail")) : H.type === "treemap" ? (convertNormalEmphasis(H.breadcrumb, "itemStyle"), each$f(H.levels, function(ee) {
      removeEC3NormalStatus(ee);
    })) : H.type === "tree" && removeEC3NormalStatus(H.leaves);
  }
}
function toArr(H) {
  return isArray$1(H) ? H : H ? [H] : [];
}
function toObj(H) {
  return (isArray$1(H) ? H[0] : H) || {};
}
function globalCompatStyle(H, C) {
  each$d(toArr(H.series), function(U) {
    isObject$2(U) && processSeries(U);
  });
  var G = ["xAxis", "yAxis", "radiusAxis", "angleAxis", "singleAxis", "parallelAxis", "radar"];
  C && G.push("valueAxis", "categoryAxis", "logAxis", "timeAxis"), each$d(G, function(U) {
    each$d(toArr(H[U]), function(K) {
      K && (compatTextStyle(K, "axisLabel"), compatTextStyle(K.axisPointer, "label"));
    });
  }), each$d(toArr(H.parallel), function(U) {
    var K = U && U.parallelAxisDefault;
    compatTextStyle(K, "axisLabel"), compatTextStyle(K && K.axisPointer, "label");
  }), each$d(toArr(H.calendar), function(U) {
    convertNormalEmphasis(U, "itemStyle"), compatTextStyle(U, "dayLabel"), compatTextStyle(U, "monthLabel"), compatTextStyle(U, "yearLabel");
  }), each$d(toArr(H.radar), function(U) {
    compatTextStyle(U, "name"), U.name && U.axisName == null && (U.axisName = U.name, delete U.name, process.env.NODE_ENV !== "production" && deprecateLog("name property in radar component has been changed to axisName")), U.nameGap != null && U.axisNameGap == null && (U.axisNameGap = U.nameGap, delete U.nameGap, process.env.NODE_ENV !== "production" && deprecateLog("nameGap property in radar component has been changed to axisNameGap")), process.env.NODE_ENV !== "production" && each$d(U.indicator, function(K) {
      K.text && deprecateReplaceLog("text", "name", "radar.indicator");
    });
  }), each$d(toArr(H.geo), function(U) {
    isObject$2(U) && (compatEC3CommonStyles(U), each$d(toArr(U.regions), function(K) {
      compatEC3CommonStyles(K);
    }));
  }), each$d(toArr(H.timeline), function(U) {
    compatEC3CommonStyles(U), convertNormalEmphasis(U, "label"), convertNormalEmphasis(U, "itemStyle"), convertNormalEmphasis(U, "controlStyle", !0);
    var K = U.data;
    isArray$1(K) && each$f(K, function(W) {
      isObject$3(W) && (convertNormalEmphasis(W, "label"), convertNormalEmphasis(W, "itemStyle"));
    });
  }), each$d(toArr(H.toolbox), function(U) {
    convertNormalEmphasis(U, "iconStyle"), each$d(U.feature, function(K) {
      convertNormalEmphasis(K, "iconStyle");
    });
  }), compatTextStyle(toObj(H.axisPointer), "label"), compatTextStyle(toObj(H.tooltip).axisPointer, "label");
}
function get(H, C) {
  for (var G = C.split(","), U = H, K = 0; K < G.length && (U = U && U[G[K]], U != null); K++)
    ;
  return U;
}
function set(H, C, G, U) {
  for (var K = C.split(","), W = H, Z, X = 0; X < K.length - 1; X++)
    Z = K[X], W[Z] == null && (W[Z] = {}), W = W[Z];
  (U || W[K[X]] == null) && (W[K[X]] = G);
}
function compatLayoutProperties(H) {
  H && each$f(LAYOUT_PROPERTIES, function(C) {
    C[0] in H && !(C[1] in H) && (H[C[1]] = H[C[0]]);
  });
}
var LAYOUT_PROPERTIES = [["x", "left"], ["y", "top"], ["x2", "right"], ["y2", "bottom"]], COMPATITABLE_COMPONENTS = ["grid", "geo", "parallel", "legend", "toolbox", "title", "visualMap", "dataZoom", "timeline"], BAR_ITEM_STYLE_MAP = [["borderRadius", "barBorderRadius"], ["borderColor", "barBorderColor"], ["borderWidth", "barBorderWidth"]];
function compatBarItemStyle(H) {
  var C = H && H.itemStyle;
  if (C)
    for (var G = 0; G < BAR_ITEM_STYLE_MAP.length; G++) {
      var U = BAR_ITEM_STYLE_MAP[G][1], K = BAR_ITEM_STYLE_MAP[G][0];
      C[U] != null && (C[K] = C[U], process.env.NODE_ENV !== "production" && deprecateReplaceLog(U, K));
    }
}
function compatPieLabel(H) {
  H && H.alignTo === "edge" && H.margin != null && H.edgeDistance == null && (process.env.NODE_ENV !== "production" && deprecateReplaceLog("label.margin", "label.edgeDistance", "pie"), H.edgeDistance = H.margin);
}
function compatSunburstState(H) {
  H && H.downplay && !H.blur && (H.blur = H.downplay, process.env.NODE_ENV !== "production" && deprecateReplaceLog("downplay", "blur", "sunburst"));
}
function compatGraphFocus(H) {
  H && H.focusNodeAdjacency != null && (H.emphasis = H.emphasis || {}, H.emphasis.focus == null && (process.env.NODE_ENV !== "production" && deprecateReplaceLog("focusNodeAdjacency", "emphasis: { focus: 'adjacency'}", "graph/sankey"), H.emphasis.focus = "adjacency"));
}
function traverseTree(H, C) {
  if (H)
    for (var G = 0; G < H.length; G++)
      C(H[G]), H[G] && traverseTree(H[G].children, C);
}
function globalBackwardCompat(H, C) {
  globalCompatStyle(H, C), H.series = normalizeToArray(H.series), each$f(H.series, function(G) {
    if (isObject$3(G)) {
      var U = G.type;
      if (U === "line")
        G.clipOverflow != null && (G.clip = G.clipOverflow, process.env.NODE_ENV !== "production" && deprecateReplaceLog("clipOverflow", "clip", "line"));
      else if (U === "pie" || U === "gauge") {
        G.clockWise != null && (G.clockwise = G.clockWise, process.env.NODE_ENV !== "production" && deprecateReplaceLog("clockWise", "clockwise")), compatPieLabel(G.label);
        var K = G.data;
        if (K && !isTypedArray(K))
          for (var W = 0; W < K.length; W++)
            compatPieLabel(K[W]);
        G.hoverOffset != null && (G.emphasis = G.emphasis || {}, (G.emphasis.scaleSize = null) && (process.env.NODE_ENV !== "production" && deprecateReplaceLog("hoverOffset", "emphasis.scaleSize"), G.emphasis.scaleSize = G.hoverOffset));
      } else if (U === "gauge") {
        var Z = get(G, "pointer.color");
        Z != null && set(G, "itemStyle.color", Z);
      } else if (U === "bar") {
        compatBarItemStyle(G), compatBarItemStyle(G.backgroundStyle), compatBarItemStyle(G.emphasis);
        var K = G.data;
        if (K && !isTypedArray(K))
          for (var W = 0; W < K.length; W++)
            typeof K[W] == "object" && (compatBarItemStyle(K[W]), compatBarItemStyle(K[W] && K[W].emphasis));
      } else if (U === "sunburst") {
        var X = G.highlightPolicy;
        X && (G.emphasis = G.emphasis || {}, G.emphasis.focus || (G.emphasis.focus = X, process.env.NODE_ENV !== "production" && deprecateReplaceLog("highlightPolicy", "emphasis.focus", "sunburst"))), compatSunburstState(G), traverseTree(G.data, compatSunburstState);
      } else
        U === "graph" || U === "sankey" ? compatGraphFocus(G) : U === "map" && (G.mapType && !G.map && (process.env.NODE_ENV !== "production" && deprecateReplaceLog("mapType", "map", "map"), G.map = G.mapType), G.mapLocation && (process.env.NODE_ENV !== "production" && deprecateLog("`mapLocation` is not used anymore."), defaults(G, G.mapLocation)));
      G.hoverAnimation != null && (G.emphasis = G.emphasis || {}, G.emphasis && G.emphasis.scale == null && (process.env.NODE_ENV !== "production" && deprecateReplaceLog("hoverAnimation", "emphasis.scale"), G.emphasis.scale = G.hoverAnimation)), compatLayoutProperties(G);
    }
  }), H.dataRange && (H.visualMap = H.dataRange), each$f(COMPATITABLE_COMPONENTS, function(G) {
    var U = H[G];
    U && (isArray$1(U) || (U = [U]), each$f(U, function(K) {
      compatLayoutProperties(K);
    }));
  });
}
function dataStack(H) {
  var C = createHashMap();
  H.eachSeries(function(G) {
    var U = G.get("stack");
    if (U) {
      var K = C.get(U) || C.set(U, []), W = G.getData(), Z = {
        // Used for calculate axis extent automatically.
        // TODO: Type getCalculationInfo return more specific type?
        stackResultDimension: W.getCalculationInfo("stackResultDimension"),
        stackedOverDimension: W.getCalculationInfo("stackedOverDimension"),
        stackedDimension: W.getCalculationInfo("stackedDimension"),
        stackedByDimension: W.getCalculationInfo("stackedByDimension"),
        isStackedByIndex: W.getCalculationInfo("isStackedByIndex"),
        data: W,
        seriesModel: G
      };
      if (!Z.stackedDimension || !(Z.isStackedByIndex || Z.stackedByDimension))
        return;
      K.length && W.setCalculationInfo("stackedOnSeries", K[K.length - 1].seriesModel), K.push(Z);
    }
  }), C.each(calculateStack);
}
function calculateStack(H) {
  each$f(H, function(C, G) {
    var U = [], K = [NaN, NaN], W = [C.stackResultDimension, C.stackedOverDimension], Z = C.data, X = C.isStackedByIndex, Q = C.seriesModel.get("stackStrategy") || "samesign";
    Z.modify(W, function(ee, te, re) {
      var ne = Z.get(C.stackedDimension, re);
      if (isNaN(ne))
        return K;
      var ae, ie;
      X ? ie = Z.getRawIndex(re) : ae = Z.get(C.stackedByDimension, re);
      for (var se = NaN, oe = G - 1; oe >= 0; oe--) {
        var le = H[oe];
        if (X || (ie = le.data.rawIndexOf(le.stackedByDimension, ae)), ie >= 0) {
          var ue = le.data.getByRawIndex(le.stackResultDimension, ie);
          if (Q === "all" || Q === "positive" && ue > 0 || Q === "negative" && ue < 0 || Q === "samesign" && ne >= 0 && ue > 0 || Q === "samesign" && ne <= 0 && ue < 0) {
            ne = addSafe(ne, ue), se = ue;
            break;
          }
        }
      }
      return U[0] = ne, U[1] = se, U;
    });
  });
}
var SourceImpl = (
  /** @class */
  function() {
    function H(C) {
      this.data = C.data || (C.sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS ? {} : []), this.sourceFormat = C.sourceFormat || SOURCE_FORMAT_UNKNOWN, this.seriesLayoutBy = C.seriesLayoutBy || SERIES_LAYOUT_BY_COLUMN, this.startIndex = C.startIndex || 0, this.dimensionsDetectedCount = C.dimensionsDetectedCount, this.metaRawOption = C.metaRawOption;
      var G = this.dimensionsDefine = C.dimensionsDefine;
      if (G)
        for (var U = 0; U < G.length; U++) {
          var K = G[U];
          K.type == null && guessOrdinal(this, U) === BE_ORDINAL.Must && (K.type = "ordinal");
        }
    }
    return H;
  }()
);
function isSourceInstance(H) {
  return H instanceof SourceImpl;
}
function createSource(H, C, G) {
  G = G || detectSourceFormat(H);
  var U = C.seriesLayoutBy, K = determineSourceDimensions(H, G, U, C.sourceHeader, C.dimensions), W = new SourceImpl({
    data: H,
    sourceFormat: G,
    seriesLayoutBy: U,
    dimensionsDefine: K.dimensionsDefine,
    startIndex: K.startIndex,
    dimensionsDetectedCount: K.dimensionsDetectedCount,
    metaRawOption: clone$4(C)
  });
  return W;
}
function createSourceFromSeriesDataOption(H) {
  return new SourceImpl({
    data: H,
    sourceFormat: isTypedArray(H) ? SOURCE_FORMAT_TYPED_ARRAY : SOURCE_FORMAT_ORIGINAL
  });
}
function cloneSourceShallow(H) {
  return new SourceImpl({
    data: H.data,
    sourceFormat: H.sourceFormat,
    seriesLayoutBy: H.seriesLayoutBy,
    dimensionsDefine: clone$4(H.dimensionsDefine),
    startIndex: H.startIndex,
    dimensionsDetectedCount: H.dimensionsDetectedCount
  });
}
function detectSourceFormat(H) {
  var C = SOURCE_FORMAT_UNKNOWN;
  if (isTypedArray(H))
    C = SOURCE_FORMAT_TYPED_ARRAY;
  else if (isArray$1(H)) {
    H.length === 0 && (C = SOURCE_FORMAT_ARRAY_ROWS);
    for (var G = 0, U = H.length; G < U; G++) {
      var K = H[G];
      if (K != null) {
        if (isArray$1(K)) {
          C = SOURCE_FORMAT_ARRAY_ROWS;
          break;
        } else if (isObject$3(K)) {
          C = SOURCE_FORMAT_OBJECT_ROWS;
          break;
        }
      }
    }
  } else if (isObject$3(H)) {
    for (var W in H)
      if (hasOwn(H, W) && isArrayLike(H[W])) {
        C = SOURCE_FORMAT_KEYED_COLUMNS;
        break;
      }
  }
  return C;
}
function determineSourceDimensions(H, C, G, U, K) {
  var W, Z;
  if (!H)
    return {
      dimensionsDefine: normalizeDimensionsOption(K),
      startIndex: Z,
      dimensionsDetectedCount: W
    };
  if (C === SOURCE_FORMAT_ARRAY_ROWS) {
    var X = H;
    U === "auto" || U == null ? arrayRowsTravelFirst(function(ee) {
      ee != null && ee !== "-" && (isString(ee) ? Z == null && (Z = 1) : Z = 0);
    }, G, X, 10) : Z = isNumber(U) ? U : U ? 1 : 0, !K && Z === 1 && (K = [], arrayRowsTravelFirst(function(ee, te) {
      K[te] = ee != null ? ee + "" : "";
    }, G, X, 1 / 0)), W = K ? K.length : G === SERIES_LAYOUT_BY_ROW ? X.length : X[0] ? X[0].length : null;
  } else if (C === SOURCE_FORMAT_OBJECT_ROWS)
    K || (K = objectRowsCollectDimensions(H));
  else if (C === SOURCE_FORMAT_KEYED_COLUMNS)
    K || (K = [], each$f(H, function(ee, te) {
      K.push(te);
    }));
  else if (C === SOURCE_FORMAT_ORIGINAL) {
    var Q = getDataItemValue(H[0]);
    W = isArray$1(Q) && Q.length || 1;
  } else
    C === SOURCE_FORMAT_TYPED_ARRAY && process.env.NODE_ENV !== "production" && assert(!!K, "dimensions must be given if data is TypedArray.");
  return {
    startIndex: Z,
    dimensionsDefine: normalizeDimensionsOption(K),
    dimensionsDetectedCount: W
  };
}
function objectRowsCollectDimensions(H) {
  for (var C = 0, G; C < H.length && !(G = H[C++]); )
    ;
  if (G) {
    var U = [];
    return each$f(G, function(K, W) {
      U.push(W);
    }), U;
  }
}
function normalizeDimensionsOption(H) {
  if (H) {
    var C = createHashMap();
    return map$1(H, function(G, U) {
      G = isObject$3(G) ? G : {
        name: G
      };
      var K = {
        name: G.name,
        displayName: G.displayName,
        type: G.type
      };
      if (K.name == null)
        return K;
      K.name += "", K.displayName == null && (K.displayName = K.name);
      var W = C.get(K.name);
      return W ? K.name += "-" + W.count++ : C.set(K.name, {
        count: 1
      }), K;
    });
  }
}
function arrayRowsTravelFirst(H, C, G, U) {
  if (C === SERIES_LAYOUT_BY_ROW)
    for (var K = 0; K < G.length && K < U; K++)
      H(G[K] ? G[K][0] : null, K);
  else
    for (var W = G[0] || [], K = 0; K < W.length && K < U; K++)
      H(W[K], K);
}
function shouldRetrieveDataByName(H) {
  var C = H.sourceFormat;
  return C === SOURCE_FORMAT_OBJECT_ROWS || C === SOURCE_FORMAT_KEYED_COLUMNS;
}
var _a, _b, _c, providerMethods, mountMethods, DefaultDataProvider = (
  /** @class */
  function() {
    function H(C, G) {
      var U = isSourceInstance(C) ? C : createSourceFromSeriesDataOption(C);
      this._source = U;
      var K = this._data = U.data;
      if (U.sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {
        if (process.env.NODE_ENV !== "production" && G == null)
          throw new Error("Typed array data must specify dimension size");
        this._offset = 0, this._dimSize = G, this._data = K;
      }
      mountMethods(this, K, U);
    }
    return H.prototype.getSource = function() {
      return this._source;
    }, H.prototype.count = function() {
      return 0;
    }, H.prototype.getItem = function(C, G) {
    }, H.prototype.appendData = function(C) {
    }, H.prototype.clean = function() {
    }, H.protoInitialize = function() {
      var C = H.prototype;
      C.pure = !1, C.persistent = !0;
    }(), H.internalField = function() {
      var C;
      mountMethods = function(Z, X, Q) {
        var ee = Q.sourceFormat, te = Q.seriesLayoutBy, re = Q.startIndex, ne = Q.dimensionsDefine, ae = providerMethods[getMethodMapKey(ee, te)];
        if (process.env.NODE_ENV !== "production" && assert(ae, "Invalide sourceFormat: " + ee), extend(Z, ae), ee === SOURCE_FORMAT_TYPED_ARRAY)
          Z.getItem = G, Z.count = K, Z.fillStorage = U;
        else {
          var ie = getRawSourceItemGetter(ee, te);
          Z.getItem = bind$1(ie, null, X, re, ne);
          var se = getRawSourceDataCounter(ee, te);
          Z.count = bind$1(se, null, X, re, ne);
        }
      };
      var G = function(Z, X) {
        Z = Z - this._offset, X = X || [];
        for (var Q = this._data, ee = this._dimSize, te = ee * Z, re = 0; re < ee; re++)
          X[re] = Q[te + re];
        return X;
      }, U = function(Z, X, Q, ee) {
        for (var te = this._data, re = this._dimSize, ne = 0; ne < re; ne++) {
          for (var ae = ee[ne], ie = ae[0] == null ? 1 / 0 : ae[0], se = ae[1] == null ? -1 / 0 : ae[1], oe = X - Z, le = Q[ne], ue = 0; ue < oe; ue++) {
            var ce = te[ue * re + ne];
            le[Z + ue] = ce, ce < ie && (ie = ce), ce > se && (se = ce);
          }
          ae[0] = ie, ae[1] = se;
        }
      }, K = function() {
        return this._data ? this._data.length / this._dimSize : 0;
      };
      providerMethods = (C = {}, C[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_COLUMN] = {
        pure: !0,
        appendData: W
      }, C[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_ROW] = {
        pure: !0,
        appendData: function() {
          throw new Error('Do not support appendData when set seriesLayoutBy: "row".');
        }
      }, C[SOURCE_FORMAT_OBJECT_ROWS] = {
        pure: !0,
        appendData: W
      }, C[SOURCE_FORMAT_KEYED_COLUMNS] = {
        pure: !0,
        appendData: function(Z) {
          var X = this._data;
          each$f(Z, function(Q, ee) {
            for (var te = X[ee] || (X[ee] = []), re = 0; re < (Q || []).length; re++)
              te.push(Q[re]);
          });
        }
      }, C[SOURCE_FORMAT_ORIGINAL] = {
        appendData: W
      }, C[SOURCE_FORMAT_TYPED_ARRAY] = {
        persistent: !1,
        pure: !0,
        appendData: function(Z) {
          process.env.NODE_ENV !== "production" && assert(isTypedArray(Z), "Added data must be TypedArray if data in initialization is TypedArray"), this._data = Z;
        },
        // Clean self if data is already used.
        clean: function() {
          this._offset += this.count(), this._data = null;
        }
      }, C);
      function W(Z) {
        for (var X = 0; X < Z.length; X++)
          this._data.push(Z[X]);
      }
    }(), H;
  }()
), getItemSimply = function(H, C, G, U) {
  return H[U];
}, rawSourceItemGetterMap = (_a = {}, _a[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_COLUMN] = function(H, C, G, U) {
  return H[U + C];
}, _a[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_ROW] = function(H, C, G, U, K) {
  U += C;
  for (var W = K || [], Z = H, X = 0; X < Z.length; X++) {
    var Q = Z[X];
    W[X] = Q ? Q[U] : null;
  }
  return W;
}, _a[SOURCE_FORMAT_OBJECT_ROWS] = getItemSimply, _a[SOURCE_FORMAT_KEYED_COLUMNS] = function(H, C, G, U, K) {
  for (var W = K || [], Z = 0; Z < G.length; Z++) {
    var X = G[Z].name;
    if (process.env.NODE_ENV !== "production" && X == null)
      throw new Error();
    var Q = H[X];
    W[Z] = Q ? Q[U] : null;
  }
  return W;
}, _a[SOURCE_FORMAT_ORIGINAL] = getItemSimply, _a);
function getRawSourceItemGetter(H, C) {
  var G = rawSourceItemGetterMap[getMethodMapKey(H, C)];
  return process.env.NODE_ENV !== "production" && assert(G, 'Do not support get item on "' + H + '", "' + C + '".'), G;
}
var countSimply = function(H, C, G) {
  return H.length;
}, rawSourceDataCounterMap = (_b = {}, _b[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_COLUMN] = function(H, C, G) {
  return Math.max(0, H.length - C);
}, _b[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_ROW] = function(H, C, G) {
  var U = H[0];
  return U ? Math.max(0, U.length - C) : 0;
}, _b[SOURCE_FORMAT_OBJECT_ROWS] = countSimply, _b[SOURCE_FORMAT_KEYED_COLUMNS] = function(H, C, G) {
  var U = G[0].name;
  if (process.env.NODE_ENV !== "production" && U == null)
    throw new Error();
  var K = H[U];
  return K ? K.length : 0;
}, _b[SOURCE_FORMAT_ORIGINAL] = countSimply, _b);
function getRawSourceDataCounter(H, C) {
  var G = rawSourceDataCounterMap[getMethodMapKey(H, C)];
  return process.env.NODE_ENV !== "production" && assert(G, 'Do not support count on "' + H + '", "' + C + '".'), G;
}
var getRawValueSimply = function(H, C, G) {
  return H[C];
}, rawSourceValueGetterMap = (_c = {}, _c[SOURCE_FORMAT_ARRAY_ROWS] = getRawValueSimply, _c[SOURCE_FORMAT_OBJECT_ROWS] = function(H, C, G) {
  return H[G];
}, _c[SOURCE_FORMAT_KEYED_COLUMNS] = getRawValueSimply, _c[SOURCE_FORMAT_ORIGINAL] = function(H, C, G) {
  var U = getDataItemValue(H);
  return U instanceof Array ? U[C] : U;
}, _c[SOURCE_FORMAT_TYPED_ARRAY] = getRawValueSimply, _c);
function getRawSourceValueGetter(H) {
  var C = rawSourceValueGetterMap[H];
  return process.env.NODE_ENV !== "production" && assert(C, 'Do not support get value on "' + H + '".'), C;
}
function getMethodMapKey(H, C) {
  return H === SOURCE_FORMAT_ARRAY_ROWS ? H + "_" + C : H;
}
function retrieveRawValue(H, C, G) {
  if (H) {
    var U = H.getRawDataItem(C);
    if (U != null) {
      var K = H.getStore(), W = K.getSource().sourceFormat;
      if (G != null) {
        var Z = H.getDimensionIndex(G), X = K.getDimensionProperty(Z);
        return getRawSourceValueGetter(W)(U, Z, X);
      } else {
        var Q = U;
        return W === SOURCE_FORMAT_ORIGINAL && (Q = getDataItemValue(U)), Q;
      }
    }
  }
}
var DIMENSION_LABEL_REG = /\{@(.+?)\}/g, DataFormatMixin = (
  /** @class */
  function() {
    function H() {
    }
    return H.prototype.getDataParams = function(C, G) {
      var U = this.getData(G), K = this.getRawValue(C, G), W = U.getRawIndex(C), Z = U.getName(C), X = U.getRawDataItem(C), Q = U.getItemVisual(C, "style"), ee = Q && Q[U.getItemVisual(C, "drawType") || "fill"], te = Q && Q.stroke, re = this.mainType, ne = re === "series", ae = U.userOutput && U.userOutput.get();
      return {
        componentType: re,
        componentSubType: this.subType,
        componentIndex: this.componentIndex,
        seriesType: ne ? this.subType : null,
        seriesIndex: this.seriesIndex,
        seriesId: ne ? this.id : null,
        seriesName: ne ? this.name : null,
        name: Z,
        dataIndex: W,
        data: X,
        dataType: G,
        value: K,
        color: ee,
        borderColor: te,
        dimensionNames: ae ? ae.fullDimensions : null,
        encode: ae ? ae.encode : null,
        // Param name list for mapping `a`, `b`, `c`, `d`, `e`
        $vars: ["seriesName", "name", "value"]
      };
    }, H.prototype.getFormattedLabel = function(C, G, U, K, W, Z) {
      G = G || "normal";
      var X = this.getData(U), Q = this.getDataParams(C, U);
      if (Z && (Q.value = Z.interpolatedValue), K != null && isArray$1(Q.value) && (Q.value = Q.value[K]), !W) {
        var ee = X.getItemModel(C);
        W = ee.get(G === "normal" ? ["label", "formatter"] : [G, "label", "formatter"]);
      }
      if (isFunction(W))
        return Q.status = G, Q.dimensionIndex = K, W(Q);
      if (isString(W)) {
        var te = formatTpl(W, Q);
        return te.replace(DIMENSION_LABEL_REG, function(re, ne) {
          var ae = ne.length, ie = ne;
          ie.charAt(0) === "[" && ie.charAt(ae - 1) === "]" && (ie = +ie.slice(1, ae - 1), process.env.NODE_ENV !== "production" && isNaN(ie) && error("Invalide label formatter: @" + ne + ", only support @[0], @[1], @[2], ..."));
          var se = retrieveRawValue(X, C, ie);
          if (Z && isArray$1(Z.interpolatedValue)) {
            var oe = X.getDimensionIndex(ie);
            oe >= 0 && (se = Z.interpolatedValue[oe]);
          }
          return se != null ? se + "" : "";
        });
      }
    }, H.prototype.getRawValue = function(C, G) {
      return retrieveRawValue(this.getData(G), C);
    }, H.prototype.formatTooltip = function(C, G, U) {
    }, H;
  }()
);
function normalizeTooltipFormatResult(H) {
  var C, G;
  return isObject$3(H) ? H.type ? G = H : process.env.NODE_ENV !== "production" && console.warn("The return type of `formatTooltip` is not supported: " + makePrintable(H)) : C = H, {
    text: C,
    // markers: markers || markersExisting,
    frag: G
  };
}
function createTask(H) {
  return new Task(H);
}
var Task = (
  /** @class */
  function() {
    function H(C) {
      C = C || {}, this._reset = C.reset, this._plan = C.plan, this._count = C.count, this._onDirty = C.onDirty, this._dirty = !0;
    }
    return H.prototype.perform = function(C) {
      var G = this._upstream, U = C && C.skip;
      if (this._dirty && G) {
        var K = this.context;
        K.data = K.outputData = G.context.outputData;
      }
      this.__pipeline && (this.__pipeline.currentTask = this);
      var W;
      this._plan && !U && (W = this._plan(this.context));
      var Z = te(this._modBy), X = this._modDataCount || 0, Q = te(C && C.modBy), ee = C && C.modDataCount || 0;
      (Z !== Q || X !== ee) && (W = "reset");
      function te(ue) {
        return !(ue >= 1) && (ue = 1), ue;
      }
      var re;
      (this._dirty || W === "reset") && (this._dirty = !1, re = this._doReset(U)), this._modBy = Q, this._modDataCount = ee;
      var ne = C && C.step;
      if (G ? (process.env.NODE_ENV !== "production" && assert(G._outputDueEnd != null), this._dueEnd = G._outputDueEnd) : (process.env.NODE_ENV !== "production" && assert(!this._progress || this._count), this._dueEnd = this._count ? this._count(this.context) : 1 / 0), this._progress) {
        var ae = this._dueIndex, ie = Math.min(ne != null ? this._dueIndex + ne : 1 / 0, this._dueEnd);
        if (!U && (re || ae < ie)) {
          var se = this._progress;
          if (isArray$1(se))
            for (var oe = 0; oe < se.length; oe++)
              this._doProgress(se[oe], ae, ie, Q, ee);
          else
            this._doProgress(se, ae, ie, Q, ee);
        }
        this._dueIndex = ie;
        var le = this._settedOutputEnd != null ? this._settedOutputEnd : ie;
        process.env.NODE_ENV !== "production" && assert(le >= this._outputDueEnd), this._outputDueEnd = le;
      } else
        this._dueIndex = this._outputDueEnd = this._settedOutputEnd != null ? this._settedOutputEnd : this._dueEnd;
      return this.unfinished();
    }, H.prototype.dirty = function() {
      this._dirty = !0, this._onDirty && this._onDirty(this.context);
    }, H.prototype._doProgress = function(C, G, U, K, W) {
      iterator.reset(G, U, K, W), this._callingProgress = C, this._callingProgress({
        start: G,
        end: U,
        count: U - G,
        next: iterator.next
      }, this.context);
    }, H.prototype._doReset = function(C) {
      this._dueIndex = this._outputDueEnd = this._dueEnd = 0, this._settedOutputEnd = null;
      var G, U;
      !C && this._reset && (G = this._reset(this.context), G && G.progress && (U = G.forceFirstProgress, G = G.progress), isArray$1(G) && !G.length && (G = null)), this._progress = G, this._modBy = this._modDataCount = null;
      var K = this._downstream;
      return K && K.dirty(), U;
    }, H.prototype.unfinished = function() {
      return this._progress && this._dueIndex < this._dueEnd;
    }, H.prototype.pipe = function(C) {
      process.env.NODE_ENV !== "production" && assert(C && !C._disposed && C !== this), (this._downstream !== C || this._dirty) && (this._downstream = C, C._upstream = this, C.dirty());
    }, H.prototype.dispose = function() {
      this._disposed || (this._upstream && (this._upstream._downstream = null), this._downstream && (this._downstream._upstream = null), this._dirty = !1, this._disposed = !0);
    }, H.prototype.getUpstream = function() {
      return this._upstream;
    }, H.prototype.getDownstream = function() {
      return this._downstream;
    }, H.prototype.setOutputEnd = function(C) {
      this._outputDueEnd = this._settedOutputEnd = C;
    }, H;
  }()
), iterator = function() {
  var H, C, G, U, K, W = {
    reset: function(Q, ee, te, re) {
      C = Q, H = ee, G = te, U = re, K = Math.ceil(U / G), W.next = G > 1 && U > 0 ? X : Z;
    }
  };
  return W;
  function Z() {
    return C < H ? C++ : null;
  }
  function X() {
    var Q = C % K * G + Math.ceil(C / K), ee = C >= H ? null : Q < U ? Q : C;
    return C++, ee;
  }
}();
function parseDataValue(H, C) {
  var G = C && C.type;
  return G === "ordinal" ? H : (G === "time" && !isNumber(H) && H != null && H !== "-" && (H = +parseDate(H)), H == null || H === "" ? NaN : +H);
}
var valueParserMap = createHashMap({
  number: function(H) {
    return parseFloat(H);
  },
  time: function(H) {
    return +parseDate(H);
  },
  trim: function(H) {
    return isString(H) ? trim$1(H) : H;
  }
});
function getRawValueParser(H) {
  return valueParserMap.get(H);
}
var ORDER_COMPARISON_OP_MAP = {
  lt: function(H, C) {
    return H < C;
  },
  lte: function(H, C) {
    return H <= C;
  },
  gt: function(H, C) {
    return H > C;
  },
  gte: function(H, C) {
    return H >= C;
  }
}, FilterOrderComparator = (
  /** @class */
  function() {
    function H(C, G) {
      if (!isNumber(G)) {
        var U = "";
        process.env.NODE_ENV !== "production" && (U = 'rvalue of "<", ">", "<=", ">=" can only be number in filter.'), throwError(U);
      }
      this._opFn = ORDER_COMPARISON_OP_MAP[C], this._rvalFloat = numericToNumber(G);
    }
    return H.prototype.evaluate = function(C) {
      return isNumber(C) ? this._opFn(C, this._rvalFloat) : this._opFn(numericToNumber(C), this._rvalFloat);
    }, H;
  }()
), SortOrderComparator = (
  /** @class */
  function() {
    function H(C, G) {
      var U = C === "desc";
      this._resultLT = U ? 1 : -1, G == null && (G = U ? "min" : "max"), this._incomparable = G === "min" ? -1 / 0 : 1 / 0;
    }
    return H.prototype.evaluate = function(C, G) {
      var U = isNumber(C) ? C : numericToNumber(C), K = isNumber(G) ? G : numericToNumber(G), W = isNaN(U), Z = isNaN(K);
      if (W && (U = this._incomparable), Z && (K = this._incomparable), W && Z) {
        var X = isString(C), Q = isString(G);
        X && (U = Q ? C : 0), Q && (K = X ? G : 0);
      }
      return U < K ? this._resultLT : U > K ? -this._resultLT : 0;
    }, H;
  }()
), FilterEqualityComparator = (
  /** @class */
  function() {
    function H(C, G) {
      this._rval = G, this._isEQ = C, this._rvalTypeof = typeof G, this._rvalFloat = numericToNumber(G);
    }
    return H.prototype.evaluate = function(C) {
      var G = C === this._rval;
      if (!G) {
        var U = typeof C;
        U !== this._rvalTypeof && (U === "number" || this._rvalTypeof === "number") && (G = numericToNumber(C) === this._rvalFloat);
      }
      return this._isEQ ? G : !G;
    }, H;
  }()
);
function createFilterComparator(H, C) {
  return H === "eq" || H === "ne" ? new FilterEqualityComparator(H === "eq", C) : hasOwn(ORDER_COMPARISON_OP_MAP, H) ? new FilterOrderComparator(H, C) : null;
}
var ExternalSource = (
  /** @class */
  function() {
    function H() {
    }
    return H.prototype.getRawData = function() {
      throw new Error("not supported");
    }, H.prototype.getRawDataItem = function(C) {
      throw new Error("not supported");
    }, H.prototype.cloneRawData = function() {
    }, H.prototype.getDimensionInfo = function(C) {
    }, H.prototype.cloneAllDimensionInfo = function() {
    }, H.prototype.count = function() {
    }, H.prototype.retrieveValue = function(C, G) {
    }, H.prototype.retrieveValueFromItem = function(C, G) {
    }, H.prototype.convertValue = function(C, G) {
      return parseDataValue(C, G);
    }, H;
  }()
);
function createExternalSource(H, C) {
  var G = new ExternalSource(), U = H.data, K = G.sourceFormat = H.sourceFormat, W = H.startIndex, Z = "";
  H.seriesLayoutBy !== SERIES_LAYOUT_BY_COLUMN && (process.env.NODE_ENV !== "production" && (Z = '`seriesLayoutBy` of upstream dataset can only be "column" in data transform.'), throwError(Z));
  var X = [], Q = {}, ee = H.dimensionsDefine;
  if (ee)
    each$f(ee, function(se, oe) {
      var le = se.name, ue = {
        index: oe,
        name: le,
        displayName: se.displayName
      };
      if (X.push(ue), le != null) {
        var ce = "";
        hasOwn(Q, le) && (process.env.NODE_ENV !== "production" && (ce = 'dimension name "' + le + '" duplicated.'), throwError(ce)), Q[le] = ue;
      }
    });
  else
    for (var te = 0; te < H.dimensionsDetectedCount; te++)
      X.push({
        index: te
      });
  var re = getRawSourceItemGetter(K, SERIES_LAYOUT_BY_COLUMN);
  C.__isBuiltIn && (G.getRawDataItem = function(se) {
    return re(U, W, X, se);
  }, G.getRawData = bind$1(getRawData, null, H)), G.cloneRawData = bind$1(cloneRawData, null, H);
  var ne = getRawSourceDataCounter(K, SERIES_LAYOUT_BY_COLUMN);
  G.count = bind$1(ne, null, U, W, X);
  var ae = getRawSourceValueGetter(K);
  G.retrieveValue = function(se, oe) {
    var le = re(U, W, X, se);
    return ie(le, oe);
  };
  var ie = G.retrieveValueFromItem = function(se, oe) {
    if (se != null) {
      var le = X[oe];
      if (le)
        return ae(se, oe, le.name);
    }
  };
  return G.getDimensionInfo = bind$1(getDimensionInfo, null, X, Q), G.cloneAllDimensionInfo = bind$1(cloneAllDimensionInfo, null, X), G;
}
function getRawData(H) {
  var C = H.sourceFormat;
  if (!isSupportedSourceFormat(C)) {
    var G = "";
    process.env.NODE_ENV !== "production" && (G = "`getRawData` is not supported in source format " + C), throwError(G);
  }
  return H.data;
}
function cloneRawData(H) {
  var C = H.sourceFormat, G = H.data;
  if (!isSupportedSourceFormat(C)) {
    var U = "";
    process.env.NODE_ENV !== "production" && (U = "`cloneRawData` is not supported in source format " + C), throwError(U);
  }
  if (C === SOURCE_FORMAT_ARRAY_ROWS) {
    for (var K = [], W = 0, Z = G.length; W < Z; W++)
      K.push(G[W].slice());
    return K;
  } else if (C === SOURCE_FORMAT_OBJECT_ROWS) {
    for (var K = [], W = 0, Z = G.length; W < Z; W++)
      K.push(extend({}, G[W]));
    return K;
  }
}
function getDimensionInfo(H, C, G) {
  if (G != null) {
    if (isNumber(G) || !isNaN(G) && !hasOwn(C, G))
      return H[G];
    if (hasOwn(C, G))
      return C[G];
  }
}
function cloneAllDimensionInfo(H) {
  return clone$4(H);
}
var externalTransformMap = createHashMap();
function registerExternalTransform(H) {
  H = clone$4(H);
  var C = H.type, G = "";
  C || (process.env.NODE_ENV !== "production" && (G = "Must have a `type` when `registerTransform`."), throwError(G));
  var U = C.split(":");
  U.length !== 2 && (process.env.NODE_ENV !== "production" && (G = 'Name must include namespace like "ns:regression".'), throwError(G));
  var K = !1;
  U[0] === "echarts" && (C = U[1], K = !0), H.__isBuiltIn = K, externalTransformMap.set(C, H);
}
function applyDataTransform(H, C, G) {
  var U = normalizeToArray(H), K = U.length, W = "";
  K || (process.env.NODE_ENV !== "production" && (W = "If `transform` declared, it should at least contain one transform."), throwError(W));
  for (var Z = 0, X = K; Z < X; Z++) {
    var Q = U[Z];
    C = applySingleDataTransform(Q, C, G, K === 1 ? null : Z), Z !== X - 1 && (C.length = Math.max(C.length, 1));
  }
  return C;
}
function applySingleDataTransform(H, C, G, U) {
  var K = "";
  C.length || (process.env.NODE_ENV !== "production" && (K = "Must have at least one upstream dataset."), throwError(K)), isObject$3(H) || (process.env.NODE_ENV !== "production" && (K = "transform declaration must be an object rather than " + typeof H + "."), throwError(K));
  var W = H.type, Z = externalTransformMap.get(W);
  Z || (process.env.NODE_ENV !== "production" && (K = 'Can not find transform on type "' + W + '".'), throwError(K));
  var X = map$1(C, function(te) {
    return createExternalSource(te, Z);
  }), Q = normalizeToArray(Z.transform({
    upstream: X[0],
    upstreamList: X,
    config: clone$4(H.config)
  }));
  if (process.env.NODE_ENV !== "production" && H.print) {
    var ee = map$1(Q, function(te) {
      var re = U != null ? " === pipe index: " + U : "";
      return ["=== dataset index: " + G.datasetIndex + re + " ===", "- transform result data:", makePrintable(te.data), "- transform result dimensions:", makePrintable(te.dimensions)].join(`
`);
    }).join(`
`);
    log(ee);
  }
  return map$1(Q, function(te, re) {
    var ne = "";
    isObject$3(te) || (process.env.NODE_ENV !== "production" && (ne = "A transform should not return some empty results."), throwError(ne)), te.data || (process.env.NODE_ENV !== "production" && (ne = "Transform result data should be not be null or undefined"), throwError(ne));
    var ae = detectSourceFormat(te.data);
    isSupportedSourceFormat(ae) || (process.env.NODE_ENV !== "production" && (ne = "Transform result data should be array rows or object rows."), throwError(ne));
    var ie, se = C[0];
    if (se && re === 0 && !te.dimensions) {
      var oe = se.startIndex;
      oe && (te.data = se.data.slice(0, oe).concat(te.data)), ie = {
        seriesLayoutBy: SERIES_LAYOUT_BY_COLUMN,
        sourceHeader: oe,
        dimensions: se.metaRawOption.dimensions
      };
    } else
      ie = {
        seriesLayoutBy: SERIES_LAYOUT_BY_COLUMN,
        sourceHeader: 0,
        dimensions: te.dimensions
      };
    return createSource(te.data, ie, null);
  });
}
function isSupportedSourceFormat(H) {
  return H === SOURCE_FORMAT_ARRAY_ROWS || H === SOURCE_FORMAT_OBJECT_ROWS;
}
var UNDEFINED = "undefined", CtorUint32Array = typeof Uint32Array === UNDEFINED ? Array : Uint32Array, CtorUint16Array = typeof Uint16Array === UNDEFINED ? Array : Uint16Array, CtorInt32Array$1 = typeof Int32Array === UNDEFINED ? Array : Int32Array, CtorFloat64Array = typeof Float64Array === UNDEFINED ? Array : Float64Array, dataCtors = {
  float: CtorFloat64Array,
  int: CtorInt32Array$1,
  // Ordinal data type can be string or int
  ordinal: Array,
  number: Array,
  time: CtorFloat64Array
}, defaultDimValueGetters;
function getIndicesCtor(H) {
  return H > 65535 ? CtorUint32Array : CtorUint16Array;
}
function getInitialExtent() {
  return [1 / 0, -1 / 0];
}
function cloneChunk(H) {
  var C = H.constructor;
  return C === Array ? H.slice() : new C(H);
}
function prepareStore(H, C, G, U, K) {
  var W = dataCtors[G || "float"];
  if (K) {
    var Z = H[C], X = Z && Z.length;
    if (X !== U) {
      for (var Q = new W(U), ee = 0; ee < X; ee++)
        Q[ee] = Z[ee];
      H[C] = Q;
    }
  } else
    H[C] = new W(U);
}
var DataStore = (
  /** @class */
  function() {
    function H() {
      this._chunks = [], this._rawExtent = [], this._extent = [], this._count = 0, this._rawCount = 0, this._calcDimNameToIdx = createHashMap();
    }
    return H.prototype.initData = function(C, G, U) {
      process.env.NODE_ENV !== "production" && assert(isFunction(C.getItem) && isFunction(C.count), "Invalid data provider."), this._provider = C, this._chunks = [], this._indices = null, this.getRawIndex = this._getRawIdxIdentity;
      var K = C.getSource(), W = this.defaultDimValueGetter = defaultDimValueGetters[K.sourceFormat];
      this._dimValueGetter = U || W, this._rawExtent = [];
      var Z = shouldRetrieveDataByName(K);
      this._dimensions = map$1(G, function(X) {
        return process.env.NODE_ENV !== "production" && Z && assert(X.property != null), {
          // Only pick these two props. Not leak other properties like orderMeta.
          type: X.type,
          property: X.property
        };
      }), this._initDataFromProvider(0, C.count());
    }, H.prototype.getProvider = function() {
      return this._provider;
    }, H.prototype.getSource = function() {
      return this._provider.getSource();
    }, H.prototype.ensureCalculationDimension = function(C, G) {
      var U = this._calcDimNameToIdx, K = this._dimensions, W = U.get(C);
      if (W != null) {
        if (K[W].type === G)
          return W;
      } else
        W = K.length;
      return K[W] = {
        type: G
      }, U.set(C, W), this._chunks[W] = new dataCtors[G || "float"](this._rawCount), this._rawExtent[W] = getInitialExtent(), W;
    }, H.prototype.collectOrdinalMeta = function(C, G) {
      var U = this._chunks[C], K = this._dimensions[C], W = this._rawExtent, Z = K.ordinalOffset || 0, X = U.length;
      Z === 0 && (W[C] = getInitialExtent());
      for (var Q = W[C], ee = Z; ee < X; ee++) {
        var te = U[ee] = G.parseAndCollect(U[ee]);
        isNaN(te) || (Q[0] = Math.min(te, Q[0]), Q[1] = Math.max(te, Q[1]));
      }
      K.ordinalMeta = G, K.ordinalOffset = X, K.type = "ordinal";
    }, H.prototype.getOrdinalMeta = function(C) {
      var G = this._dimensions[C], U = G.ordinalMeta;
      return U;
    }, H.prototype.getDimensionProperty = function(C) {
      var G = this._dimensions[C];
      return G && G.property;
    }, H.prototype.appendData = function(C) {
      process.env.NODE_ENV !== "production" && assert(!this._indices, "appendData can only be called on raw data.");
      var G = this._provider, U = this.count();
      G.appendData(C);
      var K = G.count();
      return G.persistent || (K += U), U < K && this._initDataFromProvider(U, K, !0), [U, K];
    }, H.prototype.appendValues = function(C, G) {
      for (var U = this._chunks, K = this._dimensions, W = K.length, Z = this._rawExtent, X = this.count(), Q = X + Math.max(C.length, G || 0), ee = 0; ee < W; ee++) {
        var te = K[ee];
        prepareStore(U, ee, te.type, Q, !0);
      }
      for (var re = [], ne = X; ne < Q; ne++)
        for (var ae = ne - X, ie = 0; ie < W; ie++) {
          var te = K[ie], se = defaultDimValueGetters.arrayRows.call(this, C[ae] || re, te.property, ae, ie);
          U[ie][ne] = se;
          var oe = Z[ie];
          se < oe[0] && (oe[0] = se), se > oe[1] && (oe[1] = se);
        }
      return this._rawCount = this._count = Q, {
        start: X,
        end: Q
      };
    }, H.prototype._initDataFromProvider = function(C, G, U) {
      for (var K = this._provider, W = this._chunks, Z = this._dimensions, X = Z.length, Q = this._rawExtent, ee = map$1(Z, function(ue) {
        return ue.property;
      }), te = 0; te < X; te++) {
        var re = Z[te];
        Q[te] || (Q[te] = getInitialExtent()), prepareStore(W, te, re.type, G, U);
      }
      if (K.fillStorage)
        K.fillStorage(C, G, W, Q);
      else
        for (var ne = [], ae = C; ae < G; ae++) {
          ne = K.getItem(ae, ne);
          for (var ie = 0; ie < X; ie++) {
            var se = W[ie], oe = this._dimValueGetter(ne, ee[ie], ae, ie);
            se[ae] = oe;
            var le = Q[ie];
            oe < le[0] && (le[0] = oe), oe > le[1] && (le[1] = oe);
          }
        }
      !K.persistent && K.clean && K.clean(), this._rawCount = this._count = G, this._extent = [];
    }, H.prototype.count = function() {
      return this._count;
    }, H.prototype.get = function(C, G) {
      if (!(G >= 0 && G < this._count))
        return NaN;
      var U = this._chunks[C];
      return U ? U[this.getRawIndex(G)] : NaN;
    }, H.prototype.getValues = function(C, G) {
      var U = [], K = [];
      if (G == null) {
        G = C, C = [];
        for (var W = 0; W < this._dimensions.length; W++)
          K.push(W);
      } else
        K = C;
      for (var W = 0, Z = K.length; W < Z; W++)
        U.push(this.get(K[W], G));
      return U;
    }, H.prototype.getByRawIndex = function(C, G) {
      if (!(G >= 0 && G < this._rawCount))
        return NaN;
      var U = this._chunks[C];
      return U ? U[G] : NaN;
    }, H.prototype.getSum = function(C) {
      var G = this._chunks[C], U = 0;
      if (G)
        for (var K = 0, W = this.count(); K < W; K++) {
          var Z = this.get(C, K);
          isNaN(Z) || (U += Z);
        }
      return U;
    }, H.prototype.getMedian = function(C) {
      var G = [];
      this.each([C], function(W) {
        isNaN(W) || G.push(W);
      });
      var U = G.sort(function(W, Z) {
        return W - Z;
      }), K = this.count();
      return K === 0 ? 0 : K % 2 === 1 ? U[(K - 1) / 2] : (U[K / 2] + U[K / 2 - 1]) / 2;
    }, H.prototype.indexOfRawIndex = function(C) {
      if (C >= this._rawCount || C < 0)
        return -1;
      if (!this._indices)
        return C;
      var G = this._indices, U = G[C];
      if (U != null && U < this._count && U === C)
        return C;
      for (var K = 0, W = this._count - 1; K <= W; ) {
        var Z = (K + W) / 2 | 0;
        if (G[Z] < C)
          K = Z + 1;
        else if (G[Z] > C)
          W = Z - 1;
        else
          return Z;
      }
      return -1;
    }, H.prototype.indicesOfNearest = function(C, G, U) {
      var K = this._chunks, W = K[C], Z = [];
      if (!W)
        return Z;
      U == null && (U = 1 / 0);
      for (var X = 1 / 0, Q = -1, ee = 0, te = 0, re = this.count(); te < re; te++) {
        var ne = this.getRawIndex(te), ae = G - W[ne], ie = Math.abs(ae);
        ie <= U && ((ie < X || ie === X && ae >= 0 && Q < 0) && (X = ie, Q = ae, ee = 0), ae === Q && (Z[ee++] = te));
      }
      return Z.length = ee, Z;
    }, H.prototype.getIndices = function() {
      var C, G = this._indices;
      if (G) {
        var U = G.constructor, K = this._count;
        if (U === Array) {
          C = new U(K);
          for (var W = 0; W < K; W++)
            C[W] = G[W];
        } else
          C = new U(G.buffer, 0, K);
      } else {
        var U = getIndicesCtor(this._rawCount);
        C = new U(this.count());
        for (var W = 0; W < C.length; W++)
          C[W] = W;
      }
      return C;
    }, H.prototype.filter = function(C, G) {
      if (!this._count)
        return this;
      for (var U = this.clone(), K = U.count(), W = getIndicesCtor(U._rawCount), Z = new W(K), X = [], Q = C.length, ee = 0, te = C[0], re = U._chunks, ne = 0; ne < K; ne++) {
        var ae = void 0, ie = U.getRawIndex(ne);
        if (Q === 0)
          ae = G(ne);
        else if (Q === 1) {
          var se = re[te][ie];
          ae = G(se, ne);
        } else {
          for (var oe = 0; oe < Q; oe++)
            X[oe] = re[C[oe]][ie];
          X[oe] = ne, ae = G.apply(null, X);
        }
        ae && (Z[ee++] = ie);
      }
      return ee < K && (U._indices = Z), U._count = ee, U._extent = [], U._updateGetRawIdx(), U;
    }, H.prototype.selectRange = function(C) {
      var G = this.clone(), U = G._count;
      if (!U)
        return this;
      var K = keys(C), W = K.length;
      if (!W)
        return this;
      var Z = G.count(), X = getIndicesCtor(G._rawCount), Q = new X(Z), ee = 0, te = K[0], re = C[te][0], ne = C[te][1], ae = G._chunks, ie = !1;
      if (!G._indices) {
        var se = 0;
        if (W === 1) {
          for (var oe = ae[K[0]], le = 0; le < U; le++) {
            var ue = oe[le];
            (ue >= re && ue <= ne || isNaN(ue)) && (Q[ee++] = se), se++;
          }
          ie = !0;
        } else if (W === 2) {
          for (var oe = ae[K[0]], ce = ae[K[1]], de = C[K[1]][0], ge = C[K[1]][1], le = 0; le < U; le++) {
            var ue = oe[le], fe = ce[le];
            (ue >= re && ue <= ne || isNaN(ue)) && (fe >= de && fe <= ge || isNaN(fe)) && (Q[ee++] = se), se++;
          }
          ie = !0;
        }
      }
      if (!ie)
        if (W === 1)
          for (var le = 0; le < Z; le++) {
            var ve = G.getRawIndex(le), ue = ae[K[0]][ve];
            (ue >= re && ue <= ne || isNaN(ue)) && (Q[ee++] = ve);
          }
        else
          for (var le = 0; le < Z; le++) {
            for (var pe = !0, ve = G.getRawIndex(le), he = 0; he < W; he++) {
              var me = K[he], ue = ae[me][ve];
              (ue < C[me][0] || ue > C[me][1]) && (pe = !1);
            }
            pe && (Q[ee++] = G.getRawIndex(le));
          }
      return ee < Z && (G._indices = Q), G._count = ee, G._extent = [], G._updateGetRawIdx(), G;
    }, H.prototype.map = function(C, G) {
      var U = this.clone(C);
      return this._updateDims(U, C, G), U;
    }, H.prototype.modify = function(C, G) {
      this._updateDims(this, C, G);
    }, H.prototype._updateDims = function(C, G, U) {
      for (var K = C._chunks, W = [], Z = G.length, X = C.count(), Q = [], ee = C._rawExtent, te = 0; te < G.length; te++)
        ee[G[te]] = getInitialExtent();
      for (var re = 0; re < X; re++) {
        for (var ne = C.getRawIndex(re), ae = 0; ae < Z; ae++)
          Q[ae] = K[G[ae]][ne];
        Q[Z] = re;
        var ie = U && U.apply(null, Q);
        if (ie != null) {
          typeof ie != "object" && (W[0] = ie, ie = W);
          for (var te = 0; te < ie.length; te++) {
            var se = G[te], oe = ie[te], le = ee[se], ue = K[se];
            ue && (ue[ne] = oe), oe < le[0] && (le[0] = oe), oe > le[1] && (le[1] = oe);
          }
        }
      }
    }, H.prototype.lttbDownSample = function(C, G) {
      var U = this.clone([C], !0), K = U._chunks, W = K[C], Z = this.count(), X = 0, Q = Math.floor(1 / G), ee = this.getRawIndex(0), te, re, ne, ae = new (getIndicesCtor(this._rawCount))(Math.min((Math.ceil(Z / Q) + 2) * 2, Z));
      ae[X++] = ee;
      for (var ie = 1; ie < Z - 1; ie += Q) {
        for (var se = Math.min(ie + Q, Z - 1), oe = Math.min(ie + Q * 2, Z), le = (oe + se) / 2, ue = 0, ce = se; ce < oe; ce++) {
          var de = this.getRawIndex(ce), ge = W[de];
          isNaN(ge) || (ue += ge);
        }
        ue /= oe - se;
        var fe = ie, ve = Math.min(ie + Q, Z), pe = ie - 1, he = W[ee];
        te = -1, ne = fe;
        for (var me = -1, ye = 0, ce = fe; ce < ve; ce++) {
          var de = this.getRawIndex(ce), ge = W[de];
          if (isNaN(ge)) {
            ye++, me < 0 && (me = de);
            continue;
          }
          re = Math.abs((pe - le) * (ge - he) - (pe - ce) * (ue - he)), re > te && (te = re, ne = de);
        }
        ye > 0 && ye < ve - fe && (ae[X++] = Math.min(me, ne), ne = Math.max(me, ne)), ae[X++] = ne, ee = ne;
      }
      return ae[X++] = this.getRawIndex(Z - 1), U._count = X, U._indices = ae, U.getRawIndex = this._getRawIdx, U;
    }, H.prototype.downSample = function(C, G, U, K) {
      for (var W = this.clone([C], !0), Z = W._chunks, X = [], Q = Math.floor(1 / G), ee = Z[C], te = this.count(), re = W._rawExtent[C] = getInitialExtent(), ne = new (getIndicesCtor(this._rawCount))(Math.ceil(te / Q)), ae = 0, ie = 0; ie < te; ie += Q) {
        Q > te - ie && (Q = te - ie, X.length = Q);
        for (var se = 0; se < Q; se++) {
          var oe = this.getRawIndex(ie + se);
          X[se] = ee[oe];
        }
        var le = U(X), ue = this.getRawIndex(Math.min(ie + K(X, le) || 0, te - 1));
        ee[ue] = le, le < re[0] && (re[0] = le), le > re[1] && (re[1] = le), ne[ae++] = ue;
      }
      return W._count = ae, W._indices = ne, W._updateGetRawIdx(), W;
    }, H.prototype.each = function(C, G) {
      if (this._count)
        for (var U = C.length, K = this._chunks, W = 0, Z = this.count(); W < Z; W++) {
          var X = this.getRawIndex(W);
          switch (U) {
            case 0:
              G(W);
              break;
            case 1:
              G(K[C[0]][X], W);
              break;
            case 2:
              G(K[C[0]][X], K[C[1]][X], W);
              break;
            default:
              for (var Q = 0, ee = []; Q < U; Q++)
                ee[Q] = K[C[Q]][X];
              ee[Q] = W, G.apply(null, ee);
          }
        }
    }, H.prototype.getDataExtent = function(C) {
      var G = this._chunks[C], U = getInitialExtent();
      if (!G)
        return U;
      var K = this.count(), W = !this._indices, Z;
      if (W)
        return this._rawExtent[C].slice();
      if (Z = this._extent[C], Z)
        return Z.slice();
      Z = U;
      for (var X = Z[0], Q = Z[1], ee = 0; ee < K; ee++) {
        var te = this.getRawIndex(ee), re = G[te];
        re < X && (X = re), re > Q && (Q = re);
      }
      return Z = [X, Q], this._extent[C] = Z, Z;
    }, H.prototype.getRawDataItem = function(C) {
      var G = this.getRawIndex(C);
      if (this._provider.persistent)
        return this._provider.getItem(G);
      for (var U = [], K = this._chunks, W = 0; W < K.length; W++)
        U.push(K[W][G]);
      return U;
    }, H.prototype.clone = function(C, G) {
      var U = new H(), K = this._chunks, W = C && reduce(C, function(X, Q) {
        return X[Q] = !0, X;
      }, {});
      if (W)
        for (var Z = 0; Z < K.length; Z++)
          U._chunks[Z] = W[Z] ? cloneChunk(K[Z]) : K[Z];
      else
        U._chunks = K;
      return this._copyCommonProps(U), G || (U._indices = this._cloneIndices()), U._updateGetRawIdx(), U;
    }, H.prototype._copyCommonProps = function(C) {
      C._count = this._count, C._rawCount = this._rawCount, C._provider = this._provider, C._dimensions = this._dimensions, C._extent = clone$4(this._extent), C._rawExtent = clone$4(this._rawExtent);
    }, H.prototype._cloneIndices = function() {
      if (this._indices) {
        var C = this._indices.constructor, G = void 0;
        if (C === Array) {
          var U = this._indices.length;
          G = new C(U);
          for (var K = 0; K < U; K++)
            G[K] = this._indices[K];
        } else
          G = new C(this._indices);
        return G;
      }
      return null;
    }, H.prototype._getRawIdxIdentity = function(C) {
      return C;
    }, H.prototype._getRawIdx = function(C) {
      return C < this._count && C >= 0 ? this._indices[C] : -1;
    }, H.prototype._updateGetRawIdx = function() {
      this.getRawIndex = this._indices ? this._getRawIdx : this._getRawIdxIdentity;
    }, H.internalField = function() {
      function C(G, U, K, W) {
        return parseDataValue(G[W], this._dimensions[W]);
      }
      defaultDimValueGetters = {
        arrayRows: C,
        objectRows: function(G, U, K, W) {
          return parseDataValue(G[U], this._dimensions[W]);
        },
        keyedColumns: C,
        original: function(G, U, K, W) {
          var Z = G && (G.value == null ? G : G.value);
          return parseDataValue(Z instanceof Array ? Z[W] : Z, this._dimensions[W]);
        },
        typedArray: function(G, U, K, W) {
          return G[W];
        }
      };
    }(), H;
  }()
), SourceManager = (
  /** @class */
  function() {
    function H(C) {
      this._sourceList = [], this._storeList = [], this._upstreamSignList = [], this._versionSignBase = 0, this._dirty = !0, this._sourceHost = C;
    }
    return H.prototype.dirty = function() {
      this._setLocalSource([], []), this._storeList = [], this._dirty = !0;
    }, H.prototype._setLocalSource = function(C, G) {
      this._sourceList = C, this._upstreamSignList = G, this._versionSignBase++, this._versionSignBase > 9e10 && (this._versionSignBase = 0);
    }, H.prototype._getVersionSign = function() {
      return this._sourceHost.uid + "_" + this._versionSignBase;
    }, H.prototype.prepareSource = function() {
      this._isDirty() && (this._createSource(), this._dirty = !1);
    }, H.prototype._createSource = function() {
      this._setLocalSource([], []);
      var C = this._sourceHost, G = this._getUpstreamSourceManagers(), U = !!G.length, K, W;
      if (isSeries(C)) {
        var Z = C, X = void 0, Q = void 0, ee = void 0;
        if (U) {
          var te = G[0];
          te.prepareSource(), ee = te.getSource(), X = ee.data, Q = ee.sourceFormat, W = [te._getVersionSign()];
        } else
          X = Z.get("data", !0), Q = isTypedArray(X) ? SOURCE_FORMAT_TYPED_ARRAY : SOURCE_FORMAT_ORIGINAL, W = [];
        var re = this._getSourceMetaRawOption() || {}, ne = ee && ee.metaRawOption || {}, ae = retrieve2(re.seriesLayoutBy, ne.seriesLayoutBy) || null, ie = retrieve2(re.sourceHeader, ne.sourceHeader), se = retrieve2(re.dimensions, ne.dimensions), oe = ae !== ne.seriesLayoutBy || !!ie != !!ne.sourceHeader || se;
        K = oe ? [createSource(X, {
          seriesLayoutBy: ae,
          sourceHeader: ie,
          dimensions: se
        }, Q)] : [];
      } else {
        var le = C;
        if (U) {
          var ue = this._applyTransform(G);
          K = ue.sourceList, W = ue.upstreamSignList;
        } else {
          var ce = le.get("source", !0);
          K = [createSource(ce, this._getSourceMetaRawOption(), null)], W = [];
        }
      }
      process.env.NODE_ENV !== "production" && assert(K && W), this._setLocalSource(K, W);
    }, H.prototype._applyTransform = function(C) {
      var G = this._sourceHost, U = G.get("transform", !0), K = G.get("fromTransformResult", !0);
      if (process.env.NODE_ENV !== "production" && assert(K != null || U != null), K != null) {
        var W = "";
        C.length !== 1 && (process.env.NODE_ENV !== "production" && (W = "When using `fromTransformResult`, there should be only one upstream dataset"), doThrow(W));
      }
      var Z, X = [], Q = [];
      return each$f(C, function(ee) {
        ee.prepareSource();
        var te = ee.getSource(K || 0), re = "";
        K != null && !te && (process.env.NODE_ENV !== "production" && (re = "Can not retrieve result by `fromTransformResult`: " + K), doThrow(re)), X.push(te), Q.push(ee._getVersionSign());
      }), U ? Z = applyDataTransform(U, X, {
        datasetIndex: G.componentIndex
      }) : K != null && (Z = [cloneSourceShallow(X[0])]), {
        sourceList: Z,
        upstreamSignList: Q
      };
    }, H.prototype._isDirty = function() {
      if (this._dirty)
        return !0;
      for (var C = this._getUpstreamSourceManagers(), G = 0; G < C.length; G++) {
        var U = C[G];
        if (// Consider the case that there is ancestor diry, call it recursively.
        // The performance is probably not an issue because usually the chain is not long.
        U._isDirty() || this._upstreamSignList[G] !== U._getVersionSign())
          return !0;
      }
    }, H.prototype.getSource = function(C) {
      C = C || 0;
      var G = this._sourceList[C];
      if (!G) {
        var U = this._getUpstreamSourceManagers();
        return U[0] && U[0].getSource(C);
      }
      return G;
    }, H.prototype.getSharedDataStore = function(C) {
      process.env.NODE_ENV !== "production" && assert(isSeries(this._sourceHost), "Can only call getDataStore on series source manager.");
      var G = C.makeStoreSchema();
      return this._innerGetDataStore(G.dimensions, C.source, G.hash);
    }, H.prototype._innerGetDataStore = function(C, G, U) {
      var K = 0, W = this._storeList, Z = W[K];
      Z || (Z = W[K] = {});
      var X = Z[U];
      if (!X) {
        var Q = this._getUpstreamSourceManagers()[0];
        isSeries(this._sourceHost) && Q ? X = Q._innerGetDataStore(C, G, U) : (X = new DataStore(), X.initData(new DefaultDataProvider(G, C.length), C)), Z[U] = X;
      }
      return X;
    }, H.prototype._getUpstreamSourceManagers = function() {
      var C = this._sourceHost;
      if (isSeries(C)) {
        var G = querySeriesUpstreamDatasetModel(C);
        return G ? [G.getSourceManager()] : [];
      } else
        return map$1(queryDatasetUpstreamDatasetModels(C), function(U) {
          return U.getSourceManager();
        });
    }, H.prototype._getSourceMetaRawOption = function() {
      var C = this._sourceHost, G, U, K;
      if (isSeries(C))
        G = C.get("seriesLayoutBy", !0), U = C.get("sourceHeader", !0), K = C.get("dimensions", !0);
      else if (!this._getUpstreamSourceManagers().length) {
        var W = C;
        G = W.get("seriesLayoutBy", !0), U = W.get("sourceHeader", !0), K = W.get("dimensions", !0);
      }
      return {
        seriesLayoutBy: G,
        sourceHeader: U,
        dimensions: K
      };
    }, H;
  }()
);
function disableTransformOptionMerge(H) {
  var C = H.option.transform;
  C && setAsPrimitive(H.option.transform);
}
function isSeries(H) {
  return H.mainType === "series";
}
function doThrow(H) {
  throw new Error(H);
}
var TOOLTIP_LINE_HEIGHT_CSS = "line-height:1";
function getTooltipTextStyle(H, C) {
  var G = H.color || "#6e7079", U = H.fontSize || 12, K = H.fontWeight || "400", W = H.color || "#464646", Z = H.fontSize || 14, X = H.fontWeight || "900";
  return C === "html" ? {
    // eslint-disable-next-line max-len
    nameStyle: "font-size:" + encodeHTML(U + "") + "px;color:" + encodeHTML(G) + ";font-weight:" + encodeHTML(K + ""),
    // eslint-disable-next-line max-len
    valueStyle: "font-size:" + encodeHTML(Z + "") + "px;color:" + encodeHTML(W) + ";font-weight:" + encodeHTML(X + "")
  } : {
    nameStyle: {
      fontSize: U,
      fill: G,
      fontWeight: K
    },
    valueStyle: {
      fontSize: Z,
      fill: W,
      fontWeight: X
    }
  };
}
var HTML_GAPS = [0, 10, 20, 30], RICH_TEXT_GAPS = ["", `
`, `

`, `


`];
function createTooltipMarkup(H, C) {
  return C.type = H, C;
}
function isSectionFragment(H) {
  return H.type === "section";
}
function getBuilder(H) {
  return isSectionFragment(H) ? buildSection : buildNameValue;
}
function getBlockGapLevel(H) {
  if (isSectionFragment(H)) {
    var C = 0, G = H.blocks.length, U = G > 1 || G > 0 && !H.noHeader;
    return each$f(H.blocks, function(K) {
      var W = getBlockGapLevel(K);
      W >= C && (C = W + +(U && // 0 always can not be readable gap level.
      (!W || isSectionFragment(K) && !K.noHeader)));
    }), C;
  }
  return 0;
}
function buildSection(H, C, G, U) {
  var K = C.noHeader, W = getGap(getBlockGapLevel(C)), Z = [], X = C.blocks || [];
  assert(!X || isArray$1(X)), X = X || [];
  var Q = H.orderMode;
  if (C.sortBlocks && Q) {
    X = X.slice();
    var ee = {
      valueAsc: "asc",
      valueDesc: "desc"
    };
    if (hasOwn(ee, Q)) {
      var te = new SortOrderComparator(ee[Q], null);
      X.sort(function(ie, se) {
        return te.evaluate(ie.sortParam, se.sortParam);
      });
    } else
      Q === "seriesDesc" && X.reverse();
  }
  each$f(X, function(ie, se) {
    var oe = C.valueFormatter, le = getBuilder(ie)(
      // Inherit valueFormatter
      oe ? extend(extend({}, H), {
        valueFormatter: oe
      }) : H,
      ie,
      se > 0 ? W.html : 0,
      U
    );
    le != null && Z.push(le);
  });
  var re = H.renderMode === "richText" ? Z.join(W.richText) : wrapBlockHTML(Z.join(""), K ? G : W.html);
  if (K)
    return re;
  var ne = makeValueReadable(C.header, "ordinal", H.useUTC), ae = getTooltipTextStyle(U, H.renderMode).nameStyle;
  return H.renderMode === "richText" ? wrapInlineNameRichText(H, ne, ae) + W.richText + re : wrapBlockHTML('<div style="' + ae + ";" + TOOLTIP_LINE_HEIGHT_CSS + ';">' + encodeHTML(ne) + "</div>" + re, G);
}
function buildNameValue(H, C, G, U) {
  var K = H.renderMode, W = C.noName, Z = C.noValue, X = !C.markerType, Q = C.name, ee = H.useUTC, te = C.valueFormatter || H.valueFormatter || function(de) {
    return de = isArray$1(de) ? de : [de], map$1(de, function(ge, fe) {
      return makeValueReadable(ge, isArray$1(ae) ? ae[fe] : ae, ee);
    });
  };
  if (!(W && Z)) {
    var re = X ? "" : H.markupStyleCreator.makeTooltipMarker(C.markerType, C.markerColor || "#333", K), ne = W ? "" : makeValueReadable(Q, "ordinal", ee), ae = C.valueType, ie = Z ? [] : te(C.value), se = !X || !W, oe = !X && W, le = getTooltipTextStyle(U, K), ue = le.nameStyle, ce = le.valueStyle;
    return K === "richText" ? (X ? "" : re) + (W ? "" : wrapInlineNameRichText(H, ne, ue)) + (Z ? "" : wrapInlineValueRichText(H, ie, se, oe, ce)) : wrapBlockHTML((X ? "" : re) + (W ? "" : wrapInlineNameHTML(ne, !X, ue)) + (Z ? "" : wrapInlineValueHTML(ie, se, oe, ce)), G);
  }
}
function buildTooltipMarkup(H, C, G, U, K, W) {
  if (H) {
    var Z = getBuilder(H), X = {
      useUTC: K,
      renderMode: G,
      orderMode: U,
      markupStyleCreator: C,
      valueFormatter: H.valueFormatter
    };
    return Z(X, H, 0, W);
  }
}
function getGap(H) {
  return {
    html: HTML_GAPS[H],
    richText: RICH_TEXT_GAPS[H]
  };
}
function wrapBlockHTML(H, C) {
  var G = '<div style="clear:both"></div>', U = "margin: " + C + "px 0 0";
  return '<div style="' + U + ";" + TOOLTIP_LINE_HEIGHT_CSS + ';">' + H + G + "</div>";
}
function wrapInlineNameHTML(H, C, G) {
  var U = C ? "margin-left:2px" : "";
  return '<span style="' + G + ";" + U + '">' + encodeHTML(H) + "</span>";
}
function wrapInlineValueHTML(H, C, G, U) {
  var K = G ? "10px" : "20px", W = C ? "float:right;margin-left:" + K : "";
  return H = isArray$1(H) ? H : [H], '<span style="' + W + ";" + U + '">' + map$1(H, function(Z) {
    return encodeHTML(Z);
  }).join("&nbsp;&nbsp;") + "</span>";
}
function wrapInlineNameRichText(H, C, G) {
  return H.markupStyleCreator.wrapRichTextStyle(C, G);
}
function wrapInlineValueRichText(H, C, G, U, K) {
  var W = [K], Z = U ? 10 : 20;
  return G && W.push({
    padding: [0, 0, 0, Z],
    align: "right"
  }), H.markupStyleCreator.wrapRichTextStyle(isArray$1(C) ? C.join("  ") : C, W);
}
function retrieveVisualColorForTooltipMarker(H, C) {
  var G = H.getData().getItemVisual(C, "style"), U = G[H.visualDrawType];
  return convertToColorString(U);
}
function getPaddingFromTooltipModel(H, C) {
  var G = H.get("padding");
  return G ?? (C === "richText" ? [8, 10] : 10);
}
var TooltipMarkupStyleCreator = (
  /** @class */
  function() {
    function H() {
      this.richTextStyles = {}, this._nextStyleNameId = getRandomIdBase();
    }
    return H.prototype._generateStyleName = function() {
      return "__EC_aUTo_" + this._nextStyleNameId++;
    }, H.prototype.makeTooltipMarker = function(C, G, U) {
      var K = U === "richText" ? this._generateStyleName() : null, W = getTooltipMarker({
        color: G,
        type: C,
        renderMode: U,
        markerId: K
      });
      return isString(W) ? W : (process.env.NODE_ENV !== "production" && assert(K), this.richTextStyles[K] = W.style, W.content);
    }, H.prototype.wrapRichTextStyle = function(C, G) {
      var U = {};
      isArray$1(G) ? each$f(G, function(W) {
        return extend(U, W);
      }) : extend(U, G);
      var K = this._generateStyleName();
      return this.richTextStyles[K] = U, "{" + K + "|" + C + "}";
    }, H;
  }()
);
function defaultSeriesFormatTooltip(H) {
  var C = H.series, G = H.dataIndex, U = H.multipleSeries, K = C.getData(), W = K.mapDimensionsAll("defaultedTooltip"), Z = W.length, X = C.getRawValue(G), Q = isArray$1(X), ee = retrieveVisualColorForTooltipMarker(C, G), te, re, ne, ae;
  if (Z > 1 || Q && !Z) {
    var ie = formatTooltipArrayValue(X, C, G, W, ee);
    te = ie.inlineValues, re = ie.inlineValueTypes, ne = ie.blocks, ae = ie.inlineValues[0];
  } else if (Z) {
    var se = K.getDimensionInfo(W[0]);
    ae = te = retrieveRawValue(K, G, W[0]), re = se.type;
  } else
    ae = te = Q ? X[0] : X;
  var oe = isNameSpecified(C), le = oe && C.name || "", ue = K.getName(G), ce = U ? le : ue;
  return createTooltipMarkup("section", {
    header: le,
    // When series name not specified, do not show a header line with only '-'.
    // This case alway happen in tooltip.trigger: 'item'.
    noHeader: U || !oe,
    sortParam: ae,
    blocks: [createTooltipMarkup("nameValue", {
      markerType: "item",
      markerColor: ee,
      // Do not mix display seriesName and itemName in one tooltip,
      // which might confuses users.
      name: ce,
      // name dimension might be auto assigned, where the name might
      // be not readable. So we check trim here.
      noName: !trim$1(ce),
      value: te,
      valueType: re
    })].concat(ne || [])
  });
}
function formatTooltipArrayValue(H, C, G, U, K) {
  var W = C.getData(), Z = reduce(H, function(re, ne, ae) {
    var ie = W.getDimensionInfo(ae);
    return re = re || ie && ie.tooltip !== !1 && ie.displayName != null;
  }, !1), X = [], Q = [], ee = [];
  U.length ? each$f(U, function(re) {
    te(retrieveRawValue(W, G, re), re);
  }) : each$f(H, te);
  function te(re, ne) {
    var ae = W.getDimensionInfo(ne);
    !ae || ae.otherDims.tooltip === !1 || (Z ? ee.push(createTooltipMarkup("nameValue", {
      markerType: "subItem",
      markerColor: K,
      name: ae.displayName,
      value: re,
      valueType: ae.type
    })) : (X.push(re), Q.push(ae.type)));
  }
  return {
    inlineValues: X,
    inlineValueTypes: Q,
    blocks: ee
  };
}
var inner$k = makeInner();
function getSelectionKey(H, C) {
  return H.getName(C) || H.getId(C);
}
var SERIES_UNIVERSAL_TRANSITION_PROP = "__universalTransitionEnabled", SeriesModel = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G._selectedDataIndicesMap = {}, G;
    }
    return C.prototype.init = function(G, U, K) {
      this.seriesIndex = this.componentIndex, this.dataTask = createTask({
        count: dataTaskCount,
        reset: dataTaskReset
      }), this.dataTask.context = {
        model: this
      }, this.mergeDefaultAndTheme(G, K);
      var W = inner$k(this).sourceManager = new SourceManager(this);
      W.prepareSource();
      var Z = this.getInitialData(G, K);
      wrapData(Z, this), this.dataTask.context.data = Z, process.env.NODE_ENV !== "production" && assert(Z, "getInitialData returned invalid data."), inner$k(this).dataBeforeProcessed = Z, autoSeriesName(this), this._initSelectedMapFromData(Z);
    }, C.prototype.mergeDefaultAndTheme = function(G, U) {
      var K = fetchLayoutMode(this), W = K ? getLayoutParams(G) : {}, Z = this.subType;
      ComponentModel$1.hasClass(Z) && (Z += "Series"), merge(G, U.getTheme().get(this.subType)), merge(G, this.getDefaultOption()), defaultEmphasis(G, "label", ["show"]), this.fillDataTextStyle(G.data), K && mergeLayoutParam(G, W, K);
    }, C.prototype.mergeOption = function(G, U) {
      G = merge(this.option, G, !0), this.fillDataTextStyle(G.data);
      var K = fetchLayoutMode(this);
      K && mergeLayoutParam(this.option, G, K);
      var W = inner$k(this).sourceManager;
      W.dirty(), W.prepareSource();
      var Z = this.getInitialData(G, U);
      wrapData(Z, this), this.dataTask.dirty(), this.dataTask.context.data = Z, inner$k(this).dataBeforeProcessed = Z, autoSeriesName(this), this._initSelectedMapFromData(Z);
    }, C.prototype.fillDataTextStyle = function(G) {
      if (G && !isTypedArray(G))
        for (var U = ["show"], K = 0; K < G.length; K++)
          G[K] && G[K].label && defaultEmphasis(G[K], "label", U);
    }, C.prototype.getInitialData = function(G, U) {
    }, C.prototype.appendData = function(G) {
      var U = this.getRawData();
      U.appendData(G.data);
    }, C.prototype.getData = function(G) {
      var U = getCurrentTask(this);
      if (U) {
        var K = U.context.data;
        return G == null ? K : K.getLinkedData(G);
      } else
        return inner$k(this).data;
    }, C.prototype.getAllData = function() {
      var G = this.getData();
      return G && G.getLinkedDataAll ? G.getLinkedDataAll() : [{
        data: G
      }];
    }, C.prototype.setData = function(G) {
      var U = getCurrentTask(this);
      if (U) {
        var K = U.context;
        K.outputData = G, U !== this.dataTask && (K.data = G);
      }
      inner$k(this).data = G;
    }, C.prototype.getEncode = function() {
      var G = this.get("encode", !0);
      if (G)
        return createHashMap(G);
    }, C.prototype.getSourceManager = function() {
      return inner$k(this).sourceManager;
    }, C.prototype.getSource = function() {
      return this.getSourceManager().getSource();
    }, C.prototype.getRawData = function() {
      return inner$k(this).dataBeforeProcessed;
    }, C.prototype.getColorBy = function() {
      var G = this.get("colorBy");
      return G || "series";
    }, C.prototype.isColorBySeries = function() {
      return this.getColorBy() === "series";
    }, C.prototype.getBaseAxis = function() {
      var G = this.coordinateSystem;
      return G && G.getBaseAxis && G.getBaseAxis();
    }, C.prototype.formatTooltip = function(G, U, K) {
      return defaultSeriesFormatTooltip({
        series: this,
        dataIndex: G,
        multipleSeries: U
      });
    }, C.prototype.isAnimationEnabled = function() {
      var G = this.ecModel;
      if (env$1.node && !(G && G.ssr))
        return !1;
      var U = this.getShallow("animation");
      return U && this.getData().count() > this.getShallow("animationThreshold") && (U = !1), !!U;
    }, C.prototype.restoreData = function() {
      this.dataTask.dirty();
    }, C.prototype.getColorFromPalette = function(G, U, K) {
      var W = this.ecModel, Z = PaletteMixin.prototype.getColorFromPalette.call(this, G, U, K);
      return Z || (Z = W.getColorFromPalette(G, U, K)), Z;
    }, C.prototype.coordDimToDataDim = function(G) {
      return this.getRawData().mapDimensionsAll(G);
    }, C.prototype.getProgressive = function() {
      return this.get("progressive");
    }, C.prototype.getProgressiveThreshold = function() {
      return this.get("progressiveThreshold");
    }, C.prototype.select = function(G, U) {
      this._innerSelect(this.getData(U), G);
    }, C.prototype.unselect = function(G, U) {
      var K = this.option.selectedMap;
      if (K) {
        var W = this.option.selectedMode, Z = this.getData(U);
        if (W === "series" || K === "all") {
          this.option.selectedMap = {}, this._selectedDataIndicesMap = {};
          return;
        }
        for (var X = 0; X < G.length; X++) {
          var Q = G[X], ee = getSelectionKey(Z, Q);
          K[ee] = !1, this._selectedDataIndicesMap[ee] = -1;
        }
      }
    }, C.prototype.toggleSelect = function(G, U) {
      for (var K = [], W = 0; W < G.length; W++)
        K[0] = G[W], this.isSelected(G[W], U) ? this.unselect(K, U) : this.select(K, U);
    }, C.prototype.getSelectedDataIndices = function() {
      if (this.option.selectedMap === "all")
        return [].slice.call(this.getData().getIndices());
      for (var G = this._selectedDataIndicesMap, U = keys(G), K = [], W = 0; W < U.length; W++) {
        var Z = G[U[W]];
        Z >= 0 && K.push(Z);
      }
      return K;
    }, C.prototype.isSelected = function(G, U) {
      var K = this.option.selectedMap;
      if (!K)
        return !1;
      var W = this.getData(U);
      return (K === "all" || K[getSelectionKey(W, G)]) && !W.getItemModel(G).get(["select", "disabled"]);
    }, C.prototype.isUniversalTransitionEnabled = function() {
      if (this[SERIES_UNIVERSAL_TRANSITION_PROP])
        return !0;
      var G = this.option.universalTransition;
      return G ? G === !0 ? !0 : G && G.enabled : !1;
    }, C.prototype._innerSelect = function(G, U) {
      var K, W, Z = this.option, X = Z.selectedMode, Q = U.length;
      if (!(!X || !Q)) {
        if (X === "series")
          Z.selectedMap = "all";
        else if (X === "multiple") {
          isObject$3(Z.selectedMap) || (Z.selectedMap = {});
          for (var ee = Z.selectedMap, te = 0; te < Q; te++) {
            var re = U[te], ne = getSelectionKey(G, re);
            ee[ne] = !0, this._selectedDataIndicesMap[ne] = G.getRawIndex(re);
          }
        } else if (X === "single" || X === !0) {
          var ae = U[Q - 1], ne = getSelectionKey(G, ae);
          Z.selectedMap = (K = {}, K[ne] = !0, K), this._selectedDataIndicesMap = (W = {}, W[ne] = G.getRawIndex(ae), W);
        }
      }
    }, C.prototype._initSelectedMapFromData = function(G) {
      if (!this.option.selectedMap) {
        var U = [];
        G.hasItemOption && G.each(function(K) {
          var W = G.getRawDataItem(K);
          W && W.selected && U.push(K);
        }), U.length > 0 && this._innerSelect(G, U);
      }
    }, C.registerClass = function(G) {
      return ComponentModel$1.registerClass(G);
    }, C.protoInitialize = function() {
      var G = C.prototype;
      G.type = "series.__base__", G.seriesIndex = 0, G.ignoreStyleOnData = !1, G.hasSymbolVisual = !1, G.defaultSymbol = "circle", G.visualStyleAccessPath = "itemStyle", G.visualDrawType = "fill";
    }(), C;
  }(ComponentModel$1)
);
mixin(SeriesModel, DataFormatMixin);
mixin(SeriesModel, PaletteMixin);
mountExtend(SeriesModel, ComponentModel$1);
function autoSeriesName(H) {
  var C = H.name;
  isNameSpecified(H) || (H.name = getSeriesAutoName(H) || C);
}
function getSeriesAutoName(H) {
  var C = H.getRawData(), G = C.mapDimensionsAll("seriesName"), U = [];
  return each$f(G, function(K) {
    var W = C.getDimensionInfo(K);
    W.displayName && U.push(W.displayName);
  }), U.join(" ");
}
function dataTaskCount(H) {
  return H.model.getRawData().count();
}
function dataTaskReset(H) {
  var C = H.model;
  return C.setData(C.getRawData().cloneShallow()), dataTaskProgress;
}
function dataTaskProgress(H, C) {
  C.outputData && H.end > C.outputData.count() && C.model.getRawData().cloneShallow(C.outputData);
}
function wrapData(H, C) {
  each$f(concatArray(H.CHANGABLE_METHODS, H.DOWNSAMPLE_METHODS), function(G) {
    H.wrapMethod(G, curry$1(onDataChange, C));
  });
}
function onDataChange(H, C) {
  var G = getCurrentTask(H);
  return G && G.setOutputEnd((C || this).count()), C;
}
function getCurrentTask(H) {
  var C = (H.ecModel || {}).scheduler, G = C && C.getPipeline(H.uid);
  if (G) {
    var U = G.currentTask;
    if (U) {
      var K = U.agentStubMap;
      K && (U = K.get(H.uid));
    }
    return U;
  }
}
const SeriesModel$1 = SeriesModel;
var ComponentView = (
  /** @class */
  function() {
    function H() {
      this.group = new Group$4(), this.uid = getUID("viewComponent");
    }
    return H.prototype.init = function(C, G) {
    }, H.prototype.render = function(C, G, U, K) {
    }, H.prototype.dispose = function(C, G) {
    }, H.prototype.updateView = function(C, G, U, K) {
    }, H.prototype.updateLayout = function(C, G, U, K) {
    }, H.prototype.updateVisual = function(C, G, U, K) {
    }, H.prototype.toggleBlurSeries = function(C, G, U) {
    }, H.prototype.eachRendered = function(C) {
      var G = this.group;
      G && G.traverse(C);
    }, H;
  }()
);
enableClassExtend(ComponentView);
enableClassManagement(ComponentView);
const ComponentView$1 = ComponentView;
function createRenderPlanner() {
  var H = makeInner();
  return function(C) {
    var G = H(C), U = C.pipelineContext, K = !!G.large, W = !!G.progressiveRender, Z = G.large = !!(U && U.large), X = G.progressiveRender = !!(U && U.progressiveRender);
    return (K !== Z || W !== X) && "reset";
  };
}
var inner$j = makeInner(), renderPlanner = createRenderPlanner(), ChartView = (
  /** @class */
  function() {
    function H() {
      this.group = new Group$4(), this.uid = getUID("viewChart"), this.renderTask = createTask({
        plan: renderTaskPlan,
        reset: renderTaskReset
      }), this.renderTask.context = {
        view: this
      };
    }
    return H.prototype.init = function(C, G) {
    }, H.prototype.render = function(C, G, U, K) {
      if (process.env.NODE_ENV !== "production")
        throw new Error("render method must been implemented");
    }, H.prototype.highlight = function(C, G, U, K) {
      var W = C.getData(K && K.dataType);
      if (!W) {
        process.env.NODE_ENV !== "production" && error("Unknown dataType " + K.dataType);
        return;
      }
      toggleHighlight(W, K, "emphasis");
    }, H.prototype.downplay = function(C, G, U, K) {
      var W = C.getData(K && K.dataType);
      if (!W) {
        process.env.NODE_ENV !== "production" && error("Unknown dataType " + K.dataType);
        return;
      }
      toggleHighlight(W, K, "normal");
    }, H.prototype.remove = function(C, G) {
      this.group.removeAll();
    }, H.prototype.dispose = function(C, G) {
    }, H.prototype.updateView = function(C, G, U, K) {
      this.render(C, G, U, K);
    }, H.prototype.updateLayout = function(C, G, U, K) {
      this.render(C, G, U, K);
    }, H.prototype.updateVisual = function(C, G, U, K) {
      this.render(C, G, U, K);
    }, H.prototype.eachRendered = function(C) {
      traverseElements(this.group, C);
    }, H.markUpdateMethod = function(C, G) {
      inner$j(C).updateMethod = G;
    }, H.protoInitialize = function() {
      var C = H.prototype;
      C.type = "chart";
    }(), H;
  }()
);
function elSetState(H, C, G) {
  H && isHighDownDispatcher(H) && (C === "emphasis" ? enterEmphasis : leaveEmphasis)(H, G);
}
function toggleHighlight(H, C, G) {
  var U = queryDataIndex(H, C), K = C && C.highlightKey != null ? getHighlightDigit(C.highlightKey) : null;
  U != null ? each$f(normalizeToArray(U), function(W) {
    elSetState(H.getItemGraphicEl(W), G, K);
  }) : H.eachItemGraphicEl(function(W) {
    elSetState(W, G, K);
  });
}
enableClassExtend(ChartView, ["dispose"]);
enableClassManagement(ChartView);
function renderTaskPlan(H) {
  return renderPlanner(H.model);
}
function renderTaskReset(H) {
  var C = H.model, G = H.ecModel, U = H.api, K = H.payload, W = C.pipelineContext.progressiveRender, Z = H.view, X = K && inner$j(K).updateMethod, Q = W ? "incrementalPrepareRender" : X && Z[X] ? X : "render";
  return Q !== "render" && Z[Q](C, G, U, K), progressMethodMap[Q];
}
var progressMethodMap = {
  incrementalPrepareRender: {
    progress: function(H, C) {
      C.view.incrementalRender(H, C.model, C.ecModel, C.api, C.payload);
    }
  },
  render: {
    // Put view.render in `progress` to support appendData. But in this case
    // view.render should not be called in reset, otherwise it will be called
    // twise. Use `forceFirstProgress` to make sure that view.render is called
    // in any cases.
    forceFirstProgress: !0,
    progress: function(H, C) {
      C.view.render(C.model, C.ecModel, C.api, C.payload);
    }
  }
};
const ChartView$1 = ChartView;
var ORIGIN_METHOD = "\0__throttleOriginMethod", RATE = "\0__throttleRate", THROTTLE_TYPE = "\0__throttleType";
function throttle(H, C, G) {
  var U, K = 0, W = 0, Z = null, X, Q, ee, te;
  C = C || 0;
  function re() {
    W = new Date().getTime(), Z = null, H.apply(Q, ee || []);
  }
  var ne = function() {
    for (var ae = [], ie = 0; ie < arguments.length; ie++)
      ae[ie] = arguments[ie];
    U = new Date().getTime(), Q = this, ee = ae;
    var se = te || C, oe = te || G;
    te = null, X = U - (oe ? K : W) - se, clearTimeout(Z), oe ? Z = setTimeout(re, se) : X >= 0 ? re() : Z = setTimeout(re, -X), K = U;
  };
  return ne.clear = function() {
    Z && (clearTimeout(Z), Z = null);
  }, ne.debounceNextCall = function(ae) {
    te = ae;
  }, ne;
}
function createOrUpdate(H, C, G, U) {
  var K = H[C];
  if (K) {
    var W = K[ORIGIN_METHOD] || K, Z = K[THROTTLE_TYPE], X = K[RATE];
    if (X !== G || Z !== U) {
      if (G == null || !U)
        return H[C] = W;
      K = H[C] = throttle(W, G, U === "debounce"), K[ORIGIN_METHOD] = W, K[THROTTLE_TYPE] = U, K[RATE] = G;
    }
    return K;
  }
}
function clear$1(H, C) {
  var G = H[C];
  G && G[ORIGIN_METHOD] && (G.clear && G.clear(), H[C] = G[ORIGIN_METHOD]);
}
var inner$i = makeInner(), defaultStyleMappers = {
  itemStyle: makeStyleMapper(ITEM_STYLE_KEY_MAP, !0),
  lineStyle: makeStyleMapper(LINE_STYLE_KEY_MAP, !0)
}, defaultColorKey = {
  lineStyle: "stroke",
  itemStyle: "fill"
};
function getStyleMapper(H, C) {
  var G = H.visualStyleMapper || defaultStyleMappers[C];
  return G || (console.warn("Unknown style type '" + C + "'."), defaultStyleMappers.itemStyle);
}
function getDefaultColorKey(H, C) {
  var G = H.visualDrawType || defaultColorKey[C];
  return G || (console.warn("Unknown style type '" + C + "'."), "fill");
}
var seriesStyleTask = {
  createOnAllSeries: !0,
  performRawSeries: !0,
  reset: function(H, C) {
    var G = H.getData(), U = H.visualStyleAccessPath || "itemStyle", K = H.getModel(U), W = getStyleMapper(H, U), Z = W(K), X = K.getShallow("decal");
    X && (G.setVisual("decal", X), X.dirty = !0);
    var Q = getDefaultColorKey(H, U), ee = Z[Q], te = isFunction(ee) ? ee : null, re = Z.fill === "auto" || Z.stroke === "auto";
    if (!Z[Q] || te || re) {
      var ne = H.getColorFromPalette(
        // TODO series count changed.
        H.name,
        null,
        C.getSeriesCount()
      );
      Z[Q] || (Z[Q] = ne, G.setVisual("colorFromPalette", !0)), Z.fill = Z.fill === "auto" || isFunction(Z.fill) ? ne : Z.fill, Z.stroke = Z.stroke === "auto" || isFunction(Z.stroke) ? ne : Z.stroke;
    }
    if (G.setVisual("style", Z), G.setVisual("drawType", Q), !C.isSeriesFiltered(H) && te)
      return G.setVisual("colorFromPalette", !1), {
        dataEach: function(ae, ie) {
          var se = H.getDataParams(ie), oe = extend({}, Z);
          oe[Q] = te(se), ae.setItemVisual(ie, "style", oe);
        }
      };
  }
}, sharedModel = new Model$1(), dataStyleTask = {
  createOnAllSeries: !0,
  performRawSeries: !0,
  reset: function(H, C) {
    if (!(H.ignoreStyleOnData || C.isSeriesFiltered(H))) {
      var G = H.getData(), U = H.visualStyleAccessPath || "itemStyle", K = getStyleMapper(H, U), W = G.getVisual("drawType");
      return {
        dataEach: G.hasItemOption ? function(Z, X) {
          var Q = Z.getRawDataItem(X);
          if (Q && Q[U]) {
            sharedModel.option = Q[U];
            var ee = K(sharedModel), te = Z.ensureUniqueItemVisual(X, "style");
            extend(te, ee), sharedModel.option.decal && (Z.setItemVisual(X, "decal", sharedModel.option.decal), sharedModel.option.decal.dirty = !0), W in ee && Z.setItemVisual(X, "colorFromPalette", !1);
          }
        } : null
      };
    }
  }
}, dataColorPaletteTask = {
  performRawSeries: !0,
  overallReset: function(H) {
    var C = createHashMap();
    H.eachSeries(function(G) {
      var U = G.getColorBy();
      if (!G.isColorBySeries()) {
        var K = G.type + "-" + U, W = C.get(K);
        W || (W = {}, C.set(K, W)), inner$i(G).scope = W;
      }
    }), H.eachSeries(function(G) {
      if (!(G.isColorBySeries() || H.isSeriesFiltered(G))) {
        var U = G.getRawData(), K = {}, W = G.getData(), Z = inner$i(G).scope, X = G.visualStyleAccessPath || "itemStyle", Q = getDefaultColorKey(G, X);
        W.each(function(ee) {
          var te = W.getRawIndex(ee);
          K[te] = ee;
        }), U.each(function(ee) {
          var te = K[ee], re = W.getItemVisual(te, "colorFromPalette");
          if (re) {
            var ne = W.ensureUniqueItemVisual(te, "style"), ae = U.getName(ee) || ee + "", ie = U.count();
            ne[Q] = G.getColorFromPalette(ae, Z, ie);
          }
        });
      }
    });
  }
}, PI$5 = Math.PI;
function defaultLoading(H, C) {
  C = C || {}, defaults(C, {
    text: "loading",
    textColor: "#000",
    fontSize: 12,
    fontWeight: "normal",
    fontStyle: "normal",
    fontFamily: "sans-serif",
    maskColor: "rgba(255, 255, 255, 0.8)",
    showSpinner: !0,
    color: "#5470c6",
    spinnerRadius: 10,
    lineWidth: 5,
    zlevel: 0
  });
  var G = new Group$4(), U = new Rect$3({
    style: {
      fill: C.maskColor
    },
    zlevel: C.zlevel,
    z: 1e4
  });
  G.add(U);
  var K = new ZRText$1({
    style: {
      text: C.text,
      fill: C.textColor,
      fontSize: C.fontSize,
      fontWeight: C.fontWeight,
      fontStyle: C.fontStyle,
      fontFamily: C.fontFamily
    },
    zlevel: C.zlevel,
    z: 10001
  }), W = new Rect$3({
    style: {
      fill: "none"
    },
    textContent: K,
    textConfig: {
      position: "right",
      distance: 10
    },
    zlevel: C.zlevel,
    z: 10001
  });
  G.add(W);
  var Z;
  return C.showSpinner && (Z = new Arc$1({
    shape: {
      startAngle: -PI$5 / 2,
      endAngle: -PI$5 / 2 + 0.1,
      r: C.spinnerRadius
    },
    style: {
      stroke: C.color,
      lineCap: "round",
      lineWidth: C.lineWidth
    },
    zlevel: C.zlevel,
    z: 10001
  }), Z.animateShape(!0).when(1e3, {
    endAngle: PI$5 * 3 / 2
  }).start("circularInOut"), Z.animateShape(!0).when(1e3, {
    startAngle: PI$5 * 3 / 2
  }).delay(300).start("circularInOut"), G.add(Z)), G.resize = function() {
    var X = K.getBoundingRect().width, Q = C.showSpinner ? C.spinnerRadius : 0, ee = (H.getWidth() - Q * 2 - (C.showSpinner && X ? 10 : 0) - X) / 2 - (C.showSpinner && X ? 0 : 5 + X / 2) + (C.showSpinner ? 0 : X / 2) + (X ? 0 : Q), te = H.getHeight() / 2;
    C.showSpinner && Z.setShape({
      cx: ee,
      cy: te
    }), W.setShape({
      x: ee - Q,
      y: te - Q,
      width: Q * 2,
      height: Q * 2
    }), U.setShape({
      x: 0,
      y: 0,
      width: H.getWidth(),
      height: H.getHeight()
    });
  }, G.resize(), G;
}
var Scheduler = (
  /** @class */
  function() {
    function H(C, G, U, K) {
      this._stageTaskMap = createHashMap(), this.ecInstance = C, this.api = G, U = this._dataProcessorHandlers = U.slice(), K = this._visualHandlers = K.slice(), this._allHandlers = U.concat(K);
    }
    return H.prototype.restoreData = function(C, G) {
      C.restoreData(G), this._stageTaskMap.each(function(U) {
        var K = U.overallTask;
        K && K.dirty();
      });
    }, H.prototype.getPerformArgs = function(C, G) {
      if (C.__pipeline) {
        var U = this._pipelineMap.get(C.__pipeline.id), K = U.context, W = !G && U.progressiveEnabled && (!K || K.progressiveRender) && C.__idxInPipeline > U.blockIndex, Z = W ? U.step : null, X = K && K.modDataCount, Q = X != null ? Math.ceil(X / Z) : null;
        return {
          step: Z,
          modBy: Q,
          modDataCount: X
        };
      }
    }, H.prototype.getPipeline = function(C) {
      return this._pipelineMap.get(C);
    }, H.prototype.updateStreamModes = function(C, G) {
      var U = this._pipelineMap.get(C.uid), K = C.getData(), W = K.count(), Z = U.progressiveEnabled && G.incrementalPrepareRender && W >= U.threshold, X = C.get("large") && W >= C.get("largeThreshold"), Q = C.get("progressiveChunkMode") === "mod" ? W : null;
      C.pipelineContext = U.context = {
        progressiveRender: Z,
        modDataCount: Q,
        large: X
      };
    }, H.prototype.restorePipelines = function(C) {
      var G = this, U = G._pipelineMap = createHashMap();
      C.eachSeries(function(K) {
        var W = K.getProgressive(), Z = K.uid;
        U.set(Z, {
          id: Z,
          head: null,
          tail: null,
          threshold: K.getProgressiveThreshold(),
          progressiveEnabled: W && !(K.preventIncremental && K.preventIncremental()),
          blockIndex: -1,
          step: Math.round(W || 700),
          count: 0
        }), G._pipe(K, K.dataTask);
      });
    }, H.prototype.prepareStageTasks = function() {
      var C = this._stageTaskMap, G = this.api.getModel(), U = this.api;
      each$f(this._allHandlers, function(K) {
        var W = C.get(K.uid) || C.set(K.uid, {}), Z = "";
        process.env.NODE_ENV !== "production" && (Z = '"reset" and "overallReset" must not be both specified.'), assert(!(K.reset && K.overallReset), Z), K.reset && this._createSeriesStageTask(K, W, G, U), K.overallReset && this._createOverallStageTask(K, W, G, U);
      }, this);
    }, H.prototype.prepareView = function(C, G, U, K) {
      var W = C.renderTask, Z = W.context;
      Z.model = G, Z.ecModel = U, Z.api = K, W.__block = !C.incrementalPrepareRender, this._pipe(G, W);
    }, H.prototype.performDataProcessorTasks = function(C, G) {
      this._performStageTasks(this._dataProcessorHandlers, C, G, {
        block: !0
      });
    }, H.prototype.performVisualTasks = function(C, G, U) {
      this._performStageTasks(this._visualHandlers, C, G, U);
    }, H.prototype._performStageTasks = function(C, G, U, K) {
      K = K || {};
      var W = !1, Z = this;
      each$f(C, function(Q, ee) {
        if (!(K.visualType && K.visualType !== Q.visualType)) {
          var te = Z._stageTaskMap.get(Q.uid), re = te.seriesTaskMap, ne = te.overallTask;
          if (ne) {
            var ae, ie = ne.agentStubMap;
            ie.each(function(oe) {
              X(K, oe) && (oe.dirty(), ae = !0);
            }), ae && ne.dirty(), Z.updatePayload(ne, U);
            var se = Z.getPerformArgs(ne, K.block);
            ie.each(function(oe) {
              oe.perform(se);
            }), ne.perform(se) && (W = !0);
          } else
            re && re.each(function(oe, le) {
              X(K, oe) && oe.dirty();
              var ue = Z.getPerformArgs(oe, K.block);
              ue.skip = !Q.performRawSeries && G.isSeriesFiltered(oe.context.model), Z.updatePayload(oe, U), oe.perform(ue) && (W = !0);
            });
        }
      });
      function X(Q, ee) {
        return Q.setDirty && (!Q.dirtyMap || Q.dirtyMap.get(ee.__pipeline.id));
      }
      this.unfinished = W || this.unfinished;
    }, H.prototype.performSeriesTasks = function(C) {
      var G;
      C.eachSeries(function(U) {
        G = U.dataTask.perform() || G;
      }), this.unfinished = G || this.unfinished;
    }, H.prototype.plan = function() {
      this._pipelineMap.each(function(C) {
        var G = C.tail;
        do {
          if (G.__block) {
            C.blockIndex = G.__idxInPipeline;
            break;
          }
          G = G.getUpstream();
        } while (G);
      });
    }, H.prototype.updatePayload = function(C, G) {
      G !== "remain" && (C.context.payload = G);
    }, H.prototype._createSeriesStageTask = function(C, G, U, K) {
      var W = this, Z = G.seriesTaskMap, X = G.seriesTaskMap = createHashMap(), Q = C.seriesType, ee = C.getTargetSeries;
      C.createOnAllSeries ? U.eachRawSeries(te) : Q ? U.eachRawSeriesByType(Q, te) : ee && ee(U, K).each(te);
      function te(re) {
        var ne = re.uid, ae = X.set(ne, Z && Z.get(ne) || createTask({
          plan: seriesTaskPlan,
          reset: seriesTaskReset,
          count: seriesTaskCount
        }));
        ae.context = {
          model: re,
          ecModel: U,
          api: K,
          // PENDING: `useClearVisual` not used?
          useClearVisual: C.isVisual && !C.isLayout,
          plan: C.plan,
          reset: C.reset,
          scheduler: W
        }, W._pipe(re, ae);
      }
    }, H.prototype._createOverallStageTask = function(C, G, U, K) {
      var W = this, Z = G.overallTask = G.overallTask || createTask({
        reset: overallTaskReset
      });
      Z.context = {
        ecModel: U,
        api: K,
        overallReset: C.overallReset,
        scheduler: W
      };
      var X = Z.agentStubMap, Q = Z.agentStubMap = createHashMap(), ee = C.seriesType, te = C.getTargetSeries, re = !0, ne = !1, ae = "";
      process.env.NODE_ENV !== "production" && (ae = '"createOnAllSeries" is not supported for "overallReset", because it will block all streams.'), assert(!C.createOnAllSeries, ae), ee ? U.eachRawSeriesByType(ee, ie) : te ? te(U, K).each(ie) : (re = !1, each$f(U.getSeries(), ie));
      function ie(se) {
        var oe = se.uid, le = Q.set(oe, X && X.get(oe) || // When the result of `getTargetSeries` changed, the overallTask
        // should be set as dirty and re-performed.
        (ne = !0, createTask({
          reset: stubReset,
          onDirty: stubOnDirty
        })));
        le.context = {
          model: se,
          overallProgress: re
          // FIXME:TS never used, so comment it
          // modifyOutputEnd: modifyOutputEnd
        }, le.agent = Z, le.__block = re, W._pipe(se, le);
      }
      ne && Z.dirty();
    }, H.prototype._pipe = function(C, G) {
      var U = C.uid, K = this._pipelineMap.get(U);
      !K.head && (K.head = G), K.tail && K.tail.pipe(G), K.tail = G, G.__idxInPipeline = K.count++, G.__pipeline = K;
    }, H.wrapStageHandler = function(C, G) {
      return isFunction(C) && (C = {
        overallReset: C,
        seriesType: detectSeriseType(C)
      }), C.uid = getUID("stageHandler"), G && (C.visualType = G), C;
    }, H;
  }()
);
function overallTaskReset(H) {
  H.overallReset(H.ecModel, H.api, H.payload);
}
function stubReset(H) {
  return H.overallProgress && stubProgress;
}
function stubProgress() {
  this.agent.dirty(), this.getDownstream().dirty();
}
function stubOnDirty() {
  this.agent && this.agent.dirty();
}
function seriesTaskPlan(H) {
  return H.plan ? H.plan(H.model, H.ecModel, H.api, H.payload) : null;
}
function seriesTaskReset(H) {
  H.useClearVisual && H.data.clearAllVisual();
  var C = H.resetDefines = normalizeToArray(H.reset(H.model, H.ecModel, H.api, H.payload));
  return C.length > 1 ? map$1(C, function(G, U) {
    return makeSeriesTaskProgress(U);
  }) : singleSeriesTaskProgress;
}
var singleSeriesTaskProgress = makeSeriesTaskProgress(0);
function makeSeriesTaskProgress(H) {
  return function(C, G) {
    var U = G.data, K = G.resetDefines[H];
    if (K && K.dataEach)
      for (var W = C.start; W < C.end; W++)
        K.dataEach(U, W);
    else
      K && K.progress && K.progress(C, U);
  };
}
function seriesTaskCount(H) {
  return H.data.count();
}
function detectSeriseType(H) {
  seriesType = null;
  try {
    H(ecModelMock, apiMock);
  } catch {
  }
  return seriesType;
}
var ecModelMock = {}, apiMock = {}, seriesType;
mockMethods(ecModelMock, GlobalModel$1);
mockMethods(apiMock, ExtensionAPI$1);
ecModelMock.eachSeriesByType = ecModelMock.eachRawSeriesByType = function(H) {
  seriesType = H;
};
ecModelMock.eachComponent = function(H) {
  H.mainType === "series" && H.subType && (seriesType = H.subType);
};
function mockMethods(H, C) {
  for (var G in C.prototype)
    H[G] = noop;
}
const Scheduler$1 = Scheduler;
var colorAll = ["#37A2DA", "#32C5E9", "#67E0E3", "#9FE6B8", "#FFDB5C", "#ff9f7f", "#fb7293", "#E062AE", "#E690D1", "#e7bcf3", "#9d96f5", "#8378EA", "#96BFFF"];
const lightTheme = {
  color: colorAll,
  colorLayer: [["#37A2DA", "#ffd85c", "#fd7b5f"], ["#37A2DA", "#67E0E3", "#FFDB5C", "#ff9f7f", "#E062AE", "#9d96f5"], ["#37A2DA", "#32C5E9", "#9FE6B8", "#FFDB5C", "#ff9f7f", "#fb7293", "#e7bcf3", "#8378EA", "#96BFFF"], colorAll]
};
var contrastColor = "#B9B8CE", backgroundColor = "#100C2A", axisCommon = function() {
  return {
    axisLine: {
      lineStyle: {
        color: contrastColor
      }
    },
    splitLine: {
      lineStyle: {
        color: "#484753"
      }
    },
    splitArea: {
      areaStyle: {
        color: ["rgba(255,255,255,0.02)", "rgba(255,255,255,0.05)"]
      }
    },
    minorSplitLine: {
      lineStyle: {
        color: "#20203B"
      }
    }
  };
}, colorPalette = ["#4992ff", "#7cffb2", "#fddd60", "#ff6e76", "#58d9f9", "#05c091", "#ff8a45", "#8d48e3", "#dd79ff"], theme$2 = {
  darkMode: !0,
  color: colorPalette,
  backgroundColor,
  axisPointer: {
    lineStyle: {
      color: "#817f91"
    },
    crossStyle: {
      color: "#817f91"
    },
    label: {
      // TODO Contrast of label backgorundColor
      color: "#fff"
    }
  },
  legend: {
    textStyle: {
      color: contrastColor
    }
  },
  textStyle: {
    color: contrastColor
  },
  title: {
    textStyle: {
      color: "#EEF1FA"
    },
    subtextStyle: {
      color: "#B9B8CE"
    }
  },
  toolbox: {
    iconStyle: {
      borderColor: contrastColor
    }
  },
  dataZoom: {
    borderColor: "#71708A",
    textStyle: {
      color: contrastColor
    },
    brushStyle: {
      color: "rgba(135,163,206,0.3)"
    },
    handleStyle: {
      color: "#353450",
      borderColor: "#C5CBE3"
    },
    moveHandleStyle: {
      color: "#B0B6C3",
      opacity: 0.3
    },
    fillerColor: "rgba(135,163,206,0.2)",
    emphasis: {
      handleStyle: {
        borderColor: "#91B7F2",
        color: "#4D587D"
      },
      moveHandleStyle: {
        color: "#636D9A",
        opacity: 0.7
      }
    },
    dataBackground: {
      lineStyle: {
        color: "#71708A",
        width: 1
      },
      areaStyle: {
        color: "#71708A"
      }
    },
    selectedDataBackground: {
      lineStyle: {
        color: "#87A3CE"
      },
      areaStyle: {
        color: "#87A3CE"
      }
    }
  },
  visualMap: {
    textStyle: {
      color: contrastColor
    }
  },
  timeline: {
    lineStyle: {
      color: contrastColor
    },
    label: {
      color: contrastColor
    },
    controlStyle: {
      color: contrastColor,
      borderColor: contrastColor
    }
  },
  calendar: {
    itemStyle: {
      color: backgroundColor
    },
    dayLabel: {
      color: contrastColor
    },
    monthLabel: {
      color: contrastColor
    },
    yearLabel: {
      color: contrastColor
    }
  },
  timeAxis: axisCommon(),
  logAxis: axisCommon(),
  valueAxis: axisCommon(),
  categoryAxis: axisCommon(),
  line: {
    symbol: "circle"
  },
  graph: {
    color: colorPalette
  },
  gauge: {
    title: {
      color: contrastColor
    },
    axisLine: {
      lineStyle: {
        color: [[1, "rgba(207,212,219,0.2)"]]
      }
    },
    axisLabel: {
      color: contrastColor
    },
    detail: {
      color: "#EEF1FA"
    }
  },
  candlestick: {
    itemStyle: {
      color: "#f64e56",
      color0: "#54ea92",
      borderColor: "#f64e56",
      borderColor0: "#54ea92"
      // borderColor: '#ca2824',
      // borderColor0: '#09a443'
    }
  }
};
theme$2.categoryAxis.splitLine.show = !1;
const darkTheme = theme$2;
var ECEventProcessor = (
  /** @class */
  function() {
    function H() {
    }
    return H.prototype.normalizeQuery = function(C) {
      var G = {}, U = {}, K = {};
      if (isString(C)) {
        var W = parseClassType(C);
        G.mainType = W.main || null, G.subType = W.sub || null;
      } else {
        var Z = ["Index", "Name", "Id"], X = {
          name: 1,
          dataIndex: 1,
          dataType: 1
        };
        each$f(C, function(Q, ee) {
          for (var te = !1, re = 0; re < Z.length; re++) {
            var ne = Z[re], ae = ee.lastIndexOf(ne);
            if (ae > 0 && ae === ee.length - ne.length) {
              var ie = ee.slice(0, ae);
              ie !== "data" && (G.mainType = ie, G[ne.toLowerCase()] = Q, te = !0);
            }
          }
          X.hasOwnProperty(ee) && (U[ee] = Q, te = !0), te || (K[ee] = Q);
        });
      }
      return {
        cptQuery: G,
        dataQuery: U,
        otherQuery: K
      };
    }, H.prototype.filter = function(C, G) {
      var U = this.eventInfo;
      if (!U)
        return !0;
      var K = U.targetEl, W = U.packedEvent, Z = U.model, X = U.view;
      if (!Z || !X)
        return !0;
      var Q = G.cptQuery, ee = G.dataQuery;
      return te(Q, Z, "mainType") && te(Q, Z, "subType") && te(Q, Z, "index", "componentIndex") && te(Q, Z, "name") && te(Q, Z, "id") && te(ee, W, "name") && te(ee, W, "dataIndex") && te(ee, W, "dataType") && (!X.filterForExposedEvent || X.filterForExposedEvent(C, G.otherQuery, K, W));
      function te(re, ne, ae, ie) {
        return re[ae] == null || ne[ie || ae] === re[ae];
      }
    }, H.prototype.afterTrigger = function() {
      this.eventInfo = null;
    }, H;
  }()
), SYMBOL_PROPS_WITH_CB = ["symbol", "symbolSize", "symbolRotate", "symbolOffset"], SYMBOL_PROPS = SYMBOL_PROPS_WITH_CB.concat(["symbolKeepAspect"]), seriesSymbolTask = {
  createOnAllSeries: !0,
  // For legend.
  performRawSeries: !0,
  reset: function(H, C) {
    var G = H.getData();
    if (H.legendIcon && G.setVisual("legendIcon", H.legendIcon), !H.hasSymbolVisual)
      return;
    for (var U = {}, K = {}, W = !1, Z = 0; Z < SYMBOL_PROPS_WITH_CB.length; Z++) {
      var X = SYMBOL_PROPS_WITH_CB[Z], Q = H.get(X);
      isFunction(Q) ? (W = !0, K[X] = Q) : U[X] = Q;
    }
    if (U.symbol = U.symbol || H.defaultSymbol, G.setVisual(extend({
      legendIcon: H.legendIcon || U.symbol,
      symbolKeepAspect: H.get("symbolKeepAspect")
    }, U)), C.isSeriesFiltered(H))
      return;
    var ee = keys(K);
    function te(re, ne) {
      for (var ae = H.getRawValue(ne), ie = H.getDataParams(ne), se = 0; se < ee.length; se++) {
        var oe = ee[se];
        re.setItemVisual(ne, oe, K[oe](ae, ie));
      }
    }
    return {
      dataEach: W ? te : null
    };
  }
}, dataSymbolTask = {
  createOnAllSeries: !0,
  // For legend.
  performRawSeries: !0,
  reset: function(H, C) {
    if (!H.hasSymbolVisual || C.isSeriesFiltered(H))
      return;
    var G = H.getData();
    function U(K, W) {
      for (var Z = K.getItemModel(W), X = 0; X < SYMBOL_PROPS.length; X++) {
        var Q = SYMBOL_PROPS[X], ee = Z.getShallow(Q, !0);
        ee != null && K.setItemVisual(W, Q, ee);
      }
    }
    return {
      dataEach: G.hasItemOption ? U : null
    };
  }
};
function getItemVisualFromData(H, C, G) {
  switch (G) {
    case "color":
      var U = H.getItemVisual(C, "style");
      return U[H.getVisual("drawType")];
    case "opacity":
      return H.getItemVisual(C, "style").opacity;
    case "symbol":
    case "symbolSize":
    case "liftZ":
      return H.getItemVisual(C, G);
    default:
      process.env.NODE_ENV !== "production" && console.warn("Unknown visual type " + G);
  }
}
function getVisualFromData(H, C) {
  switch (C) {
    case "color":
      var G = H.getVisual("style");
      return G[H.getVisual("drawType")];
    case "opacity":
      return H.getVisual("style").opacity;
    case "symbol":
    case "symbolSize":
    case "liftZ":
      return H.getVisual(C);
    default:
      process.env.NODE_ENV !== "production" && console.warn("Unknown visual type " + C);
  }
}
function setItemVisualFromData(H, C, G, U) {
  switch (G) {
    case "color":
      var K = H.ensureUniqueItemVisual(C, "style");
      K[H.getVisual("drawType")] = U, H.setItemVisual(C, "colorFromPalette", !1);
      break;
    case "opacity":
      H.ensureUniqueItemVisual(C, "style").opacity = U;
      break;
    case "symbol":
    case "symbolSize":
    case "liftZ":
      H.setItemVisual(C, G, U);
      break;
    default:
      process.env.NODE_ENV !== "production" && console.warn("Unknown visual type " + G);
  }
}
function createLegacyDataSelectAction(H, C) {
  function G(U, K) {
    var W = [];
    return U.eachComponent({
      mainType: "series",
      subType: H,
      query: K
    }, function(Z) {
      W.push(Z.seriesIndex);
    }), W;
  }
  each$f([[H + "ToggleSelect", "toggleSelect"], [H + "Select", "select"], [H + "UnSelect", "unselect"]], function(U) {
    C(U[0], function(K, W, Z) {
      K = extend({}, K), process.env.NODE_ENV !== "production" && deprecateReplaceLog(K.type, U[1]), Z.dispatchAction(extend(K, {
        type: U[1],
        seriesIndex: G(W, K)
      }));
    });
  });
}
function handleSeriesLegacySelectEvents(H, C, G, U, K) {
  var W = H + C;
  G.isSilent(W) || (process.env.NODE_ENV !== "production" && deprecateLog("event " + W + " is deprecated."), U.eachComponent({
    mainType: "series",
    subType: "pie"
  }, function(Z) {
    for (var X = Z.seriesIndex, Q = Z.option.selectedMap, ee = K.selected, te = 0; te < ee.length; te++)
      if (ee[te].seriesIndex === X) {
        var re = Z.getData(), ne = queryDataIndex(re, K.fromActionPayload);
        G.trigger(W, {
          type: W,
          seriesId: Z.id,
          name: isArray$1(ne) ? re.getName(ne[0]) : re.getName(ne),
          selected: isString(Q) ? Q : extend({}, Q)
        });
      }
  }));
}
function handleLegacySelectEvents(H, C, G) {
  H.on("selectchanged", function(U) {
    var K = G.getModel();
    U.isFromClick ? (handleSeriesLegacySelectEvents("map", "selectchanged", C, K, U), handleSeriesLegacySelectEvents("pie", "selectchanged", C, K, U)) : U.fromAction === "select" ? (handleSeriesLegacySelectEvents("map", "selected", C, K, U), handleSeriesLegacySelectEvents("pie", "selected", C, K, U)) : U.fromAction === "unselect" && (handleSeriesLegacySelectEvents("map", "unselected", C, K, U), handleSeriesLegacySelectEvents("pie", "unselected", C, K, U));
  });
}
function findEventDispatcher(H, C, G) {
  for (var U; H && !(C(H) && (U = H, G)); )
    H = H.__hostTarget || H.parent;
  return U;
}
var wmUniqueIndex = Math.round(Math.random() * 9), supportDefineProperty = typeof Object.defineProperty == "function", WeakMap$1 = function() {
  function H() {
    this._id = "__ec_inner_" + wmUniqueIndex++;
  }
  return H.prototype.get = function(C) {
    return this._guard(C)[this._id];
  }, H.prototype.set = function(C, G) {
    var U = this._guard(C);
    return supportDefineProperty ? Object.defineProperty(U, this._id, {
      value: G,
      enumerable: !1,
      configurable: !0
    }) : U[this._id] = G, this;
  }, H.prototype.delete = function(C) {
    return this.has(C) ? (delete this._guard(C)[this._id], !0) : !1;
  }, H.prototype.has = function(C) {
    return !!this._guard(C)[this._id];
  }, H.prototype._guard = function(C) {
    if (C !== Object(C))
      throw TypeError("Value of WeakMap is not a non-null object.");
    return C;
  }, H;
}();
const WeakMap$2 = WeakMap$1;
var Triangle = Path$1.extend({
  type: "triangle",
  shape: {
    cx: 0,
    cy: 0,
    width: 0,
    height: 0
  },
  buildPath: function(H, C) {
    var G = C.cx, U = C.cy, K = C.width / 2, W = C.height / 2;
    H.moveTo(G, U - W), H.lineTo(G + K, U + W), H.lineTo(G - K, U + W), H.closePath();
  }
}), Diamond = Path$1.extend({
  type: "diamond",
  shape: {
    cx: 0,
    cy: 0,
    width: 0,
    height: 0
  },
  buildPath: function(H, C) {
    var G = C.cx, U = C.cy, K = C.width / 2, W = C.height / 2;
    H.moveTo(G, U - W), H.lineTo(G + K, U), H.lineTo(G, U + W), H.lineTo(G - K, U), H.closePath();
  }
}), Pin = Path$1.extend({
  type: "pin",
  shape: {
    // x, y on the cusp
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  buildPath: function(H, C) {
    var G = C.x, U = C.y, K = C.width / 5 * 3, W = Math.max(K, C.height), Z = K / 2, X = Z * Z / (W - Z), Q = U - W + Z + X, ee = Math.asin(X / Z), te = Math.cos(ee) * Z, re = Math.sin(ee), ne = Math.cos(ee), ae = Z * 0.6, ie = Z * 0.7;
    H.moveTo(G - te, Q + X), H.arc(G, Q, Z, Math.PI - ee, Math.PI * 2 + ee), H.bezierCurveTo(G + te - re * ae, Q + X + ne * ae, G, U - ie, G, U), H.bezierCurveTo(G, U - ie, G - te + re * ae, Q + X + ne * ae, G - te, Q + X), H.closePath();
  }
}), Arrow = Path$1.extend({
  type: "arrow",
  shape: {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  buildPath: function(H, C) {
    var G = C.height, U = C.width, K = C.x, W = C.y, Z = U / 3 * 2;
    H.moveTo(K, W), H.lineTo(K + Z, W + G), H.lineTo(K, W + G / 4 * 3), H.lineTo(K - Z, W + G), H.lineTo(K, W), H.closePath();
  }
}), symbolCtors = {
  line: Line$3,
  rect: Rect$3,
  roundRect: Rect$3,
  square: Rect$3,
  circle: Circle$1,
  diamond: Diamond,
  pin: Pin,
  arrow: Arrow,
  triangle: Triangle
}, symbolShapeMakers = {
  line: function(H, C, G, U, K) {
    K.x1 = H, K.y1 = C + U / 2, K.x2 = H + G, K.y2 = C + U / 2;
  },
  rect: function(H, C, G, U, K) {
    K.x = H, K.y = C, K.width = G, K.height = U;
  },
  roundRect: function(H, C, G, U, K) {
    K.x = H, K.y = C, K.width = G, K.height = U, K.r = Math.min(G, U) / 4;
  },
  square: function(H, C, G, U, K) {
    var W = Math.min(G, U);
    K.x = H, K.y = C, K.width = W, K.height = W;
  },
  circle: function(H, C, G, U, K) {
    K.cx = H + G / 2, K.cy = C + U / 2, K.r = Math.min(G, U) / 2;
  },
  diamond: function(H, C, G, U, K) {
    K.cx = H + G / 2, K.cy = C + U / 2, K.width = G, K.height = U;
  },
  pin: function(H, C, G, U, K) {
    K.x = H + G / 2, K.y = C + U / 2, K.width = G, K.height = U;
  },
  arrow: function(H, C, G, U, K) {
    K.x = H + G / 2, K.y = C + U / 2, K.width = G, K.height = U;
  },
  triangle: function(H, C, G, U, K) {
    K.cx = H + G / 2, K.cy = C + U / 2, K.width = G, K.height = U;
  }
}, symbolBuildProxies = {};
each$f(symbolCtors, function(H, C) {
  symbolBuildProxies[C] = new H();
});
var SymbolClz$1 = Path$1.extend({
  type: "symbol",
  shape: {
    symbolType: "",
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  calculateTextPosition: function(H, C, G) {
    var U = calculateTextPosition(H, C, G), K = this.shape;
    return K && K.symbolType === "pin" && C.position === "inside" && (U.y = G.y + G.height * 0.4), U;
  },
  buildPath: function(H, C, G) {
    var U = C.symbolType;
    if (U !== "none") {
      var K = symbolBuildProxies[U];
      K || (U = "rect", K = symbolBuildProxies[U]), symbolShapeMakers[U](C.x, C.y, C.width, C.height, K.shape), K.buildPath(H, K.shape, G);
    }
  }
});
function symbolPathSetColor(H, C) {
  if (this.type !== "image") {
    var G = this.style;
    this.__isEmptyBrush ? (G.stroke = H, G.fill = C || "#fff", G.lineWidth = 2) : this.shape.symbolType === "line" ? G.stroke = H : G.fill = H, this.markRedraw();
  }
}
function createSymbol$1(H, C, G, U, K, W, Z) {
  var X = H.indexOf("empty") === 0;
  X && (H = H.substr(5, 1).toLowerCase() + H.substr(6));
  var Q;
  return H.indexOf("image://") === 0 ? Q = makeImage(H.slice(8), new BoundingRect$1(C, G, U, K), Z ? "center" : "cover") : H.indexOf("path://") === 0 ? Q = makePath(H.slice(7), {}, new BoundingRect$1(C, G, U, K), Z ? "center" : "cover") : Q = new SymbolClz$1({
    shape: {
      symbolType: H,
      x: C,
      y: G,
      width: U,
      height: K
    }
  }), Q.__isEmptyBrush = X, Q.setColor = symbolPathSetColor, W && Q.setColor(W), Q;
}
function normalizeSymbolSize(H) {
  return isArray$1(H) || (H = [+H, +H]), [H[0] || 0, H[1] || 0];
}
function normalizeSymbolOffset(H, C) {
  if (H != null)
    return isArray$1(H) || (H = [H, H]), [parsePercent(H[0], C[0]) || 0, parsePercent(retrieve2(H[1], H[0]), C[1]) || 0];
}
function isSafeNum(H) {
  return isFinite(H);
}
function createLinearGradient(H, C, G) {
  var U = C.x == null ? 0 : C.x, K = C.x2 == null ? 1 : C.x2, W = C.y == null ? 0 : C.y, Z = C.y2 == null ? 0 : C.y2;
  C.global || (U = U * G.width + G.x, K = K * G.width + G.x, W = W * G.height + G.y, Z = Z * G.height + G.y), U = isSafeNum(U) ? U : 0, K = isSafeNum(K) ? K : 1, W = isSafeNum(W) ? W : 0, Z = isSafeNum(Z) ? Z : 0;
  var X = H.createLinearGradient(U, W, K, Z);
  return X;
}
function createRadialGradient(H, C, G) {
  var U = G.width, K = G.height, W = Math.min(U, K), Z = C.x == null ? 0.5 : C.x, X = C.y == null ? 0.5 : C.y, Q = C.r == null ? 0.5 : C.r;
  C.global || (Z = Z * U + G.x, X = X * K + G.y, Q = Q * W), Z = isSafeNum(Z) ? Z : 0.5, X = isSafeNum(X) ? X : 0.5, Q = Q >= 0 && isSafeNum(Q) ? Q : 0.5;
  var ee = H.createRadialGradient(Z, X, 0, Z, X, Q);
  return ee;
}
function getCanvasGradient(H, C, G) {
  for (var U = C.type === "radial" ? createRadialGradient(H, C, G) : createLinearGradient(H, C, G), K = C.colorStops, W = 0; W < K.length; W++)
    U.addColorStop(K[W].offset, K[W].color);
  return U;
}
function isClipPathChanged(H, C) {
  if (H === C || !H && !C)
    return !1;
  if (!H || !C || H.length !== C.length)
    return !0;
  for (var G = 0; G < H.length; G++)
    if (H[G] !== C[G])
      return !0;
  return !1;
}
function parseInt10(H) {
  return parseInt(H, 10);
}
function getSize$1(H, C, G) {
  var U = ["width", "height"][C], K = ["clientWidth", "clientHeight"][C], W = ["paddingLeft", "paddingTop"][C], Z = ["paddingRight", "paddingBottom"][C];
  if (G[U] != null && G[U] !== "auto")
    return parseFloat(G[U]);
  var X = document.defaultView.getComputedStyle(H);
  return (H[K] || parseInt10(X[U]) || parseInt10(H.style[U])) - (parseInt10(X[W]) || 0) - (parseInt10(X[Z]) || 0) | 0;
}
function normalizeLineDash(H, C) {
  return !H || H === "solid" || !(C > 0) ? null : H === "dashed" ? [4 * C, 2 * C] : H === "dotted" ? [C] : isNumber(H) ? [H] : isArray$1(H) ? H : null;
}
function getLineDash(H) {
  var C = H.style, G = C.lineDash && C.lineWidth > 0 && normalizeLineDash(C.lineDash, C.lineWidth), U = C.lineDashOffset;
  if (G) {
    var K = C.strokeNoScale && H.getLineScale ? H.getLineScale() : 1;
    K && K !== 1 && (G = map$1(G, function(W) {
      return W / K;
    }), U /= K);
  }
  return [G, U];
}
var pathProxyForDraw = new PathProxy$1(!0);
function styleHasStroke(H) {
  var C = H.stroke;
  return !(C == null || C === "none" || !(H.lineWidth > 0));
}
function isValidStrokeFillStyle(H) {
  return typeof H == "string" && H !== "none";
}
function styleHasFill(H) {
  var C = H.fill;
  return C != null && C !== "none";
}
function doFillPath(H, C) {
  if (C.fillOpacity != null && C.fillOpacity !== 1) {
    var G = H.globalAlpha;
    H.globalAlpha = C.fillOpacity * C.opacity, H.fill(), H.globalAlpha = G;
  } else
    H.fill();
}
function doStrokePath(H, C) {
  if (C.strokeOpacity != null && C.strokeOpacity !== 1) {
    var G = H.globalAlpha;
    H.globalAlpha = C.strokeOpacity * C.opacity, H.stroke(), H.globalAlpha = G;
  } else
    H.stroke();
}
function createCanvasPattern(H, C, G) {
  var U = createOrUpdateImage(C.image, C.__image, G);
  if (isImageReady(U)) {
    var K = H.createPattern(U, C.repeat || "repeat");
    if (typeof DOMMatrix == "function" && K && K.setTransform) {
      var W = new DOMMatrix();
      W.translateSelf(C.x || 0, C.y || 0), W.rotateSelf(0, 0, (C.rotation || 0) * RADIAN_TO_DEGREE), W.scaleSelf(C.scaleX || 1, C.scaleY || 1), K.setTransform(W);
    }
    return K;
  }
}
function brushPath(H, C, G, U) {
  var K, W = styleHasStroke(G), Z = styleHasFill(G), X = G.strokePercent, Q = X < 1, ee = !C.path;
  (!C.silent || Q) && ee && C.createPathProxy();
  var te = C.path || pathProxyForDraw, re = C.__dirty;
  if (!U) {
    var ne = G.fill, ae = G.stroke, ie = Z && !!ne.colorStops, se = W && !!ae.colorStops, oe = Z && !!ne.image, le = W && !!ae.image, ue = void 0, ce = void 0, de = void 0, ge = void 0, fe = void 0;
    (ie || se) && (fe = C.getBoundingRect()), ie && (ue = re ? getCanvasGradient(H, ne, fe) : C.__canvasFillGradient, C.__canvasFillGradient = ue), se && (ce = re ? getCanvasGradient(H, ae, fe) : C.__canvasStrokeGradient, C.__canvasStrokeGradient = ce), oe && (de = re || !C.__canvasFillPattern ? createCanvasPattern(H, ne, C) : C.__canvasFillPattern, C.__canvasFillPattern = de), le && (ge = re || !C.__canvasStrokePattern ? createCanvasPattern(H, ae, C) : C.__canvasStrokePattern, C.__canvasStrokePattern = de), ie ? H.fillStyle = ue : oe && (de ? H.fillStyle = de : Z = !1), se ? H.strokeStyle = ce : le && (ge ? H.strokeStyle = ge : W = !1);
  }
  var ve = C.getGlobalScale();
  te.setScale(ve[0], ve[1], C.segmentIgnoreThreshold);
  var pe, he;
  H.setLineDash && G.lineDash && (K = getLineDash(C), pe = K[0], he = K[1]);
  var me = !0;
  (ee || re & SHAPE_CHANGED_BIT) && (te.setDPR(H.dpr), Q ? te.setContext(null) : (te.setContext(H), me = !1), te.reset(), C.buildPath(te, C.shape, U), te.toStatic(), C.pathUpdated()), me && te.rebuildPath(H, Q ? X : 1), pe && (H.setLineDash(pe), H.lineDashOffset = he), U || (G.strokeFirst ? (W && doStrokePath(H, G), Z && doFillPath(H, G)) : (Z && doFillPath(H, G), W && doStrokePath(H, G))), pe && H.setLineDash([]);
}
function brushImage(H, C, G) {
  var U = C.__image = createOrUpdateImage(G.image, C.__image, C, C.onload);
  if (!(!U || !isImageReady(U))) {
    var K = G.x || 0, W = G.y || 0, Z = C.getWidth(), X = C.getHeight(), Q = U.width / U.height;
    if (Z == null && X != null ? Z = X * Q : X == null && Z != null ? X = Z / Q : Z == null && X == null && (Z = U.width, X = U.height), G.sWidth && G.sHeight) {
      var ee = G.sx || 0, te = G.sy || 0;
      H.drawImage(U, ee, te, G.sWidth, G.sHeight, K, W, Z, X);
    } else if (G.sx && G.sy) {
      var ee = G.sx, te = G.sy, re = Z - ee, ne = X - te;
      H.drawImage(U, ee, te, re, ne, K, W, Z, X);
    } else
      H.drawImage(U, K, W, Z, X);
  }
}
function brushText(H, C, G) {
  var U, K = G.text;
  if (K != null && (K += ""), K) {
    H.font = G.font || DEFAULT_FONT, H.textAlign = G.textAlign, H.textBaseline = G.textBaseline;
    var W = void 0, Z = void 0;
    H.setLineDash && G.lineDash && (U = getLineDash(C), W = U[0], Z = U[1]), W && (H.setLineDash(W), H.lineDashOffset = Z), G.strokeFirst ? (styleHasStroke(G) && H.strokeText(K, G.x, G.y), styleHasFill(G) && H.fillText(K, G.x, G.y)) : (styleHasFill(G) && H.fillText(K, G.x, G.y), styleHasStroke(G) && H.strokeText(K, G.x, G.y)), W && H.setLineDash([]);
  }
}
var SHADOW_NUMBER_PROPS = ["shadowBlur", "shadowOffsetX", "shadowOffsetY"], STROKE_PROPS = [
  ["lineCap", "butt"],
  ["lineJoin", "miter"],
  ["miterLimit", 10]
];
function bindCommonProps(H, C, G, U, K) {
  var W = !1;
  if (!U && (G = G || {}, C === G))
    return !1;
  if (U || C.opacity !== G.opacity) {
    flushPathDrawn(H, K), W = !0;
    var Z = Math.max(Math.min(C.opacity, 1), 0);
    H.globalAlpha = isNaN(Z) ? DEFAULT_COMMON_STYLE.opacity : Z;
  }
  (U || C.blend !== G.blend) && (W || (flushPathDrawn(H, K), W = !0), H.globalCompositeOperation = C.blend || DEFAULT_COMMON_STYLE.blend);
  for (var X = 0; X < SHADOW_NUMBER_PROPS.length; X++) {
    var Q = SHADOW_NUMBER_PROPS[X];
    (U || C[Q] !== G[Q]) && (W || (flushPathDrawn(H, K), W = !0), H[Q] = H.dpr * (C[Q] || 0));
  }
  return (U || C.shadowColor !== G.shadowColor) && (W || (flushPathDrawn(H, K), W = !0), H.shadowColor = C.shadowColor || DEFAULT_COMMON_STYLE.shadowColor), W;
}
function bindPathAndTextCommonStyle(H, C, G, U, K) {
  var W = getStyle(C, K.inHover), Z = U ? null : G && getStyle(G, K.inHover) || {};
  if (W === Z)
    return !1;
  var X = bindCommonProps(H, W, Z, U, K);
  if ((U || W.fill !== Z.fill) && (X || (flushPathDrawn(H, K), X = !0), isValidStrokeFillStyle(W.fill) && (H.fillStyle = W.fill)), (U || W.stroke !== Z.stroke) && (X || (flushPathDrawn(H, K), X = !0), isValidStrokeFillStyle(W.stroke) && (H.strokeStyle = W.stroke)), (U || W.opacity !== Z.opacity) && (X || (flushPathDrawn(H, K), X = !0), H.globalAlpha = W.opacity == null ? 1 : W.opacity), C.hasStroke()) {
    var Q = W.lineWidth, ee = Q / (W.strokeNoScale && C.getLineScale ? C.getLineScale() : 1);
    H.lineWidth !== ee && (X || (flushPathDrawn(H, K), X = !0), H.lineWidth = ee);
  }
  for (var te = 0; te < STROKE_PROPS.length; te++) {
    var re = STROKE_PROPS[te], ne = re[0];
    (U || W[ne] !== Z[ne]) && (X || (flushPathDrawn(H, K), X = !0), H[ne] = W[ne] || re[1]);
  }
  return X;
}
function bindImageStyle(H, C, G, U, K) {
  return bindCommonProps(H, getStyle(C, K.inHover), G && getStyle(G, K.inHover), U, K);
}
function setContextTransform(H, C) {
  var G = C.transform, U = H.dpr || 1;
  G ? H.setTransform(U * G[0], U * G[1], U * G[2], U * G[3], U * G[4], U * G[5]) : H.setTransform(U, 0, 0, U, 0, 0);
}
function updateClipStatus(H, C, G) {
  for (var U = !1, K = 0; K < H.length; K++) {
    var W = H[K];
    U = U || W.isZeroArea(), setContextTransform(C, W), C.beginPath(), W.buildPath(C, W.shape), C.clip();
  }
  G.allClipped = U;
}
function isTransformChanged(H, C) {
  return H && C ? H[0] !== C[0] || H[1] !== C[1] || H[2] !== C[2] || H[3] !== C[3] || H[4] !== C[4] || H[5] !== C[5] : !(!H && !C);
}
var DRAW_TYPE_PATH = 1, DRAW_TYPE_IMAGE = 2, DRAW_TYPE_TEXT = 3, DRAW_TYPE_INCREMENTAL = 4;
function canPathBatch(H) {
  var C = styleHasFill(H), G = styleHasStroke(H);
  return !(H.lineDash || !(+C ^ +G) || C && typeof H.fill != "string" || G && typeof H.stroke != "string" || H.strokePercent < 1 || H.strokeOpacity < 1 || H.fillOpacity < 1);
}
function flushPathDrawn(H, C) {
  C.batchFill && H.fill(), C.batchStroke && H.stroke(), C.batchFill = "", C.batchStroke = "";
}
function getStyle(H, C) {
  return C && H.__hoverStyle || H.style;
}
function brushSingle(H, C) {
  brush$1(H, C, { inHover: !1, viewWidth: 0, viewHeight: 0 }, !0);
}
function brush$1(H, C, G, U) {
  var K = C.transform;
  if (!C.shouldBePainted(G.viewWidth, G.viewHeight, !1, !1)) {
    C.__dirty &= ~REDRAW_BIT, C.__isRendered = !1;
    return;
  }
  var W = C.__clipPaths, Z = G.prevElClipPaths, X = !1, Q = !1;
  if ((!Z || isClipPathChanged(W, Z)) && (Z && Z.length && (flushPathDrawn(H, G), H.restore(), Q = X = !0, G.prevElClipPaths = null, G.allClipped = !1, G.prevEl = null), W && W.length && (flushPathDrawn(H, G), H.save(), updateClipStatus(W, H, G), X = !0), G.prevElClipPaths = W), G.allClipped) {
    C.__isRendered = !1;
    return;
  }
  C.beforeBrush && C.beforeBrush(), C.innerBeforeBrush();
  var ee = G.prevEl;
  ee || (Q = X = !0);
  var te = C instanceof Path$1 && C.autoBatch && canPathBatch(C.style);
  X || isTransformChanged(K, ee.transform) ? (flushPathDrawn(H, G), setContextTransform(H, C)) : te || flushPathDrawn(H, G);
  var re = getStyle(C, G.inHover);
  C instanceof Path$1 ? (G.lastDrawType !== DRAW_TYPE_PATH && (Q = !0, G.lastDrawType = DRAW_TYPE_PATH), bindPathAndTextCommonStyle(H, C, ee, Q, G), (!te || !G.batchFill && !G.batchStroke) && H.beginPath(), brushPath(H, C, re, te), te && (G.batchFill = re.fill || "", G.batchStroke = re.stroke || "")) : C instanceof TSpan$1 ? (G.lastDrawType !== DRAW_TYPE_TEXT && (Q = !0, G.lastDrawType = DRAW_TYPE_TEXT), bindPathAndTextCommonStyle(H, C, ee, Q, G), brushText(H, C, re)) : C instanceof ZRImage$1 ? (G.lastDrawType !== DRAW_TYPE_IMAGE && (Q = !0, G.lastDrawType = DRAW_TYPE_IMAGE), bindImageStyle(H, C, ee, Q, G), brushImage(H, C, re)) : C.getTemporalDisplayables && (G.lastDrawType !== DRAW_TYPE_INCREMENTAL && (Q = !0, G.lastDrawType = DRAW_TYPE_INCREMENTAL), brushIncremental(H, C, G)), te && U && flushPathDrawn(H, G), C.innerAfterBrush(), C.afterBrush && C.afterBrush(), G.prevEl = C, C.__dirty = 0, C.__isRendered = !0;
}
function brushIncremental(H, C, G) {
  var U = C.getDisplayables(), K = C.getTemporalDisplayables();
  H.save();
  var W = {
    prevElClipPaths: null,
    prevEl: null,
    allClipped: !1,
    viewWidth: G.viewWidth,
    viewHeight: G.viewHeight,
    inHover: G.inHover
  }, Z, X;
  for (Z = C.getCursor(), X = U.length; Z < X; Z++) {
    var Q = U[Z];
    Q.beforeBrush && Q.beforeBrush(), Q.innerBeforeBrush(), brush$1(H, Q, W, Z === X - 1), Q.innerAfterBrush(), Q.afterBrush && Q.afterBrush(), W.prevEl = Q;
  }
  for (var ee = 0, te = K.length; ee < te; ee++) {
    var Q = K[ee];
    Q.beforeBrush && Q.beforeBrush(), Q.innerBeforeBrush(), brush$1(H, Q, W, ee === te - 1), Q.innerAfterBrush(), Q.afterBrush && Q.afterBrush(), W.prevEl = Q;
  }
  C.clearTemporalDisplayables(), C.notClear = !0, H.restore();
}
var decalMap = new WeakMap$2(), decalCache = new LRU$1(100), decalKeys = ["symbol", "symbolSize", "symbolKeepAspect", "color", "backgroundColor", "dashArrayX", "dashArrayY", "maxTileWidth", "maxTileHeight"];
function createOrUpdatePatternFromDecal(H, C) {
  if (H === "none")
    return null;
  var G = C.getDevicePixelRatio(), U = C.getZr(), K = U.painter.type === "svg";
  H.dirty && decalMap.delete(H);
  var W = decalMap.get(H);
  if (W)
    return W;
  var Z = defaults(H, {
    symbol: "rect",
    symbolSize: 1,
    symbolKeepAspect: !0,
    color: "rgba(0, 0, 0, 0.2)",
    backgroundColor: null,
    dashArrayX: 5,
    dashArrayY: 5,
    rotation: 0,
    maxTileWidth: 512,
    maxTileHeight: 512
  });
  Z.backgroundColor === "none" && (Z.backgroundColor = null);
  var X = {
    repeat: "repeat"
  };
  return Q(X), X.rotation = Z.rotation, X.scaleX = X.scaleY = K ? 1 : 1 / G, decalMap.set(H, X), H.dirty = !1, X;
  function Q(ee) {
    for (var te = [G], re = !0, ne = 0; ne < decalKeys.length; ++ne) {
      var ae = Z[decalKeys[ne]];
      if (ae != null && !isArray$1(ae) && !isString(ae) && !isNumber(ae) && typeof ae != "boolean") {
        re = !1;
        break;
      }
      te.push(ae);
    }
    var ie;
    if (re) {
      ie = te.join(",") + (K ? "-svg" : "");
      var se = decalCache.get(ie);
      se && (K ? ee.svgElement = se : ee.image = se);
    }
    var oe = normalizeDashArrayX(Z.dashArrayX), le = normalizeDashArrayY(Z.dashArrayY), ue = normalizeSymbolArray(Z.symbol), ce = getLineBlockLengthX(oe), de = getLineBlockLengthY(le), ge = !K && platformApi.createCanvas(), fe = K && {
      tag: "g",
      attrs: {},
      key: "dcl",
      children: []
    }, ve = he(), pe;
    ge && (ge.width = ve.width * G, ge.height = ve.height * G, pe = ge.getContext("2d")), me(), re && decalCache.put(ie, ge || fe), ee.image = ge, ee.svgElement = fe, ee.svgWidth = ve.width, ee.svgHeight = ve.height;
    function he() {
      for (var ye = 1, Ce = 0, Ie = ce.length; Ce < Ie; ++Ce)
        ye = getLeastCommonMultiple(ye, ce[Ce]);
      for (var be = 1, Ce = 0, Ie = ue.length; Ce < Ie; ++Ce)
        be = getLeastCommonMultiple(be, ue[Ce].length);
      ye *= be;
      var Se = de * ce.length * ue.length;
      if (process.env.NODE_ENV !== "production") {
        var Ae = function(_e) {
          console.warn("Calculated decal size is greater than " + _e + " due to decal option settings so " + _e + " is used for the decal size. Please consider changing the decal option to make a smaller decal or set " + _e + " to be larger to avoid incontinuity.");
        };
        ye > Z.maxTileWidth && Ae("maxTileWidth"), Se > Z.maxTileHeight && Ae("maxTileHeight");
      }
      return {
        width: Math.max(1, Math.min(ye, Z.maxTileWidth)),
        height: Math.max(1, Math.min(Se, Z.maxTileHeight))
      };
    }
    function me() {
      pe && (pe.clearRect(0, 0, ge.width, ge.height), Z.backgroundColor && (pe.fillStyle = Z.backgroundColor, pe.fillRect(0, 0, ge.width, ge.height)));
      for (var ye = 0, Ce = 0; Ce < le.length; ++Ce)
        ye += le[Ce];
      if (ye <= 0)
        return;
      for (var Ie = -de, be = 0, Se = 0, Ae = 0; Ie < ve.height; ) {
        if (be % 2 === 0) {
          for (var _e = Se / 2 % ue.length, xe = 0, Te = 0, Pe = 0; xe < ve.width * 2; ) {
            for (var $e = 0, Ce = 0; Ce < oe[Ae].length; ++Ce)
              $e += oe[Ae][Ce];
            if ($e <= 0)
              break;
            if (Te % 2 === 0) {
              var Me = (1 - Z.symbolSize) * 0.5, Ee = xe + oe[Ae][Te] * Me, we = Ie + le[be] * Me, Oe = oe[Ae][Te] * Z.symbolSize, Ne = le[be] * Z.symbolSize, ke = Pe / 2 % ue[_e].length;
              ze(Ee, we, Oe, Ne, ue[_e][ke]);
            }
            xe += oe[Ae][Te], ++Pe, ++Te, Te === oe[Ae].length && (Te = 0);
          }
          ++Ae, Ae === oe.length && (Ae = 0);
        }
        Ie += le[be], ++Se, ++be, be === le.length && (be = 0);
      }
      function ze(He, We, Re, Le, De) {
        var Ue = K ? 1 : G, st = createSymbol$1(De, He * Ue, We * Ue, Re * Ue, Le * Ue, Z.color, Z.symbolKeepAspect);
        if (K) {
          var ot = U.painter.renderOneToVNode(st);
          ot && fe.children.push(ot);
        } else
          brushSingle(pe, st);
      }
    }
  }
}
function normalizeSymbolArray(H) {
  if (!H || H.length === 0)
    return [["rect"]];
  if (isString(H))
    return [[H]];
  for (var C = !0, G = 0; G < H.length; ++G)
    if (!isString(H[G])) {
      C = !1;
      break;
    }
  if (C)
    return normalizeSymbolArray([H]);
  for (var U = [], G = 0; G < H.length; ++G)
    isString(H[G]) ? U.push([H[G]]) : U.push(H[G]);
  return U;
}
function normalizeDashArrayX(H) {
  if (!H || H.length === 0)
    return [[0, 0]];
  if (isNumber(H)) {
    var C = Math.ceil(H);
    return [[C, C]];
  }
  for (var G = !0, U = 0; U < H.length; ++U)
    if (!isNumber(H[U])) {
      G = !1;
      break;
    }
  if (G)
    return normalizeDashArrayX([H]);
  for (var K = [], U = 0; U < H.length; ++U)
    if (isNumber(H[U])) {
      var C = Math.ceil(H[U]);
      K.push([C, C]);
    } else {
      var C = map$1(H[U], function(X) {
        return Math.ceil(X);
      });
      C.length % 2 === 1 ? K.push(C.concat(C)) : K.push(C);
    }
  return K;
}
function normalizeDashArrayY(H) {
  if (!H || typeof H == "object" && H.length === 0)
    return [0, 0];
  if (isNumber(H)) {
    var C = Math.ceil(H);
    return [C, C];
  }
  var G = map$1(H, function(U) {
    return Math.ceil(U);
  });
  return H.length % 2 ? G.concat(G) : G;
}
function getLineBlockLengthX(H) {
  return map$1(H, function(C) {
    return getLineBlockLengthY(C);
  });
}
function getLineBlockLengthY(H) {
  for (var C = 0, G = 0; G < H.length; ++G)
    C += H[G];
  return H.length % 2 === 1 ? C * 2 : C;
}
function decalVisual(H, C) {
  H.eachRawSeries(function(G) {
    if (!H.isSeriesFiltered(G)) {
      var U = G.getData();
      U.hasItemVisual() && U.each(function(Z) {
        var X = U.getItemVisual(Z, "decal");
        if (X) {
          var Q = U.ensureUniqueItemVisual(Z, "style");
          Q.decal = createOrUpdatePatternFromDecal(X, C);
        }
      });
      var K = U.getVisual("decal");
      if (K) {
        var W = U.getVisual("style");
        W.decal = createOrUpdatePatternFromDecal(K, C);
      }
    }
  });
}
var lifecycle = new Eventful$1();
const lifecycle$1 = lifecycle;
var implsStore = {};
function registerImpl(H, C) {
  process.env.NODE_ENV !== "production" && implsStore[H] && error("Already has an implementation of " + H + "."), implsStore[H] = C;
}
function getImpl(H) {
  return process.env.NODE_ENV !== "production" && (implsStore[H] || error("Implementation of " + H + " doesn't exists.")), implsStore[H];
}
var TEST_FRAME_REMAIN_TIME = 1, PRIORITY_PROCESSOR_SERIES_FILTER = 800, PRIORITY_PROCESSOR_DATASTACK = 900, PRIORITY_PROCESSOR_FILTER = 1e3, PRIORITY_PROCESSOR_DEFAULT = 2e3, PRIORITY_PROCESSOR_STATISTIC = 5e3, PRIORITY_VISUAL_LAYOUT = 1e3, PRIORITY_VISUAL_PROGRESSIVE_LAYOUT = 1100, PRIORITY_VISUAL_GLOBAL = 2e3, PRIORITY_VISUAL_CHART = 3e3, PRIORITY_VISUAL_COMPONENT = 4e3, PRIORITY_VISUAL_CHART_DATA_CUSTOM = 4500, PRIORITY_VISUAL_POST_CHART_LAYOUT = 4600, PRIORITY_VISUAL_BRUSH = 5e3, PRIORITY_VISUAL_ARIA = 6e3, PRIORITY_VISUAL_DECAL = 7e3, PRIORITY = {
  PROCESSOR: {
    FILTER: PRIORITY_PROCESSOR_FILTER,
    SERIES_FILTER: PRIORITY_PROCESSOR_SERIES_FILTER,
    STATISTIC: PRIORITY_PROCESSOR_STATISTIC
  },
  VISUAL: {
    LAYOUT: PRIORITY_VISUAL_LAYOUT,
    PROGRESSIVE_LAYOUT: PRIORITY_VISUAL_PROGRESSIVE_LAYOUT,
    GLOBAL: PRIORITY_VISUAL_GLOBAL,
    CHART: PRIORITY_VISUAL_CHART,
    POST_CHART_LAYOUT: PRIORITY_VISUAL_POST_CHART_LAYOUT,
    COMPONENT: PRIORITY_VISUAL_COMPONENT,
    BRUSH: PRIORITY_VISUAL_BRUSH,
    CHART_ITEM: PRIORITY_VISUAL_CHART_DATA_CUSTOM,
    ARIA: PRIORITY_VISUAL_ARIA,
    DECAL: PRIORITY_VISUAL_DECAL
  }
}, IN_MAIN_PROCESS_KEY = "__flagInMainProcess", PENDING_UPDATE = "__pendingUpdate", STATUS_NEEDS_UPDATE_KEY = "__needsUpdateStatus", ACTION_REG = /^[a-zA-Z0-9_]+$/, CONNECT_STATUS_KEY = "__connectUpdateStatus", CONNECT_STATUS_PENDING = 0, CONNECT_STATUS_UPDATING = 1, CONNECT_STATUS_UPDATED = 2;
function createRegisterEventWithLowercaseECharts(H) {
  return function() {
    for (var C = [], G = 0; G < arguments.length; G++)
      C[G] = arguments[G];
    if (this.isDisposed()) {
      disposedWarning(this.id);
      return;
    }
    return toLowercaseNameAndCallEventful(this, H, C);
  };
}
function createRegisterEventWithLowercaseMessageCenter(H) {
  return function() {
    for (var C = [], G = 0; G < arguments.length; G++)
      C[G] = arguments[G];
    return toLowercaseNameAndCallEventful(this, H, C);
  };
}
function toLowercaseNameAndCallEventful(H, C, G) {
  return G[0] = G[0] && G[0].toLowerCase(), Eventful$1.prototype[C].apply(H, G);
}
var MessageCenter = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      return H !== null && H.apply(this, arguments) || this;
    }
    return C;
  }(Eventful$1)
), messageCenterProto = MessageCenter.prototype;
messageCenterProto.on = createRegisterEventWithLowercaseMessageCenter("on");
messageCenterProto.off = createRegisterEventWithLowercaseMessageCenter("off");
var prepare, prepareView, updateDirectly, updateMethods, doConvertPixel, updateStreamModes, doDispatchAction, flushPendingActions, triggerUpdatedEvent, bindRenderedEvent, bindMouseEvent, render, renderComponents, renderSeries, createExtensionAPI, enableConnect, markStatusToUpdate, applyChangedStates, ECharts = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C(G, U, K) {
      var W = H.call(this, new ECEventProcessor()) || this;
      W._chartsViews = [], W._chartsMap = {}, W._componentsViews = [], W._componentsMap = {}, W._pendingActions = [], K = K || {}, isString(U) && (U = themeStorage[U]), W._dom = G;
      var Z = "canvas", X = "auto", Q = !1;
      if (process.env.NODE_ENV !== "production") {
        var ee = (
          /* eslint-disable-next-line */
          env$1.hasGlobalWindow ? window : global
        );
        Z = ee.__ECHARTS__DEFAULT__RENDERER__ || Z, X = retrieve2(ee.__ECHARTS__DEFAULT__COARSE_POINTER, X);
        var te = ee.__ECHARTS__DEFAULT__USE_DIRTY_RECT__;
        Q = te ?? Q;
      }
      var re = W._zr = init$2(G, {
        renderer: K.renderer || Z,
        devicePixelRatio: K.devicePixelRatio,
        width: K.width,
        height: K.height,
        ssr: K.ssr,
        useDirtyRect: retrieve2(K.useDirtyRect, Q),
        useCoarsePointer: retrieve2(K.useCoarsePointer, X),
        pointerSize: K.pointerSize
      });
      W._ssr = K.ssr, W._throttledZrFlush = throttle(bind$1(re.flush, re), 17), U = clone$4(U), U && globalBackwardCompat(U, !0), W._theme = U, W._locale = createLocaleObject(K.locale || SYSTEM_LANG), W._coordSysMgr = new CoordinateSystem();
      var ne = W._api = createExtensionAPI(W);
      function ae(ie, se) {
        return ie.__prio - se.__prio;
      }
      return sort$2(visualFuncs, ae), sort$2(dataProcessorFuncs, ae), W._scheduler = new Scheduler$1(W, ne, dataProcessorFuncs, visualFuncs), W._messageCenter = new MessageCenter(), W._initEvents(), W.resize = bind$1(W.resize, W), re.animation.on("frame", W._onframe, W), bindRenderedEvent(re, W), bindMouseEvent(re, W), setAsPrimitive(W), W;
    }
    return C.prototype._onframe = function() {
      if (!this._disposed) {
        applyChangedStates(this);
        var G = this._scheduler;
        if (this[PENDING_UPDATE]) {
          var U = this[PENDING_UPDATE].silent;
          this[IN_MAIN_PROCESS_KEY] = !0;
          try {
            prepare(this), updateMethods.update.call(this, null, this[PENDING_UPDATE].updateParams);
          } catch (Q) {
            throw this[IN_MAIN_PROCESS_KEY] = !1, this[PENDING_UPDATE] = null, Q;
          }
          this._zr.flush(), this[IN_MAIN_PROCESS_KEY] = !1, this[PENDING_UPDATE] = null, flushPendingActions.call(this, U), triggerUpdatedEvent.call(this, U);
        } else if (G.unfinished) {
          var K = TEST_FRAME_REMAIN_TIME, W = this._model, Z = this._api;
          G.unfinished = !1;
          do {
            var X = +new Date();
            G.performSeriesTasks(W), G.performDataProcessorTasks(W), updateStreamModes(this, W), G.performVisualTasks(W), renderSeries(this, this._model, Z, "remain", {}), K -= +new Date() - X;
          } while (K > 0 && G.unfinished);
          G.unfinished || this._zr.flush();
        }
      }
    }, C.prototype.getDom = function() {
      return this._dom;
    }, C.prototype.getId = function() {
      return this.id;
    }, C.prototype.getZr = function() {
      return this._zr;
    }, C.prototype.isSSR = function() {
      return this._ssr;
    }, C.prototype.setOption = function(G, U, K) {
      if (this[IN_MAIN_PROCESS_KEY]) {
        process.env.NODE_ENV !== "production" && error("`setOption` should not be called during main process.");
        return;
      }
      if (this._disposed) {
        disposedWarning(this.id);
        return;
      }
      var W, Z, X;
      if (isObject$3(U) && (K = U.lazyUpdate, W = U.silent, Z = U.replaceMerge, X = U.transition, U = U.notMerge), this[IN_MAIN_PROCESS_KEY] = !0, !this._model || U) {
        var Q = new OptionManager$1(this._api), ee = this._theme, te = this._model = new GlobalModel$1();
        te.scheduler = this._scheduler, te.ssr = this._ssr, te.init(null, null, null, ee, this._locale, Q);
      }
      this._model.setOption(G, {
        replaceMerge: Z
      }, optionPreprocessorFuncs);
      var re = {
        seriesTransition: X,
        optionChanged: !0
      };
      if (K)
        this[PENDING_UPDATE] = {
          silent: W,
          updateParams: re
        }, this[IN_MAIN_PROCESS_KEY] = !1, this.getZr().wakeUp();
      else {
        try {
          prepare(this), updateMethods.update.call(this, null, re);
        } catch (ne) {
          throw this[PENDING_UPDATE] = null, this[IN_MAIN_PROCESS_KEY] = !1, ne;
        }
        this._ssr || this._zr.flush(), this[PENDING_UPDATE] = null, this[IN_MAIN_PROCESS_KEY] = !1, flushPendingActions.call(this, W), triggerUpdatedEvent.call(this, W);
      }
    }, C.prototype.setTheme = function() {
      deprecateLog("ECharts#setTheme() is DEPRECATED in ECharts 3.0");
    }, C.prototype.getModel = function() {
      return this._model;
    }, C.prototype.getOption = function() {
      return this._model && this._model.getOption();
    }, C.prototype.getWidth = function() {
      return this._zr.getWidth();
    }, C.prototype.getHeight = function() {
      return this._zr.getHeight();
    }, C.prototype.getDevicePixelRatio = function() {
      return this._zr.painter.dpr || env$1.hasGlobalWindow && window.devicePixelRatio || 1;
    }, C.prototype.getRenderedCanvas = function(G) {
      return process.env.NODE_ENV !== "production" && deprecateReplaceLog("getRenderedCanvas", "renderToCanvas"), this.renderToCanvas(G);
    }, C.prototype.renderToCanvas = function(G) {
      G = G || {};
      var U = this._zr.painter;
      if (process.env.NODE_ENV !== "production" && U.type !== "canvas")
        throw new Error("renderToCanvas can only be used in the canvas renderer.");
      return U.getRenderedCanvas({
        backgroundColor: G.backgroundColor || this._model.get("backgroundColor"),
        pixelRatio: G.pixelRatio || this.getDevicePixelRatio()
      });
    }, C.prototype.renderToSVGString = function(G) {
      G = G || {};
      var U = this._zr.painter;
      if (process.env.NODE_ENV !== "production" && U.type !== "svg")
        throw new Error("renderToSVGString can only be used in the svg renderer.");
      return U.renderToString({
        useViewBox: G.useViewBox
      });
    }, C.prototype.getSvgDataURL = function() {
      if (env$1.svgSupported) {
        var G = this._zr, U = G.storage.getDisplayList();
        return each$f(U, function(K) {
          K.stopAnimation(null, !0);
        }), G.painter.toDataURL();
      }
    }, C.prototype.getDataURL = function(G) {
      if (this._disposed) {
        disposedWarning(this.id);
        return;
      }
      G = G || {};
      var U = G.excludeComponents, K = this._model, W = [], Z = this;
      each$f(U, function(Q) {
        K.eachComponent({
          mainType: Q
        }, function(ee) {
          var te = Z._componentsMap[ee.__viewId];
          te.group.ignore || (W.push(te), te.group.ignore = !0);
        });
      });
      var X = this._zr.painter.getType() === "svg" ? this.getSvgDataURL() : this.renderToCanvas(G).toDataURL("image/" + (G && G.type || "png"));
      return each$f(W, function(Q) {
        Q.group.ignore = !1;
      }), X;
    }, C.prototype.getConnectedDataURL = function(G) {
      if (this._disposed) {
        disposedWarning(this.id);
        return;
      }
      var U = G.type === "svg", K = this.group, W = Math.min, Z = Math.max, X = 1 / 0;
      if (connectedGroups[K]) {
        var Q = X, ee = X, te = -X, re = -X, ne = [], ae = G && G.pixelRatio || this.getDevicePixelRatio();
        each$f(instances, function(ce, de) {
          if (ce.group === K) {
            var ge = U ? ce.getZr().painter.getSvgDom().innerHTML : ce.renderToCanvas(clone$4(G)), fe = ce.getDom().getBoundingClientRect();
            Q = W(fe.left, Q), ee = W(fe.top, ee), te = Z(fe.right, te), re = Z(fe.bottom, re), ne.push({
              dom: ge,
              left: fe.left,
              top: fe.top
            });
          }
        }), Q *= ae, ee *= ae, te *= ae, re *= ae;
        var ie = te - Q, se = re - ee, oe = platformApi.createCanvas(), le = init$2(oe, {
          renderer: U ? "svg" : "canvas"
        });
        if (le.resize({
          width: ie,
          height: se
        }), U) {
          var ue = "";
          return each$f(ne, function(ce) {
            var de = ce.left - Q, ge = ce.top - ee;
            ue += '<g transform="translate(' + de + "," + ge + ')">' + ce.dom + "</g>";
          }), le.painter.getSvgRoot().innerHTML = ue, G.connectedBackgroundColor && le.painter.setBackgroundColor(G.connectedBackgroundColor), le.refreshImmediately(), le.painter.toDataURL();
        } else
          return G.connectedBackgroundColor && le.add(new Rect$3({
            shape: {
              x: 0,
              y: 0,
              width: ie,
              height: se
            },
            style: {
              fill: G.connectedBackgroundColor
            }
          })), each$f(ne, function(ce) {
            var de = new ZRImage$1({
              style: {
                x: ce.left * ae - Q,
                y: ce.top * ae - ee,
                image: ce.dom
              }
            });
            le.add(de);
          }), le.refreshImmediately(), oe.toDataURL("image/" + (G && G.type || "png"));
      } else
        return this.getDataURL(G);
    }, C.prototype.convertToPixel = function(G, U) {
      return doConvertPixel(this, "convertToPixel", G, U);
    }, C.prototype.convertFromPixel = function(G, U) {
      return doConvertPixel(this, "convertFromPixel", G, U);
    }, C.prototype.containPixel = function(G, U) {
      if (this._disposed) {
        disposedWarning(this.id);
        return;
      }
      var K = this._model, W, Z = parseFinder$1(K, G);
      return each$f(Z, function(X, Q) {
        Q.indexOf("Models") >= 0 && each$f(X, function(ee) {
          var te = ee.coordinateSystem;
          if (te && te.containPoint)
            W = W || !!te.containPoint(U);
          else if (Q === "seriesModels") {
            var re = this._chartsMap[ee.__viewId];
            re && re.containPoint ? W = W || re.containPoint(U, ee) : process.env.NODE_ENV !== "production" && warn(Q + ": " + (re ? "The found component do not support containPoint." : "No view mapping to the found component."));
          } else
            process.env.NODE_ENV !== "production" && warn(Q + ": containPoint is not supported");
        }, this);
      }, this), !!W;
    }, C.prototype.getVisual = function(G, U) {
      var K = this._model, W = parseFinder$1(K, G, {
        defaultMainType: "series"
      }), Z = W.seriesModel;
      process.env.NODE_ENV !== "production" && (Z || warn("There is no specified series model"));
      var X = Z.getData(), Q = W.hasOwnProperty("dataIndexInside") ? W.dataIndexInside : W.hasOwnProperty("dataIndex") ? X.indexOfRawIndex(W.dataIndex) : null;
      return Q != null ? getItemVisualFromData(X, Q, U) : getVisualFromData(X, U);
    }, C.prototype.getViewOfComponentModel = function(G) {
      return this._componentsMap[G.__viewId];
    }, C.prototype.getViewOfSeriesModel = function(G) {
      return this._chartsMap[G.__viewId];
    }, C.prototype._initEvents = function() {
      var G = this;
      each$f(MOUSE_EVENT_NAMES, function(U) {
        var K = function(W) {
          var Z = G.getModel(), X = W.target, Q, ee = U === "globalout";
          if (ee ? Q = {} : X && findEventDispatcher(X, function(ie) {
            var se = getECData(ie);
            if (se && se.dataIndex != null) {
              var oe = se.dataModel || Z.getSeriesByIndex(se.seriesIndex);
              return Q = oe && oe.getDataParams(se.dataIndex, se.dataType) || {}, !0;
            } else if (se.eventData)
              return Q = extend({}, se.eventData), !0;
          }, !0), Q) {
            var te = Q.componentType, re = Q.componentIndex;
            (te === "markLine" || te === "markPoint" || te === "markArea") && (te = "series", re = Q.seriesIndex);
            var ne = te && re != null && Z.getComponent(te, re), ae = ne && G[ne.mainType === "series" ? "_chartsMap" : "_componentsMap"][ne.__viewId];
            process.env.NODE_ENV !== "production" && !ee && !(ne && ae) && warn("model or view can not be found by params"), Q.event = W, Q.type = U, G._$eventProcessor.eventInfo = {
              targetEl: X,
              packedEvent: Q,
              model: ne,
              view: ae
            }, G.trigger(U, Q);
          }
        };
        K.zrEventfulCallAtLast = !0, G._zr.on(U, K, G);
      }), each$f(eventActionMap, function(U, K) {
        G._messageCenter.on(K, function(W) {
          this.trigger(K, W);
        }, G);
      }), each$f(["selectchanged"], function(U) {
        G._messageCenter.on(U, function(K) {
          this.trigger(U, K);
        }, G);
      }), handleLegacySelectEvents(this._messageCenter, this, this._api);
    }, C.prototype.isDisposed = function() {
      return this._disposed;
    }, C.prototype.clear = function() {
      if (this._disposed) {
        disposedWarning(this.id);
        return;
      }
      this.setOption({
        series: []
      }, !0);
    }, C.prototype.dispose = function() {
      if (this._disposed) {
        disposedWarning(this.id);
        return;
      }
      this._disposed = !0;
      var G = this.getDom();
      G && setAttribute(this.getDom(), DOM_ATTRIBUTE_KEY, "");
      var U = this, K = U._api, W = U._model;
      each$f(U._componentsViews, function(Z) {
        Z.dispose(W, K);
      }), each$f(U._chartsViews, function(Z) {
        Z.dispose(W, K);
      }), U._zr.dispose(), U._dom = U._model = U._chartsMap = U._componentsMap = U._chartsViews = U._componentsViews = U._scheduler = U._api = U._zr = U._throttledZrFlush = U._theme = U._coordSysMgr = U._messageCenter = null, delete instances[U.id];
    }, C.prototype.resize = function(G) {
      if (this[IN_MAIN_PROCESS_KEY]) {
        process.env.NODE_ENV !== "production" && error("`resize` should not be called during main process.");
        return;
      }
      if (this._disposed) {
        disposedWarning(this.id);
        return;
      }
      this._zr.resize(G);
      var U = this._model;
      if (this._loadingFX && this._loadingFX.resize(), !!U) {
        var K = U.resetOption("media"), W = G && G.silent;
        this[PENDING_UPDATE] && (W == null && (W = this[PENDING_UPDATE].silent), K = !0, this[PENDING_UPDATE] = null), this[IN_MAIN_PROCESS_KEY] = !0;
        try {
          K && prepare(this), updateMethods.update.call(this, {
            type: "resize",
            animation: extend({
              // Disable animation
              duration: 0
            }, G && G.animation)
          });
        } catch (Z) {
          throw this[IN_MAIN_PROCESS_KEY] = !1, Z;
        }
        this[IN_MAIN_PROCESS_KEY] = !1, flushPendingActions.call(this, W), triggerUpdatedEvent.call(this, W);
      }
    }, C.prototype.showLoading = function(G, U) {
      if (this._disposed) {
        disposedWarning(this.id);
        return;
      }
      if (isObject$3(G) && (U = G, G = ""), G = G || "default", this.hideLoading(), !loadingEffects[G]) {
        process.env.NODE_ENV !== "production" && warn("Loading effects " + G + " not exists.");
        return;
      }
      var K = loadingEffects[G](this._api, U), W = this._zr;
      this._loadingFX = K, W.add(K);
    }, C.prototype.hideLoading = function() {
      if (this._disposed) {
        disposedWarning(this.id);
        return;
      }
      this._loadingFX && this._zr.remove(this._loadingFX), this._loadingFX = null;
    }, C.prototype.makeActionFromEvent = function(G) {
      var U = extend({}, G);
      return U.type = eventActionMap[G.type], U;
    }, C.prototype.dispatchAction = function(G, U) {
      if (this._disposed) {
        disposedWarning(this.id);
        return;
      }
      if (isObject$3(U) || (U = {
        silent: !!U
      }), !!actions[G.type] && this._model) {
        if (this[IN_MAIN_PROCESS_KEY]) {
          this._pendingActions.push(G);
          return;
        }
        var K = U.silent;
        doDispatchAction.call(this, G, K);
        var W = U.flush;
        W ? this._zr.flush() : W !== !1 && env$1.browser.weChat && this._throttledZrFlush(), flushPendingActions.call(this, K), triggerUpdatedEvent.call(this, K);
      }
    }, C.prototype.updateLabelLayout = function() {
      lifecycle$1.trigger("series:layoutlabels", this._model, this._api, {
        // Not adding series labels.
        // TODO
        updatedSeries: []
      });
    }, C.prototype.appendData = function(G) {
      if (this._disposed) {
        disposedWarning(this.id);
        return;
      }
      var U = G.seriesIndex, K = this.getModel(), W = K.getSeriesByIndex(U);
      process.env.NODE_ENV !== "production" && assert(G.data && W), W.appendData(G), this._scheduler.unfinished = !0, this.getZr().wakeUp();
    }, C.internalField = function() {
      prepare = function(re) {
        var ne = re._scheduler;
        ne.restorePipelines(re._model), ne.prepareStageTasks(), prepareView(re, !0), prepareView(re, !1), ne.plan();
      }, prepareView = function(re, ne) {
        for (var ae = re._model, ie = re._scheduler, se = ne ? re._componentsViews : re._chartsViews, oe = ne ? re._componentsMap : re._chartsMap, le = re._zr, ue = re._api, ce = 0; ce < se.length; ce++)
          se[ce].__alive = !1;
        ne ? ae.eachComponent(function(fe, ve) {
          fe !== "series" && de(ve);
        }) : ae.eachSeries(de);
        function de(fe) {
          var ve = fe.__requireNewView;
          fe.__requireNewView = !1;
          var pe = "_ec_" + fe.id + "_" + fe.type, he = !ve && oe[pe];
          if (!he) {
            var me = parseClassType(fe.type), ye = ne ? ComponentView$1.getClass(me.main, me.sub) : (
              // FIXME:TS
              // (ChartView as ChartViewConstructor).getClass('series', classType.sub)
              // For backward compat, still support a chart type declared as only subType
              // like "liquidfill", but recommend "series.liquidfill"
              // But need a base class to make a type series.
              ChartView$1.getClass(me.sub)
            );
            process.env.NODE_ENV !== "production" && assert(ye, me.sub + " does not exist."), he = new ye(), he.init(ae, ue), oe[pe] = he, se.push(he), le.add(he.group);
          }
          fe.__viewId = he.__id = pe, he.__alive = !0, he.__model = fe, he.group.__ecComponentInfo = {
            mainType: fe.mainType,
            index: fe.componentIndex
          }, !ne && ie.prepareView(he, fe, ae, ue);
        }
        for (var ce = 0; ce < se.length; ) {
          var ge = se[ce];
          ge.__alive ? ce++ : (!ne && ge.renderTask.dispose(), le.remove(ge.group), ge.dispose(ae, ue), se.splice(ce, 1), oe[ge.__id] === ge && delete oe[ge.__id], ge.__id = ge.group.__ecComponentInfo = null);
        }
      }, updateDirectly = function(re, ne, ae, ie, se) {
        var oe = re._model;
        if (oe.setUpdatePayload(ae), !ie) {
          each$f([].concat(re._componentsViews).concat(re._chartsViews), ge);
          return;
        }
        var le = {};
        le[ie + "Id"] = ae[ie + "Id"], le[ie + "Index"] = ae[ie + "Index"], le[ie + "Name"] = ae[ie + "Name"];
        var ue = {
          mainType: ie,
          query: le
        };
        se && (ue.subType = se);
        var ce = ae.excludeSeriesId, de;
        ce != null && (de = createHashMap(), each$f(normalizeToArray(ce), function(fe) {
          var ve = convertOptionIdName(fe, null);
          ve != null && de.set(ve, !0);
        })), oe && oe.eachComponent(ue, function(fe) {
          var ve = de && de.get(fe.id) != null;
          if (!ve)
            if (isHighDownPayload(ae))
              if (fe instanceof SeriesModel$1)
                ae.type === HIGHLIGHT_ACTION_TYPE && !ae.notBlur && !fe.get(["emphasis", "disabled"]) && blurSeriesFromHighlightPayload(fe, ae, re._api);
              else {
                var pe = findComponentHighDownDispatchers(fe.mainType, fe.componentIndex, ae.name, re._api), he = pe.focusSelf, me = pe.dispatchers;
                ae.type === HIGHLIGHT_ACTION_TYPE && he && !ae.notBlur && blurComponent(fe.mainType, fe.componentIndex, re._api), me && each$f(me, function(ye) {
                  ae.type === HIGHLIGHT_ACTION_TYPE ? enterEmphasis(ye) : leaveEmphasis(ye);
                });
              }
            else
              isSelectChangePayload(ae) && fe instanceof SeriesModel$1 && (toggleSelectionFromPayload(fe, ae, re._api), updateSeriesElementSelection(fe), markStatusToUpdate(re));
        }, re), oe && oe.eachComponent(ue, function(fe) {
          var ve = de && de.get(fe.id) != null;
          ve || ge(re[ie === "series" ? "_chartsMap" : "_componentsMap"][fe.__viewId]);
        }, re);
        function ge(fe) {
          fe && fe.__alive && fe[ne] && fe[ne](fe.__model, oe, re._api, ae);
        }
      }, updateMethods = {
        prepareAndUpdate: function(re) {
          prepare(this), updateMethods.update.call(this, re, {
            // Needs to mark option changed if newOption is given.
            // It's from MagicType.
            // TODO If use a separate flag optionChanged in payload?
            optionChanged: re.newOption != null
          });
        },
        update: function(re, ne) {
          var ae = this._model, ie = this._api, se = this._zr, oe = this._coordSysMgr, le = this._scheduler;
          if (ae) {
            ae.setUpdatePayload(re), le.restoreData(ae, re), le.performSeriesTasks(ae), oe.create(ae, ie), le.performDataProcessorTasks(ae, re), updateStreamModes(this, ae), oe.update(ae, ie), G(ae), le.performVisualTasks(ae, re), render(this, ae, ie, re, ne);
            var ue = ae.get("backgroundColor") || "transparent", ce = ae.get("darkMode");
            se.setBackgroundColor(ue), ce != null && ce !== "auto" && se.setDarkMode(ce), lifecycle$1.trigger("afterupdate", ae, ie);
          }
        },
        updateTransform: function(re) {
          var ne = this, ae = this._model, ie = this._api;
          if (ae) {
            ae.setUpdatePayload(re);
            var se = [];
            ae.eachComponent(function(le, ue) {
              if (le !== "series") {
                var ce = ne.getViewOfComponentModel(ue);
                if (ce && ce.__alive)
                  if (ce.updateTransform) {
                    var de = ce.updateTransform(ue, ae, ie, re);
                    de && de.update && se.push(ce);
                  } else
                    se.push(ce);
              }
            });
            var oe = createHashMap();
            ae.eachSeries(function(le) {
              var ue = ne._chartsMap[le.__viewId];
              if (ue.updateTransform) {
                var ce = ue.updateTransform(le, ae, ie, re);
                ce && ce.update && oe.set(le.uid, 1);
              } else
                oe.set(le.uid, 1);
            }), G(ae), this._scheduler.performVisualTasks(ae, re, {
              setDirty: !0,
              dirtyMap: oe
            }), renderSeries(this, ae, ie, re, {}, oe), lifecycle$1.trigger("afterupdate", ae, ie);
          }
        },
        updateView: function(re) {
          var ne = this._model;
          ne && (ne.setUpdatePayload(re), ChartView$1.markUpdateMethod(re, "updateView"), G(ne), this._scheduler.performVisualTasks(ne, re, {
            setDirty: !0
          }), render(this, ne, this._api, re, {}), lifecycle$1.trigger("afterupdate", ne, this._api));
        },
        updateVisual: function(re) {
          var ne = this, ae = this._model;
          ae && (ae.setUpdatePayload(re), ae.eachSeries(function(ie) {
            ie.getData().clearAllVisual();
          }), ChartView$1.markUpdateMethod(re, "updateVisual"), G(ae), this._scheduler.performVisualTasks(ae, re, {
            visualType: "visual",
            setDirty: !0
          }), ae.eachComponent(function(ie, se) {
            if (ie !== "series") {
              var oe = ne.getViewOfComponentModel(se);
              oe && oe.__alive && oe.updateVisual(se, ae, ne._api, re);
            }
          }), ae.eachSeries(function(ie) {
            var se = ne._chartsMap[ie.__viewId];
            se.updateVisual(ie, ae, ne._api, re);
          }), lifecycle$1.trigger("afterupdate", ae, this._api));
        },
        updateLayout: function(re) {
          updateMethods.update.call(this, re);
        }
      }, doConvertPixel = function(re, ne, ae, ie) {
        if (re._disposed) {
          disposedWarning(re.id);
          return;
        }
        for (var se = re._model, oe = re._coordSysMgr.getCoordinateSystems(), le, ue = parseFinder$1(se, ae), ce = 0; ce < oe.length; ce++) {
          var de = oe[ce];
          if (de[ne] && (le = de[ne](se, ue, ie)) != null)
            return le;
        }
        process.env.NODE_ENV !== "production" && warn("No coordinate system that supports " + ne + " found by the given finder.");
      }, updateStreamModes = function(re, ne) {
        var ae = re._chartsMap, ie = re._scheduler;
        ne.eachSeries(function(se) {
          ie.updateStreamModes(se, ae[se.__viewId]);
        });
      }, doDispatchAction = function(re, ne) {
        var ae = this, ie = this.getModel(), se = re.type, oe = re.escapeConnect, le = actions[se], ue = le.actionInfo, ce = (ue.update || "update").split(":"), de = ce.pop(), ge = ce[0] != null && parseClassType(ce[0]);
        this[IN_MAIN_PROCESS_KEY] = !0;
        var fe = [re], ve = !1;
        re.batch && (ve = !0, fe = map$1(re.batch, function(be) {
          return be = defaults(extend({}, be), re), be.batch = null, be;
        }));
        var pe = [], he, me = isSelectChangePayload(re), ye = isHighDownPayload(re);
        if (ye && allLeaveBlur(this._api), each$f(fe, function(be) {
          if (he = le.action(be, ae._model, ae._api), he = he || extend({}, be), he.type = ue.event || he.type, pe.push(he), ye) {
            var Se = preParseFinder(re), Ae = Se.queryOptionMap, _e = Se.mainTypeSpecified, xe = _e ? Ae.keys()[0] : "series";
            updateDirectly(ae, de, be, xe), markStatusToUpdate(ae);
          } else
            me ? (updateDirectly(ae, de, be, "series"), markStatusToUpdate(ae)) : ge && updateDirectly(ae, de, be, ge.main, ge.sub);
        }), de !== "none" && !ye && !me && !ge)
          try {
            this[PENDING_UPDATE] ? (prepare(this), updateMethods.update.call(this, re), this[PENDING_UPDATE] = null) : updateMethods[de].call(this, re);
          } catch (be) {
            throw this[IN_MAIN_PROCESS_KEY] = !1, be;
          }
        if (ve ? he = {
          type: ue.event || se,
          escapeConnect: oe,
          batch: pe
        } : he = pe[0], this[IN_MAIN_PROCESS_KEY] = !1, !ne) {
          var Ce = this._messageCenter;
          if (Ce.trigger(he.type, he), me) {
            var Ie = {
              type: "selectchanged",
              escapeConnect: oe,
              selected: getAllSelectedIndices(ie),
              isFromClick: re.isFromClick || !1,
              fromAction: re.type,
              fromActionPayload: re
            };
            Ce.trigger(Ie.type, Ie);
          }
        }
      }, flushPendingActions = function(re) {
        for (var ne = this._pendingActions; ne.length; ) {
          var ae = ne.shift();
          doDispatchAction.call(this, ae, re);
        }
      }, triggerUpdatedEvent = function(re) {
        !re && this.trigger("updated");
      }, bindRenderedEvent = function(re, ne) {
        re.on("rendered", function(ae) {
          ne.trigger("rendered", ae), // Although zr is dirty if initial animation is not finished
          // and this checking is called on frame, we also check
          // animation finished for robustness.
          re.animation.isFinished() && !ne[PENDING_UPDATE] && !ne._scheduler.unfinished && !ne._pendingActions.length && ne.trigger("finished");
        });
      }, bindMouseEvent = function(re, ne) {
        re.on("mouseover", function(ae) {
          var ie = ae.target, se = findEventDispatcher(ie, isHighDownDispatcher);
          se && (handleGlobalMouseOverForHighDown(se, ae, ne._api), markStatusToUpdate(ne));
        }).on("mouseout", function(ae) {
          var ie = ae.target, se = findEventDispatcher(ie, isHighDownDispatcher);
          se && (handleGlobalMouseOutForHighDown(se, ae, ne._api), markStatusToUpdate(ne));
        }).on("click", function(ae) {
          var ie = ae.target, se = findEventDispatcher(ie, function(ue) {
            return getECData(ue).dataIndex != null;
          }, !0);
          if (se) {
            var oe = se.selected ? "unselect" : "select", le = getECData(se);
            ne._api.dispatchAction({
              type: oe,
              dataType: le.dataType,
              dataIndexInside: le.dataIndex,
              seriesIndex: le.seriesIndex,
              isFromClick: !0
            });
          }
        });
      };
      function G(re) {
        re.clearColorPalette(), re.eachSeries(function(ne) {
          ne.clearColorPalette();
        });
      }
      function U(re) {
        var ne = [], ae = [], ie = !1;
        if (re.eachComponent(function(ue, ce) {
          var de = ce.get("zlevel") || 0, ge = ce.get("z") || 0, fe = ce.getZLevelKey();
          ie = ie || !!fe, (ue === "series" ? ae : ne).push({
            zlevel: de,
            z: ge,
            idx: ce.componentIndex,
            type: ue,
            key: fe
          });
        }), ie) {
          var se = ne.concat(ae), oe, le;
          sort$2(se, function(ue, ce) {
            return ue.zlevel === ce.zlevel ? ue.z - ce.z : ue.zlevel - ce.zlevel;
          }), each$f(se, function(ue) {
            var ce = re.getComponent(ue.type, ue.idx), de = ue.zlevel, ge = ue.key;
            oe != null && (de = Math.max(oe, de)), ge ? (de === oe && ge !== le && de++, le = ge) : le && (de === oe && de++, le = ""), oe = de, ce.setZLevel(de);
          });
        }
      }
      render = function(re, ne, ae, ie, se) {
        U(ne), renderComponents(re, ne, ae, ie, se), each$f(re._chartsViews, function(oe) {
          oe.__alive = !1;
        }), renderSeries(re, ne, ae, ie, se), each$f(re._chartsViews, function(oe) {
          oe.__alive || oe.remove(ne, ae);
        });
      }, renderComponents = function(re, ne, ae, ie, se, oe) {
        each$f(oe || re._componentsViews, function(le) {
          var ue = le.__model;
          ee(ue, le), le.render(ue, ne, ae, ie), X(ue, le), te(ue, le);
        });
      }, renderSeries = function(re, ne, ae, ie, se, oe) {
        var le = re._scheduler;
        se = extend(se || {}, {
          updatedSeries: ne.getSeries()
        }), lifecycle$1.trigger("series:beforeupdate", ne, ae, se);
        var ue = !1;
        ne.eachSeries(function(ce) {
          var de = re._chartsMap[ce.__viewId];
          de.__alive = !0;
          var ge = de.renderTask;
          le.updatePayload(ge, ie), ee(ce, de), oe && oe.get(ce.uid) && ge.dirty(), ge.perform(le.getPerformArgs(ge)) && (ue = !0), de.group.silent = !!ce.get("silent"), Z(ce, de), updateSeriesElementSelection(ce);
        }), le.unfinished = ue || le.unfinished, lifecycle$1.trigger("series:layoutlabels", ne, ae, se), lifecycle$1.trigger("series:transition", ne, ae, se), ne.eachSeries(function(ce) {
          var de = re._chartsMap[ce.__viewId];
          X(ce, de), te(ce, de);
        }), W(re, ne), lifecycle$1.trigger("series:afterupdate", ne, ae, se);
      }, markStatusToUpdate = function(re) {
        re[STATUS_NEEDS_UPDATE_KEY] = !0, re.getZr().wakeUp();
      }, applyChangedStates = function(re) {
        re[STATUS_NEEDS_UPDATE_KEY] && (re.getZr().storage.traverse(function(ne) {
          isElementRemoved(ne) || K(ne);
        }), re[STATUS_NEEDS_UPDATE_KEY] = !1);
      };
      function K(re) {
        for (var ne = [], ae = re.currentStates, ie = 0; ie < ae.length; ie++) {
          var se = ae[ie];
          se === "emphasis" || se === "blur" || se === "select" || ne.push(se);
        }
        re.selected && re.states.select && ne.push("select"), re.hoverState === HOVER_STATE_EMPHASIS && re.states.emphasis ? ne.push("emphasis") : re.hoverState === HOVER_STATE_BLUR && re.states.blur && ne.push("blur"), re.useStates(ne);
      }
      function W(re, ne) {
        var ae = re._zr, ie = ae.storage, se = 0;
        ie.traverse(function(oe) {
          oe.isGroup || se++;
        }), se > ne.get("hoverLayerThreshold") && !env$1.node && !env$1.worker && ne.eachSeries(function(oe) {
          if (!oe.preventUsingHoverLayer) {
            var le = re._chartsMap[oe.__viewId];
            le.__alive && le.eachRendered(function(ue) {
              ue.states.emphasis && (ue.states.emphasis.hoverLayer = !0);
            });
          }
        });
      }
      function Z(re, ne) {
        var ae = re.get("blendMode") || null;
        ne.eachRendered(function(ie) {
          ie.isGroup || (ie.style.blend = ae);
        });
      }
      function X(re, ne) {
        if (!re.preventAutoZ) {
          var ae = re.get("z") || 0, ie = re.get("zlevel") || 0;
          ne.eachRendered(function(se) {
            return Q(se, ae, ie, -1 / 0), !0;
          });
        }
      }
      function Q(re, ne, ae, ie) {
        var se = re.getTextContent(), oe = re.getTextGuideLine(), le = re.isGroup;
        if (le)
          for (var ue = re.childrenRef(), ce = 0; ce < ue.length; ce++)
            ie = Math.max(Q(ue[ce], ne, ae, ie), ie);
        else
          re.z = ne, re.zlevel = ae, ie = Math.max(re.z2, ie);
        if (se && (se.z = ne, se.zlevel = ae, isFinite(ie) && (se.z2 = ie + 2)), oe) {
          var de = re.textGuideLineConfig;
          oe.z = ne, oe.zlevel = ae, isFinite(ie) && (oe.z2 = ie + (de && de.showAbove ? 1 : -1));
        }
        return ie;
      }
      function ee(re, ne) {
        ne.eachRendered(function(ae) {
          if (!isElementRemoved(ae)) {
            var ie = ae.getTextContent(), se = ae.getTextGuideLine();
            ae.stateTransition && (ae.stateTransition = null), ie && ie.stateTransition && (ie.stateTransition = null), se && se.stateTransition && (se.stateTransition = null), ae.hasState() ? (ae.prevStates = ae.currentStates, ae.clearStates()) : ae.prevStates && (ae.prevStates = null);
          }
        });
      }
      function te(re, ne) {
        var ae = re.getModel("stateAnimation"), ie = re.isAnimationEnabled(), se = ae.get("duration"), oe = se > 0 ? {
          duration: se,
          delay: ae.get("delay"),
          easing: ae.get("easing")
          // additive: stateAnimationModel.get('additive')
        } : null;
        ne.eachRendered(function(le) {
          if (le.states && le.states.emphasis) {
            if (isElementRemoved(le))
              return;
            if (le instanceof Path$1 && savePathStates(le), le.__dirty) {
              var ue = le.prevStates;
              ue && le.useStates(ue);
            }
            if (ie) {
              le.stateTransition = oe;
              var ce = le.getTextContent(), de = le.getTextGuideLine();
              ce && (ce.stateTransition = oe), de && (de.stateTransition = oe);
            }
            le.__dirty && K(le);
          }
        });
      }
      createExtensionAPI = function(re) {
        return new /** @class */
        (function(ne) {
          __extends$1(ae, ne);
          function ae() {
            return ne !== null && ne.apply(this, arguments) || this;
          }
          return ae.prototype.getCoordinateSystems = function() {
            return re._coordSysMgr.getCoordinateSystems();
          }, ae.prototype.getComponentByElement = function(ie) {
            for (; ie; ) {
              var se = ie.__ecComponentInfo;
              if (se != null)
                return re._model.getComponent(se.mainType, se.index);
              ie = ie.parent;
            }
          }, ae.prototype.enterEmphasis = function(ie, se) {
            enterEmphasis(ie, se), markStatusToUpdate(re);
          }, ae.prototype.leaveEmphasis = function(ie, se) {
            leaveEmphasis(ie, se), markStatusToUpdate(re);
          }, ae.prototype.enterBlur = function(ie) {
            enterBlur(ie), markStatusToUpdate(re);
          }, ae.prototype.leaveBlur = function(ie) {
            leaveBlur(ie), markStatusToUpdate(re);
          }, ae.prototype.enterSelect = function(ie) {
            enterSelect(ie), markStatusToUpdate(re);
          }, ae.prototype.leaveSelect = function(ie) {
            leaveSelect(ie), markStatusToUpdate(re);
          }, ae.prototype.getModel = function() {
            return re.getModel();
          }, ae.prototype.getViewOfComponentModel = function(ie) {
            return re.getViewOfComponentModel(ie);
          }, ae.prototype.getViewOfSeriesModel = function(ie) {
            return re.getViewOfSeriesModel(ie);
          }, ae;
        }(ExtensionAPI$1))(re);
      }, enableConnect = function(re) {
        function ne(ae, ie) {
          for (var se = 0; se < ae.length; se++) {
            var oe = ae[se];
            oe[CONNECT_STATUS_KEY] = ie;
          }
        }
        each$f(eventActionMap, function(ae, ie) {
          re._messageCenter.on(ie, function(se) {
            if (connectedGroups[re.group] && re[CONNECT_STATUS_KEY] !== CONNECT_STATUS_PENDING) {
              if (se && se.escapeConnect)
                return;
              var oe = re.makeActionFromEvent(se), le = [];
              each$f(instances, function(ue) {
                ue !== re && ue.group === re.group && le.push(ue);
              }), ne(le, CONNECT_STATUS_PENDING), each$f(le, function(ue) {
                ue[CONNECT_STATUS_KEY] !== CONNECT_STATUS_UPDATING && ue.dispatchAction(oe);
              }), ne(le, CONNECT_STATUS_UPDATED);
            }
          });
        });
      };
    }(), C;
  }(Eventful$1)
), echartsProto = ECharts.prototype;
echartsProto.on = createRegisterEventWithLowercaseECharts("on");
echartsProto.off = createRegisterEventWithLowercaseECharts("off");
echartsProto.one = function(H, C, G) {
  var U = this;
  deprecateLog("ECharts#one is deprecated.");
  function K() {
    for (var W = [], Z = 0; Z < arguments.length; Z++)
      W[Z] = arguments[Z];
    C && C.apply && C.apply(this, W), U.off(H, K);
  }
  this.on.call(this, H, K, G);
};
var MOUSE_EVENT_NAMES = ["click", "dblclick", "mouseover", "mouseout", "mousemove", "mousedown", "mouseup", "globalout", "contextmenu"];
function disposedWarning(H) {
  process.env.NODE_ENV !== "production" && warn("Instance " + H + " has been disposed");
}
var actions = {}, eventActionMap = {}, dataProcessorFuncs = [], optionPreprocessorFuncs = [], visualFuncs = [], themeStorage = {}, loadingEffects = {}, instances = {}, connectedGroups = {}, idBase = +new Date() - 0, DOM_ATTRIBUTE_KEY = "_echarts_instance_";
function init$1(H, C, G) {
  var U = !(G && G.ssr);
  if (U) {
    if (process.env.NODE_ENV !== "production" && !H)
      throw new Error("Initialize failed: invalid dom.");
    var K = getInstanceByDom(H);
    if (K)
      return process.env.NODE_ENV !== "production" && warn("There is a chart instance already initialized on the dom."), K;
    process.env.NODE_ENV !== "production" && isDom(H) && H.nodeName.toUpperCase() !== "CANVAS" && (!H.clientWidth && (!G || G.width == null) || !H.clientHeight && (!G || G.height == null)) && warn("Can't get DOM width or height. Please check dom.clientWidth and dom.clientHeight. They should not be 0.For example, you may need to call this in the callback of window.onload.");
  }
  var W = new ECharts(H, C, G);
  return W.id = "ec_" + idBase++, instances[W.id] = W, U && setAttribute(H, DOM_ATTRIBUTE_KEY, W.id), enableConnect(W), lifecycle$1.trigger("afterinit", W), W;
}
function getInstanceByDom(H) {
  return instances[getAttribute(H, DOM_ATTRIBUTE_KEY)];
}
function registerTheme(H, C) {
  themeStorage[H] = C;
}
function registerPreprocessor(H) {
  indexOf(optionPreprocessorFuncs, H) < 0 && optionPreprocessorFuncs.push(H);
}
function registerProcessor(H, C) {
  normalizeRegister(dataProcessorFuncs, H, C, PRIORITY_PROCESSOR_DEFAULT);
}
function registerPostInit(H) {
  registerUpdateLifecycle("afterinit", H);
}
function registerPostUpdate(H) {
  registerUpdateLifecycle("afterupdate", H);
}
function registerUpdateLifecycle(H, C) {
  lifecycle$1.on(H, C);
}
function registerAction(H, C, G) {
  isFunction(C) && (G = C, C = "");
  var U = isObject$3(H) ? H.type : [H, H = {
    event: C
  }][0];
  H.event = (H.event || U).toLowerCase(), C = H.event, !eventActionMap[C] && (assert(ACTION_REG.test(U) && ACTION_REG.test(C)), actions[U] || (actions[U] = {
    action: G,
    actionInfo: H
  }), eventActionMap[C] = U);
}
function registerCoordinateSystem(H, C) {
  CoordinateSystem.register(H, C);
}
function registerLayout(H, C) {
  normalizeRegister(visualFuncs, H, C, PRIORITY_VISUAL_LAYOUT, "layout");
}
function registerVisual(H, C) {
  normalizeRegister(visualFuncs, H, C, PRIORITY_VISUAL_CHART, "visual");
}
var registeredTasks = [];
function normalizeRegister(H, C, G, U, K) {
  if ((isFunction(C) || isObject$3(C)) && (G = C, C = U), process.env.NODE_ENV !== "production") {
    if (isNaN(C) || C == null)
      throw new Error("Illegal priority");
    each$f(H, function(Z) {
      assert(Z.__raw !== G);
    });
  }
  if (!(indexOf(registeredTasks, G) >= 0)) {
    registeredTasks.push(G);
    var W = Scheduler$1.wrapStageHandler(G, K);
    W.__prio = C, W.__raw = G, H.push(W);
  }
}
function registerLoading(H, C) {
  loadingEffects[H] = C;
}
function registerMap$1(H, C, G) {
  var U = getImpl("registerMap");
  U && U(H, C, G);
}
var registerTransform = registerExternalTransform;
registerVisual(PRIORITY_VISUAL_GLOBAL, seriesStyleTask);
registerVisual(PRIORITY_VISUAL_CHART_DATA_CUSTOM, dataStyleTask);
registerVisual(PRIORITY_VISUAL_CHART_DATA_CUSTOM, dataColorPaletteTask);
registerVisual(PRIORITY_VISUAL_GLOBAL, seriesSymbolTask);
registerVisual(PRIORITY_VISUAL_CHART_DATA_CUSTOM, dataSymbolTask);
registerVisual(PRIORITY_VISUAL_DECAL, decalVisual);
registerPreprocessor(globalBackwardCompat);
registerProcessor(PRIORITY_PROCESSOR_DATASTACK, dataStack);
registerLoading("default", defaultLoading);
registerAction({
  type: HIGHLIGHT_ACTION_TYPE,
  event: HIGHLIGHT_ACTION_TYPE,
  update: HIGHLIGHT_ACTION_TYPE
}, noop);
registerAction({
  type: DOWNPLAY_ACTION_TYPE,
  event: DOWNPLAY_ACTION_TYPE,
  update: DOWNPLAY_ACTION_TYPE
}, noop);
registerAction({
  type: SELECT_ACTION_TYPE,
  event: SELECT_ACTION_TYPE,
  update: SELECT_ACTION_TYPE
}, noop);
registerAction({
  type: UNSELECT_ACTION_TYPE,
  event: UNSELECT_ACTION_TYPE,
  update: UNSELECT_ACTION_TYPE
}, noop);
registerAction({
  type: TOGGLE_SELECT_ACTION_TYPE,
  event: TOGGLE_SELECT_ACTION_TYPE,
  update: TOGGLE_SELECT_ACTION_TYPE
}, noop);
registerTheme("light", lightTheme);
registerTheme("dark", darkTheme);
var extensions = [], extensionRegisters = {
  registerPreprocessor,
  registerProcessor,
  registerPostInit,
  registerPostUpdate,
  registerUpdateLifecycle,
  registerAction,
  registerCoordinateSystem,
  registerLayout,
  registerVisual,
  registerTransform,
  registerLoading,
  registerMap: registerMap$1,
  registerImpl,
  PRIORITY,
  ComponentModel: ComponentModel$1,
  ComponentView: ComponentView$1,
  SeriesModel: SeriesModel$1,
  ChartView: ChartView$1,
  // TODO Use ComponentModel and SeriesModel instead of Constructor
  registerComponentModel: function(H) {
    ComponentModel$1.registerClass(H);
  },
  registerComponentView: function(H) {
    ComponentView$1.registerClass(H);
  },
  registerSeriesModel: function(H) {
    SeriesModel$1.registerClass(H);
  },
  registerChartView: function(H) {
    ChartView$1.registerClass(H);
  },
  registerSubTypeDefaulter: function(H, C) {
    ComponentModel$1.registerSubTypeDefaulter(H, C);
  },
  registerPainter: function(H, C) {
    registerPainter(H, C);
  }
};
function use(H) {
  if (isArray$1(H)) {
    each$f(H, function(C) {
      use(C);
    });
    return;
  }
  indexOf(extensions, H) >= 0 || (extensions.push(H), isFunction(H) && (H = {
    install: H
  }), H.install(extensionRegisters));
}
function dataIndexMapValueLength(H) {
  return H == null ? 0 : H.length || 1;
}
function defaultKeyGetter(H) {
  return H;
}
var DataDiffer = (
  /** @class */
  function() {
    function H(C, G, U, K, W, Z) {
      this._old = C, this._new = G, this._oldKeyGetter = U || defaultKeyGetter, this._newKeyGetter = K || defaultKeyGetter, this.context = W, this._diffModeMultiple = Z === "multiple";
    }
    return H.prototype.add = function(C) {
      return this._add = C, this;
    }, H.prototype.update = function(C) {
      return this._update = C, this;
    }, H.prototype.updateManyToOne = function(C) {
      return this._updateManyToOne = C, this;
    }, H.prototype.updateOneToMany = function(C) {
      return this._updateOneToMany = C, this;
    }, H.prototype.updateManyToMany = function(C) {
      return this._updateManyToMany = C, this;
    }, H.prototype.remove = function(C) {
      return this._remove = C, this;
    }, H.prototype.execute = function() {
      this[this._diffModeMultiple ? "_executeMultiple" : "_executeOneToOne"]();
    }, H.prototype._executeOneToOne = function() {
      var C = this._old, G = this._new, U = {}, K = new Array(C.length), W = new Array(G.length);
      this._initIndexMap(C, null, K, "_oldKeyGetter"), this._initIndexMap(G, U, W, "_newKeyGetter");
      for (var Z = 0; Z < C.length; Z++) {
        var X = K[Z], Q = U[X], ee = dataIndexMapValueLength(Q);
        if (ee > 1) {
          var te = Q.shift();
          Q.length === 1 && (U[X] = Q[0]), this._update && this._update(te, Z);
        } else
          ee === 1 ? (U[X] = null, this._update && this._update(Q, Z)) : this._remove && this._remove(Z);
      }
      this._performRestAdd(W, U);
    }, H.prototype._executeMultiple = function() {
      var C = this._old, G = this._new, U = {}, K = {}, W = [], Z = [];
      this._initIndexMap(C, U, W, "_oldKeyGetter"), this._initIndexMap(G, K, Z, "_newKeyGetter");
      for (var X = 0; X < W.length; X++) {
        var Q = W[X], ee = U[Q], te = K[Q], re = dataIndexMapValueLength(ee), ne = dataIndexMapValueLength(te);
        if (re > 1 && ne === 1)
          this._updateManyToOne && this._updateManyToOne(te, ee), K[Q] = null;
        else if (re === 1 && ne > 1)
          this._updateOneToMany && this._updateOneToMany(te, ee), K[Q] = null;
        else if (re === 1 && ne === 1)
          this._update && this._update(te, ee), K[Q] = null;
        else if (re > 1 && ne > 1)
          this._updateManyToMany && this._updateManyToMany(te, ee), K[Q] = null;
        else if (re > 1)
          for (var ae = 0; ae < re; ae++)
            this._remove && this._remove(ee[ae]);
        else
          this._remove && this._remove(ee);
      }
      this._performRestAdd(Z, K);
    }, H.prototype._performRestAdd = function(C, G) {
      for (var U = 0; U < C.length; U++) {
        var K = C[U], W = G[K], Z = dataIndexMapValueLength(W);
        if (Z > 1)
          for (var X = 0; X < Z; X++)
            this._add && this._add(W[X]);
        else
          Z === 1 && this._add && this._add(W);
        G[K] = null;
      }
    }, H.prototype._initIndexMap = function(C, G, U, K) {
      for (var W = this._diffModeMultiple, Z = 0; Z < C.length; Z++) {
        var X = "_ec_" + this[K](C[Z], Z);
        if (W || (U[Z] = X), !!G) {
          var Q = G[X], ee = dataIndexMapValueLength(Q);
          ee === 0 ? (G[X] = Z, W && U.push(X)) : ee === 1 ? G[X] = [Q, Z] : Q.push(Z);
        }
      }
    }, H;
  }()
);
const DataDiffer$1 = DataDiffer;
var DimensionUserOuput = (
  /** @class */
  function() {
    function H(C, G) {
      this._encode = C, this._schema = G;
    }
    return H.prototype.get = function() {
      return {
        // Do not generate full dimension name until fist used.
        fullDimensions: this._getFullDimensionNames(),
        encode: this._encode
      };
    }, H.prototype._getFullDimensionNames = function() {
      return this._cachedDimNames || (this._cachedDimNames = this._schema ? this._schema.makeOutputDimensionNames() : []), this._cachedDimNames;
    }, H;
  }()
);
function summarizeDimensions(H, C) {
  var G = {}, U = G.encode = {}, K = createHashMap(), W = [], Z = [], X = {};
  each$f(H.dimensions, function(ne) {
    var ae = H.getDimensionInfo(ne), ie = ae.coordDim;
    if (ie) {
      process.env.NODE_ENV !== "production" && assert(VISUAL_DIMENSIONS.get(ie) == null);
      var se = ae.coordDimIndex;
      getOrCreateEncodeArr(U, ie)[se] = ne, ae.isExtraCoord || (K.set(ie, 1), mayLabelDimType(ae.type) && (W[0] = ne), getOrCreateEncodeArr(X, ie)[se] = H.getDimensionIndex(ae.name)), ae.defaultTooltip && Z.push(ne);
    }
    VISUAL_DIMENSIONS.each(function(oe, le) {
      var ue = getOrCreateEncodeArr(U, le), ce = ae.otherDims[le];
      ce != null && ce !== !1 && (ue[ce] = ae.name);
    });
  });
  var Q = [], ee = {};
  K.each(function(ne, ae) {
    var ie = U[ae];
    ee[ae] = ie[0], Q = Q.concat(ie);
  }), G.dataDimsOnCoord = Q, G.dataDimIndicesOnCoord = map$1(Q, function(ne) {
    return H.getDimensionInfo(ne).storeDimIndex;
  }), G.encodeFirstDimNotExtra = ee;
  var te = U.label;
  te && te.length && (W = te.slice());
  var re = U.tooltip;
  return re && re.length ? Z = re.slice() : Z.length || (Z = W.slice()), U.defaultedLabel = W, U.defaultedTooltip = Z, G.userOutput = new DimensionUserOuput(X, C), G;
}
function getOrCreateEncodeArr(H, C) {
  return H.hasOwnProperty(C) || (H[C] = []), H[C];
}
function getDimensionTypeByAxis(H) {
  return H === "category" ? "ordinal" : H === "time" ? "time" : "float";
}
function mayLabelDimType(H) {
  return !(H === "ordinal" || H === "time");
}
var SeriesDimensionDefine = (
  /** @class */
  function() {
    function H(C) {
      this.otherDims = {}, C != null && extend(this, C);
    }
    return H;
  }()
);
const SeriesDimensionDefine$1 = SeriesDimensionDefine;
var inner$h = makeInner(), dimTypeShort = {
  float: "f",
  int: "i",
  ordinal: "o",
  number: "n",
  time: "t"
}, SeriesDataSchema = (
  /** @class */
  function() {
    function H(C) {
      this.dimensions = C.dimensions, this._dimOmitted = C.dimensionOmitted, this.source = C.source, this._fullDimCount = C.fullDimensionCount, this._updateDimOmitted(C.dimensionOmitted);
    }
    return H.prototype.isDimensionOmitted = function() {
      return this._dimOmitted;
    }, H.prototype._updateDimOmitted = function(C) {
      this._dimOmitted = C, C && (this._dimNameMap || (this._dimNameMap = ensureSourceDimNameMap(this.source)));
    }, H.prototype.getSourceDimensionIndex = function(C) {
      return retrieve2(this._dimNameMap.get(C), -1);
    }, H.prototype.getSourceDimension = function(C) {
      var G = this.source.dimensionsDefine;
      if (G)
        return G[C];
    }, H.prototype.makeStoreSchema = function() {
      for (var C = this._fullDimCount, G = shouldRetrieveDataByName(this.source), U = !shouldOmitUnusedDimensions(C), K = "", W = [], Z = 0, X = 0; Z < C; Z++) {
        var Q = void 0, ee = void 0, te = void 0, re = this.dimensions[X];
        if (re && re.storeDimIndex === Z)
          Q = G ? re.name : null, ee = re.type, te = re.ordinalMeta, X++;
        else {
          var ne = this.getSourceDimension(Z);
          ne && (Q = G ? ne.name : null, ee = ne.type);
        }
        W.push({
          property: Q,
          type: ee,
          ordinalMeta: te
        }), G && Q != null && (!re || !re.isCalculationCoord) && (K += U ? Q.replace(/\`/g, "`1").replace(/\$/g, "`2") : Q), K += "$", K += dimTypeShort[ee] || "f", te && (K += te.uid), K += "$";
      }
      var ae = this.source, ie = [ae.seriesLayoutBy, ae.startIndex, K].join("$$");
      return {
        dimensions: W,
        hash: ie
      };
    }, H.prototype.makeOutputDimensionNames = function() {
      for (var C = [], G = 0, U = 0; G < this._fullDimCount; G++) {
        var K = void 0, W = this.dimensions[U];
        if (W && W.storeDimIndex === G)
          W.isCalculationCoord || (K = W.name), U++;
        else {
          var Z = this.getSourceDimension(G);
          Z && (K = Z.name);
        }
        C.push(K);
      }
      return C;
    }, H.prototype.appendCalculationDimension = function(C) {
      this.dimensions.push(C), C.isCalculationCoord = !0, this._fullDimCount++, this._updateDimOmitted(!0);
    }, H;
  }()
);
function isSeriesDataSchema(H) {
  return H instanceof SeriesDataSchema;
}
function createDimNameMap(H) {
  for (var C = createHashMap(), G = 0; G < (H || []).length; G++) {
    var U = H[G], K = isObject$3(U) ? U.name : U;
    K != null && C.get(K) == null && C.set(K, G);
  }
  return C;
}
function ensureSourceDimNameMap(H) {
  var C = inner$h(H);
  return C.dimNameMap || (C.dimNameMap = createDimNameMap(H.dimensionsDefine));
}
function shouldOmitUnusedDimensions(H) {
  return H > 30;
}
var isObject$1 = isObject$3, map = map$1, CtorInt32Array = typeof Int32Array > "u" ? Array : Int32Array, ID_PREFIX = "e\0\0", INDEX_NOT_FOUND = -1, TRANSFERABLE_PROPERTIES = ["hasItemOption", "_nameList", "_idList", "_invertedIndicesMap", "_dimSummary", "userOutput", "_rawData", "_dimValueGetter", "_nameDimIdx", "_idDimIdx", "_nameRepeatCount"], CLONE_PROPERTIES = ["_approximateExtent"], prepareInvertedIndex, getId, getIdNameFromStore, normalizeDimensions, transferProperties, cloneListForMapAndSample, makeIdFromName, SeriesData = (
  /** @class */
  function() {
    function H(C, G) {
      this.type = "list", this._dimOmitted = !1, this._nameList = [], this._idList = [], this._visual = {}, this._layout = {}, this._itemVisuals = [], this._itemLayouts = [], this._graphicEls = [], this._approximateExtent = {}, this._calculationInfo = {}, this.hasItemOption = !1, this.TRANSFERABLE_METHODS = ["cloneShallow", "downSample", "lttbDownSample", "map"], this.CHANGABLE_METHODS = ["filterSelf", "selectRange"], this.DOWNSAMPLE_METHODS = ["downSample", "lttbDownSample"];
      var U, K = !1;
      isSeriesDataSchema(C) ? (U = C.dimensions, this._dimOmitted = C.isDimensionOmitted(), this._schema = C) : (K = !0, U = C), U = U || ["x", "y"];
      for (var W = {}, Z = [], X = {}, Q = !1, ee = {}, te = 0; te < U.length; te++) {
        var re = U[te], ne = isString(re) ? new SeriesDimensionDefine$1({
          name: re
        }) : re instanceof SeriesDimensionDefine$1 ? re : new SeriesDimensionDefine$1(re), ae = ne.name;
        ne.type = ne.type || "float", ne.coordDim || (ne.coordDim = ae, ne.coordDimIndex = 0);
        var ie = ne.otherDims = ne.otherDims || {};
        Z.push(ae), W[ae] = ne, ee[ae] != null && (Q = !0), ne.createInvertedIndices && (X[ae] = []), ie.itemName === 0 && (this._nameDimIdx = te), ie.itemId === 0 && (this._idDimIdx = te), process.env.NODE_ENV !== "production" && assert(K || ne.storeDimIndex >= 0), K && (ne.storeDimIndex = te);
      }
      if (this.dimensions = Z, this._dimInfos = W, this._initGetDimensionInfo(Q), this.hostModel = G, this._invertedIndicesMap = X, this._dimOmitted) {
        var se = this._dimIdxToName = createHashMap();
        each$f(Z, function(oe) {
          se.set(W[oe].storeDimIndex, oe);
        });
      }
    }
    return H.prototype.getDimension = function(C) {
      var G = this._recognizeDimIndex(C);
      if (G == null)
        return C;
      if (G = C, !this._dimOmitted)
        return this.dimensions[G];
      var U = this._dimIdxToName.get(G);
      if (U != null)
        return U;
      var K = this._schema.getSourceDimension(G);
      if (K)
        return K.name;
    }, H.prototype.getDimensionIndex = function(C) {
      var G = this._recognizeDimIndex(C);
      if (G != null)
        return G;
      if (C == null)
        return -1;
      var U = this._getDimInfo(C);
      return U ? U.storeDimIndex : this._dimOmitted ? this._schema.getSourceDimensionIndex(C) : -1;
    }, H.prototype._recognizeDimIndex = function(C) {
      if (isNumber(C) || C != null && !isNaN(C) && !this._getDimInfo(C) && (!this._dimOmitted || this._schema.getSourceDimensionIndex(C) < 0))
        return +C;
    }, H.prototype._getStoreDimIndex = function(C) {
      var G = this.getDimensionIndex(C);
      if (process.env.NODE_ENV !== "production" && G == null)
        throw new Error("Unknown dimension " + C);
      return G;
    }, H.prototype.getDimensionInfo = function(C) {
      return this._getDimInfo(this.getDimension(C));
    }, H.prototype._initGetDimensionInfo = function(C) {
      var G = this._dimInfos;
      this._getDimInfo = C ? function(U) {
        return G.hasOwnProperty(U) ? G[U] : void 0;
      } : function(U) {
        return G[U];
      };
    }, H.prototype.getDimensionsOnCoord = function() {
      return this._dimSummary.dataDimsOnCoord.slice();
    }, H.prototype.mapDimension = function(C, G) {
      var U = this._dimSummary;
      if (G == null)
        return U.encodeFirstDimNotExtra[C];
      var K = U.encode[C];
      return K ? K[G] : null;
    }, H.prototype.mapDimensionsAll = function(C) {
      var G = this._dimSummary, U = G.encode[C];
      return (U || []).slice();
    }, H.prototype.getStore = function() {
      return this._store;
    }, H.prototype.initData = function(C, G, U) {
      var K = this, W;
      if (C instanceof DataStore && (W = C), !W) {
        var Z = this.dimensions, X = isSourceInstance(C) || isArrayLike(C) ? new DefaultDataProvider(C, Z.length) : C;
        W = new DataStore();
        var Q = map(Z, function(ee) {
          return {
            type: K._dimInfos[ee].type,
            property: ee
          };
        });
        W.initData(X, Q, U);
      }
      this._store = W, this._nameList = (G || []).slice(), this._idList = [], this._nameRepeatCount = {}, this._doInit(0, W.count()), this._dimSummary = summarizeDimensions(this, this._schema), this.userOutput = this._dimSummary.userOutput;
    }, H.prototype.appendData = function(C) {
      var G = this._store.appendData(C);
      this._doInit(G[0], G[1]);
    }, H.prototype.appendValues = function(C, G) {
      var U = this._store.appendValues(C, G.length), K = U.start, W = U.end, Z = this._shouldMakeIdFromName();
      if (this._updateOrdinalMeta(), G)
        for (var X = K; X < W; X++) {
          var Q = X - K;
          this._nameList[X] = G[Q], Z && makeIdFromName(this, X);
        }
    }, H.prototype._updateOrdinalMeta = function() {
      for (var C = this._store, G = this.dimensions, U = 0; U < G.length; U++) {
        var K = this._dimInfos[G[U]];
        K.ordinalMeta && C.collectOrdinalMeta(K.storeDimIndex, K.ordinalMeta);
      }
    }, H.prototype._shouldMakeIdFromName = function() {
      var C = this._store.getProvider();
      return this._idDimIdx == null && C.getSource().sourceFormat !== SOURCE_FORMAT_TYPED_ARRAY && !C.fillStorage;
    }, H.prototype._doInit = function(C, G) {
      if (!(C >= G)) {
        var U = this._store, K = U.getProvider();
        this._updateOrdinalMeta();
        var W = this._nameList, Z = this._idList, X = K.getSource().sourceFormat, Q = X === SOURCE_FORMAT_ORIGINAL;
        if (Q && !K.pure)
          for (var ee = [], te = C; te < G; te++) {
            var re = K.getItem(te, ee);
            if (!this.hasItemOption && isDataItemOption(re) && (this.hasItemOption = !0), re) {
              var ne = re.name;
              W[te] == null && ne != null && (W[te] = convertOptionIdName(ne, null));
              var ae = re.id;
              Z[te] == null && ae != null && (Z[te] = convertOptionIdName(ae, null));
            }
          }
        if (this._shouldMakeIdFromName())
          for (var te = C; te < G; te++)
            makeIdFromName(this, te);
        prepareInvertedIndex(this);
      }
    }, H.prototype.getApproximateExtent = function(C) {
      return this._approximateExtent[C] || this._store.getDataExtent(this._getStoreDimIndex(C));
    }, H.prototype.setApproximateExtent = function(C, G) {
      G = this.getDimension(G), this._approximateExtent[G] = C.slice();
    }, H.prototype.getCalculationInfo = function(C) {
      return this._calculationInfo[C];
    }, H.prototype.setCalculationInfo = function(C, G) {
      isObject$1(C) ? extend(this._calculationInfo, C) : this._calculationInfo[C] = G;
    }, H.prototype.getName = function(C) {
      var G = this.getRawIndex(C), U = this._nameList[G];
      return U == null && this._nameDimIdx != null && (U = getIdNameFromStore(this, this._nameDimIdx, G)), U == null && (U = ""), U;
    }, H.prototype._getCategory = function(C, G) {
      var U = this._store.get(C, G), K = this._store.getOrdinalMeta(C);
      return K ? K.categories[U] : U;
    }, H.prototype.getId = function(C) {
      return getId(this, this.getRawIndex(C));
    }, H.prototype.count = function() {
      return this._store.count();
    }, H.prototype.get = function(C, G) {
      var U = this._store, K = this._dimInfos[C];
      if (K)
        return U.get(K.storeDimIndex, G);
    }, H.prototype.getByRawIndex = function(C, G) {
      var U = this._store, K = this._dimInfos[C];
      if (K)
        return U.getByRawIndex(K.storeDimIndex, G);
    }, H.prototype.getIndices = function() {
      return this._store.getIndices();
    }, H.prototype.getDataExtent = function(C) {
      return this._store.getDataExtent(this._getStoreDimIndex(C));
    }, H.prototype.getSum = function(C) {
      return this._store.getSum(this._getStoreDimIndex(C));
    }, H.prototype.getMedian = function(C) {
      return this._store.getMedian(this._getStoreDimIndex(C));
    }, H.prototype.getValues = function(C, G) {
      var U = this, K = this._store;
      return isArray$1(C) ? K.getValues(map(C, function(W) {
        return U._getStoreDimIndex(W);
      }), G) : K.getValues(C);
    }, H.prototype.hasValue = function(C) {
      for (var G = this._dimSummary.dataDimIndicesOnCoord, U = 0, K = G.length; U < K; U++)
        if (isNaN(this._store.get(G[U], C)))
          return !1;
      return !0;
    }, H.prototype.indexOfName = function(C) {
      for (var G = 0, U = this._store.count(); G < U; G++)
        if (this.getName(G) === C)
          return G;
      return -1;
    }, H.prototype.getRawIndex = function(C) {
      return this._store.getRawIndex(C);
    }, H.prototype.indexOfRawIndex = function(C) {
      return this._store.indexOfRawIndex(C);
    }, H.prototype.rawIndexOf = function(C, G) {
      var U = C && this._invertedIndicesMap[C];
      if (process.env.NODE_ENV !== "production" && !U)
        throw new Error("Do not supported yet");
      var K = U[G];
      return K == null || isNaN(K) ? INDEX_NOT_FOUND : K;
    }, H.prototype.indicesOfNearest = function(C, G, U) {
      return this._store.indicesOfNearest(this._getStoreDimIndex(C), G, U);
    }, H.prototype.each = function(C, G, U) {
      isFunction(C) && (U = G, G = C, C = []);
      var K = U || this, W = map(normalizeDimensions(C), this._getStoreDimIndex, this);
      this._store.each(W, K ? bind$1(G, K) : G);
    }, H.prototype.filterSelf = function(C, G, U) {
      isFunction(C) && (U = G, G = C, C = []);
      var K = U || this, W = map(normalizeDimensions(C), this._getStoreDimIndex, this);
      return this._store = this._store.filter(W, K ? bind$1(G, K) : G), this;
    }, H.prototype.selectRange = function(C) {
      var G = this, U = {}, K = keys(C);
      return each$f(K, function(W) {
        var Z = G._getStoreDimIndex(W);
        U[Z] = C[W];
      }), this._store = this._store.selectRange(U), this;
    }, H.prototype.mapArray = function(C, G, U) {
      isFunction(C) && (U = G, G = C, C = []), U = U || this;
      var K = [];
      return this.each(C, function() {
        K.push(G && G.apply(this, arguments));
      }, U), K;
    }, H.prototype.map = function(C, G, U, K) {
      var W = U || K || this, Z = map(normalizeDimensions(C), this._getStoreDimIndex, this), X = cloneListForMapAndSample(this);
      return X._store = this._store.map(Z, W ? bind$1(G, W) : G), X;
    }, H.prototype.modify = function(C, G, U, K) {
      var W = this, Z = U || K || this;
      process.env.NODE_ENV !== "production" && each$f(normalizeDimensions(C), function(Q) {
        var ee = W.getDimensionInfo(Q);
        ee.isCalculationCoord || console.error("Danger: only stack dimension can be modified");
      });
      var X = map(normalizeDimensions(C), this._getStoreDimIndex, this);
      this._store.modify(X, Z ? bind$1(G, Z) : G);
    }, H.prototype.downSample = function(C, G, U, K) {
      var W = cloneListForMapAndSample(this);
      return W._store = this._store.downSample(this._getStoreDimIndex(C), G, U, K), W;
    }, H.prototype.lttbDownSample = function(C, G) {
      var U = cloneListForMapAndSample(this);
      return U._store = this._store.lttbDownSample(this._getStoreDimIndex(C), G), U;
    }, H.prototype.getRawDataItem = function(C) {
      return this._store.getRawDataItem(C);
    }, H.prototype.getItemModel = function(C) {
      var G = this.hostModel, U = this.getRawDataItem(C);
      return new Model$1(U, G, G && G.ecModel);
    }, H.prototype.diff = function(C) {
      var G = this;
      return new DataDiffer$1(C ? C.getStore().getIndices() : [], this.getStore().getIndices(), function(U) {
        return getId(C, U);
      }, function(U) {
        return getId(G, U);
      });
    }, H.prototype.getVisual = function(C) {
      var G = this._visual;
      return G && G[C];
    }, H.prototype.setVisual = function(C, G) {
      this._visual = this._visual || {}, isObject$1(C) ? extend(this._visual, C) : this._visual[C] = G;
    }, H.prototype.getItemVisual = function(C, G) {
      var U = this._itemVisuals[C], K = U && U[G];
      return K ?? this.getVisual(G);
    }, H.prototype.hasItemVisual = function() {
      return this._itemVisuals.length > 0;
    }, H.prototype.ensureUniqueItemVisual = function(C, G) {
      var U = this._itemVisuals, K = U[C];
      K || (K = U[C] = {});
      var W = K[G];
      return W == null && (W = this.getVisual(G), isArray$1(W) ? W = W.slice() : isObject$1(W) && (W = extend({}, W)), K[G] = W), W;
    }, H.prototype.setItemVisual = function(C, G, U) {
      var K = this._itemVisuals[C] || {};
      this._itemVisuals[C] = K, isObject$1(G) ? extend(K, G) : K[G] = U;
    }, H.prototype.clearAllVisual = function() {
      this._visual = {}, this._itemVisuals = [];
    }, H.prototype.setLayout = function(C, G) {
      isObject$1(C) ? extend(this._layout, C) : this._layout[C] = G;
    }, H.prototype.getLayout = function(C) {
      return this._layout[C];
    }, H.prototype.getItemLayout = function(C) {
      return this._itemLayouts[C];
    }, H.prototype.setItemLayout = function(C, G, U) {
      this._itemLayouts[C] = U ? extend(this._itemLayouts[C] || {}, G) : G;
    }, H.prototype.clearItemLayouts = function() {
      this._itemLayouts.length = 0;
    }, H.prototype.setItemGraphicEl = function(C, G) {
      var U = this.hostModel && this.hostModel.seriesIndex;
      setCommonECData(U, this.dataType, C, G), this._graphicEls[C] = G;
    }, H.prototype.getItemGraphicEl = function(C) {
      return this._graphicEls[C];
    }, H.prototype.eachItemGraphicEl = function(C, G) {
      each$f(this._graphicEls, function(U, K) {
        U && C && C.call(G, U, K);
      });
    }, H.prototype.cloneShallow = function(C) {
      return C || (C = new H(this._schema ? this._schema : map(this.dimensions, this._getDimInfo, this), this.hostModel)), transferProperties(C, this), C._store = this._store, C;
    }, H.prototype.wrapMethod = function(C, G) {
      var U = this[C];
      isFunction(U) && (this.__wrappedMethods = this.__wrappedMethods || [], this.__wrappedMethods.push(C), this[C] = function() {
        var K = U.apply(this, arguments);
        return G.apply(this, [K].concat(slice(arguments)));
      });
    }, H.internalField = function() {
      prepareInvertedIndex = function(C) {
        var G = C._invertedIndicesMap;
        each$f(G, function(U, K) {
          var W = C._dimInfos[K], Z = W.ordinalMeta, X = C._store;
          if (Z) {
            U = G[K] = new CtorInt32Array(Z.categories.length);
            for (var Q = 0; Q < U.length; Q++)
              U[Q] = INDEX_NOT_FOUND;
            for (var Q = 0; Q < X.count(); Q++)
              U[X.get(W.storeDimIndex, Q)] = Q;
          }
        });
      }, getIdNameFromStore = function(C, G, U) {
        return convertOptionIdName(C._getCategory(G, U), null);
      }, getId = function(C, G) {
        var U = C._idList[G];
        return U == null && C._idDimIdx != null && (U = getIdNameFromStore(C, C._idDimIdx, G)), U == null && (U = ID_PREFIX + G), U;
      }, normalizeDimensions = function(C) {
        return isArray$1(C) || (C = C != null ? [C] : []), C;
      }, cloneListForMapAndSample = function(C) {
        var G = new H(C._schema ? C._schema : map(C.dimensions, C._getDimInfo, C), C.hostModel);
        return transferProperties(G, C), G;
      }, transferProperties = function(C, G) {
        each$f(TRANSFERABLE_PROPERTIES.concat(G.__wrappedMethods || []), function(U) {
          G.hasOwnProperty(U) && (C[U] = G[U]);
        }), C.__wrappedMethods = G.__wrappedMethods, each$f(CLONE_PROPERTIES, function(U) {
          C[U] = clone$4(G[U]);
        }), C._calculationInfo = extend({}, G._calculationInfo);
      }, makeIdFromName = function(C, G) {
        var U = C._nameList, K = C._idList, W = C._nameDimIdx, Z = C._idDimIdx, X = U[G], Q = K[G];
        if (X == null && W != null && (U[G] = X = getIdNameFromStore(C, W, G)), Q == null && Z != null && (K[G] = Q = getIdNameFromStore(C, Z, G)), Q == null && X != null) {
          var ee = C._nameRepeatCount, te = ee[X] = (ee[X] || 0) + 1;
          Q = X, te > 1 && (Q += "__ec__" + te), K[G] = Q;
        }
      };
    }(), H;
  }()
);
const SeriesData$1 = SeriesData;
function prepareSeriesDataSchema(H, C) {
  isSourceInstance(H) || (H = createSourceFromSeriesDataOption(H)), C = C || {};
  var G = C.coordDimensions || [], U = C.dimensionsDefine || H.dimensionsDefine || [], K = createHashMap(), W = [], Z = getDimCount(H, G, U, C.dimensionsCount), X = C.canOmitUnusedDimensions && shouldOmitUnusedDimensions(Z), Q = U === H.dimensionsDefine, ee = Q ? ensureSourceDimNameMap(H) : createDimNameMap(U), te = C.encodeDefine;
  !te && C.encodeDefaulter && (te = C.encodeDefaulter(H, Z));
  for (var re = createHashMap(te), ne = new CtorInt32Array$1(Z), ae = 0; ae < ne.length; ae++)
    ne[ae] = -1;
  function ie(he) {
    var me = ne[he];
    if (me < 0) {
      var ye = U[he], Ce = isObject$3(ye) ? ye : {
        name: ye
      }, Ie = new SeriesDimensionDefine$1(), be = Ce.name;
      be != null && ee.get(be) != null && (Ie.name = Ie.displayName = be), Ce.type != null && (Ie.type = Ce.type), Ce.displayName != null && (Ie.displayName = Ce.displayName);
      var Se = W.length;
      return ne[he] = Se, Ie.storeDimIndex = he, W.push(Ie), Ie;
    }
    return W[me];
  }
  if (!X)
    for (var ae = 0; ae < Z; ae++)
      ie(ae);
  re.each(function(he, me) {
    var ye = normalizeToArray(he).slice();
    if (ye.length === 1 && !isString(ye[0]) && ye[0] < 0) {
      re.set(me, !1);
      return;
    }
    var Ce = re.set(me, []);
    each$f(ye, function(Ie, be) {
      var Se = isString(Ie) ? ee.get(Ie) : Ie;
      Se != null && Se < Z && (Ce[be] = Se, oe(ie(Se), me, be));
    });
  });
  var se = 0;
  each$f(G, function(he) {
    var me, ye, Ce, Ie;
    if (isString(he))
      me = he, Ie = {};
    else {
      Ie = he, me = Ie.name;
      var be = Ie.ordinalMeta;
      Ie.ordinalMeta = null, Ie = extend({}, Ie), Ie.ordinalMeta = be, ye = Ie.dimsDef, Ce = Ie.otherDims, Ie.name = Ie.coordDim = Ie.coordDimIndex = Ie.dimsDef = Ie.otherDims = null;
    }
    var Se = re.get(me);
    if (Se !== !1) {
      if (Se = normalizeToArray(Se), !Se.length)
        for (var Ae = 0; Ae < (ye && ye.length || 1); Ae++) {
          for (; se < Z && ie(se).coordDim != null; )
            se++;
          se < Z && Se.push(se++);
        }
      each$f(Se, function(_e, xe) {
        var Te = ie(_e);
        if (Q && Ie.type != null && (Te.type = Ie.type), oe(defaults(Te, Ie), me, xe), Te.name == null && ye) {
          var Pe = ye[xe];
          !isObject$3(Pe) && (Pe = {
            name: Pe
          }), Te.name = Te.displayName = Pe.name, Te.defaultTooltip = Pe.defaultTooltip;
        }
        Ce && defaults(Te.otherDims, Ce);
      });
    }
  });
  function oe(he, me, ye) {
    VISUAL_DIMENSIONS.get(me) != null ? he.otherDims[me] = ye : (he.coordDim = me, he.coordDimIndex = ye, K.set(me, !0));
  }
  var le = C.generateCoord, ue = C.generateCoordCount, ce = ue != null;
  ue = le ? ue || 1 : 0;
  var de = le || "value";
  function ge(he) {
    he.name == null && (he.name = he.coordDim);
  }
  if (X)
    each$f(W, function(he) {
      ge(he);
    }), W.sort(function(he, me) {
      return he.storeDimIndex - me.storeDimIndex;
    });
  else
    for (var fe = 0; fe < Z; fe++) {
      var ve = ie(fe), pe = ve.coordDim;
      pe == null && (ve.coordDim = genCoordDimName(de, K, ce), ve.coordDimIndex = 0, (!le || ue <= 0) && (ve.isExtraCoord = !0), ue--), ge(ve), ve.type == null && (guessOrdinal(H, fe) === BE_ORDINAL.Must || ve.isExtraCoord && (ve.otherDims.itemName != null || ve.otherDims.seriesName != null)) && (ve.type = "ordinal");
    }
  return removeDuplication(W), new SeriesDataSchema({
    source: H,
    dimensions: W,
    fullDimensionCount: Z,
    dimensionOmitted: X
  });
}
function removeDuplication(H) {
  for (var C = createHashMap(), G = 0; G < H.length; G++) {
    var U = H[G], K = U.name, W = C.get(K) || 0;
    W > 0 && (U.name = K + (W - 1)), W++, C.set(K, W);
  }
}
function getDimCount(H, C, G, U) {
  var K = Math.max(H.dimensionsDetectedCount || 1, C.length, G.length, U || 0);
  return each$f(C, function(W) {
    var Z;
    isObject$3(W) && (Z = W.dimsDef) && (K = Math.max(K, Z.length));
  }), K;
}
function genCoordDimName(H, C, G) {
  if (G || C.hasKey(H)) {
    for (var U = 0; C.hasKey(H + U); )
      U++;
    H += U;
  }
  return C.set(H, !0), H;
}
var CoordSysInfo = (
  /** @class */
  function() {
    function H(C) {
      this.coordSysDims = [], this.axisMap = createHashMap(), this.categoryAxisMap = createHashMap(), this.coordSysName = C;
    }
    return H;
  }()
);
function getCoordSysInfoBySeries(H) {
  var C = H.get("coordinateSystem"), G = new CoordSysInfo(C), U = fetchers[C];
  if (U)
    return U(H, G, G.axisMap, G.categoryAxisMap), G;
}
var fetchers = {
  cartesian2d: function(H, C, G, U) {
    var K = H.getReferringComponents("xAxis", SINGLE_REFERRING).models[0], W = H.getReferringComponents("yAxis", SINGLE_REFERRING).models[0];
    if (process.env.NODE_ENV !== "production") {
      if (!K)
        throw new Error('xAxis "' + retrieve(H.get("xAxisIndex"), H.get("xAxisId"), 0) + '" not found');
      if (!W)
        throw new Error('yAxis "' + retrieve(H.get("xAxisIndex"), H.get("yAxisId"), 0) + '" not found');
    }
    C.coordSysDims = ["x", "y"], G.set("x", K), G.set("y", W), isCategory(K) && (U.set("x", K), C.firstCategoryDimIndex = 0), isCategory(W) && (U.set("y", W), C.firstCategoryDimIndex == null && (C.firstCategoryDimIndex = 1));
  },
  singleAxis: function(H, C, G, U) {
    var K = H.getReferringComponents("singleAxis", SINGLE_REFERRING).models[0];
    if (process.env.NODE_ENV !== "production" && !K)
      throw new Error("singleAxis should be specified.");
    C.coordSysDims = ["single"], G.set("single", K), isCategory(K) && (U.set("single", K), C.firstCategoryDimIndex = 0);
  },
  polar: function(H, C, G, U) {
    var K = H.getReferringComponents("polar", SINGLE_REFERRING).models[0], W = K.findAxisModel("radiusAxis"), Z = K.findAxisModel("angleAxis");
    if (process.env.NODE_ENV !== "production") {
      if (!Z)
        throw new Error("angleAxis option not found");
      if (!W)
        throw new Error("radiusAxis option not found");
    }
    C.coordSysDims = ["radius", "angle"], G.set("radius", W), G.set("angle", Z), isCategory(W) && (U.set("radius", W), C.firstCategoryDimIndex = 0), isCategory(Z) && (U.set("angle", Z), C.firstCategoryDimIndex == null && (C.firstCategoryDimIndex = 1));
  },
  geo: function(H, C, G, U) {
    C.coordSysDims = ["lng", "lat"];
  },
  parallel: function(H, C, G, U) {
    var K = H.ecModel, W = K.getComponent("parallel", H.get("parallelIndex")), Z = C.coordSysDims = W.dimensions.slice();
    each$f(W.parallelAxisIndex, function(X, Q) {
      var ee = K.getComponent("parallelAxis", X), te = Z[Q];
      G.set(te, ee), isCategory(ee) && (U.set(te, ee), C.firstCategoryDimIndex == null && (C.firstCategoryDimIndex = Q));
    });
  }
};
function isCategory(H) {
  return H.get("type") === "category";
}
function enableDataStack(H, C, G) {
  G = G || {};
  var U = G.byIndex, K = G.stackedCoordDimension, W, Z, X;
  isLegacyDimensionsInput(C) ? W = C : (Z = C.schema, W = Z.dimensions, X = C.store);
  var Q = !!(H && H.get("stack")), ee, te, re, ne;
  if (each$f(W, function(ue, ce) {
    isString(ue) && (W[ce] = ue = {
      name: ue
    }), Q && !ue.isExtraCoord && (!U && !ee && ue.ordinalMeta && (ee = ue), !te && ue.type !== "ordinal" && ue.type !== "time" && (!K || K === ue.coordDim) && (te = ue));
  }), te && !U && !ee && (U = !0), te) {
    re = "__\0ecstackresult_" + H.id, ne = "__\0ecstackedover_" + H.id, ee && (ee.createInvertedIndices = !0);
    var ae = te.coordDim, ie = te.type, se = 0;
    each$f(W, function(ue) {
      ue.coordDim === ae && se++;
    });
    var oe = {
      name: re,
      coordDim: ae,
      coordDimIndex: se,
      type: ie,
      isExtraCoord: !0,
      isCalculationCoord: !0,
      storeDimIndex: W.length
    }, le = {
      name: ne,
      // This dimension contains stack base (generally, 0), so do not set it as
      // `stackedDimCoordDim` to avoid extent calculation, consider log scale.
      coordDim: ne,
      coordDimIndex: se + 1,
      type: ie,
      isExtraCoord: !0,
      isCalculationCoord: !0,
      storeDimIndex: W.length + 1
    };
    Z ? (X && (oe.storeDimIndex = X.ensureCalculationDimension(ne, ie), le.storeDimIndex = X.ensureCalculationDimension(re, ie)), Z.appendCalculationDimension(oe), Z.appendCalculationDimension(le)) : (W.push(oe), W.push(le));
  }
  return {
    stackedDimension: te && te.name,
    stackedByDimension: ee && ee.name,
    isStackedByIndex: U,
    stackedOverDimension: ne,
    stackResultDimension: re
  };
}
function isLegacyDimensionsInput(H) {
  return !isSeriesDataSchema(H.schema);
}
function isDimensionStacked(H, C) {
  return !!C && C === H.getCalculationInfo("stackedDimension");
}
function getStackedDimension(H, C) {
  return isDimensionStacked(H, C) ? H.getCalculationInfo("stackResultDimension") : C;
}
function getCoordSysDimDefs(H, C) {
  var G = H.get("coordinateSystem"), U = CoordinateSystem.get(G), K;
  return C && C.coordSysDims && (K = map$1(C.coordSysDims, function(W) {
    var Z = {
      name: W
    }, X = C.axisMap.get(W);
    if (X) {
      var Q = X.get("type");
      Z.type = getDimensionTypeByAxis(Q);
    }
    return Z;
  })), K || (K = U && (U.getDimensionsInfo ? U.getDimensionsInfo() : U.dimensions.slice()) || ["x", "y"]), K;
}
function injectOrdinalMeta(H, C, G) {
  var U, K;
  return G && each$f(H, function(W, Z) {
    var X = W.coordDim, Q = G.categoryAxisMap.get(X);
    Q && (U == null && (U = Z), W.ordinalMeta = Q.getOrdinalMeta(), C && (W.createInvertedIndices = !0)), W.otherDims.itemName != null && (K = !0);
  }), !K && U != null && (H[U].otherDims.itemName = 0), U;
}
function createSeriesData(H, C, G) {
  G = G || {};
  var U = C.getSourceManager(), K, W = !1;
  H ? (W = !0, K = createSourceFromSeriesDataOption(H)) : (K = U.getSource(), W = K.sourceFormat === SOURCE_FORMAT_ORIGINAL);
  var Z = getCoordSysInfoBySeries(C), X = getCoordSysDimDefs(C, Z), Q = G.useEncodeDefaulter, ee = isFunction(Q) ? Q : Q ? curry$1(makeSeriesEncodeForAxisCoordSys, X, C) : null, te = {
    coordDimensions: X,
    generateCoord: G.generateCoord,
    encodeDefine: C.getEncode(),
    encodeDefaulter: ee,
    canOmitUnusedDimensions: !W
  }, re = prepareSeriesDataSchema(K, te), ne = injectOrdinalMeta(re.dimensions, G.createInvertedIndices, Z), ae = W ? null : U.getSharedDataStore(re), ie = enableDataStack(C, {
    schema: re,
    store: ae
  }), se = new SeriesData$1(re, C);
  se.setCalculationInfo(ie);
  var oe = ne != null && isNeedCompleteOrdinalData(K) ? function(le, ue, ce, de) {
    return de === ne ? ce : this.defaultDimValueGetter(le, ue, ce, de);
  } : null;
  return se.hasItemOption = !1, se.initData(
    // Try to reuse the data store in sourceManager if using dataset.
    W ? K : ae,
    null,
    oe
  ), se;
}
function isNeedCompleteOrdinalData(H) {
  if (H.sourceFormat === SOURCE_FORMAT_ORIGINAL) {
    var C = firstDataNotNull(H.data || []);
    return !isArray$1(getDataItemValue(C));
  }
}
function firstDataNotNull(H) {
  for (var C = 0; C < H.length && H[C] == null; )
    C++;
  return H[C];
}
var Scale = (
  /** @class */
  function() {
    function H(C) {
      this._setting = C || {}, this._extent = [1 / 0, -1 / 0];
    }
    return H.prototype.getSetting = function(C) {
      return this._setting[C];
    }, H.prototype.unionExtent = function(C) {
      var G = this._extent;
      C[0] < G[0] && (G[0] = C[0]), C[1] > G[1] && (G[1] = C[1]);
    }, H.prototype.unionExtentFromData = function(C, G) {
      this.unionExtent(C.getApproximateExtent(G));
    }, H.prototype.getExtent = function() {
      return this._extent.slice();
    }, H.prototype.setExtent = function(C, G) {
      var U = this._extent;
      isNaN(C) || (U[0] = C), isNaN(G) || (U[1] = G);
    }, H.prototype.isInExtentRange = function(C) {
      return this._extent[0] <= C && this._extent[1] >= C;
    }, H.prototype.isBlank = function() {
      return this._isBlank;
    }, H.prototype.setBlank = function(C) {
      this._isBlank = C;
    }, H;
  }()
);
enableClassManagement(Scale);
const Scale$1 = Scale;
var uidBase = 0, OrdinalMeta = (
  /** @class */
  function() {
    function H(C) {
      this.categories = C.categories || [], this._needCollect = C.needCollect, this._deduplication = C.deduplication, this.uid = ++uidBase;
    }
    return H.createByAxisModel = function(C) {
      var G = C.option, U = G.data, K = U && map$1(U, getName);
      return new H({
        categories: K,
        needCollect: !K,
        // deduplication is default in axis.
        deduplication: G.dedplication !== !1
      });
    }, H.prototype.getOrdinal = function(C) {
      return this._getOrCreateMap().get(C);
    }, H.prototype.parseAndCollect = function(C) {
      var G, U = this._needCollect;
      if (!isString(C) && !U)
        return C;
      if (U && !this._deduplication)
        return G = this.categories.length, this.categories[G] = C, G;
      var K = this._getOrCreateMap();
      return G = K.get(C), G == null && (U ? (G = this.categories.length, this.categories[G] = C, K.set(C, G)) : G = NaN), G;
    }, H.prototype._getOrCreateMap = function() {
      return this._map || (this._map = createHashMap(this.categories));
    }, H;
  }()
);
function getName(H) {
  return isObject$3(H) && H.value != null ? H.value : H + "";
}
const OrdinalMeta$1 = OrdinalMeta;
function isValueNice(H) {
  var C = Math.pow(10, quantityExponent(Math.abs(H))), G = Math.abs(H / C);
  return G === 0 || G === 1 || G === 2 || G === 3 || G === 5;
}
function isIntervalOrLogScale(H) {
  return H.type === "interval" || H.type === "log";
}
function intervalScaleNiceTicks(H, C, G, U) {
  var K = {}, W = H[1] - H[0], Z = K.interval = nice(W / C, !0);
  G != null && Z < G && (Z = K.interval = G), U != null && Z > U && (Z = K.interval = U);
  var X = K.intervalPrecision = getIntervalPrecision(Z), Q = K.niceTickExtent = [round$3(Math.ceil(H[0] / Z) * Z, X), round$3(Math.floor(H[1] / Z) * Z, X)];
  return fixExtent(Q, H), K;
}
function increaseInterval(H) {
  var C = Math.pow(10, quantityExponent(H)), G = H / C;
  return G ? G === 2 ? G = 3 : G === 3 ? G = 5 : G *= 2 : G = 1, round$3(G * C);
}
function getIntervalPrecision(H) {
  return getPrecision(H) + 2;
}
function clamp(H, C, G) {
  H[C] = Math.max(Math.min(H[C], G[1]), G[0]);
}
function fixExtent(H, C) {
  !isFinite(H[0]) && (H[0] = C[0]), !isFinite(H[1]) && (H[1] = C[1]), clamp(H, 0, C), clamp(H, 1, C), H[0] > H[1] && (H[0] = H[1]);
}
function contain$1(H, C) {
  return H >= C[0] && H <= C[1];
}
function normalize$2(H, C) {
  return C[1] === C[0] ? 0.5 : (H - C[0]) / (C[1] - C[0]);
}
function scale(H, C) {
  return H * (C[1] - C[0]) + C[0];
}
var OrdinalScale = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C(G) {
      var U = H.call(this, G) || this;
      U.type = "ordinal";
      var K = U.getSetting("ordinalMeta");
      return K || (K = new OrdinalMeta$1({})), isArray$1(K) && (K = new OrdinalMeta$1({
        categories: map$1(K, function(W) {
          return isObject$3(W) ? W.value : W;
        })
      })), U._ordinalMeta = K, U._extent = U.getSetting("extent") || [0, K.categories.length - 1], U;
    }
    return C.prototype.parse = function(G) {
      return G == null ? NaN : isString(G) ? this._ordinalMeta.getOrdinal(G) : Math.round(G);
    }, C.prototype.contain = function(G) {
      return G = this.parse(G), contain$1(G, this._extent) && this._ordinalMeta.categories[G] != null;
    }, C.prototype.normalize = function(G) {
      return G = this._getTickNumber(this.parse(G)), normalize$2(G, this._extent);
    }, C.prototype.scale = function(G) {
      return G = Math.round(scale(G, this._extent)), this.getRawOrdinalNumber(G);
    }, C.prototype.getTicks = function() {
      for (var G = [], U = this._extent, K = U[0]; K <= U[1]; )
        G.push({
          value: K
        }), K++;
      return G;
    }, C.prototype.getMinorTicks = function(G) {
    }, C.prototype.setSortInfo = function(G) {
      if (G == null) {
        this._ordinalNumbersByTick = this._ticksByOrdinalNumber = null;
        return;
      }
      for (var U = G.ordinalNumbers, K = this._ordinalNumbersByTick = [], W = this._ticksByOrdinalNumber = [], Z = 0, X = this._ordinalMeta.categories.length, Q = Math.min(X, U.length); Z < Q; ++Z) {
        var ee = U[Z];
        K[Z] = ee, W[ee] = Z;
      }
      for (var te = 0; Z < X; ++Z) {
        for (; W[te] != null; )
          te++;
        K.push(te), W[te] = Z;
      }
    }, C.prototype._getTickNumber = function(G) {
      var U = this._ticksByOrdinalNumber;
      return U && G >= 0 && G < U.length ? U[G] : G;
    }, C.prototype.getRawOrdinalNumber = function(G) {
      var U = this._ordinalNumbersByTick;
      return U && G >= 0 && G < U.length ? U[G] : G;
    }, C.prototype.getLabel = function(G) {
      if (!this.isBlank()) {
        var U = this.getRawOrdinalNumber(G.value), K = this._ordinalMeta.categories[U];
        return K == null ? "" : K + "";
      }
    }, C.prototype.count = function() {
      return this._extent[1] - this._extent[0] + 1;
    }, C.prototype.unionExtentFromData = function(G, U) {
      this.unionExtent(G.getApproximateExtent(U));
    }, C.prototype.isInExtentRange = function(G) {
      return G = this._getTickNumber(G), this._extent[0] <= G && this._extent[1] >= G;
    }, C.prototype.getOrdinalMeta = function() {
      return this._ordinalMeta;
    }, C.prototype.calcNiceTicks = function() {
    }, C.prototype.calcNiceExtent = function() {
    }, C.type = "ordinal", C;
  }(Scale$1)
);
Scale$1.registerClass(OrdinalScale);
const OrdinalScale$1 = OrdinalScale;
var roundNumber = round$3, IntervalScale = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = "interval", G._interval = 0, G._intervalPrecision = 2, G;
    }
    return C.prototype.parse = function(G) {
      return G;
    }, C.prototype.contain = function(G) {
      return contain$1(G, this._extent);
    }, C.prototype.normalize = function(G) {
      return normalize$2(G, this._extent);
    }, C.prototype.scale = function(G) {
      return scale(G, this._extent);
    }, C.prototype.setExtent = function(G, U) {
      var K = this._extent;
      isNaN(G) || (K[0] = parseFloat(G)), isNaN(U) || (K[1] = parseFloat(U));
    }, C.prototype.unionExtent = function(G) {
      var U = this._extent;
      G[0] < U[0] && (U[0] = G[0]), G[1] > U[1] && (U[1] = G[1]), this.setExtent(U[0], U[1]);
    }, C.prototype.getInterval = function() {
      return this._interval;
    }, C.prototype.setInterval = function(G) {
      this._interval = G, this._niceExtent = this._extent.slice(), this._intervalPrecision = getIntervalPrecision(G);
    }, C.prototype.getTicks = function(G) {
      var U = this._interval, K = this._extent, W = this._niceExtent, Z = this._intervalPrecision, X = [];
      if (!U)
        return X;
      var Q = 1e4;
      K[0] < W[0] && (G ? X.push({
        value: roundNumber(W[0] - U, Z)
      }) : X.push({
        value: K[0]
      }));
      for (var ee = W[0]; ee <= W[1] && (X.push({
        value: ee
      }), ee = roundNumber(ee + U, Z), ee !== X[X.length - 1].value); )
        if (X.length > Q)
          return [];
      var te = X.length ? X[X.length - 1].value : W[1];
      return K[1] > te && (G ? X.push({
        value: roundNumber(te + U, Z)
      }) : X.push({
        value: K[1]
      })), X;
    }, C.prototype.getMinorTicks = function(G) {
      for (var U = this.getTicks(!0), K = [], W = this.getExtent(), Z = 1; Z < U.length; Z++) {
        for (var X = U[Z], Q = U[Z - 1], ee = 0, te = [], re = X.value - Q.value, ne = re / G; ee < G - 1; ) {
          var ae = roundNumber(Q.value + (ee + 1) * ne);
          ae > W[0] && ae < W[1] && te.push(ae), ee++;
        }
        K.push(te);
      }
      return K;
    }, C.prototype.getLabel = function(G, U) {
      if (G == null)
        return "";
      var K = U && U.precision;
      K == null ? K = getPrecision(G.value) || 0 : K === "auto" && (K = this._intervalPrecision);
      var W = roundNumber(G.value, K, !0);
      return addCommas(W);
    }, C.prototype.calcNiceTicks = function(G, U, K) {
      G = G || 5;
      var W = this._extent, Z = W[1] - W[0];
      if (isFinite(Z)) {
        Z < 0 && (Z = -Z, W.reverse());
        var X = intervalScaleNiceTicks(W, G, U, K);
        this._intervalPrecision = X.intervalPrecision, this._interval = X.interval, this._niceExtent = X.niceTickExtent;
      }
    }, C.prototype.calcNiceExtent = function(G) {
      var U = this._extent;
      if (U[0] === U[1])
        if (U[0] !== 0) {
          var K = Math.abs(U[0]);
          G.fixMax || (U[1] += K / 2), U[0] -= K / 2;
        } else
          U[1] = 1;
      var W = U[1] - U[0];
      isFinite(W) || (U[0] = 0, U[1] = 1), this.calcNiceTicks(G.splitNumber, G.minInterval, G.maxInterval);
      var Z = this._interval;
      G.fixMin || (U[0] = roundNumber(Math.floor(U[0] / Z) * Z)), G.fixMax || (U[1] = roundNumber(Math.ceil(U[1] / Z) * Z));
    }, C.prototype.setNiceExtent = function(G, U) {
      this._niceExtent = [G, U];
    }, C.type = "interval", C;
  }(Scale$1)
);
Scale$1.registerClass(IntervalScale);
const IntervalScale$1 = IntervalScale;
var supportFloat32Array = typeof Float32Array < "u", Float32ArrayCtor = supportFloat32Array ? Float32Array : Array;
function createFloat32Array(H) {
  return isArray$1(H) ? supportFloat32Array ? new Float32Array(H) : H : new Float32ArrayCtor(H);
}
var STACK_PREFIX = "__ec_stack_";
function getSeriesStackId$1(H) {
  return H.get("stack") || STACK_PREFIX + H.seriesIndex;
}
function getAxisKey$1(H) {
  return H.dim + H.index;
}
function getLayoutOnAxis(H) {
  var C = [], G = H.axis, U = "axis0";
  if (G.type === "category") {
    for (var K = G.getBandWidth(), W = 0; W < H.count; W++)
      C.push(defaults({
        bandWidth: K,
        axisKey: U,
        stackId: STACK_PREFIX + W
      }, H));
    for (var Z = doCalBarWidthAndOffset(C), X = [], W = 0; W < H.count; W++) {
      var Q = Z[U][STACK_PREFIX + W];
      Q.offsetCenter = Q.offset + Q.width / 2, X.push(Q);
    }
    return X;
  }
}
function prepareLayoutBarSeries(H, C) {
  var G = [];
  return C.eachSeriesByType(H, function(U) {
    isOnCartesian(U) && G.push(U);
  }), G;
}
function getValueAxesMinGaps(H) {
  var C = {};
  each$f(H, function(Q) {
    var ee = Q.coordinateSystem, te = ee.getBaseAxis();
    if (!(te.type !== "time" && te.type !== "value"))
      for (var re = Q.getData(), ne = te.dim + "_" + te.index, ae = re.getDimensionIndex(re.mapDimension(te.dim)), ie = re.getStore(), se = 0, oe = ie.count(); se < oe; ++se) {
        var le = ie.get(ae, se);
        C[ne] ? C[ne].push(le) : C[ne] = [le];
      }
  });
  var G = {};
  for (var U in C)
    if (C.hasOwnProperty(U)) {
      var K = C[U];
      if (K) {
        K.sort(function(Q, ee) {
          return Q - ee;
        });
        for (var W = null, Z = 1; Z < K.length; ++Z) {
          var X = K[Z] - K[Z - 1];
          X > 0 && (W = W === null ? X : Math.min(W, X));
        }
        G[U] = W;
      }
    }
  return G;
}
function makeColumnLayout(H) {
  var C = getValueAxesMinGaps(H), G = [];
  return each$f(H, function(U) {
    var K = U.coordinateSystem, W = K.getBaseAxis(), Z = W.getExtent(), X;
    if (W.type === "category")
      X = W.getBandWidth();
    else if (W.type === "value" || W.type === "time") {
      var Q = W.dim + "_" + W.index, ee = C[Q], te = Math.abs(Z[1] - Z[0]), re = W.scale.getExtent(), ne = Math.abs(re[1] - re[0]);
      X = ee ? te / ne * ee : te;
    } else {
      var ae = U.getData();
      X = Math.abs(Z[1] - Z[0]) / ae.count();
    }
    var ie = parsePercent(U.get("barWidth"), X), se = parsePercent(U.get("barMaxWidth"), X), oe = parsePercent(
      // barMinWidth by default is 0.5 / 1 in cartesian. Because in value axis,
      // the auto-calculated bar width might be less than 0.5 / 1.
      U.get("barMinWidth") || (isInLargeMode(U) ? 0.5 : 1),
      X
    ), le = U.get("barGap"), ue = U.get("barCategoryGap");
    G.push({
      bandWidth: X,
      barWidth: ie,
      barMaxWidth: se,
      barMinWidth: oe,
      barGap: le,
      barCategoryGap: ue,
      axisKey: getAxisKey$1(W),
      stackId: getSeriesStackId$1(U)
    });
  }), doCalBarWidthAndOffset(G);
}
function doCalBarWidthAndOffset(H) {
  var C = {};
  each$f(H, function(U, K) {
    var W = U.axisKey, Z = U.bandWidth, X = C[W] || {
      bandWidth: Z,
      remainedWidth: Z,
      autoWidthCount: 0,
      categoryGap: null,
      gap: "20%",
      stacks: {}
    }, Q = X.stacks;
    C[W] = X;
    var ee = U.stackId;
    Q[ee] || X.autoWidthCount++, Q[ee] = Q[ee] || {
      width: 0,
      maxWidth: 0
    };
    var te = U.barWidth;
    te && !Q[ee].width && (Q[ee].width = te, te = Math.min(X.remainedWidth, te), X.remainedWidth -= te);
    var re = U.barMaxWidth;
    re && (Q[ee].maxWidth = re);
    var ne = U.barMinWidth;
    ne && (Q[ee].minWidth = ne);
    var ae = U.barGap;
    ae != null && (X.gap = ae);
    var ie = U.barCategoryGap;
    ie != null && (X.categoryGap = ie);
  });
  var G = {};
  return each$f(C, function(U, K) {
    G[K] = {};
    var W = U.stacks, Z = U.bandWidth, X = U.categoryGap;
    if (X == null) {
      var Q = keys(W).length;
      X = Math.max(35 - Q * 4, 15) + "%";
    }
    var ee = parsePercent(X, Z), te = parsePercent(U.gap, 1), re = U.remainedWidth, ne = U.autoWidthCount, ae = (re - ee) / (ne + (ne - 1) * te);
    ae = Math.max(ae, 0), each$f(W, function(le) {
      var ue = le.maxWidth, ce = le.minWidth;
      if (le.width) {
        var de = le.width;
        ue && (de = Math.min(de, ue)), ce && (de = Math.max(de, ce)), le.width = de, re -= de + te * de, ne--;
      } else {
        var de = ae;
        ue && ue < de && (de = Math.min(ue, re)), ce && ce > de && (de = ce), de !== ae && (le.width = de, re -= de + te * de, ne--);
      }
    }), ae = (re - ee) / (ne + (ne - 1) * te), ae = Math.max(ae, 0);
    var ie = 0, se;
    each$f(W, function(le, ue) {
      le.width || (le.width = ae), se = le, ie += le.width * (1 + te);
    }), se && (ie -= se.width * te);
    var oe = -ie / 2;
    each$f(W, function(le, ue) {
      G[K][ue] = G[K][ue] || {
        bandWidth: Z,
        offset: oe,
        width: le.width
      }, oe += le.width * (1 + te);
    });
  }), G;
}
function retrieveColumnLayout(H, C, G) {
  if (H && C) {
    var U = H[getAxisKey$1(C)];
    return U != null && G != null ? U[getSeriesStackId$1(G)] : U;
  }
}
function layout$3(H, C) {
  var G = prepareLayoutBarSeries(H, C), U = makeColumnLayout(G);
  each$f(G, function(K) {
    var W = K.getData(), Z = K.coordinateSystem, X = Z.getBaseAxis(), Q = getSeriesStackId$1(K), ee = U[getAxisKey$1(X)][Q], te = ee.offset, re = ee.width;
    W.setLayout({
      bandWidth: ee.bandWidth,
      offset: te,
      size: re
    });
  });
}
function createProgressiveLayout(H) {
  return {
    seriesType: H,
    plan: createRenderPlanner(),
    reset: function(C) {
      if (isOnCartesian(C)) {
        var G = C.getData(), U = C.coordinateSystem, K = U.getBaseAxis(), W = U.getOtherAxis(K), Z = G.getDimensionIndex(G.mapDimension(W.dim)), X = G.getDimensionIndex(G.mapDimension(K.dim)), Q = C.get("showBackground", !0), ee = G.mapDimension(W.dim), te = G.getCalculationInfo("stackResultDimension"), re = isDimensionStacked(G, ee) && !!G.getCalculationInfo("stackedOnSeries"), ne = W.isHorizontal(), ae = getValueAxisStart(K, W), ie = isInLargeMode(C), se = C.get("barMinHeight") || 0, oe = te && G.getDimensionIndex(te), le = G.getLayout("size"), ue = G.getLayout("offset");
        return {
          progress: function(ce, de) {
            for (var ge = ce.count, fe = ie && createFloat32Array(ge * 3), ve = ie && Q && createFloat32Array(ge * 3), pe = ie && createFloat32Array(ge), he = U.master.getRect(), me = ne ? he.width : he.height, ye, Ce = de.getStore(), Ie = 0; (ye = ce.next()) != null; ) {
              var be = Ce.get(re ? oe : Z, ye), Se = Ce.get(X, ye), Ae = ae, _e = void 0;
              re && (_e = +be - Ce.get(Z, ye));
              var xe = void 0, Te = void 0, Pe = void 0, $e = void 0;
              if (ne) {
                var Me = U.dataToPoint([be, Se]);
                if (re) {
                  var Ee = U.dataToPoint([_e, Se]);
                  Ae = Ee[0];
                }
                xe = Ae, Te = Me[1] + ue, Pe = Me[0] - Ae, $e = le, Math.abs(Pe) < se && (Pe = (Pe < 0 ? -1 : 1) * se);
              } else {
                var Me = U.dataToPoint([Se, be]);
                if (re) {
                  var Ee = U.dataToPoint([Se, _e]);
                  Ae = Ee[1];
                }
                xe = Me[0] + ue, Te = Ae, Pe = le, $e = Me[1] - Ae, Math.abs($e) < se && ($e = ($e <= 0 ? -1 : 1) * se);
              }
              ie ? (fe[Ie] = xe, fe[Ie + 1] = Te, fe[Ie + 2] = ne ? Pe : $e, ve && (ve[Ie] = ne ? he.x : xe, ve[Ie + 1] = ne ? Te : he.y, ve[Ie + 2] = me), pe[ye] = ye) : de.setItemLayout(ye, {
                x: xe,
                y: Te,
                width: Pe,
                height: $e
              }), Ie += 3;
            }
            ie && de.setLayout({
              largePoints: fe,
              largeDataIndices: pe,
              largeBackgroundPoints: ve,
              valueAxisHorizontal: ne
            });
          }
        };
      }
    }
  };
}
function isOnCartesian(H) {
  return H.coordinateSystem && H.coordinateSystem.type === "cartesian2d";
}
function isInLargeMode(H) {
  return H.pipelineContext && H.pipelineContext.large;
}
function getValueAxisStart(H, C) {
  return C.toGlobalCoord(C.dataToCoord(C.type === "log" ? 1 : 0));
}
var bisect = function(H, C, G, U) {
  for (; G < U; ) {
    var K = G + U >>> 1;
    H[K][1] < C ? G = K + 1 : U = K;
  }
  return G;
}, TimeScale = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C(G) {
      var U = H.call(this, G) || this;
      return U.type = "time", U;
    }
    return C.prototype.getLabel = function(G) {
      var U = this.getSetting("useUTC");
      return format(G.value, fullLeveledFormatter[getDefaultFormatPrecisionOfInterval(getPrimaryTimeUnit(this._minLevelUnit))] || fullLeveledFormatter.second, U, this.getSetting("locale"));
    }, C.prototype.getFormattedLabel = function(G, U, K) {
      var W = this.getSetting("useUTC"), Z = this.getSetting("locale");
      return leveledFormat(G, U, K, Z, W);
    }, C.prototype.getTicks = function() {
      var G = this._interval, U = this._extent, K = [];
      if (!G)
        return K;
      K.push({
        value: U[0],
        level: 0
      });
      var W = this.getSetting("useUTC"), Z = getIntervalTicks(this._minLevelUnit, this._approxInterval, W, U);
      return K = K.concat(Z), K.push({
        value: U[1],
        level: 0
      }), K;
    }, C.prototype.calcNiceExtent = function(G) {
      var U = this._extent;
      if (U[0] === U[1] && (U[0] -= ONE_DAY, U[1] += ONE_DAY), U[1] === -1 / 0 && U[0] === 1 / 0) {
        var K = new Date();
        U[1] = +new Date(K.getFullYear(), K.getMonth(), K.getDate()), U[0] = U[1] - ONE_DAY;
      }
      this.calcNiceTicks(G.splitNumber, G.minInterval, G.maxInterval);
    }, C.prototype.calcNiceTicks = function(G, U, K) {
      G = G || 10;
      var W = this._extent, Z = W[1] - W[0];
      this._approxInterval = Z / G, U != null && this._approxInterval < U && (this._approxInterval = U), K != null && this._approxInterval > K && (this._approxInterval = K);
      var X = scaleIntervals.length, Q = Math.min(bisect(scaleIntervals, this._approxInterval, 0, X), X - 1);
      this._interval = scaleIntervals[Q][1], this._minLevelUnit = scaleIntervals[Math.max(Q - 1, 0)][0];
    }, C.prototype.parse = function(G) {
      return isNumber(G) ? G : +parseDate(G);
    }, C.prototype.contain = function(G) {
      return contain$1(this.parse(G), this._extent);
    }, C.prototype.normalize = function(G) {
      return normalize$2(this.parse(G), this._extent);
    }, C.prototype.scale = function(G) {
      return scale(G, this._extent);
    }, C.type = "time", C;
  }(IntervalScale$1)
), scaleIntervals = [
  // Format                           interval
  ["second", ONE_SECOND],
  ["minute", ONE_MINUTE],
  ["hour", ONE_HOUR],
  ["quarter-day", ONE_HOUR * 6],
  ["half-day", ONE_HOUR * 12],
  ["day", ONE_DAY * 1.2],
  ["half-week", ONE_DAY * 3.5],
  ["week", ONE_DAY * 7],
  ["month", ONE_DAY * 31],
  ["quarter", ONE_DAY * 95],
  ["half-year", ONE_YEAR / 2],
  ["year", ONE_YEAR]
  // 1Y
];
function isUnitValueSame(H, C, G, U) {
  var K = parseDate(C), W = parseDate(G), Z = function(ie) {
    return getUnitValue(K, ie, U) === getUnitValue(W, ie, U);
  }, X = function() {
    return Z("year");
  }, Q = function() {
    return X() && Z("month");
  }, ee = function() {
    return Q() && Z("day");
  }, te = function() {
    return ee() && Z("hour");
  }, re = function() {
    return te() && Z("minute");
  }, ne = function() {
    return re() && Z("second");
  }, ae = function() {
    return ne() && Z("millisecond");
  };
  switch (H) {
    case "year":
      return X();
    case "month":
      return Q();
    case "day":
      return ee();
    case "hour":
      return te();
    case "minute":
      return re();
    case "second":
      return ne();
    case "millisecond":
      return ae();
  }
}
function getDateInterval(H, C) {
  return H /= ONE_DAY, H > 16 ? 16 : H > 7.5 ? 7 : H > 3.5 ? 4 : H > 1.5 ? 2 : 1;
}
function getMonthInterval(H) {
  var C = 30 * ONE_DAY;
  return H /= C, H > 6 ? 6 : H > 3 ? 3 : H > 2 ? 2 : 1;
}
function getHourInterval(H) {
  return H /= ONE_HOUR, H > 12 ? 12 : H > 6 ? 6 : H > 3.5 ? 4 : H > 2 ? 2 : 1;
}
function getMinutesAndSecondsInterval(H, C) {
  return H /= C ? ONE_MINUTE : ONE_SECOND, H > 30 ? 30 : H > 20 ? 20 : H > 15 ? 15 : H > 10 ? 10 : H > 5 ? 5 : H > 2 ? 2 : 1;
}
function getMillisecondsInterval(H) {
  return nice(H, !0);
}
function getFirstTimestampOfUnit(H, C, G) {
  var U = new Date(H);
  switch (getPrimaryTimeUnit(C)) {
    case "year":
    case "month":
      U[monthSetterName(G)](0);
    case "day":
      U[dateSetterName(G)](1);
    case "hour":
      U[hoursSetterName(G)](0);
    case "minute":
      U[minutesSetterName(G)](0);
    case "second":
      U[secondsSetterName(G)](0), U[millisecondsSetterName(G)](0);
  }
  return U.getTime();
}
function getIntervalTicks(H, C, G, U) {
  var K = 1e4, W = timeUnits, Z = 0;
  function X(me, ye, Ce, Ie, be, Se, Ae) {
    for (var _e = new Date(ye), xe = ye, Te = _e[Ie](); xe < Ce && xe <= U[1]; )
      Ae.push({
        value: xe
      }), Te += me, _e[be](Te), xe = _e.getTime();
    Ae.push({
      value: xe,
      notAdd: !0
    });
  }
  function Q(me, ye, Ce) {
    var Ie = [], be = !ye.length;
    if (!isUnitValueSame(getPrimaryTimeUnit(me), U[0], U[1], G)) {
      be && (ye = [{
        // TODO Optimize. Not include so may ticks.
        value: getFirstTimestampOfUnit(new Date(U[0]), me, G)
      }, {
        value: U[1]
      }]);
      for (var Se = 0; Se < ye.length - 1; Se++) {
        var Ae = ye[Se].value, _e = ye[Se + 1].value;
        if (Ae !== _e) {
          var xe = void 0, Te = void 0, Pe = void 0, $e = !1;
          switch (me) {
            case "year":
              xe = Math.max(1, Math.round(C / ONE_DAY / 365)), Te = fullYearGetterName(G), Pe = fullYearSetterName(G);
              break;
            case "half-year":
            case "quarter":
            case "month":
              xe = getMonthInterval(C), Te = monthGetterName(G), Pe = monthSetterName(G);
              break;
            case "week":
            case "half-week":
            case "day":
              xe = getDateInterval(C), Te = dateGetterName(G), Pe = dateSetterName(G), $e = !0;
              break;
            case "half-day":
            case "quarter-day":
            case "hour":
              xe = getHourInterval(C), Te = hoursGetterName(G), Pe = hoursSetterName(G);
              break;
            case "minute":
              xe = getMinutesAndSecondsInterval(C, !0), Te = minutesGetterName(G), Pe = minutesSetterName(G);
              break;
            case "second":
              xe = getMinutesAndSecondsInterval(C, !1), Te = secondsGetterName(G), Pe = secondsSetterName(G);
              break;
            case "millisecond":
              xe = getMillisecondsInterval(C), Te = millisecondsGetterName(G), Pe = millisecondsSetterName(G);
              break;
          }
          X(xe, Ae, _e, Te, Pe, $e, Ie), me === "year" && Ce.length > 1 && Se === 0 && Ce.unshift({
            value: Ce[0].value - xe
          });
        }
      }
      for (var Se = 0; Se < Ie.length; Se++)
        Ce.push(Ie[Se]);
      return Ie;
    }
  }
  for (var ee = [], te = [], re = 0, ne = 0, ae = 0; ae < W.length && Z++ < K; ++ae) {
    var ie = getPrimaryTimeUnit(W[ae]);
    if (isPrimaryTimeUnit(W[ae])) {
      Q(W[ae], ee[ee.length - 1] || [], te);
      var se = W[ae + 1] ? getPrimaryTimeUnit(W[ae + 1]) : null;
      if (ie !== se) {
        if (te.length) {
          ne = re, te.sort(function(me, ye) {
            return me.value - ye.value;
          });
          for (var oe = [], le = 0; le < te.length; ++le) {
            var ue = te[le].value;
            (le === 0 || te[le - 1].value !== ue) && (oe.push(te[le]), ue >= U[0] && ue <= U[1] && re++);
          }
          var ce = (U[1] - U[0]) / C;
          if (re > ce * 1.5 && ne > ce / 1.5 || (ee.push(oe), re > ce || H === W[ae]))
            break;
        }
        te = [];
      }
    }
  }
  process.env.NODE_ENV !== "production" && Z >= K && warn("Exceed safe limit.");
  for (var de = filter(map$1(ee, function(me) {
    return filter(me, function(ye) {
      return ye.value >= U[0] && ye.value <= U[1] && !ye.notAdd;
    });
  }), function(me) {
    return me.length > 0;
  }), ge = [], fe = de.length - 1, ae = 0; ae < de.length; ++ae)
    for (var ve = de[ae], pe = 0; pe < ve.length; ++pe)
      ge.push({
        value: ve[pe].value,
        level: fe - ae
      });
  ge.sort(function(me, ye) {
    return me.value - ye.value;
  });
  for (var he = [], ae = 0; ae < ge.length; ++ae)
    (ae === 0 || ge[ae].value !== ge[ae - 1].value) && he.push(ge[ae]);
  return he;
}
Scale$1.registerClass(TimeScale);
const TimeScale$1 = TimeScale;
var scaleProto = Scale$1.prototype, intervalScaleProto = IntervalScale$1.prototype, roundingErrorFix = round$3, mathFloor$1 = Math.floor, mathCeil$1 = Math.ceil, mathPow$1 = Math.pow, mathLog$1 = Math.log, LogScale = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = "log", G.base = 10, G._originalScale = new IntervalScale$1(), G._interval = 0, G;
    }
    return C.prototype.getTicks = function(G) {
      var U = this._originalScale, K = this._extent, W = U.getExtent(), Z = intervalScaleProto.getTicks.call(this, G);
      return map$1(Z, function(X) {
        var Q = X.value, ee = round$3(mathPow$1(this.base, Q));
        return ee = Q === K[0] && this._fixMin ? fixRoundingError(ee, W[0]) : ee, ee = Q === K[1] && this._fixMax ? fixRoundingError(ee, W[1]) : ee, {
          value: ee
        };
      }, this);
    }, C.prototype.setExtent = function(G, U) {
      var K = mathLog$1(this.base);
      G = mathLog$1(Math.max(0, G)) / K, U = mathLog$1(Math.max(0, U)) / K, intervalScaleProto.setExtent.call(this, G, U);
    }, C.prototype.getExtent = function() {
      var G = this.base, U = scaleProto.getExtent.call(this);
      U[0] = mathPow$1(G, U[0]), U[1] = mathPow$1(G, U[1]);
      var K = this._originalScale, W = K.getExtent();
      return this._fixMin && (U[0] = fixRoundingError(U[0], W[0])), this._fixMax && (U[1] = fixRoundingError(U[1], W[1])), U;
    }, C.prototype.unionExtent = function(G) {
      this._originalScale.unionExtent(G);
      var U = this.base;
      G[0] = mathLog$1(G[0]) / mathLog$1(U), G[1] = mathLog$1(G[1]) / mathLog$1(U), scaleProto.unionExtent.call(this, G);
    }, C.prototype.unionExtentFromData = function(G, U) {
      this.unionExtent(G.getApproximateExtent(U));
    }, C.prototype.calcNiceTicks = function(G) {
      G = G || 10;
      var U = this._extent, K = U[1] - U[0];
      if (!(K === 1 / 0 || K <= 0)) {
        var W = quantity(K), Z = G / K * W;
        for (Z <= 0.5 && (W *= 10); !isNaN(W) && Math.abs(W) < 1 && Math.abs(W) > 0; )
          W *= 10;
        var X = [round$3(mathCeil$1(U[0] / W) * W), round$3(mathFloor$1(U[1] / W) * W)];
        this._interval = W, this._niceExtent = X;
      }
    }, C.prototype.calcNiceExtent = function(G) {
      intervalScaleProto.calcNiceExtent.call(this, G), this._fixMin = G.fixMin, this._fixMax = G.fixMax;
    }, C.prototype.parse = function(G) {
      return G;
    }, C.prototype.contain = function(G) {
      return G = mathLog$1(G) / mathLog$1(this.base), contain$1(G, this._extent);
    }, C.prototype.normalize = function(G) {
      return G = mathLog$1(G) / mathLog$1(this.base), normalize$2(G, this._extent);
    }, C.prototype.scale = function(G) {
      return G = scale(G, this._extent), mathPow$1(this.base, G);
    }, C.type = "log", C;
  }(Scale$1)
), proto = LogScale.prototype;
proto.getMinorTicks = intervalScaleProto.getMinorTicks;
proto.getLabel = intervalScaleProto.getLabel;
function fixRoundingError(H, C) {
  return roundingErrorFix(H, getPrecision(C));
}
Scale$1.registerClass(LogScale);
const LogScale$1 = LogScale;
var ScaleRawExtentInfo = (
  /** @class */
  function() {
    function H(C, G, U) {
      this._prepareParams(C, G, U);
    }
    return H.prototype._prepareParams = function(C, G, U) {
      U[1] < U[0] && (U = [NaN, NaN]), this._dataMin = U[0], this._dataMax = U[1];
      var K = this._isOrdinal = C.type === "ordinal";
      this._needCrossZero = C.type === "interval" && G.getNeedCrossZero && G.getNeedCrossZero();
      var W = this._modelMinRaw = G.get("min", !0);
      isFunction(W) ? this._modelMinNum = parseAxisModelMinMax(C, W({
        min: U[0],
        max: U[1]
      })) : W !== "dataMin" && (this._modelMinNum = parseAxisModelMinMax(C, W));
      var Z = this._modelMaxRaw = G.get("max", !0);
      if (isFunction(Z) ? this._modelMaxNum = parseAxisModelMinMax(C, Z({
        min: U[0],
        max: U[1]
      })) : Z !== "dataMax" && (this._modelMaxNum = parseAxisModelMinMax(C, Z)), K)
        this._axisDataLen = G.getCategories().length;
      else {
        var X = G.get("boundaryGap"), Q = isArray$1(X) ? X : [X || 0, X || 0];
        typeof Q[0] == "boolean" || typeof Q[1] == "boolean" ? (process.env.NODE_ENV !== "production" && console.warn('Boolean type for boundaryGap is only allowed for ordinal axis. Please use string in percentage instead, e.g., "20%". Currently, boundaryGap is set to be 0.'), this._boundaryGapInner = [0, 0]) : this._boundaryGapInner = [parsePercent$1(Q[0], 1), parsePercent$1(Q[1], 1)];
      }
    }, H.prototype.calculate = function() {
      var C = this._isOrdinal, G = this._dataMin, U = this._dataMax, K = this._axisDataLen, W = this._boundaryGapInner, Z = C ? null : U - G || Math.abs(G), X = this._modelMinRaw === "dataMin" ? G : this._modelMinNum, Q = this._modelMaxRaw === "dataMax" ? U : this._modelMaxNum, ee = X != null, te = Q != null;
      X == null && (X = C ? K ? 0 : NaN : G - W[0] * Z), Q == null && (Q = C ? K ? K - 1 : NaN : U + W[1] * Z), (X == null || !isFinite(X)) && (X = NaN), (Q == null || !isFinite(Q)) && (Q = NaN);
      var re = eqNaN(X) || eqNaN(Q) || C && !K;
      this._needCrossZero && (X > 0 && Q > 0 && !ee && (X = 0), X < 0 && Q < 0 && !te && (Q = 0));
      var ne = this._determinedMin, ae = this._determinedMax;
      return ne != null && (X = ne, ee = !0), ae != null && (Q = ae, te = !0), {
        min: X,
        max: Q,
        minFixed: ee,
        maxFixed: te,
        isBlank: re
      };
    }, H.prototype.modifyDataMinMax = function(C, G) {
      process.env.NODE_ENV !== "production" && assert(!this.frozen), this[DATA_MIN_MAX_ATTR[C]] = G;
    }, H.prototype.setDeterminedMinMax = function(C, G) {
      var U = DETERMINED_MIN_MAX_ATTR[C];
      process.env.NODE_ENV !== "production" && assert(!this.frozen && this[U] == null), this[U] = G;
    }, H.prototype.freeze = function() {
      this.frozen = !0;
    }, H;
  }()
), DETERMINED_MIN_MAX_ATTR = {
  min: "_determinedMin",
  max: "_determinedMax"
}, DATA_MIN_MAX_ATTR = {
  min: "_dataMin",
  max: "_dataMax"
};
function ensureScaleRawExtentInfo(H, C, G) {
  var U = H.rawExtentInfo;
  return U || (U = new ScaleRawExtentInfo(H, C, G), H.rawExtentInfo = U, U);
}
function parseAxisModelMinMax(H, C) {
  return C == null ? null : eqNaN(C) ? NaN : H.parse(C);
}
function getScaleExtent(H, C) {
  var G = H.type, U = ensureScaleRawExtentInfo(H, C, H.getExtent()).calculate();
  H.setBlank(U.isBlank);
  var K = U.min, W = U.max, Z = C.ecModel;
  if (Z && G === "time") {
    var X = prepareLayoutBarSeries("bar", Z), Q = !1;
    if (each$f(X, function(re) {
      Q = Q || re.getBaseAxis() === C.axis;
    }), Q) {
      var ee = makeColumnLayout(X), te = adjustScaleForOverflow(K, W, C, ee);
      K = te.min, W = te.max;
    }
  }
  return {
    extent: [K, W],
    // "fix" means "fixed", the value should not be
    // changed in the subsequent steps.
    fixMin: U.minFixed,
    fixMax: U.maxFixed
  };
}
function adjustScaleForOverflow(H, C, G, U) {
  var K = G.axis.getExtent(), W = K[1] - K[0], Z = retrieveColumnLayout(U, G.axis);
  if (Z === void 0)
    return {
      min: H,
      max: C
    };
  var X = 1 / 0;
  each$f(Z, function(ae) {
    X = Math.min(ae.offset, X);
  });
  var Q = -1 / 0;
  each$f(Z, function(ae) {
    Q = Math.max(ae.offset + ae.width, Q);
  }), X = Math.abs(X), Q = Math.abs(Q);
  var ee = X + Q, te = C - H, re = 1 - (X + Q) / W, ne = te / re - te;
  return C += ne * (Q / ee), H -= ne * (X / ee), {
    min: H,
    max: C
  };
}
function niceScaleExtent(H, C) {
  var G = C, U = getScaleExtent(H, G), K = U.extent, W = G.get("splitNumber");
  H instanceof LogScale$1 && (H.base = G.get("logBase"));
  var Z = H.type, X = G.get("interval"), Q = Z === "interval" || Z === "time";
  H.setExtent(K[0], K[1]), H.calcNiceExtent({
    splitNumber: W,
    fixMin: U.fixMin,
    fixMax: U.fixMax,
    minInterval: Q ? G.get("minInterval") : null,
    maxInterval: Q ? G.get("maxInterval") : null
  }), X != null && H.setInterval && H.setInterval(X);
}
function createScaleByModel$1(H, C) {
  if (C = C || H.get("type"), C)
    switch (C) {
      case "category":
        return new OrdinalScale$1({
          ordinalMeta: H.getOrdinalMeta ? H.getOrdinalMeta() : H.getCategories(),
          extent: [1 / 0, -1 / 0]
        });
      case "time":
        return new TimeScale$1({
          locale: H.ecModel.getLocaleModel(),
          useUTC: H.ecModel.get("useUTC")
        });
      default:
        return new (Scale$1.getClass(C) || IntervalScale$1)();
    }
}
function ifAxisCrossZero(H) {
  var C = H.scale.getExtent(), G = C[0], U = C[1];
  return !(G > 0 && U > 0 || G < 0 && U < 0);
}
function makeLabelFormatter(H) {
  var C = H.getLabelModel().get("formatter"), G = H.type === "category" ? H.scale.getExtent()[0] : null;
  return H.scale.type === "time" ? function(U) {
    return function(K, W) {
      return H.scale.getFormattedLabel(K, W, U);
    };
  }(C) : isString(C) ? function(U) {
    return function(K) {
      var W = H.scale.getLabel(K), Z = U.replace("{value}", W ?? "");
      return Z;
    };
  }(C) : isFunction(C) ? function(U) {
    return function(K, W) {
      return G != null && (W = K.value - G), U(getAxisRawValue(H, K), W, K.level != null ? {
        level: K.level
      } : null);
    };
  }(C) : function(U) {
    return H.scale.getLabel(U);
  };
}
function getAxisRawValue(H, C) {
  return H.type === "category" ? H.scale.getLabel(C) : C.value;
}
function estimateLabelUnionRect(H) {
  var C = H.model, G = H.scale;
  if (!(!C.get(["axisLabel", "show"]) || G.isBlank())) {
    var U, K, W = G.getExtent();
    G instanceof OrdinalScale$1 ? K = G.count() : (U = G.getTicks(), K = U.length);
    var Z = H.getLabelModel(), X = makeLabelFormatter(H), Q, ee = 1;
    K > 40 && (ee = Math.ceil(K / 40));
    for (var te = 0; te < K; te += ee) {
      var re = U ? U[te] : {
        value: W[0] + te
      }, ne = X(re, te), ae = Z.getTextRect(ne), ie = rotateTextRect(ae, Z.get("rotate") || 0);
      Q ? Q.union(ie) : Q = ie;
    }
    return Q;
  }
}
function rotateTextRect(H, C) {
  var G = C * Math.PI / 180, U = H.width, K = H.height, W = U * Math.abs(Math.cos(G)) + Math.abs(K * Math.sin(G)), Z = U * Math.abs(Math.sin(G)) + Math.abs(K * Math.cos(G)), X = new BoundingRect$1(H.x, H.y, W, Z);
  return X;
}
function getOptionCategoryInterval(H) {
  var C = H.get("interval");
  return C ?? "auto";
}
function shouldShowAllLabels(H) {
  return H.type === "category" && getOptionCategoryInterval(H.getLabelModel()) === 0;
}
function getDataDimensionsOnAxis(H, C) {
  var G = {};
  return each$f(H.mapDimensionsAll(C), function(U) {
    G[getStackedDimension(H, U)] = !0;
  }), keys(G);
}
function unionAxisExtentFromData(H, C, G) {
  C && each$f(getDataDimensionsOnAxis(C, G), function(U) {
    var K = C.getApproximateExtent(U);
    K[0] < H[0] && (H[0] = K[0]), K[1] > H[1] && (H[1] = K[1]);
  });
}
var AxisModelCommonMixin = (
  /** @class */
  function() {
    function H() {
    }
    return H.prototype.getNeedCrossZero = function() {
      var C = this.option;
      return !C.scale;
    }, H.prototype.getCoordSysModel = function() {
    }, H;
  }()
), EPSILON = 1e-8;
function isAroundEqual(H, C) {
  return Math.abs(H - C) < EPSILON;
}
function contain(H, C, G) {
  var U = 0, K = H[0];
  if (!K)
    return !1;
  for (var W = 1; W < H.length; W++) {
    var Z = H[W];
    U += windingLine(K[0], K[1], Z[0], Z[1], C, G), K = Z;
  }
  var X = H[0];
  return (!isAroundEqual(K[0], X[0]) || !isAroundEqual(K[1], X[1])) && (U += windingLine(K[0], K[1], X[0], X[1], C, G)), U !== 0;
}
var TMP_TRANSFORM = [];
function transformPoints(H, C) {
  for (var G = 0; G < H.length; G++)
    applyTransform$1(H[G], H[G], C);
}
function updateBBoxFromPoints(H, C, G, U) {
  for (var K = 0; K < H.length; K++) {
    var W = H[K];
    U && (W = U.project(W)), W && isFinite(W[0]) && isFinite(W[1]) && (min$1(C, C, W), max$1(G, G, W));
  }
}
function centroid$1(H) {
  for (var C = 0, G = 0, U = 0, K = H.length, W = H[K - 1][0], Z = H[K - 1][1], X = 0; X < K; X++) {
    var Q = H[X][0], ee = H[X][1], te = W * ee - Q * Z;
    C += te, G += (W + Q) * te, U += (Z + ee) * te, W = Q, Z = ee;
  }
  return C ? [G / C / 3, U / C / 3, C] : [H[0][0] || 0, H[0][1] || 0];
}
var Region = (
  /** @class */
  function() {
    function H(C) {
      this.name = C;
    }
    return H.prototype.setCenter = function(C) {
      this._center = C;
    }, H.prototype.getCenter = function() {
      var C = this._center;
      return C || (C = this._center = this.calcCenter()), C;
    }, H;
  }()
), GeoJSONPolygonGeometry = (
  /** @class */
  function() {
    function H(C, G) {
      this.type = "polygon", this.exterior = C, this.interiors = G;
    }
    return H;
  }()
), GeoJSONLineStringGeometry = (
  /** @class */
  function() {
    function H(C) {
      this.type = "linestring", this.points = C;
    }
    return H;
  }()
), GeoJSONRegion = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C(G, U, K) {
      var W = H.call(this, G) || this;
      return W.type = "geoJSON", W.geometries = U, W._center = K && [K[0], K[1]], W;
    }
    return C.prototype.calcCenter = function() {
      for (var G = this.geometries, U, K = 0, W = 0; W < G.length; W++) {
        var Z = G[W], X = Z.exterior, Q = X && X.length;
        Q > K && (U = Z, K = Q);
      }
      if (U)
        return centroid$1(U.exterior);
      var ee = this.getBoundingRect();
      return [ee.x + ee.width / 2, ee.y + ee.height / 2];
    }, C.prototype.getBoundingRect = function(G) {
      var U = this._rect;
      if (U && !G)
        return U;
      var K = [1 / 0, 1 / 0], W = [-1 / 0, -1 / 0], Z = this.geometries;
      return each$f(Z, function(X) {
        X.type === "polygon" ? updateBBoxFromPoints(X.exterior, K, W, G) : each$f(X.points, function(Q) {
          updateBBoxFromPoints(Q, K, W, G);
        });
      }), isFinite(K[0]) && isFinite(K[1]) && isFinite(W[0]) && isFinite(W[1]) || (K[0] = K[1] = W[0] = W[1] = 0), U = new BoundingRect$1(K[0], K[1], W[0] - K[0], W[1] - K[1]), G || (this._rect = U), U;
    }, C.prototype.contain = function(G) {
      var U = this.getBoundingRect(), K = this.geometries;
      if (!U.contain(G[0], G[1]))
        return !1;
      e:
        for (var W = 0, Z = K.length; W < Z; W++) {
          var X = K[W];
          if (X.type === "polygon") {
            var Q = X.exterior, ee = X.interiors;
            if (contain(Q, G[0], G[1])) {
              for (var te = 0; te < (ee ? ee.length : 0); te++)
                if (contain(ee[te], G[0], G[1]))
                  continue e;
              return !0;
            }
          }
        }
      return !1;
    }, C.prototype.transformTo = function(G, U, K, W) {
      var Z = this.getBoundingRect(), X = Z.width / Z.height;
      K ? W || (W = K / X) : K = X * W;
      for (var Q = new BoundingRect$1(G, U, K, W), ee = Z.calculateTransform(Q), te = this.geometries, re = 0; re < te.length; re++) {
        var ne = te[re];
        ne.type === "polygon" ? (transformPoints(ne.exterior, ee), each$f(ne.interiors, function(ae) {
          transformPoints(ae, ee);
        })) : each$f(ne.points, function(ae) {
          transformPoints(ae, ee);
        });
      }
      Z = this._rect, Z.copy(Q), this._center = [Z.x + Z.width / 2, Z.y + Z.height / 2];
    }, C.prototype.cloneShallow = function(G) {
      G == null && (G = this.name);
      var U = new C(G, this.geometries, this._center);
      return U._rect = this._rect, U.transformTo = null, U;
    }, C;
  }(Region)
), GeoSVGRegion = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C(G, U) {
      var K = H.call(this, G) || this;
      return K.type = "geoSVG", K._elOnlyForCalculate = U, K;
    }
    return C.prototype.calcCenter = function() {
      for (var G = this._elOnlyForCalculate, U = G.getBoundingRect(), K = [U.x + U.width / 2, U.y + U.height / 2], W = identity(TMP_TRANSFORM), Z = G; Z && !Z.isGeoSVGGraphicRoot; )
        mul(W, Z.getLocalTransform(), W), Z = Z.parent;
      return invert(W, W), applyTransform$1(K, K, W), K;
    }, C;
  }(Region)
);
function decode(H) {
  if (!H.UTF8Encoding)
    return H;
  var C = H, G = C.UTF8Scale;
  G == null && (G = 1024);
  var U = C.features;
  return each$f(U, function(K) {
    var W = K.geometry, Z = W.encodeOffsets, X = W.coordinates;
    if (Z)
      switch (W.type) {
        case "LineString":
          W.coordinates = decodeRing(X, Z, G);
          break;
        case "Polygon":
          decodeRings(X, Z, G);
          break;
        case "MultiLineString":
          decodeRings(X, Z, G);
          break;
        case "MultiPolygon":
          each$f(X, function(Q, ee) {
            return decodeRings(Q, Z[ee], G);
          });
      }
  }), C.UTF8Encoding = !1, C;
}
function decodeRings(H, C, G) {
  for (var U = 0; U < H.length; U++)
    H[U] = decodeRing(H[U], C[U], G);
}
function decodeRing(H, C, G) {
  for (var U = [], K = C[0], W = C[1], Z = 0; Z < H.length; Z += 2) {
    var X = H.charCodeAt(Z) - 64, Q = H.charCodeAt(Z + 1) - 64;
    X = X >> 1 ^ -(X & 1), Q = Q >> 1 ^ -(Q & 1), X += K, Q += W, K = X, W = Q, U.push([X / G, Q / G]);
  }
  return U;
}
function parseGeoJSON(H, C) {
  return H = decode(H), map$1(filter(H.features, function(G) {
    return G.geometry && G.properties && G.geometry.coordinates.length > 0;
  }), function(G) {
    var U = G.properties, K = G.geometry, W = [];
    switch (K.type) {
      case "Polygon":
        var Z = K.coordinates;
        W.push(new GeoJSONPolygonGeometry(Z[0], Z.slice(1)));
        break;
      case "MultiPolygon":
        each$f(K.coordinates, function(Q) {
          Q[0] && W.push(new GeoJSONPolygonGeometry(Q[0], Q.slice(1)));
        });
        break;
      case "LineString":
        W.push(new GeoJSONLineStringGeometry([K.coordinates]));
        break;
      case "MultiLineString":
        W.push(new GeoJSONLineStringGeometry(K.coordinates));
    }
    var X = new GeoJSONRegion(U[C || "name"], W, U.cp);
    return X.properties = U, X;
  });
}
var inner$g = makeInner();
function createAxisLabels(H) {
  return H.type === "category" ? makeCategoryLabels(H) : makeRealNumberLabels(H);
}
function createAxisTicks(H, C) {
  return H.type === "category" ? makeCategoryTicks(H, C) : {
    ticks: map$1(H.scale.getTicks(), function(G) {
      return G.value;
    })
  };
}
function makeCategoryLabels(H) {
  var C = H.getLabelModel(), G = makeCategoryLabelsActually(H, C);
  return !C.get("show") || H.scale.isBlank() ? {
    labels: [],
    labelCategoryInterval: G.labelCategoryInterval
  } : G;
}
function makeCategoryLabelsActually(H, C) {
  var G = getListCache(H, "labels"), U = getOptionCategoryInterval(C), K = listCacheGet(G, U);
  if (K)
    return K;
  var W, Z;
  return isFunction(U) ? W = makeLabelsByCustomizedCategoryInterval(H, U) : (Z = U === "auto" ? makeAutoCategoryInterval(H) : U, W = makeLabelsByNumericCategoryInterval(H, Z)), listCacheSet(G, U, {
    labels: W,
    labelCategoryInterval: Z
  });
}
function makeCategoryTicks(H, C) {
  var G = getListCache(H, "ticks"), U = getOptionCategoryInterval(C), K = listCacheGet(G, U);
  if (K)
    return K;
  var W, Z;
  if ((!C.get("show") || H.scale.isBlank()) && (W = []), isFunction(U))
    W = makeLabelsByCustomizedCategoryInterval(H, U, !0);
  else if (U === "auto") {
    var X = makeCategoryLabelsActually(H, H.getLabelModel());
    Z = X.labelCategoryInterval, W = map$1(X.labels, function(Q) {
      return Q.tickValue;
    });
  } else
    Z = U, W = makeLabelsByNumericCategoryInterval(H, Z, !0);
  return listCacheSet(G, U, {
    ticks: W,
    tickCategoryInterval: Z
  });
}
function makeRealNumberLabels(H) {
  var C = H.scale.getTicks(), G = makeLabelFormatter(H);
  return {
    labels: map$1(C, function(U, K) {
      return {
        level: U.level,
        formattedLabel: G(U, K),
        rawLabel: H.scale.getLabel(U),
        tickValue: U.value
      };
    })
  };
}
function getListCache(H, C) {
  return inner$g(H)[C] || (inner$g(H)[C] = []);
}
function listCacheGet(H, C) {
  for (var G = 0; G < H.length; G++)
    if (H[G].key === C)
      return H[G].value;
}
function listCacheSet(H, C, G) {
  return H.push({
    key: C,
    value: G
  }), G;
}
function makeAutoCategoryInterval(H) {
  var C = inner$g(H).autoInterval;
  return C ?? (inner$g(H).autoInterval = H.calculateCategoryInterval());
}
function calculateCategoryInterval(H) {
  var C = fetchAutoCategoryIntervalCalculationParams(H), G = makeLabelFormatter(H), U = (C.axisRotate - C.labelRotate) / 180 * Math.PI, K = H.scale, W = K.getExtent(), Z = K.count();
  if (W[1] - W[0] < 1)
    return 0;
  var X = 1;
  Z > 40 && (X = Math.max(1, Math.floor(Z / 40)));
  for (var Q = W[0], ee = H.dataToCoord(Q + 1) - H.dataToCoord(Q), te = Math.abs(ee * Math.cos(U)), re = Math.abs(ee * Math.sin(U)), ne = 0, ae = 0; Q <= W[1]; Q += X) {
    var ie = 0, se = 0, oe = getBoundingRect(G({
      value: Q
    }), C.font, "center", "top");
    ie = oe.width * 1.3, se = oe.height * 1.3, ne = Math.max(ne, ie, 7), ae = Math.max(ae, se, 7);
  }
  var le = ne / te, ue = ae / re;
  isNaN(le) && (le = 1 / 0), isNaN(ue) && (ue = 1 / 0);
  var ce = Math.max(0, Math.floor(Math.min(le, ue))), de = inner$g(H.model), ge = H.getExtent(), fe = de.lastAutoInterval, ve = de.lastTickCount;
  return fe != null && ve != null && Math.abs(fe - ce) <= 1 && Math.abs(ve - Z) <= 1 && fe > ce && de.axisExtent0 === ge[0] && de.axisExtent1 === ge[1] ? ce = fe : (de.lastTickCount = Z, de.lastAutoInterval = ce, de.axisExtent0 = ge[0], de.axisExtent1 = ge[1]), ce;
}
function fetchAutoCategoryIntervalCalculationParams(H) {
  var C = H.getLabelModel();
  return {
    axisRotate: H.getRotate ? H.getRotate() : H.isHorizontal && !H.isHorizontal() ? 90 : 0,
    labelRotate: C.get("rotate") || 0,
    font: C.getFont()
  };
}
function makeLabelsByNumericCategoryInterval(H, C, G) {
  var U = makeLabelFormatter(H), K = H.scale, W = K.getExtent(), Z = H.getLabelModel(), X = [], Q = Math.max((C || 0) + 1, 1), ee = W[0], te = K.count();
  ee !== 0 && Q > 1 && te / Q > 2 && (ee = Math.round(Math.ceil(ee / Q) * Q));
  var re = shouldShowAllLabels(H), ne = Z.get("showMinLabel") || re, ae = Z.get("showMaxLabel") || re;
  ne && ee !== W[0] && se(W[0]);
  for (var ie = ee; ie <= W[1]; ie += Q)
    se(ie);
  ae && ie - Q !== W[1] && se(W[1]);
  function se(oe) {
    var le = {
      value: oe
    };
    X.push(G ? oe : {
      formattedLabel: U(le),
      rawLabel: K.getLabel(le),
      tickValue: oe
    });
  }
  return X;
}
function makeLabelsByCustomizedCategoryInterval(H, C, G) {
  var U = H.scale, K = makeLabelFormatter(H), W = [];
  return each$f(U.getTicks(), function(Z) {
    var X = U.getLabel(Z), Q = Z.value;
    C(Z.value, X) && W.push(G ? Q : {
      formattedLabel: K(Z),
      rawLabel: X,
      tickValue: Q
    });
  }), W;
}
var NORMALIZED_EXTENT = [0, 1], Axis = (
  /** @class */
  function() {
    function H(C, G, U) {
      this.onBand = !1, this.inverse = !1, this.dim = C, this.scale = G, this._extent = U || [0, 0];
    }
    return H.prototype.contain = function(C) {
      var G = this._extent, U = Math.min(G[0], G[1]), K = Math.max(G[0], G[1]);
      return C >= U && C <= K;
    }, H.prototype.containData = function(C) {
      return this.scale.contain(C);
    }, H.prototype.getExtent = function() {
      return this._extent.slice();
    }, H.prototype.getPixelPrecision = function(C) {
      return getPixelPrecision(C || this.scale.getExtent(), this._extent);
    }, H.prototype.setExtent = function(C, G) {
      var U = this._extent;
      U[0] = C, U[1] = G;
    }, H.prototype.dataToCoord = function(C, G) {
      var U = this._extent, K = this.scale;
      return C = K.normalize(C), this.onBand && K.type === "ordinal" && (U = U.slice(), fixExtentWithBands(U, K.count())), linearMap$2(C, NORMALIZED_EXTENT, U, G);
    }, H.prototype.coordToData = function(C, G) {
      var U = this._extent, K = this.scale;
      this.onBand && K.type === "ordinal" && (U = U.slice(), fixExtentWithBands(U, K.count()));
      var W = linearMap$2(C, U, NORMALIZED_EXTENT, G);
      return this.scale.scale(W);
    }, H.prototype.pointToData = function(C, G) {
    }, H.prototype.getTicksCoords = function(C) {
      C = C || {};
      var G = C.tickModel || this.getTickModel(), U = createAxisTicks(this, G), K = U.ticks, W = map$1(K, function(X) {
        return {
          coord: this.dataToCoord(this.scale.type === "ordinal" ? this.scale.getRawOrdinalNumber(X) : X),
          tickValue: X
        };
      }, this), Z = G.get("alignWithLabel");
      return fixOnBandTicksCoords(this, W, Z, C.clamp), W;
    }, H.prototype.getMinorTicksCoords = function() {
      if (this.scale.type === "ordinal")
        return [];
      var C = this.model.getModel("minorTick"), G = C.get("splitNumber");
      G > 0 && G < 100 || (G = 5);
      var U = this.scale.getMinorTicks(G), K = map$1(U, function(W) {
        return map$1(W, function(Z) {
          return {
            coord: this.dataToCoord(Z),
            tickValue: Z
          };
        }, this);
      }, this);
      return K;
    }, H.prototype.getViewLabels = function() {
      return createAxisLabels(this).labels;
    }, H.prototype.getLabelModel = function() {
      return this.model.getModel("axisLabel");
    }, H.prototype.getTickModel = function() {
      return this.model.getModel("axisTick");
    }, H.prototype.getBandWidth = function() {
      var C = this._extent, G = this.scale.getExtent(), U = G[1] - G[0] + (this.onBand ? 1 : 0);
      U === 0 && (U = 1);
      var K = Math.abs(C[1] - C[0]);
      return Math.abs(K) / U;
    }, H.prototype.calculateCategoryInterval = function() {
      return calculateCategoryInterval(this);
    }, H;
  }()
);
function fixExtentWithBands(H, C) {
  var G = H[1] - H[0], U = C, K = G / U / 2;
  H[0] += K, H[1] -= K;
}
function fixOnBandTicksCoords(H, C, G, U) {
  var K = C.length;
  if (!H.onBand || G || !K)
    return;
  var W = H.getExtent(), Z, X;
  if (K === 1)
    C[0].coord = W[0], Z = C[1] = {
      coord: W[0]
    };
  else {
    var Q = C[K - 1].tickValue - C[0].tickValue, ee = (C[K - 1].coord - C[0].coord) / Q;
    each$f(C, function(ae) {
      ae.coord -= ee / 2;
    });
    var te = H.scale.getExtent();
    X = 1 + te[1] - C[K - 1].tickValue, Z = {
      coord: C[K - 1].coord + ee * X
    }, C.push(Z);
  }
  var re = W[0] > W[1];
  ne(C[0].coord, W[0]) && (U ? C[0].coord = W[0] : C.shift()), U && ne(W[0], C[0].coord) && C.unshift({
    coord: W[0]
  }), ne(W[1], Z.coord) && (U ? Z.coord = W[1] : C.pop()), U && ne(Z.coord, W[1]) && C.push({
    coord: W[1]
  });
  function ne(ae, ie) {
    return ae = round$3(ae), ie = round$3(ie), re ? ae > ie : ae < ie;
  }
}
const Axis$1 = Axis;
var PI2$2 = Math.PI * 2, CMD$1 = PathProxy$1.CMD, DEFAULT_SEARCH_SPACE = ["top", "right", "bottom", "left"];
function getCandidateAnchor(H, C, G, U, K) {
  var W = G.width, Z = G.height;
  switch (H) {
    case "top":
      U.set(G.x + W / 2, G.y - C), K.set(0, -1);
      break;
    case "bottom":
      U.set(G.x + W / 2, G.y + Z + C), K.set(0, 1);
      break;
    case "left":
      U.set(G.x - C, G.y + Z / 2), K.set(-1, 0);
      break;
    case "right":
      U.set(G.x + W + C, G.y + Z / 2), K.set(1, 0);
      break;
  }
}
function projectPointToArc(H, C, G, U, K, W, Z, X, Q) {
  Z -= H, X -= C;
  var ee = Math.sqrt(Z * Z + X * X);
  Z /= ee, X /= ee;
  var te = Z * G + H, re = X * G + C;
  if (Math.abs(U - K) % PI2$2 < 1e-4)
    return Q[0] = te, Q[1] = re, ee - G;
  if (W) {
    var ne = U;
    U = normalizeRadian(K), K = normalizeRadian(ne);
  } else
    U = normalizeRadian(U), K = normalizeRadian(K);
  U > K && (K += PI2$2);
  var ae = Math.atan2(X, Z);
  if (ae < 0 && (ae += PI2$2), ae >= U && ae <= K || ae + PI2$2 >= U && ae + PI2$2 <= K)
    return Q[0] = te, Q[1] = re, ee - G;
  var ie = G * Math.cos(U) + H, se = G * Math.sin(U) + C, oe = G * Math.cos(K) + H, le = G * Math.sin(K) + C, ue = (ie - Z) * (ie - Z) + (se - X) * (se - X), ce = (oe - Z) * (oe - Z) + (le - X) * (le - X);
  return ue < ce ? (Q[0] = ie, Q[1] = se, Math.sqrt(ue)) : (Q[0] = oe, Q[1] = le, Math.sqrt(ce));
}
function projectPointToLine(H, C, G, U, K, W, Z, X) {
  var Q = K - H, ee = W - C, te = G - H, re = U - C, ne = Math.sqrt(te * te + re * re);
  te /= ne, re /= ne;
  var ae = Q * te + ee * re, ie = ae / ne;
  X && (ie = Math.min(Math.max(ie, 0), 1)), ie *= ne;
  var se = Z[0] = H + ie * te, oe = Z[1] = C + ie * re;
  return Math.sqrt((se - K) * (se - K) + (oe - W) * (oe - W));
}
function projectPointToRect(H, C, G, U, K, W, Z) {
  G < 0 && (H = H + G, G = -G), U < 0 && (C = C + U, U = -U);
  var X = H + G, Q = C + U, ee = Z[0] = Math.min(Math.max(K, H), X), te = Z[1] = Math.min(Math.max(W, C), Q);
  return Math.sqrt((ee - K) * (ee - K) + (te - W) * (te - W));
}
var tmpPt = [];
function nearestPointOnRect(H, C, G) {
  var U = projectPointToRect(C.x, C.y, C.width, C.height, H.x, H.y, tmpPt);
  return G.set(tmpPt[0], tmpPt[1]), U;
}
function nearestPointOnPath(H, C, G) {
  for (var U = 0, K = 0, W = 0, Z = 0, X, Q, ee = 1 / 0, te = C.data, re = H.x, ne = H.y, ae = 0; ae < te.length; ) {
    var ie = te[ae++];
    ae === 1 && (U = te[ae], K = te[ae + 1], W = U, Z = K);
    var se = ee;
    switch (ie) {
      case CMD$1.M:
        W = te[ae++], Z = te[ae++], U = W, K = Z;
        break;
      case CMD$1.L:
        se = projectPointToLine(U, K, te[ae], te[ae + 1], re, ne, tmpPt, !0), U = te[ae++], K = te[ae++];
        break;
      case CMD$1.C:
        se = cubicProjectPoint(U, K, te[ae++], te[ae++], te[ae++], te[ae++], te[ae], te[ae + 1], re, ne, tmpPt), U = te[ae++], K = te[ae++];
        break;
      case CMD$1.Q:
        se = quadraticProjectPoint(U, K, te[ae++], te[ae++], te[ae], te[ae + 1], re, ne, tmpPt), U = te[ae++], K = te[ae++];
        break;
      case CMD$1.A:
        var oe = te[ae++], le = te[ae++], ue = te[ae++], ce = te[ae++], de = te[ae++], ge = te[ae++];
        ae += 1;
        var fe = !!(1 - te[ae++]);
        X = Math.cos(de) * ue + oe, Q = Math.sin(de) * ce + le, ae <= 1 && (W = X, Z = Q);
        var ve = (re - oe) * ce / ue + oe;
        se = projectPointToArc(oe, le, ce, de, de + ge, fe, ve, ne, tmpPt), U = Math.cos(de + ge) * ue + oe, K = Math.sin(de + ge) * ce + le;
        break;
      case CMD$1.R:
        W = U = te[ae++], Z = K = te[ae++];
        var pe = te[ae++], he = te[ae++];
        se = projectPointToRect(W, Z, pe, he, re, ne, tmpPt);
        break;
      case CMD$1.Z:
        se = projectPointToLine(U, K, W, Z, re, ne, tmpPt, !0), U = W, K = Z;
        break;
    }
    se < ee && (ee = se, G.set(tmpPt[0], tmpPt[1]));
  }
  return ee;
}
var pt0 = new Point$1(), pt1 = new Point$1(), pt2 = new Point$1(), dir = new Point$1(), dir2 = new Point$1();
function updateLabelLinePoints(H, C) {
  if (H) {
    var G = H.getTextGuideLine(), U = H.getTextContent();
    if (U && G) {
      var K = H.textGuideLineConfig || {}, W = [[0, 0], [0, 0], [0, 0]], Z = K.candidates || DEFAULT_SEARCH_SPACE, X = U.getBoundingRect().clone();
      X.applyTransform(U.getComputedTransform());
      var Q = 1 / 0, ee = K.anchor, te = H.getComputedTransform(), re = te && invert([], te), ne = C.get("length2") || 0;
      ee && pt2.copy(ee);
      for (var ae = 0; ae < Z.length; ae++) {
        var ie = Z[ae];
        getCandidateAnchor(ie, 0, X, pt0, dir), Point$1.scaleAndAdd(pt1, pt0, dir, ne), pt1.transform(re);
        var se = H.getBoundingRect(), oe = ee ? ee.distance(pt1) : H instanceof Path$1 ? nearestPointOnPath(pt1, H.path, pt2) : nearestPointOnRect(pt1, se, pt2);
        oe < Q && (Q = oe, pt1.transform(te), pt2.transform(te), pt2.toArray(W[0]), pt1.toArray(W[1]), pt0.toArray(W[2]));
      }
      limitTurnAngle(W, C.get("minTurnAngle")), G.setShape({
        points: W
      });
    }
  }
}
var tmpArr = [], tmpProjPoint = new Point$1();
function limitTurnAngle(H, C) {
  if (C <= 180 && C > 0) {
    C = C / 180 * Math.PI, pt0.fromArray(H[0]), pt1.fromArray(H[1]), pt2.fromArray(H[2]), Point$1.sub(dir, pt0, pt1), Point$1.sub(dir2, pt2, pt1);
    var G = dir.len(), U = dir2.len();
    if (!(G < 1e-3 || U < 1e-3)) {
      dir.scale(1 / G), dir2.scale(1 / U);
      var K = dir.dot(dir2), W = Math.cos(C);
      if (W < K) {
        var Z = projectPointToLine(pt1.x, pt1.y, pt2.x, pt2.y, pt0.x, pt0.y, tmpArr, !1);
        tmpProjPoint.fromArray(tmpArr), tmpProjPoint.scaleAndAdd(dir2, Z / Math.tan(Math.PI - C));
        var X = pt2.x !== pt1.x ? (tmpProjPoint.x - pt1.x) / (pt2.x - pt1.x) : (tmpProjPoint.y - pt1.y) / (pt2.y - pt1.y);
        if (isNaN(X))
          return;
        X < 0 ? Point$1.copy(tmpProjPoint, pt1) : X > 1 && Point$1.copy(tmpProjPoint, pt2), tmpProjPoint.toArray(H[1]);
      }
    }
  }
}
function limitSurfaceAngle(H, C, G) {
  if (G <= 180 && G > 0) {
    G = G / 180 * Math.PI, pt0.fromArray(H[0]), pt1.fromArray(H[1]), pt2.fromArray(H[2]), Point$1.sub(dir, pt1, pt0), Point$1.sub(dir2, pt2, pt1);
    var U = dir.len(), K = dir2.len();
    if (!(U < 1e-3 || K < 1e-3)) {
      dir.scale(1 / U), dir2.scale(1 / K);
      var W = dir.dot(C), Z = Math.cos(G);
      if (W < Z) {
        var X = projectPointToLine(pt1.x, pt1.y, pt2.x, pt2.y, pt0.x, pt0.y, tmpArr, !1);
        tmpProjPoint.fromArray(tmpArr);
        var Q = Math.PI / 2, ee = Math.acos(dir2.dot(C)), te = Q + ee - G;
        if (te >= Q)
          Point$1.copy(tmpProjPoint, pt2);
        else {
          tmpProjPoint.scaleAndAdd(dir2, X / Math.tan(Math.PI / 2 - te));
          var re = pt2.x !== pt1.x ? (tmpProjPoint.x - pt1.x) / (pt2.x - pt1.x) : (tmpProjPoint.y - pt1.y) / (pt2.y - pt1.y);
          if (isNaN(re))
            return;
          re < 0 ? Point$1.copy(tmpProjPoint, pt1) : re > 1 && Point$1.copy(tmpProjPoint, pt2);
        }
        tmpProjPoint.toArray(H[1]);
      }
    }
  }
}
function setLabelLineState(H, C, G, U) {
  var K = G === "normal", W = K ? H : H.ensureState(G);
  W.ignore = C;
  var Z = U.get("smooth");
  Z && Z === !0 && (Z = 0.3), W.shape = W.shape || {}, Z > 0 && (W.shape.smooth = Z);
  var X = U.getModel("lineStyle").getLineStyle();
  K ? H.useStyle(X) : W.style = X;
}
function buildLabelLinePath(H, C) {
  var G = C.smooth, U = C.points;
  if (U)
    if (H.moveTo(U[0][0], U[0][1]), G > 0 && U.length >= 3) {
      var K = dist$1(U[0], U[1]), W = dist$1(U[1], U[2]);
      if (!K || !W) {
        H.lineTo(U[1][0], U[1][1]), H.lineTo(U[2][0], U[2][1]);
        return;
      }
      var Z = Math.min(K, W) * G, X = lerp$1([], U[1], U[0], Z / K), Q = lerp$1([], U[1], U[2], Z / W), ee = lerp$1([], X, Q, 0.5);
      H.bezierCurveTo(X[0], X[1], X[0], X[1], ee[0], ee[1]), H.bezierCurveTo(Q[0], Q[1], Q[0], Q[1], U[2][0], U[2][1]);
    } else
      for (var te = 1; te < U.length; te++)
        H.lineTo(U[te][0], U[te][1]);
}
function setLabelLineStyle(H, C, G) {
  var U = H.getTextGuideLine(), K = H.getTextContent();
  if (!K) {
    U && H.removeTextGuideLine();
    return;
  }
  for (var W = C.normal, Z = W.get("show"), X = K.ignore, Q = 0; Q < DISPLAY_STATES.length; Q++) {
    var ee = DISPLAY_STATES[Q], te = C[ee], re = ee === "normal";
    if (te) {
      var ne = te.get("show"), ae = re ? X : retrieve2(K.states[ee] && K.states[ee].ignore, X);
      if (ae || !retrieve2(ne, Z)) {
        var ie = re ? U : U && U.states[ee];
        ie && (ie.ignore = !0);
        continue;
      }
      U || (U = new Polyline$3(), H.setTextGuideLine(U), !re && (X || !Z) && setLabelLineState(U, !0, "normal", C.normal), H.stateProxy && (U.stateProxy = H.stateProxy)), setLabelLineState(U, !1, ee, te);
    }
  }
  if (U) {
    defaults(U.style, G), U.style.fill = null;
    var se = W.get("showAbove"), oe = H.textGuideLineConfig = H.textGuideLineConfig || {};
    oe.showAbove = se || !1, U.buildPath = buildLabelLinePath;
  }
}
function getLabelLineStatesModels(H, C) {
  C = C || "labelLine";
  for (var G = {
    normal: H.getModel(C)
  }, U = 0; U < SPECIAL_STATES.length; U++) {
    var K = SPECIAL_STATES[U];
    G[K] = H.getModel([K, C]);
  }
  return G;
}
function prepareLayoutList(H) {
  for (var C = [], G = 0; G < H.length; G++) {
    var U = H[G];
    if (!U.defaultAttr.ignore) {
      var K = U.label, W = K.getComputedTransform(), Z = K.getBoundingRect(), X = !W || W[1] < 1e-5 && W[2] < 1e-5, Q = K.style.margin || 0, ee = Z.clone();
      ee.applyTransform(W), ee.x -= Q / 2, ee.y -= Q / 2, ee.width += Q, ee.height += Q;
      var te = X ? new OrientedBoundingRect$1(Z, W) : null;
      C.push({
        label: K,
        labelLine: U.labelLine,
        rect: ee,
        localRect: Z,
        obb: te,
        priority: U.priority,
        defaultAttr: U.defaultAttr,
        layoutOption: U.computedLayoutOption,
        axisAligned: X,
        transform: W
      });
    }
  }
  return C;
}
function shiftLayout(H, C, G, U, K, W) {
  var Z = H.length;
  if (Z < 2)
    return;
  H.sort(function(pe, he) {
    return pe.rect[C] - he.rect[C];
  });
  for (var X = 0, Q, ee = !1, te = 0, re = 0; re < Z; re++) {
    var ne = H[re], ae = ne.rect;
    Q = ae[C] - X, Q < 0 && (ae[C] -= Q, ne.label[C] -= Q, ee = !0);
    var ie = Math.max(-Q, 0);
    te += ie, X = ae[C] + ae[G];
  }
  te > 0 && W && ge(-te / Z, 0, Z);
  var se = H[0], oe = H[Z - 1], le, ue;
  ce(), le < 0 && fe(-le, 0.8), ue < 0 && fe(ue, 0.8), ce(), de(le, ue, 1), de(ue, le, -1), ce(), le < 0 && ve(-le), ue < 0 && ve(ue);
  function ce() {
    le = se.rect[C] - U, ue = K - oe.rect[C] - oe.rect[G];
  }
  function de(pe, he, me) {
    if (pe < 0) {
      var ye = Math.min(he, -pe);
      if (ye > 0) {
        ge(ye * me, 0, Z);
        var Ce = ye + pe;
        Ce < 0 && fe(-Ce * me, 1);
      } else
        fe(-pe * me, 1);
    }
  }
  function ge(pe, he, me) {
    pe !== 0 && (ee = !0);
    for (var ye = he; ye < me; ye++) {
      var Ce = H[ye], Ie = Ce.rect;
      Ie[C] += pe, Ce.label[C] += pe;
    }
  }
  function fe(pe, he) {
    for (var me = [], ye = 0, Ce = 1; Ce < Z; Ce++) {
      var Ie = H[Ce - 1].rect, be = Math.max(H[Ce].rect[C] - Ie[C] - Ie[G], 0);
      me.push(be), ye += be;
    }
    if (ye) {
      var Se = Math.min(Math.abs(pe) / ye, he);
      if (pe > 0)
        for (var Ce = 0; Ce < Z - 1; Ce++) {
          var Ae = me[Ce] * Se;
          ge(Ae, 0, Ce + 1);
        }
      else
        for (var Ce = Z - 1; Ce > 0; Ce--) {
          var Ae = me[Ce - 1] * Se;
          ge(-Ae, Ce, Z);
        }
    }
  }
  function ve(pe) {
    var he = pe < 0 ? -1 : 1;
    pe = Math.abs(pe);
    for (var me = Math.ceil(pe / (Z - 1)), ye = 0; ye < Z - 1; ye++)
      if (he > 0 ? ge(me, 0, ye + 1) : ge(-me, Z - ye - 1, Z), pe -= me, pe <= 0)
        return;
  }
  return ee;
}
function shiftLayoutOnX(H, C, G, U) {
  return shiftLayout(H, "x", "width", C, G, U);
}
function shiftLayoutOnY(H, C, G, U) {
  return shiftLayout(H, "y", "height", C, G, U);
}
function hideOverlap(H) {
  var C = [];
  H.sort(function(se, oe) {
    return oe.priority - se.priority;
  });
  var G = new BoundingRect$1(0, 0, 0, 0);
  function U(se) {
    if (!se.ignore) {
      var oe = se.ensureState("emphasis");
      oe.ignore == null && (oe.ignore = !1);
    }
    se.ignore = !0;
  }
  for (var K = 0; K < H.length; K++) {
    var W = H[K], Z = W.axisAligned, X = W.localRect, Q = W.transform, ee = W.label, te = W.labelLine;
    G.copy(W.rect), G.width -= 0.1, G.height -= 0.1, G.x += 0.05, G.y += 0.05;
    for (var re = W.obb, ne = !1, ae = 0; ae < C.length; ae++) {
      var ie = C[ae];
      if (G.intersect(ie.rect)) {
        if (Z && ie.axisAligned) {
          ne = !0;
          break;
        }
        if (ie.obb || (ie.obb = new OrientedBoundingRect$1(ie.localRect, ie.transform)), re || (re = new OrientedBoundingRect$1(X, Q)), re.intersect(ie.obb)) {
          ne = !0;
          break;
        }
      }
    }
    ne ? (U(ee), te && U(te)) : (ee.attr("ignore", W.defaultAttr.ignore), te && te.attr("ignore", W.defaultAttr.labelGuideIgnore), C.push(W));
  }
}
function cloneArr(H) {
  if (H) {
    for (var C = [], G = 0; G < H.length; G++)
      C.push(H[G].slice());
    return C;
  }
}
function prepareLayoutCallbackParams(H, C) {
  var G = H.label, U = C && C.getTextGuideLine();
  return {
    dataIndex: H.dataIndex,
    dataType: H.dataType,
    seriesIndex: H.seriesModel.seriesIndex,
    text: H.label.style.text,
    rect: H.hostRect,
    labelRect: H.rect,
    // x: labelAttr.x,
    // y: labelAttr.y,
    align: G.style.align,
    verticalAlign: G.style.verticalAlign,
    labelLinePoints: cloneArr(U && U.shape.points)
  };
}
var LABEL_OPTION_TO_STYLE_KEYS = ["align", "verticalAlign", "width", "height", "fontSize"], dummyTransformable = new Transformable(), labelLayoutInnerStore = makeInner(), labelLineAnimationStore = makeInner();
function extendWithKeys(H, C, G) {
  for (var U = 0; U < G.length; U++) {
    var K = G[U];
    C[K] != null && (H[K] = C[K]);
  }
}
var LABEL_LAYOUT_PROPS = ["x", "y", "rotation"], LabelManager = (
  /** @class */
  function() {
    function H() {
      this._labelList = [], this._chartViewList = [];
    }
    return H.prototype.clearLabels = function() {
      this._labelList = [], this._chartViewList = [];
    }, H.prototype._addLabel = function(C, G, U, K, W) {
      var Z = K.style, X = K.__hostTarget, Q = X.textConfig || {}, ee = K.getComputedTransform(), te = K.getBoundingRect().plain();
      BoundingRect$1.applyTransform(te, te, ee), ee ? dummyTransformable.setLocalTransform(ee) : (dummyTransformable.x = dummyTransformable.y = dummyTransformable.rotation = dummyTransformable.originX = dummyTransformable.originY = 0, dummyTransformable.scaleX = dummyTransformable.scaleY = 1);
      var re = K.__hostTarget, ne;
      if (re) {
        ne = re.getBoundingRect().plain();
        var ae = re.getComputedTransform();
        BoundingRect$1.applyTransform(ne, ne, ae);
      }
      var ie = ne && re.getTextGuideLine();
      this._labelList.push({
        label: K,
        labelLine: ie,
        seriesModel: U,
        dataIndex: C,
        dataType: G,
        layoutOption: W,
        computedLayoutOption: null,
        rect: te,
        hostRect: ne,
        // Label with lower priority will be hidden when overlapped
        // Use rect size as default priority
        priority: ne ? ne.width * ne.height : 0,
        // Save default label attributes.
        // For restore if developers want get back to default value in callback.
        defaultAttr: {
          ignore: K.ignore,
          labelGuideIgnore: ie && ie.ignore,
          x: dummyTransformable.x,
          y: dummyTransformable.y,
          scaleX: dummyTransformable.scaleX,
          scaleY: dummyTransformable.scaleY,
          rotation: dummyTransformable.rotation,
          style: {
            x: Z.x,
            y: Z.y,
            align: Z.align,
            verticalAlign: Z.verticalAlign,
            width: Z.width,
            height: Z.height,
            fontSize: Z.fontSize
          },
          cursor: K.cursor,
          attachedPos: Q.position,
          attachedRot: Q.rotation
        }
      });
    }, H.prototype.addLabelsOfSeries = function(C) {
      var G = this;
      this._chartViewList.push(C);
      var U = C.__model, K = U.get("labelLayout");
      (isFunction(K) || keys(K).length) && C.group.traverse(function(W) {
        if (W.ignore)
          return !0;
        var Z = W.getTextContent(), X = getECData(W);
        Z && !Z.disableLabelLayout && G._addLabel(X.dataIndex, X.dataType, U, Z, K);
      });
    }, H.prototype.updateLayoutConfig = function(C) {
      var G = C.getWidth(), U = C.getHeight();
      function K(ce, de) {
        return function() {
          updateLabelLinePoints(ce, de);
        };
      }
      for (var W = 0; W < this._labelList.length; W++) {
        var Z = this._labelList[W], X = Z.label, Q = X.__hostTarget, ee = Z.defaultAttr, te = void 0;
        isFunction(Z.layoutOption) ? te = Z.layoutOption(prepareLayoutCallbackParams(Z, Q)) : te = Z.layoutOption, te = te || {}, Z.computedLayoutOption = te;
        var re = Math.PI / 180;
        Q && Q.setTextConfig({
          // Force to set local false.
          local: !1,
          // Ignore position and rotation config on the host el if x or y is changed.
          position: te.x != null || te.y != null ? null : ee.attachedPos,
          // Ignore rotation config on the host el if rotation is changed.
          rotation: te.rotate != null ? te.rotate * re : ee.attachedRot,
          offset: [te.dx || 0, te.dy || 0]
        });
        var ne = !1;
        if (te.x != null ? (X.x = parsePercent(te.x, G), X.setStyle("x", 0), ne = !0) : (X.x = ee.x, X.setStyle("x", ee.style.x)), te.y != null ? (X.y = parsePercent(te.y, U), X.setStyle("y", 0), ne = !0) : (X.y = ee.y, X.setStyle("y", ee.style.y)), te.labelLinePoints) {
          var ae = Q.getTextGuideLine();
          ae && (ae.setShape({
            points: te.labelLinePoints
          }), ne = !1);
        }
        var ie = labelLayoutInnerStore(X);
        ie.needsUpdateLabelLine = ne, X.rotation = te.rotate != null ? te.rotate * re : ee.rotation, X.scaleX = ee.scaleX, X.scaleY = ee.scaleY;
        for (var se = 0; se < LABEL_OPTION_TO_STYLE_KEYS.length; se++) {
          var oe = LABEL_OPTION_TO_STYLE_KEYS[se];
          X.setStyle(oe, te[oe] != null ? te[oe] : ee.style[oe]);
        }
        if (te.draggable) {
          if (X.draggable = !0, X.cursor = "move", Q) {
            var le = Z.seriesModel;
            if (Z.dataIndex != null) {
              var ue = Z.seriesModel.getData(Z.dataType);
              le = ue.getItemModel(Z.dataIndex);
            }
            X.on("drag", K(Q, le.getModel("labelLine")));
          }
        } else
          X.off("drag"), X.cursor = ee.cursor;
      }
    }, H.prototype.layout = function(C) {
      var G = C.getWidth(), U = C.getHeight(), K = prepareLayoutList(this._labelList), W = filter(K, function(Q) {
        return Q.layoutOption.moveOverlap === "shiftX";
      }), Z = filter(K, function(Q) {
        return Q.layoutOption.moveOverlap === "shiftY";
      });
      shiftLayoutOnX(W, 0, G), shiftLayoutOnY(Z, 0, U);
      var X = filter(K, function(Q) {
        return Q.layoutOption.hideOverlap;
      });
      hideOverlap(X);
    }, H.prototype.processLabelsOverall = function() {
      var C = this;
      each$f(this._chartViewList, function(G) {
        var U = G.__model, K = G.ignoreLabelLineUpdate, W = U.isAnimationEnabled();
        G.group.traverse(function(Z) {
          if (Z.ignore && !Z.forceLabelAnimation)
            return !0;
          var X = !K, Q = Z.getTextContent();
          !X && Q && (X = labelLayoutInnerStore(Q).needsUpdateLabelLine), X && C._updateLabelLine(Z, U), W && C._animateLabels(Z, U);
        });
      });
    }, H.prototype._updateLabelLine = function(C, G) {
      var U = C.getTextContent(), K = getECData(C), W = K.dataIndex;
      if (U && W != null) {
        var Z = G.getData(K.dataType), X = Z.getItemModel(W), Q = {}, ee = Z.getItemVisual(W, "style"), te = Z.getVisual("drawType");
        Q.stroke = ee[te];
        var re = X.getModel("labelLine");
        setLabelLineStyle(C, getLabelLineStatesModels(X), Q), updateLabelLinePoints(C, re);
      }
    }, H.prototype._animateLabels = function(C, G) {
      var U = C.getTextContent(), K = C.getTextGuideLine();
      if (U && (C.forceLabelAnimation || !U.ignore && !U.invisible && !C.disableLabelAnimation && !isElementRemoved(C))) {
        var W = labelLayoutInnerStore(U), Z = W.oldLayout, X = getECData(C), Q = X.dataIndex, ee = {
          x: U.x,
          y: U.y,
          rotation: U.rotation
        }, te = G.getData(X.dataType);
        if (Z) {
          U.attr(Z);
          var ne = C.prevStates;
          ne && (indexOf(ne, "select") >= 0 && U.attr(W.oldLayoutSelect), indexOf(ne, "emphasis") >= 0 && U.attr(W.oldLayoutEmphasis)), updateProps$1(U, ee, G, Q);
        } else if (U.attr(ee), !labelInner(U).valueAnimation) {
          var re = retrieve2(U.style.opacity, 1);
          U.style.opacity = 0, initProps(U, {
            style: {
              opacity: re
            }
          }, G, Q);
        }
        if (W.oldLayout = ee, U.states.select) {
          var ae = W.oldLayoutSelect = {};
          extendWithKeys(ae, ee, LABEL_LAYOUT_PROPS), extendWithKeys(ae, U.states.select, LABEL_LAYOUT_PROPS);
        }
        if (U.states.emphasis) {
          var ie = W.oldLayoutEmphasis = {};
          extendWithKeys(ie, ee, LABEL_LAYOUT_PROPS), extendWithKeys(ie, U.states.emphasis, LABEL_LAYOUT_PROPS);
        }
        animateLabelValue(U, Q, te, G, G);
      }
      if (K && !K.ignore && !K.invisible) {
        var W = labelLineAnimationStore(K), Z = W.oldLayout, se = {
          points: K.shape.points
        };
        Z ? (K.attr({
          shape: Z
        }), updateProps$1(K, {
          shape: se
        }, G)) : (K.setShape(se), K.style.strokePercent = 0, initProps(K, {
          style: {
            strokePercent: 1
          }
        }, G)), W.oldLayout = se;
      }
    }, H;
  }()
);
const LabelManager$1 = LabelManager;
var getLabelManager = makeInner();
function installLabelLayout(H) {
  H.registerUpdateLifecycle("series:beforeupdate", function(C, G, U) {
    var K = getLabelManager(G).labelManager;
    K || (K = getLabelManager(G).labelManager = new LabelManager$1()), K.clearLabels();
  }), H.registerUpdateLifecycle("series:layoutlabels", function(C, G, U) {
    var K = getLabelManager(G).labelManager;
    U.updatedSeries.forEach(function(W) {
      K.addLabelsOfSeries(G.getViewOfSeriesModel(W));
    }), K.updateLayoutConfig(G), K.layout(G), K.processLabelsOverall();
  });
}
var mathSin = Math.sin, mathCos = Math.cos, PI$4 = Math.PI, PI2$1 = Math.PI * 2, degree = 180 / PI$4, SVGPathRebuilder = function() {
  function H() {
  }
  return H.prototype.reset = function(C) {
    this._start = !0, this._d = [], this._str = "", this._p = Math.pow(10, C || 4);
  }, H.prototype.moveTo = function(C, G) {
    this._add("M", C, G);
  }, H.prototype.lineTo = function(C, G) {
    this._add("L", C, G);
  }, H.prototype.bezierCurveTo = function(C, G, U, K, W, Z) {
    this._add("C", C, G, U, K, W, Z);
  }, H.prototype.quadraticCurveTo = function(C, G, U, K) {
    this._add("Q", C, G, U, K);
  }, H.prototype.arc = function(C, G, U, K, W, Z) {
    this.ellipse(C, G, U, U, 0, K, W, Z);
  }, H.prototype.ellipse = function(C, G, U, K, W, Z, X, Q) {
    var ee = X - Z, te = !Q, re = Math.abs(ee), ne = isAroundZero(re - PI2$1) || (te ? ee >= PI2$1 : -ee >= PI2$1), ae = ee > 0 ? ee % PI2$1 : ee % PI2$1 + PI2$1, ie = !1;
    ne ? ie = !0 : isAroundZero(re) ? ie = !1 : ie = ae >= PI$4 == !!te;
    var se = C + U * mathCos(Z), oe = G + K * mathSin(Z);
    this._start && this._add("M", se, oe);
    var le = Math.round(W * degree);
    if (ne) {
      var ue = 1 / this._p, ce = (te ? 1 : -1) * (PI2$1 - ue);
      this._add("A", U, K, le, 1, +te, C + U * mathCos(Z + ce), G + K * mathSin(Z + ce)), ue > 0.01 && this._add("A", U, K, le, 0, +te, se, oe);
    } else {
      var de = C + U * mathCos(X), ge = G + K * mathSin(X);
      this._add("A", U, K, le, +ie, +te, de, ge);
    }
  }, H.prototype.rect = function(C, G, U, K) {
    this._add("M", C, G), this._add("l", U, 0), this._add("l", 0, K), this._add("l", -U, 0), this._add("Z");
  }, H.prototype.closePath = function() {
    this._d.length > 0 && this._add("Z");
  }, H.prototype._add = function(C, G, U, K, W, Z, X, Q, ee) {
    for (var te = [], re = this._p, ne = 1; ne < arguments.length; ne++) {
      var ae = arguments[ne];
      if (isNaN(ae)) {
        this._invalid = !0;
        return;
      }
      te.push(Math.round(ae * re) / re);
    }
    this._d.push(C + te.join(" ")), this._start = C === "Z";
  }, H.prototype.generateStr = function() {
    this._str = this._invalid ? "" : this._d.join(""), this._d = [];
  }, H.prototype.getStr = function() {
    return this._str;
  }, H;
}();
const SVGPathRebuilder$1 = SVGPathRebuilder;
var NONE = "none", mathRound = Math.round;
function pathHasFill(H) {
  var C = H.fill;
  return C != null && C !== NONE;
}
function pathHasStroke(H) {
  var C = H.stroke;
  return C != null && C !== NONE;
}
var strokeProps = ["lineCap", "miterLimit", "lineJoin"], svgStrokeProps = map$1(strokeProps, function(H) {
  return "stroke-" + H.toLowerCase();
});
function mapStyleToAttrs(H, C, G, U) {
  var K = C.opacity == null ? 1 : C.opacity;
  if (G instanceof ZRImage$1) {
    H("opacity", K);
    return;
  }
  if (pathHasFill(C)) {
    var W = normalizeColor(C.fill);
    H("fill", W.color);
    var Z = C.fillOpacity != null ? C.fillOpacity * W.opacity * K : W.opacity * K;
    (U || Z < 1) && H("fill-opacity", Z);
  } else
    H("fill", NONE);
  if (pathHasStroke(C)) {
    var X = normalizeColor(C.stroke);
    H("stroke", X.color);
    var Q = C.strokeNoScale ? G.getLineScale() : 1, ee = Q ? (C.lineWidth || 0) / Q : 0, te = C.strokeOpacity != null ? C.strokeOpacity * X.opacity * K : X.opacity * K, re = C.strokeFirst;
    if ((U || ee !== 1) && H("stroke-width", ee), (U || re) && H("paint-order", re ? "stroke" : "fill"), (U || te < 1) && H("stroke-opacity", te), C.lineDash) {
      var ne = getLineDash(G), ae = ne[0], ie = ne[1];
      ae && (ie = mathRound(ie || 0), H("stroke-dasharray", ae.join(",")), (ie || U) && H("stroke-dashoffset", ie));
    } else
      U && H("stroke-dasharray", NONE);
    for (var se = 0; se < strokeProps.length; se++) {
      var oe = strokeProps[se];
      if (U || C[oe] !== DEFAULT_PATH_STYLE[oe]) {
        var le = C[oe] || DEFAULT_PATH_STYLE[oe];
        le && H(svgStrokeProps[se], le);
      }
    }
  } else
    U && H("stroke", NONE);
}
var SVGNS = "http://www.w3.org/2000/svg", XLINKNS = "http://www.w3.org/1999/xlink", XMLNS = "http://www.w3.org/2000/xmlns/", XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
function createElement(H) {
  return document.createElementNS(SVGNS, H);
}
function createVNode(H, C, G, U, K) {
  return {
    tag: H,
    attrs: G || {},
    children: U,
    text: K,
    key: C
  };
}
function createElementOpen(H, C) {
  var G = [];
  if (C)
    for (var U in C) {
      var K = C[U], W = U;
      K !== !1 && (K !== !0 && K != null && (W += '="' + K + '"'), G.push(W));
    }
  return "<" + H + " " + G.join(" ") + ">";
}
function createElementClose(H) {
  return "</" + H + ">";
}
function vNodeToString(H, C) {
  C = C || {};
  var G = C.newline ? `
` : "";
  function U(K) {
    var W = K.children, Z = K.tag, X = K.attrs;
    return createElementOpen(Z, X) + encodeHTML(K.text) + (W ? "" + G + map$1(W, function(Q) {
      return U(Q);
    }).join(G) + G : "") + createElementClose(Z);
  }
  return U(H);
}
function getCssString(H, C, G) {
  G = G || {};
  var U = G.newline ? `
` : "", K = " {" + U, W = U + "}", Z = map$1(keys(H), function(Q) {
    return Q + K + map$1(keys(H[Q]), function(ee) {
      return ee + ":" + H[Q][ee] + ";";
    }).join(U) + W;
  }).join(U), X = map$1(keys(C), function(Q) {
    return "@keyframes " + Q + K + map$1(keys(C[Q]), function(ee) {
      return ee + K + map$1(keys(C[Q][ee]), function(te) {
        var re = C[Q][ee][te];
        return te === "d" && (re = 'path("' + re + '")'), te + ":" + re + ";";
      }).join(U) + W;
    }).join(U) + W;
  }).join(U);
  return !Z && !X ? "" : ["<![CDATA[", Z, X, "]]>"].join(U);
}
function createBrushScope(H) {
  return {
    zrId: H,
    shadowCache: {},
    patternCache: {},
    gradientCache: {},
    clipPathCache: {},
    defs: {},
    cssNodes: {},
    cssAnims: {},
    cssClassIdx: 0,
    cssAnimIdx: 0,
    shadowIdx: 0,
    gradientIdx: 0,
    patternIdx: 0,
    clipPathIdx: 0
  };
}
function createSVGVNode(H, C, G, U) {
  return createVNode("svg", "root", {
    width: H,
    height: C,
    xmlns: SVGNS,
    "xmlns:xlink": XLINKNS,
    version: "1.1",
    baseProfile: "full",
    viewBox: U ? "0 0 " + H + " " + C : !1
  }, G);
}
var EASING_MAP = {
  cubicIn: "0.32,0,0.67,0",
  cubicOut: "0.33,1,0.68,1",
  cubicInOut: "0.65,0,0.35,1",
  quadraticIn: "0.11,0,0.5,0",
  quadraticOut: "0.5,1,0.89,1",
  quadraticInOut: "0.45,0,0.55,1",
  quarticIn: "0.5,0,0.75,0",
  quarticOut: "0.25,1,0.5,1",
  quarticInOut: "0.76,0,0.24,1",
  quinticIn: "0.64,0,0.78,0",
  quinticOut: "0.22,1,0.36,1",
  quinticInOut: "0.83,0,0.17,1",
  sinusoidalIn: "0.12,0,0.39,0",
  sinusoidalOut: "0.61,1,0.88,1",
  sinusoidalInOut: "0.37,0,0.63,1",
  exponentialIn: "0.7,0,0.84,0",
  exponentialOut: "0.16,1,0.3,1",
  exponentialInOut: "0.87,0,0.13,1",
  circularIn: "0.55,0,1,0.45",
  circularOut: "0,0.55,0.45,1",
  circularInOut: "0.85,0,0.15,1"
}, transformOriginKey = "transform-origin";
function buildPathString(H, C, G) {
  var U = extend({}, H.shape);
  extend(U, C), H.buildPath(G, U);
  var K = new SVGPathRebuilder$1();
  return K.reset(getPathPrecision(H)), G.rebuildPath(K, 1), K.generateStr(), K.getStr();
}
function setTransformOrigin(H, C) {
  var G = C.originX, U = C.originY;
  (G || U) && (H[transformOriginKey] = G + "px " + U + "px");
}
var ANIMATE_STYLE_MAP = {
  fill: "fill",
  opacity: "opacity",
  lineWidth: "stroke-width",
  lineDashOffset: "stroke-dashoffset"
};
function addAnimation(H, C) {
  var G = C.zrId + "-ani-" + C.cssAnimIdx++;
  return C.cssAnims[G] = H, G;
}
function createCompoundPathCSSAnimation(H, C, G) {
  var U = H.shape.paths, K = {}, W, Z;
  if (each$f(U, function(Q) {
    var ee = createBrushScope(G.zrId);
    ee.animation = !0, createCSSAnimation(Q, {}, ee, !0);
    var te = ee.cssAnims, re = ee.cssNodes, ne = keys(te), ae = ne.length;
    if (ae) {
      Z = ne[ae - 1];
      var ie = te[Z];
      for (var se in ie) {
        var oe = ie[se];
        K[se] = K[se] || { d: "" }, K[se].d += oe.d || "";
      }
      for (var le in re) {
        var ue = re[le].animation;
        ue.indexOf(Z) >= 0 && (W = ue);
      }
    }
  }), !!W) {
    C.d = !1;
    var X = addAnimation(K, G);
    return W.replace(Z, X);
  }
}
function getEasingFunc(H) {
  return isString(H) ? EASING_MAP[H] ? "cubic-bezier(" + EASING_MAP[H] + ")" : createCubicEasingFunc(H) ? H : "" : "";
}
function createCSSAnimation(H, C, G, U) {
  var K = H.animators, W = K.length, Z = [];
  if (H instanceof CompoundPath$1) {
    var X = createCompoundPathCSSAnimation(H, C, G);
    if (X)
      Z.push(X);
    else if (!W)
      return;
  } else if (!W)
    return;
  for (var Q = {}, ee = 0; ee < W; ee++) {
    var te = K[ee], re = [te.getMaxTime() / 1e3 + "s"], ne = getEasingFunc(te.getClip().easing), ae = te.getDelay();
    ne ? re.push(ne) : re.push("linear"), ae && re.push(ae / 1e3 + "s"), te.getLoop() && re.push("infinite");
    var ie = re.join(" ");
    Q[ie] = Q[ie] || [ie, []], Q[ie][1].push(te);
  }
  function se(ue) {
    var ce = ue[1], de = ce.length, ge = {}, fe = {}, ve = {}, pe = "animation-timing-function";
    function he(ze, He, We) {
      for (var Re = ze.getTracks(), Le = ze.getMaxTime(), De = 0; De < Re.length; De++) {
        var Ue = Re[De];
        if (Ue.needsAnimate()) {
          var st = Ue.keyframes, ot = Ue.propName;
          if (We && (ot = We(ot)), ot)
            for (var ct = 0; ct < st.length; ct++) {
              var vt = st[ct], ut = Math.round(vt.time / Le * 100) + "%", at = getEasingFunc(vt.easing), Ze = vt.rawValue;
              (isString(Ze) || isNumber(Ze)) && (He[ut] = He[ut] || {}, He[ut][ot] = vt.rawValue, at && (He[ut][pe] = at));
            }
        }
      }
    }
    for (var me = 0; me < de; me++) {
      var ye = ce[me], Ce = ye.targetName;
      Ce ? Ce === "shape" && he(ye, fe) : !U && he(ye, ge);
    }
    for (var Ie in ge) {
      var be = {};
      copyTransform(be, H), extend(be, ge[Ie]);
      var Se = getSRTTransformString(be), Ae = ge[Ie][pe];
      ve[Ie] = Se ? {
        transform: Se
      } : {}, setTransformOrigin(ve[Ie], be), Ae && (ve[Ie][pe] = Ae);
    }
    var _e, xe = !0;
    for (var Ie in fe) {
      ve[Ie] = ve[Ie] || {};
      var Te = !_e, Ae = fe[Ie][pe];
      Te && (_e = new PathProxy$1());
      var Pe = _e.len();
      _e.reset(), ve[Ie].d = buildPathString(H, fe[Ie], _e);
      var $e = _e.len();
      if (!Te && Pe !== $e) {
        xe = !1;
        break;
      }
      Ae && (ve[Ie][pe] = Ae);
    }
    if (!xe)
      for (var Ie in ve)
        delete ve[Ie].d;
    if (!U)
      for (var me = 0; me < de; me++) {
        var ye = ce[me], Ce = ye.targetName;
        Ce === "style" && he(ye, ve, function(Re) {
          return ANIMATE_STYLE_MAP[Re];
        });
      }
    for (var Me = keys(ve), Ee = !0, we, me = 1; me < Me.length; me++) {
      var Oe = Me[me - 1], Ne = Me[me];
      if (ve[Oe][transformOriginKey] !== ve[Ne][transformOriginKey]) {
        Ee = !1;
        break;
      }
      we = ve[Oe][transformOriginKey];
    }
    if (Ee && we) {
      for (var Ie in ve)
        ve[Ie][transformOriginKey] && delete ve[Ie][transformOriginKey];
      C[transformOriginKey] = we;
    }
    if (filter(Me, function(ze) {
      return keys(ve[ze]).length > 0;
    }).length) {
      var ke = addAnimation(ve, G);
      return ke + " " + ue[0] + " both";
    }
  }
  for (var oe in Q) {
    var X = se(Q[oe]);
    X && Z.push(X);
  }
  if (Z.length) {
    var le = G.zrId + "-cls-" + G.cssClassIdx++;
    G.cssNodes["." + le] = {
      animation: Z.join(",")
    }, C.class = le;
  }
}
var round$1 = Math.round;
function isImageLike(H) {
  return H && isString(H.src);
}
function isCanvasLike(H) {
  return H && isFunction(H.toDataURL);
}
function setStyleAttrs(H, C, G, U) {
  mapStyleToAttrs(function(K, W) {
    var Z = K === "fill" || K === "stroke";
    Z && isGradient(W) ? setGradient(C, H, K, U) : Z && isPattern(W) ? setPattern(G, H, K, U) : H[K] = W;
  }, C, G, !1), setShadow(G, H, U);
}
function noRotateScale(H) {
  return isAroundZero(H[0] - 1) && isAroundZero(H[1]) && isAroundZero(H[2]) && isAroundZero(H[3] - 1);
}
function noTranslate(H) {
  return isAroundZero(H[4]) && isAroundZero(H[5]);
}
function setTransform(H, C, G) {
  if (C && !(noTranslate(C) && noRotateScale(C))) {
    var U = G ? 10 : 1e4;
    H.transform = noRotateScale(C) ? "translate(" + round$1(C[4] * U) / U + " " + round$1(C[5] * U) / U + ")" : getMatrixStr(C);
  }
}
function convertPolyShape(H, C, G) {
  for (var U = H.points, K = [], W = 0; W < U.length; W++)
    K.push(round$1(U[W][0] * G) / G), K.push(round$1(U[W][1] * G) / G);
  C.points = K.join(" ");
}
function validatePolyShape(H) {
  return !H.smooth;
}
function createAttrsConvert(H) {
  var C = map$1(H, function(G) {
    return typeof G == "string" ? [G, G] : G;
  });
  return function(G, U, K) {
    for (var W = 0; W < C.length; W++) {
      var Z = C[W], X = G[Z[0]];
      X != null && (U[Z[1]] = round$1(X * K) / K);
    }
  };
}
var builtinShapesDef = {
  circle: [createAttrsConvert(["cx", "cy", "r"])],
  polyline: [convertPolyShape, validatePolyShape],
  polygon: [convertPolyShape, validatePolyShape]
};
function hasShapeAnimation(H) {
  for (var C = H.animators, G = 0; G < C.length; G++)
    if (C[G].targetName === "shape")
      return !0;
  return !1;
}
function brushSVGPath(H, C) {
  var G = H.style, U = H.shape, K = builtinShapesDef[H.type], W = {}, Z = C.animation, X = "path", Q = H.style.strokePercent, ee = C.compress && getPathPrecision(H) || 4;
  if (K && !C.willUpdate && !(K[1] && !K[1](U)) && !(Z && hasShapeAnimation(H)) && !(Q < 1)) {
    X = H.type;
    var te = Math.pow(10, ee);
    K[0](U, W, te);
  } else {
    var re = !H.path || H.shapeChanged();
    H.path || H.createPathProxy();
    var ne = H.path;
    re && (ne.beginPath(), H.buildPath(ne, H.shape), H.pathUpdated());
    var ae = ne.getVersion(), ie = H, se = ie.__svgPathBuilder;
    (ie.__svgPathVersion !== ae || !se || Q !== ie.__svgPathStrokePercent) && (se || (se = ie.__svgPathBuilder = new SVGPathRebuilder$1()), se.reset(ee), ne.rebuildPath(se, Q), se.generateStr(), ie.__svgPathVersion = ae, ie.__svgPathStrokePercent = Q), W.d = se.getStr();
  }
  return setTransform(W, H.transform), setStyleAttrs(W, G, H, C), C.animation && createCSSAnimation(H, W, C), createVNode(X, H.id + "", W);
}
function brushSVGImage(H, C) {
  var G = H.style, U = G.image;
  if (U && !isString(U) && (isImageLike(U) ? U = U.src : isCanvasLike(U) && (U = U.toDataURL())), !!U) {
    var K = G.x || 0, W = G.y || 0, Z = G.width, X = G.height, Q = {
      href: U,
      width: Z,
      height: X
    };
    return K && (Q.x = K), W && (Q.y = W), setTransform(Q, H.transform), setStyleAttrs(Q, G, H, C), C.animation && createCSSAnimation(H, Q, C), createVNode("image", H.id + "", Q);
  }
}
function brushSVGTSpan(H, C) {
  var G = H.style, U = G.text;
  if (U != null && (U += ""), !(!U || isNaN(G.x) || isNaN(G.y))) {
    var K = G.font || DEFAULT_FONT, W = G.x || 0, Z = adjustTextY$1(G.y || 0, getLineHeight(K), G.textBaseline), X = TEXT_ALIGN_TO_ANCHOR[G.textAlign] || G.textAlign, Q = {
      "dominant-baseline": "central",
      "text-anchor": X
    };
    if (hasSeparateFont(G)) {
      var ee = "", te = G.fontStyle, re = parseFontSize(G.fontSize);
      if (!parseFloat(re))
        return;
      var ne = G.fontFamily || DEFAULT_FONT_FAMILY, ae = G.fontWeight;
      ee += "font-size:" + re + ";font-family:" + ne + ";", te && te !== "normal" && (ee += "font-style:" + te + ";"), ae && ae !== "normal" && (ee += "font-weight:" + ae + ";"), Q.style = ee;
    } else
      Q.style = "font: " + K;
    return U.match(/\s/) && (Q["xml:space"] = "preserve"), W && (Q.x = W), Z && (Q.y = Z), setTransform(Q, H.transform), setStyleAttrs(Q, G, H, C), C.animation && createCSSAnimation(H, Q, C), createVNode("text", H.id + "", Q, void 0, U);
  }
}
function brush(H, C) {
  if (H instanceof Path$1)
    return brushSVGPath(H, C);
  if (H instanceof ZRImage$1)
    return brushSVGImage(H, C);
  if (H instanceof TSpan$1)
    return brushSVGTSpan(H, C);
}
function setShadow(H, C, G) {
  var U = H.style;
  if (hasShadow(U)) {
    var K = getShadowKey(H), W = G.shadowCache, Z = W[K];
    if (!Z) {
      var X = H.getGlobalScale(), Q = X[0], ee = X[1];
      if (!Q || !ee)
        return;
      var te = U.shadowOffsetX || 0, re = U.shadowOffsetY || 0, ne = U.shadowBlur, ae = normalizeColor(U.shadowColor), ie = ae.opacity, se = ae.color, oe = ne / 2 / Q, le = ne / 2 / ee, ue = oe + " " + le;
      Z = G.zrId + "-s" + G.shadowIdx++, G.defs[Z] = createVNode("filter", Z, {
        id: Z,
        x: "-100%",
        y: "-100%",
        width: "300%",
        height: "300%"
      }, [
        createVNode("feDropShadow", "", {
          dx: te / Q,
          dy: re / ee,
          stdDeviation: ue,
          "flood-color": se,
          "flood-opacity": ie
        })
      ]), W[K] = Z;
    }
    C.filter = getIdURL(Z);
  }
}
function setGradient(H, C, G, U) {
  var K = H[G], W, Z = {
    gradientUnits: K.global ? "userSpaceOnUse" : "objectBoundingBox"
  };
  if (isLinearGradient(K))
    W = "linearGradient", Z.x1 = K.x, Z.y1 = K.y, Z.x2 = K.x2, Z.y2 = K.y2;
  else if (isRadialGradient(K))
    W = "radialGradient", Z.cx = retrieve2(K.x, 0.5), Z.cy = retrieve2(K.y, 0.5), Z.r = retrieve2(K.r, 0.5);
  else {
    process.env.NODE_ENV !== "production" && logError("Illegal gradient type.");
    return;
  }
  for (var X = K.colorStops, Q = [], ee = 0, te = X.length; ee < te; ++ee) {
    var re = round4(X[ee].offset) * 100 + "%", ne = X[ee].color, ae = normalizeColor(ne), ie = ae.color, se = ae.opacity, oe = {
      offset: re
    };
    oe["stop-color"] = ie, se < 1 && (oe["stop-opacity"] = se), Q.push(createVNode("stop", ee + "", oe));
  }
  var le = createVNode(W, "", Z, Q), ue = vNodeToString(le), ce = U.gradientCache, de = ce[ue];
  de || (de = U.zrId + "-g" + U.gradientIdx++, ce[ue] = de, Z.id = de, U.defs[de] = createVNode(W, de, Z, Q)), C[G] = getIdURL(de);
}
function setPattern(H, C, G, U) {
  var K = H.style[G], W = H.getBoundingRect(), Z = {}, X = K.repeat, Q = X === "no-repeat", ee = X === "repeat-x", te = X === "repeat-y", re;
  if (isImagePattern(K)) {
    var ne = K.imageWidth, ae = K.imageHeight, ie = void 0, se = K.image;
    if (isString(se) ? ie = se : isImageLike(se) ? ie = se.src : isCanvasLike(se) && (ie = se.toDataURL()), typeof Image > "u") {
      var oe = "Image width/height must been given explictly in svg-ssr renderer.";
      assert(ne, oe), assert(ae, oe);
    } else if (ne == null || ae == null) {
      var le = function(me, ye) {
        if (me) {
          var Ce = me.elm, Ie = ne || ye.width, be = ae || ye.height;
          me.tag === "pattern" && (ee ? (be = 1, Ie /= W.width) : te && (Ie = 1, be /= W.height)), me.attrs.width = Ie, me.attrs.height = be, Ce && (Ce.setAttribute("width", Ie), Ce.setAttribute("height", be));
        }
      }, ue = createOrUpdateImage(ie, null, H, function(me) {
        Q || le(fe, me), le(re, me);
      });
      ue && ue.width && ue.height && (ne = ne || ue.width, ae = ae || ue.height);
    }
    re = createVNode("image", "img", {
      href: ie,
      width: ne,
      height: ae
    }), Z.width = ne, Z.height = ae;
  } else
    K.svgElement && (re = clone$4(K.svgElement), Z.width = K.svgWidth, Z.height = K.svgHeight);
  if (re) {
    var ce, de;
    Q ? ce = de = 1 : ee ? (de = 1, ce = Z.width / W.width) : te ? (ce = 1, de = Z.height / W.height) : Z.patternUnits = "userSpaceOnUse", ce != null && !isNaN(ce) && (Z.width = ce), de != null && !isNaN(de) && (Z.height = de);
    var ge = getSRTTransformString(K);
    ge && (Z.patternTransform = ge);
    var fe = createVNode("pattern", "", Z, [re]), ve = vNodeToString(fe), pe = U.patternCache, he = pe[ve];
    he || (he = U.zrId + "-p" + U.patternIdx++, pe[ve] = he, Z.id = he, fe = U.defs[he] = createVNode("pattern", he, Z, [re])), C[G] = getIdURL(he);
  }
}
function setClipPath(H, C, G) {
  var U = G.clipPathCache, K = G.defs, W = U[H.id];
  if (!W) {
    W = G.zrId + "-c" + G.clipPathIdx++;
    var Z = {
      id: W
    };
    U[H.id] = W, K[W] = createVNode("clipPath", W, Z, [brushSVGPath(H, G)]);
  }
  C["clip-path"] = getIdURL(W);
}
function createTextNode(H) {
  return document.createTextNode(H);
}
function insertBefore(H, C, G) {
  H.insertBefore(C, G);
}
function removeChild(H, C) {
  H.removeChild(C);
}
function appendChild(H, C) {
  H.appendChild(C);
}
function parentNode(H) {
  return H.parentNode;
}
function nextSibling(H) {
  return H.nextSibling;
}
function setTextContent(H, C) {
  H.textContent = C;
}
var colonChar = 58, xChar = 120, emptyNode = createVNode("", "");
function isUndef(H) {
  return H === void 0;
}
function isDef(H) {
  return H !== void 0;
}
function createKeyToOldIdx(H, C, G) {
  for (var U = {}, K = C; K <= G; ++K) {
    var W = H[K].key;
    W !== void 0 && (process.env.NODE_ENV !== "production" && U[W] != null && console.error("Duplicate key " + W), U[W] = K);
  }
  return U;
}
function sameVnode(H, C) {
  var G = H.key === C.key, U = H.tag === C.tag;
  return U && G;
}
function createElm(H) {
  var C, G = H.children, U = H.tag;
  if (isDef(U)) {
    var K = H.elm = createElement(U);
    if (updateAttrs(emptyNode, H), isArray$1(G))
      for (C = 0; C < G.length; ++C) {
        var W = G[C];
        W != null && appendChild(K, createElm(W));
      }
    else
      isDef(H.text) && !isObject$3(H.text) && appendChild(K, createTextNode(H.text));
  } else
    H.elm = createTextNode(H.text);
  return H.elm;
}
function addVnodes(H, C, G, U, K) {
  for (; U <= K; ++U) {
    var W = G[U];
    W != null && insertBefore(H, createElm(W), C);
  }
}
function removeVnodes(H, C, G, U) {
  for (; G <= U; ++G) {
    var K = C[G];
    if (K != null)
      if (isDef(K.tag)) {
        var W = parentNode(K.elm);
        removeChild(W, K.elm);
      } else
        removeChild(H, K.elm);
  }
}
function updateAttrs(H, C) {
  var G, U = C.elm, K = H && H.attrs || {}, W = C.attrs || {};
  if (K !== W) {
    for (G in W) {
      var Z = W[G], X = K[G];
      X !== Z && (Z === !0 ? U.setAttribute(G, "") : Z === !1 ? U.removeAttribute(G) : G.charCodeAt(0) !== xChar ? U.setAttribute(G, Z) : G === "xmlns:xlink" || G === "xmlns" ? U.setAttributeNS(XMLNS, G, Z) : G.charCodeAt(3) === colonChar ? U.setAttributeNS(XML_NAMESPACE, G, Z) : G.charCodeAt(5) === colonChar ? U.setAttributeNS(XLINKNS, G, Z) : U.setAttribute(G, Z));
    }
    for (G in K)
      G in W || U.removeAttribute(G);
  }
}
function updateChildren(H, C, G) {
  for (var U = 0, K = 0, W = C.length - 1, Z = C[0], X = C[W], Q = G.length - 1, ee = G[0], te = G[Q], re, ne, ae, ie; U <= W && K <= Q; )
    Z == null ? Z = C[++U] : X == null ? X = C[--W] : ee == null ? ee = G[++K] : te == null ? te = G[--Q] : sameVnode(Z, ee) ? (patchVnode(Z, ee), Z = C[++U], ee = G[++K]) : sameVnode(X, te) ? (patchVnode(X, te), X = C[--W], te = G[--Q]) : sameVnode(Z, te) ? (patchVnode(Z, te), insertBefore(H, Z.elm, nextSibling(X.elm)), Z = C[++U], te = G[--Q]) : sameVnode(X, ee) ? (patchVnode(X, ee), insertBefore(H, X.elm, Z.elm), X = C[--W], ee = G[++K]) : (isUndef(re) && (re = createKeyToOldIdx(C, U, W)), ne = re[ee.key], isUndef(ne) ? insertBefore(H, createElm(ee), Z.elm) : (ae = C[ne], ae.tag !== ee.tag ? insertBefore(H, createElm(ee), Z.elm) : (patchVnode(ae, ee), C[ne] = void 0, insertBefore(H, ae.elm, Z.elm))), ee = G[++K]);
  (U <= W || K <= Q) && (U > W ? (ie = G[Q + 1] == null ? null : G[Q + 1].elm, addVnodes(H, ie, G, K, Q)) : removeVnodes(H, C, U, W));
}
function patchVnode(H, C) {
  var G = C.elm = H.elm, U = H.children, K = C.children;
  H !== C && (updateAttrs(H, C), isUndef(C.text) ? isDef(U) && isDef(K) ? U !== K && updateChildren(G, U, K) : isDef(K) ? (isDef(H.text) && setTextContent(G, ""), addVnodes(G, null, K, 0, K.length - 1)) : isDef(U) ? removeVnodes(G, U, 0, U.length - 1) : isDef(H.text) && setTextContent(G, "") : H.text !== C.text && (isDef(U) && removeVnodes(G, U, 0, U.length - 1), setTextContent(G, C.text)));
}
function patch(H, C) {
  if (sameVnode(H, C))
    patchVnode(H, C);
  else {
    var G = H.elm, U = parentNode(G);
    createElm(C), U !== null && (insertBefore(U, C.elm, nextSibling(G)), removeVnodes(U, [H], 0, 0));
  }
  return C;
}
var svgId = 0, SVGPainter = function() {
  function H(C, G, U) {
    if (this.type = "svg", this.refreshHover = createMethodNotSupport("refreshHover"), this.configLayer = createMethodNotSupport("configLayer"), this.storage = G, this._opts = U = extend({}, U), this.root = C, this._id = "zr" + svgId++, this._oldVNode = createSVGVNode(U.width, U.height), C && !U.ssr) {
      var K = this._viewport = document.createElement("div");
      K.style.cssText = "position:relative;overflow:hidden";
      var W = this._svgDom = this._oldVNode.elm = createElement("svg");
      updateAttrs(null, this._oldVNode), K.appendChild(W), C.appendChild(K);
    }
    this.resize(U.width, U.height);
  }
  return H.prototype.getType = function() {
    return this.type;
  }, H.prototype.getViewportRoot = function() {
    return this._viewport;
  }, H.prototype.getViewportRootOffset = function() {
    var C = this.getViewportRoot();
    if (C)
      return {
        offsetLeft: C.offsetLeft || 0,
        offsetTop: C.offsetTop || 0
      };
  }, H.prototype.getSvgDom = function() {
    return this._svgDom;
  }, H.prototype.refresh = function() {
    if (this.root) {
      var C = this.renderToVNode({
        willUpdate: !0
      });
      C.attrs.style = "position:absolute;left:0;top:0;user-select:none", patch(this._oldVNode, C), this._oldVNode = C;
    }
  }, H.prototype.renderOneToVNode = function(C) {
    return brush(C, createBrushScope(this._id));
  }, H.prototype.renderToVNode = function(C) {
    C = C || {};
    var G = this.storage.getDisplayList(!0), U = this._width, K = this._height, W = createBrushScope(this._id);
    W.animation = C.animation, W.willUpdate = C.willUpdate, W.compress = C.compress;
    var Z = [], X = this._bgVNode = createBackgroundVNode(U, K, this._backgroundColor, W);
    X && Z.push(X);
    var Q = C.compress ? null : this._mainVNode = createVNode("g", "main", {}, []);
    this._paintList(G, W, Q ? Q.children : Z), Q && Z.push(Q);
    var ee = map$1(keys(W.defs), function(ne) {
      return W.defs[ne];
    });
    if (ee.length && Z.push(createVNode("defs", "defs", {}, ee)), C.animation) {
      var te = getCssString(W.cssNodes, W.cssAnims, { newline: !0 });
      if (te) {
        var re = createVNode("style", "stl", {}, [], te);
        Z.push(re);
      }
    }
    return createSVGVNode(U, K, Z, C.useViewBox);
  }, H.prototype.renderToString = function(C) {
    return C = C || {}, vNodeToString(this.renderToVNode({
      animation: retrieve2(C.cssAnimation, !0),
      willUpdate: !1,
      compress: !0,
      useViewBox: retrieve2(C.useViewBox, !0)
    }), { newline: !0 });
  }, H.prototype.setBackgroundColor = function(C) {
    this._backgroundColor = C;
  }, H.prototype.getSvgRoot = function() {
    return this._mainVNode && this._mainVNode.elm;
  }, H.prototype._paintList = function(C, G, U) {
    for (var K = C.length, W = [], Z = 0, X, Q, ee = 0, te = 0; te < K; te++) {
      var re = C[te];
      if (!re.invisible) {
        var ne = re.__clipPaths, ae = ne && ne.length || 0, ie = Q && Q.length || 0, se = void 0;
        for (se = Math.max(ae - 1, ie - 1); se >= 0 && !(ne && Q && ne[se] === Q[se]); se--)
          ;
        for (var oe = ie - 1; oe > se; oe--)
          Z--, X = W[Z - 1];
        for (var le = se + 1; le < ae; le++) {
          var ue = {};
          setClipPath(ne[le], ue, G);
          var ce = createVNode("g", "clip-g-" + ee++, ue, []);
          (X ? X.children : U).push(ce), W[Z++] = ce, X = ce;
        }
        Q = ne;
        var de = brush(re, G);
        de && (X ? X.children : U).push(de);
      }
    }
  }, H.prototype.resize = function(C, G) {
    var U = this._opts, K = this.root, W = this._viewport;
    if (C != null && (U.width = C), G != null && (U.height = G), K && W && (W.style.display = "none", C = getSize$1(K, 0, U), G = getSize$1(K, 1, U), W.style.display = ""), this._width !== C || this._height !== G) {
      if (this._width = C, this._height = G, W) {
        var Z = W.style;
        Z.width = C + "px", Z.height = G + "px";
      }
      if (isPattern(this._backgroundColor))
        this.refresh();
      else {
        var X = this._svgDom;
        X && (X.setAttribute("width", C), X.setAttribute("height", G));
        var Q = this._bgVNode && this._bgVNode.elm;
        Q && (Q.setAttribute("width", C), Q.setAttribute("height", G));
      }
    }
  }, H.prototype.getWidth = function() {
    return this._width;
  }, H.prototype.getHeight = function() {
    return this._height;
  }, H.prototype.dispose = function() {
    this.root && (this.root.innerHTML = ""), this._svgDom = this._viewport = this.storage = this._oldVNode = this._bgVNode = this._mainVNode = null;
  }, H.prototype.clear = function() {
    this._svgDom && (this._svgDom.innerHTML = null), this._oldVNode = null;
  }, H.prototype.toDataURL = function(C) {
    var G = this.renderToString(), U = "data:image/svg+xml;";
    return C ? (G = encodeBase64(G), G && U + "base64," + G) : U + "charset=UTF-8," + encodeURIComponent(G);
  }, H;
}();
function createMethodNotSupport(H) {
  return function() {
    process.env.NODE_ENV !== "production" && logError('In SVG mode painter not support method "' + H + '"');
  };
}
function createBackgroundVNode(H, C, G, U) {
  var K;
  if (G && G !== "none")
    if (K = createVNode("rect", "bg", {
      width: H,
      height: C,
      x: "0",
      y: "0",
      id: "0"
    }), isGradient(G))
      setGradient({ fill: G }, K.attrs, "fill", U);
    else if (isPattern(G))
      setPattern({
        style: {
          fill: G
        },
        dirty: noop,
        getBoundingRect: function() {
          return { width: H, height: C };
        }
      }, K.attrs, "fill", U);
    else {
      var W = normalizeColor(G), Z = W.color, X = W.opacity;
      K.attrs.fill = Z, X < 1 && (K.attrs["fill-opacity"] = X);
    }
  return K;
}
const SVGPainter$1 = SVGPainter;
function install$S(H) {
  H.registerPainter("svg", SVGPainter$1);
}
function createDom(H, C, G) {
  var U = platformApi.createCanvas(), K = C.getWidth(), W = C.getHeight(), Z = U.style;
  return Z && (Z.position = "absolute", Z.left = "0", Z.top = "0", Z.width = K + "px", Z.height = W + "px", U.setAttribute("data-zr-dom-id", H)), U.width = K * G, U.height = W * G, U;
}
var Layer = function(H) {
  __extends(C, H);
  function C(G, U, K) {
    var W = H.call(this) || this;
    W.motionBlur = !1, W.lastFrameAlpha = 0.7, W.dpr = 1, W.virtual = !1, W.config = {}, W.incremental = !1, W.zlevel = 0, W.maxRepaintRectCount = 5, W.__dirty = !0, W.__firstTimePaint = !0, W.__used = !1, W.__drawIndex = 0, W.__startIndex = 0, W.__endIndex = 0, W.__prevStartIndex = null, W.__prevEndIndex = null;
    var Z;
    K = K || devicePixelRatio, typeof G == "string" ? Z = createDom(G, U, K) : isObject$3(G) && (Z = G, G = Z.id), W.id = G, W.dom = Z;
    var X = Z.style;
    return X && (disableUserSelect(Z), Z.onselectstart = function() {
      return !1;
    }, X.padding = "0", X.margin = "0", X.borderWidth = "0"), W.painter = U, W.dpr = K, W;
  }
  return C.prototype.getElementCount = function() {
    return this.__endIndex - this.__startIndex;
  }, C.prototype.afterBrush = function() {
    this.__prevStartIndex = this.__startIndex, this.__prevEndIndex = this.__endIndex;
  }, C.prototype.initContext = function() {
    this.ctx = this.dom.getContext("2d"), this.ctx.dpr = this.dpr;
  }, C.prototype.setUnpainted = function() {
    this.__firstTimePaint = !0;
  }, C.prototype.createBackBuffer = function() {
    var G = this.dpr;
    this.domBack = createDom("back-" + this.id, this.painter, G), this.ctxBack = this.domBack.getContext("2d"), G !== 1 && this.ctxBack.scale(G, G);
  }, C.prototype.createRepaintRects = function(G, U, K, W) {
    if (this.__firstTimePaint)
      return this.__firstTimePaint = !1, null;
    var Z = [], X = this.maxRepaintRectCount, Q = !1, ee = new BoundingRect$1(0, 0, 0, 0);
    function te(ue) {
      if (!(!ue.isFinite() || ue.isZero()))
        if (Z.length === 0) {
          var ce = new BoundingRect$1(0, 0, 0, 0);
          ce.copy(ue), Z.push(ce);
        } else {
          for (var de = !1, ge = 1 / 0, fe = 0, ve = 0; ve < Z.length; ++ve) {
            var pe = Z[ve];
            if (pe.intersect(ue)) {
              var he = new BoundingRect$1(0, 0, 0, 0);
              he.copy(pe), he.union(ue), Z[ve] = he, de = !0;
              break;
            } else if (Q) {
              ee.copy(ue), ee.union(pe);
              var me = ue.width * ue.height, ye = pe.width * pe.height, Ce = ee.width * ee.height, Ie = Ce - me - ye;
              Ie < ge && (ge = Ie, fe = ve);
            }
          }
          if (Q && (Z[fe].union(ue), de = !0), !de) {
            var ce = new BoundingRect$1(0, 0, 0, 0);
            ce.copy(ue), Z.push(ce);
          }
          Q || (Q = Z.length >= X);
        }
    }
    for (var re = this.__startIndex; re < this.__endIndex; ++re) {
      var ne = G[re];
      if (ne) {
        var ae = ne.shouldBePainted(K, W, !0, !0), ie = ne.__isRendered && (ne.__dirty & REDRAW_BIT || !ae) ? ne.getPrevPaintRect() : null;
        ie && te(ie);
        var se = ae && (ne.__dirty & REDRAW_BIT || !ne.__isRendered) ? ne.getPaintRect() : null;
        se && te(se);
      }
    }
    for (var re = this.__prevStartIndex; re < this.__prevEndIndex; ++re) {
      var ne = U[re], ae = ne.shouldBePainted(K, W, !0, !0);
      if (ne && (!ae || !ne.__zr) && ne.__isRendered) {
        var ie = ne.getPrevPaintRect();
        ie && te(ie);
      }
    }
    var oe;
    do {
      oe = !1;
      for (var re = 0; re < Z.length; ) {
        if (Z[re].isZero()) {
          Z.splice(re, 1);
          continue;
        }
        for (var le = re + 1; le < Z.length; )
          Z[re].intersect(Z[le]) ? (oe = !0, Z[re].union(Z[le]), Z.splice(le, 1)) : le++;
        re++;
      }
    } while (oe);
    return this._paintRects = Z, Z;
  }, C.prototype.debugGetPaintRects = function() {
    return (this._paintRects || []).slice();
  }, C.prototype.resize = function(G, U) {
    var K = this.dpr, W = this.dom, Z = W.style, X = this.domBack;
    Z && (Z.width = G + "px", Z.height = U + "px"), W.width = G * K, W.height = U * K, X && (X.width = G * K, X.height = U * K, K !== 1 && this.ctxBack.scale(K, K));
  }, C.prototype.clear = function(G, U, K) {
    var W = this.dom, Z = this.ctx, X = W.width, Q = W.height;
    U = U || this.clearColor;
    var ee = this.motionBlur && !G, te = this.lastFrameAlpha, re = this.dpr, ne = this;
    ee && (this.domBack || this.createBackBuffer(), this.ctxBack.globalCompositeOperation = "copy", this.ctxBack.drawImage(W, 0, 0, X / re, Q / re));
    var ae = this.domBack;
    function ie(se, oe, le, ue) {
      if (Z.clearRect(se, oe, le, ue), U && U !== "transparent") {
        var ce = void 0;
        if (isGradientObject(U)) {
          var de = U.global || U.__width === le && U.__height === ue;
          ce = de && U.__canvasGradient || getCanvasGradient(Z, U, {
            x: 0,
            y: 0,
            width: le,
            height: ue
          }), U.__canvasGradient = ce, U.__width = le, U.__height = ue;
        } else
          isImagePatternObject(U) && (U.scaleX = U.scaleX || re, U.scaleY = U.scaleY || re, ce = createCanvasPattern(Z, U, {
            dirty: function() {
              ne.setUnpainted(), ne.__painter.refresh();
            }
          }));
        Z.save(), Z.fillStyle = ce || U, Z.fillRect(se, oe, le, ue), Z.restore();
      }
      ee && (Z.save(), Z.globalAlpha = te, Z.drawImage(ae, se, oe, le, ue), Z.restore());
    }
    !K || ee ? ie(0, 0, X, Q) : K.length && each$f(K, function(se) {
      ie(se.x * re, se.y * re, se.width * re, se.height * re);
    });
  }, C;
}(Eventful$1);
const Layer$1 = Layer;
var HOVER_LAYER_ZLEVEL = 1e5, CANVAS_ZLEVEL = 314159, EL_AFTER_INCREMENTAL_INC = 0.01, INCREMENTAL_INC = 1e-3;
function isLayerValid(H) {
  return H ? H.__builtin__ ? !0 : !(typeof H.resize != "function" || typeof H.refresh != "function") : !1;
}
function createRoot(H, C) {
  var G = document.createElement("div");
  return G.style.cssText = [
    "position:relative",
    "width:" + H + "px",
    "height:" + C + "px",
    "padding:0",
    "margin:0",
    "border-width:0"
  ].join(";") + ";", G;
}
var CanvasPainter = function() {
  function H(C, G, U, K) {
    this.type = "canvas", this._zlevelList = [], this._prevDisplayList = [], this._layers = {}, this._layerConfig = {}, this._needsManuallyCompositing = !1, this.type = "canvas";
    var W = !C.nodeName || C.nodeName.toUpperCase() === "CANVAS";
    this._opts = U = extend({}, U || {}), this.dpr = U.devicePixelRatio || devicePixelRatio, this._singleCanvas = W, this.root = C;
    var Z = C.style;
    Z && (disableUserSelect(C), C.innerHTML = ""), this.storage = G;
    var X = this._zlevelList;
    this._prevDisplayList = [];
    var Q = this._layers;
    if (W) {
      var te = C, re = te.width, ne = te.height;
      U.width != null && (re = U.width), U.height != null && (ne = U.height), this.dpr = U.devicePixelRatio || 1, te.width = re * this.dpr, te.height = ne * this.dpr, this._width = re, this._height = ne;
      var ae = new Layer$1(te, this, this.dpr);
      ae.__builtin__ = !0, ae.initContext(), Q[CANVAS_ZLEVEL] = ae, ae.zlevel = CANVAS_ZLEVEL, X.push(CANVAS_ZLEVEL), this._domRoot = C;
    } else {
      this._width = getSize$1(C, 0, U), this._height = getSize$1(C, 1, U);
      var ee = this._domRoot = createRoot(this._width, this._height);
      C.appendChild(ee);
    }
  }
  return H.prototype.getType = function() {
    return "canvas";
  }, H.prototype.isSingleCanvas = function() {
    return this._singleCanvas;
  }, H.prototype.getViewportRoot = function() {
    return this._domRoot;
  }, H.prototype.getViewportRootOffset = function() {
    var C = this.getViewportRoot();
    if (C)
      return {
        offsetLeft: C.offsetLeft || 0,
        offsetTop: C.offsetTop || 0
      };
  }, H.prototype.refresh = function(C) {
    var G = this.storage.getDisplayList(!0), U = this._prevDisplayList, K = this._zlevelList;
    this._redrawId = Math.random(), this._paintList(G, U, C, this._redrawId);
    for (var W = 0; W < K.length; W++) {
      var Z = K[W], X = this._layers[Z];
      if (!X.__builtin__ && X.refresh) {
        var Q = W === 0 ? this._backgroundColor : null;
        X.refresh(Q);
      }
    }
    return this._opts.useDirtyRect && (this._prevDisplayList = G.slice()), this;
  }, H.prototype.refreshHover = function() {
    this._paintHoverList(this.storage.getDisplayList(!1));
  }, H.prototype._paintHoverList = function(C) {
    var G = C.length, U = this._hoverlayer;
    if (U && U.clear(), !!G) {
      for (var K = {
        inHover: !0,
        viewWidth: this._width,
        viewHeight: this._height
      }, W, Z = 0; Z < G; Z++) {
        var X = C[Z];
        X.__inHover && (U || (U = this._hoverlayer = this.getLayer(HOVER_LAYER_ZLEVEL)), W || (W = U.ctx, W.save()), brush$1(W, X, K, Z === G - 1));
      }
      W && W.restore();
    }
  }, H.prototype.getHoverLayer = function() {
    return this.getLayer(HOVER_LAYER_ZLEVEL);
  }, H.prototype.paintOne = function(C, G) {
    brushSingle(C, G);
  }, H.prototype._paintList = function(C, G, U, K) {
    if (this._redrawId === K) {
      U = U || !1, this._updateLayerStatus(C);
      var W = this._doPaintList(C, G, U), Z = W.finished, X = W.needsRefreshHover;
      if (this._needsManuallyCompositing && this._compositeManually(), X && this._paintHoverList(C), Z)
        this.eachLayer(function(ee) {
          ee.afterBrush && ee.afterBrush();
        });
      else {
        var Q = this;
        requestAnimationFrame$2(function() {
          Q._paintList(C, G, U, K);
        });
      }
    }
  }, H.prototype._compositeManually = function() {
    var C = this.getLayer(CANVAS_ZLEVEL).ctx, G = this._domRoot.width, U = this._domRoot.height;
    C.clearRect(0, 0, G, U), this.eachBuiltinLayer(function(K) {
      K.virtual && C.drawImage(K.dom, 0, 0, G, U);
    });
  }, H.prototype._doPaintList = function(C, G, U) {
    for (var K = this, W = [], Z = this._opts.useDirtyRect, X = 0; X < this._zlevelList.length; X++) {
      var Q = this._zlevelList[X], ee = this._layers[Q];
      ee.__builtin__ && ee !== this._hoverlayer && (ee.__dirty || U) && W.push(ee);
    }
    for (var te = !0, re = !1, ne = function(se) {
      var oe = W[se], le = oe.ctx, ue = Z && oe.createRepaintRects(C, G, ae._width, ae._height), ce = U ? oe.__startIndex : oe.__drawIndex, de = !U && oe.incremental && Date.now, ge = de && Date.now(), fe = oe.zlevel === ae._zlevelList[0] ? ae._backgroundColor : null;
      if (oe.__startIndex === oe.__endIndex)
        oe.clear(!1, fe, ue);
      else if (ce === oe.__startIndex) {
        var ve = C[ce];
        (!ve.incremental || !ve.notClear || U) && oe.clear(!1, fe, ue);
      }
      ce === -1 && (console.error("For some unknown reason. drawIndex is -1"), ce = oe.__startIndex);
      var pe, he = function(Ie) {
        var be = {
          inHover: !1,
          allClipped: !1,
          prevEl: null,
          viewWidth: K._width,
          viewHeight: K._height
        };
        for (pe = ce; pe < oe.__endIndex; pe++) {
          var Se = C[pe];
          if (Se.__inHover && (re = !0), K._doPaintEl(Se, oe, Z, Ie, be, pe === oe.__endIndex - 1), de) {
            var Ae = Date.now() - ge;
            if (Ae > 15)
              break;
          }
        }
        be.prevElClipPaths && le.restore();
      };
      if (ue)
        if (ue.length === 0)
          pe = oe.__endIndex;
        else
          for (var me = ae.dpr, ye = 0; ye < ue.length; ++ye) {
            var Ce = ue[ye];
            le.save(), le.beginPath(), le.rect(Ce.x * me, Ce.y * me, Ce.width * me, Ce.height * me), le.clip(), he(Ce), le.restore();
          }
      else
        le.save(), he(), le.restore();
      oe.__drawIndex = pe, oe.__drawIndex < oe.__endIndex && (te = !1);
    }, ae = this, ie = 0; ie < W.length; ie++)
      ne(ie);
    return env$1.wxa && each$f(this._layers, function(se) {
      se && se.ctx && se.ctx.draw && se.ctx.draw();
    }), {
      finished: te,
      needsRefreshHover: re
    };
  }, H.prototype._doPaintEl = function(C, G, U, K, W, Z) {
    var X = G.ctx;
    if (U) {
      var Q = C.getPaintRect();
      (!K || Q && Q.intersect(K)) && (brush$1(X, C, W, Z), C.setPrevPaintRect(Q));
    } else
      brush$1(X, C, W, Z);
  }, H.prototype.getLayer = function(C, G) {
    this._singleCanvas && !this._needsManuallyCompositing && (C = CANVAS_ZLEVEL);
    var U = this._layers[C];
    return U || (U = new Layer$1("zr_" + C, this, this.dpr), U.zlevel = C, U.__builtin__ = !0, this._layerConfig[C] ? merge(U, this._layerConfig[C], !0) : this._layerConfig[C - EL_AFTER_INCREMENTAL_INC] && merge(U, this._layerConfig[C - EL_AFTER_INCREMENTAL_INC], !0), G && (U.virtual = G), this.insertLayer(C, U), U.initContext()), U;
  }, H.prototype.insertLayer = function(C, G) {
    var U = this._layers, K = this._zlevelList, W = K.length, Z = this._domRoot, X = null, Q = -1;
    if (U[C]) {
      process.env.NODE_ENV !== "production" && logError("ZLevel " + C + " has been used already");
      return;
    }
    if (!isLayerValid(G)) {
      process.env.NODE_ENV !== "production" && logError("Layer of zlevel " + C + " is not valid");
      return;
    }
    if (W > 0 && C > K[0]) {
      for (Q = 0; Q < W - 1 && !(K[Q] < C && K[Q + 1] > C); Q++)
        ;
      X = U[K[Q]];
    }
    if (K.splice(Q + 1, 0, C), U[C] = G, !G.virtual)
      if (X) {
        var ee = X.dom;
        ee.nextSibling ? Z.insertBefore(G.dom, ee.nextSibling) : Z.appendChild(G.dom);
      } else
        Z.firstChild ? Z.insertBefore(G.dom, Z.firstChild) : Z.appendChild(G.dom);
    G.__painter = this;
  }, H.prototype.eachLayer = function(C, G) {
    for (var U = this._zlevelList, K = 0; K < U.length; K++) {
      var W = U[K];
      C.call(G, this._layers[W], W);
    }
  }, H.prototype.eachBuiltinLayer = function(C, G) {
    for (var U = this._zlevelList, K = 0; K < U.length; K++) {
      var W = U[K], Z = this._layers[W];
      Z.__builtin__ && C.call(G, Z, W);
    }
  }, H.prototype.eachOtherLayer = function(C, G) {
    for (var U = this._zlevelList, K = 0; K < U.length; K++) {
      var W = U[K], Z = this._layers[W];
      Z.__builtin__ || C.call(G, Z, W);
    }
  }, H.prototype.getLayers = function() {
    return this._layers;
  }, H.prototype._updateLayerStatus = function(C) {
    this.eachBuiltinLayer(function(re, ne) {
      re.__dirty = re.__used = !1;
    });
    function G(re) {
      W && (W.__endIndex !== re && (W.__dirty = !0), W.__endIndex = re);
    }
    if (this._singleCanvas)
      for (var U = 1; U < C.length; U++) {
        var K = C[U];
        if (K.zlevel !== C[U - 1].zlevel || K.incremental) {
          this._needsManuallyCompositing = !0;
          break;
        }
      }
    var W = null, Z = 0, X, Q;
    for (Q = 0; Q < C.length; Q++) {
      var K = C[Q], ee = K.zlevel, te = void 0;
      X !== ee && (X = ee, Z = 0), K.incremental ? (te = this.getLayer(ee + INCREMENTAL_INC, this._needsManuallyCompositing), te.incremental = !0, Z = 1) : te = this.getLayer(ee + (Z > 0 ? EL_AFTER_INCREMENTAL_INC : 0), this._needsManuallyCompositing), te.__builtin__ || logError("ZLevel " + ee + " has been used by unkown layer " + te.id), te !== W && (te.__used = !0, te.__startIndex !== Q && (te.__dirty = !0), te.__startIndex = Q, te.incremental ? te.__drawIndex = -1 : te.__drawIndex = Q, G(Q), W = te), K.__dirty & REDRAW_BIT && !K.__inHover && (te.__dirty = !0, te.incremental && te.__drawIndex < 0 && (te.__drawIndex = Q));
    }
    G(Q), this.eachBuiltinLayer(function(re, ne) {
      !re.__used && re.getElementCount() > 0 && (re.__dirty = !0, re.__startIndex = re.__endIndex = re.__drawIndex = 0), re.__dirty && re.__drawIndex < 0 && (re.__drawIndex = re.__startIndex);
    });
  }, H.prototype.clear = function() {
    return this.eachBuiltinLayer(this._clearLayer), this;
  }, H.prototype._clearLayer = function(C) {
    C.clear();
  }, H.prototype.setBackgroundColor = function(C) {
    this._backgroundColor = C, each$f(this._layers, function(G) {
      G.setUnpainted();
    });
  }, H.prototype.configLayer = function(C, G) {
    if (G) {
      var U = this._layerConfig;
      U[C] ? merge(U[C], G, !0) : U[C] = G;
      for (var K = 0; K < this._zlevelList.length; K++) {
        var W = this._zlevelList[K];
        if (W === C || W === C + EL_AFTER_INCREMENTAL_INC) {
          var Z = this._layers[W];
          merge(Z, U[C], !0);
        }
      }
    }
  }, H.prototype.delLayer = function(C) {
    var G = this._layers, U = this._zlevelList, K = G[C];
    K && (K.dom.parentNode.removeChild(K.dom), delete G[C], U.splice(indexOf(U, C), 1));
  }, H.prototype.resize = function(C, G) {
    if (this._domRoot.style) {
      var U = this._domRoot;
      U.style.display = "none";
      var K = this._opts, W = this.root;
      if (C != null && (K.width = C), G != null && (K.height = G), C = getSize$1(W, 0, K), G = getSize$1(W, 1, K), U.style.display = "", this._width !== C || G !== this._height) {
        U.style.width = C + "px", U.style.height = G + "px";
        for (var Z in this._layers)
          this._layers.hasOwnProperty(Z) && this._layers[Z].resize(C, G);
        this.refresh(!0);
      }
      this._width = C, this._height = G;
    } else {
      if (C == null || G == null)
        return;
      this._width = C, this._height = G, this.getLayer(CANVAS_ZLEVEL).resize(C, G);
    }
    return this;
  }, H.prototype.clearLayer = function(C) {
    var G = this._layers[C];
    G && G.clear();
  }, H.prototype.dispose = function() {
    this.root.innerHTML = "", this.root = this.storage = this._domRoot = this._layers = null;
  }, H.prototype.getRenderedCanvas = function(C) {
    if (C = C || {}, this._singleCanvas && !this._compositeManually)
      return this._layers[CANVAS_ZLEVEL].dom;
    var G = new Layer$1("image", this, C.pixelRatio || this.dpr);
    G.initContext(), G.clear(!1, C.backgroundColor || this._backgroundColor);
    var U = G.ctx;
    if (C.pixelRatio <= this.dpr) {
      this.refresh();
      var K = G.dom.width, W = G.dom.height;
      this.eachLayer(function(re) {
        re.__builtin__ ? U.drawImage(re.dom, 0, 0, K, W) : re.renderToCanvas && (U.save(), re.renderToCanvas(U), U.restore());
      });
    } else
      for (var Z = {
        inHover: !1,
        viewWidth: this._width,
        viewHeight: this._height
      }, X = this.storage.getDisplayList(!0), Q = 0, ee = X.length; Q < ee; Q++) {
        var te = X[Q];
        brush$1(U, te, Z, Q === ee - 1);
      }
    return G.dom;
  }, H.prototype.getWidth = function() {
    return this._width;
  }, H.prototype.getHeight = function() {
    return this._height;
  }, H;
}();
const CanvasPainter$1 = CanvasPainter;
function install$R(H) {
  H.registerPainter("canvas", CanvasPainter$1);
}
var LineSeriesModel = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G.hasSymbolVisual = !0, G;
    }
    return C.prototype.getInitialData = function(G) {
      if (process.env.NODE_ENV !== "production") {
        var U = G.coordinateSystem;
        if (U !== "polar" && U !== "cartesian2d")
          throw new Error("Line not support coordinateSystem besides cartesian and polar");
      }
      return createSeriesData(null, this, {
        useEncodeDefaulter: !0
      });
    }, C.prototype.getLegendIcon = function(G) {
      var U = new Group$4(), K = createSymbol$1("line", 0, G.itemHeight / 2, G.itemWidth, 0, G.lineStyle.stroke, !1);
      U.add(K), K.setStyle(G.lineStyle);
      var W = this.getData().getVisual("symbol"), Z = this.getData().getVisual("symbolRotate"), X = W === "none" ? "circle" : W, Q = G.itemHeight * 0.8, ee = createSymbol$1(X, (G.itemWidth - Q) / 2, (G.itemHeight - Q) / 2, Q, Q, G.itemStyle.fill);
      U.add(ee), ee.setStyle(G.itemStyle);
      var te = G.iconRotate === "inherit" ? Z : G.iconRotate || 0;
      return ee.rotation = te * Math.PI / 180, ee.setOrigin([G.itemWidth / 2, G.itemHeight / 2]), X.indexOf("empty") > -1 && (ee.style.stroke = ee.style.fill, ee.style.fill = "#fff", ee.style.lineWidth = 2), U;
    }, C.type = "series.line", C.dependencies = ["grid", "polar"], C.defaultOption = {
      // zlevel: 0,
      z: 3,
      coordinateSystem: "cartesian2d",
      legendHoverLink: !0,
      clip: !0,
      label: {
        position: "top"
      },
      // itemStyle: {
      // },
      endLabel: {
        show: !1,
        valueAnimation: !0,
        distance: 8
      },
      lineStyle: {
        width: 2,
        type: "solid"
      },
      emphasis: {
        scale: !0
      },
      // areaStyle: {
      // origin of areaStyle. Valid values:
      // `'auto'/null/undefined`: from axisLine to data
      // `'start'`: from min to data
      // `'end'`: from data to max
      // origin: 'auto'
      // },
      // false, 'start', 'end', 'middle'
      step: !1,
      // Disabled if step is true
      smooth: !1,
      smoothMonotone: null,
      symbol: "emptyCircle",
      symbolSize: 4,
      symbolRotate: null,
      showSymbol: !0,
      // `false`: follow the label interval strategy.
      // `true`: show all symbols.
      // `'auto'`: If possible, show all symbols, otherwise
      //           follow the label interval strategy.
      showAllSymbol: "auto",
      // Whether to connect break point.
      connectNulls: !1,
      // Sampling for large data. Can be: 'average', 'max', 'min', 'sum', 'lttb'.
      sampling: "none",
      animationEasing: "linear",
      // Disable progressive
      progressive: 0,
      hoverLayerThreshold: 1 / 0,
      universalTransition: {
        divideShape: "clone"
      },
      triggerLineEvent: !1
    }, C;
  }(SeriesModel$1)
);
const LineSeries = LineSeriesModel;
function getDefaultLabel(H, C) {
  var G = H.mapDimensionsAll("defaultedLabel"), U = G.length;
  if (U === 1) {
    var K = retrieveRawValue(H, C, G[0]);
    return K != null ? K + "" : null;
  } else if (U) {
    for (var W = [], Z = 0; Z < G.length; Z++)
      W.push(retrieveRawValue(H, C, G[Z]));
    return W.join(" ");
  }
}
function getDefaultInterpolatedLabel(H, C) {
  var G = H.mapDimensionsAll("defaultedLabel");
  if (!isArray$1(C))
    return C + "";
  for (var U = [], K = 0; K < G.length; K++) {
    var W = H.getDimensionIndex(G[K]);
    W >= 0 && U.push(C[W]);
  }
  return U.join(" ");
}
var Symbol$1 = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C(G, U, K, W) {
      var Z = H.call(this) || this;
      return Z.updateData(G, U, K, W), Z;
    }
    return C.prototype._createSymbol = function(G, U, K, W, Z) {
      this.removeAll();
      var X = createSymbol$1(G, -1, -1, 2, 2, null, Z);
      X.attr({
        z2: 100,
        culling: !0,
        scaleX: W[0] / 2,
        scaleY: W[1] / 2
      }), X.drift = driftSymbol, this._symbolType = G, this.add(X);
    }, C.prototype.stopSymbolAnimation = function(G) {
      this.childAt(0).stopAnimation(null, G);
    }, C.prototype.getSymbolType = function() {
      return this._symbolType;
    }, C.prototype.getSymbolPath = function() {
      return this.childAt(0);
    }, C.prototype.highlight = function() {
      enterEmphasis(this.childAt(0));
    }, C.prototype.downplay = function() {
      leaveEmphasis(this.childAt(0));
    }, C.prototype.setZ = function(G, U) {
      var K = this.childAt(0);
      K.zlevel = G, K.z = U;
    }, C.prototype.setDraggable = function(G, U) {
      var K = this.childAt(0);
      K.draggable = G, K.cursor = !U && G ? "move" : K.cursor;
    }, C.prototype.updateData = function(G, U, K, W) {
      this.silent = !1;
      var Z = G.getItemVisual(U, "symbol") || "circle", X = G.hostModel, Q = C.getSymbolSize(G, U), ee = Z !== this._symbolType, te = W && W.disableAnimation;
      if (ee) {
        var re = G.getItemVisual(U, "symbolKeepAspect");
        this._createSymbol(Z, G, U, Q, re);
      } else {
        var ne = this.childAt(0);
        ne.silent = !1;
        var ae = {
          scaleX: Q[0] / 2,
          scaleY: Q[1] / 2
        };
        te ? ne.attr(ae) : updateProps$1(ne, ae, X, U), saveOldStyle(ne);
      }
      if (this._updateCommon(G, U, Q, K, W), ee) {
        var ne = this.childAt(0);
        if (!te) {
          var ae = {
            scaleX: this._sizeX,
            scaleY: this._sizeY,
            style: {
              // Always fadeIn. Because it has fadeOut animation when symbol is removed..
              opacity: ne.style.opacity
            }
          };
          ne.scaleX = ne.scaleY = 0, ne.style.opacity = 0, initProps(ne, ae, X, U);
        }
      }
      te && this.childAt(0).stopAnimation("leave");
    }, C.prototype._updateCommon = function(G, U, K, W, Z) {
      var X = this.childAt(0), Q = G.hostModel, ee, te, re, ne, ae, ie, se, oe, le;
      if (W && (ee = W.emphasisItemStyle, te = W.blurItemStyle, re = W.selectItemStyle, ne = W.focus, ae = W.blurScope, se = W.labelStatesModels, oe = W.hoverScale, le = W.cursorStyle, ie = W.emphasisDisabled), !W || G.hasItemOption) {
        var ue = W && W.itemModel ? W.itemModel : G.getItemModel(U), ce = ue.getModel("emphasis");
        ee = ce.getModel("itemStyle").getItemStyle(), re = ue.getModel(["select", "itemStyle"]).getItemStyle(), te = ue.getModel(["blur", "itemStyle"]).getItemStyle(), ne = ce.get("focus"), ae = ce.get("blurScope"), ie = ce.get("disabled"), se = getLabelStatesModels(ue), oe = ce.getShallow("scale"), le = ue.getShallow("cursor");
      }
      var de = G.getItemVisual(U, "symbolRotate");
      X.attr("rotation", (de || 0) * Math.PI / 180 || 0);
      var ge = normalizeSymbolOffset(G.getItemVisual(U, "symbolOffset"), K);
      ge && (X.x = ge[0], X.y = ge[1]), le && X.attr("cursor", le);
      var fe = G.getItemVisual(U, "style"), ve = fe.fill;
      if (X instanceof ZRImage$1) {
        var pe = X.style;
        X.useStyle(extend({
          // TODO other properties like x, y ?
          image: pe.image,
          x: pe.x,
          y: pe.y,
          width: pe.width,
          height: pe.height
        }, fe));
      } else
        X.__isEmptyBrush ? X.useStyle(extend({}, fe)) : X.useStyle(fe), X.style.decal = null, X.setColor(ve, Z && Z.symbolInnerColor), X.style.strokeNoScale = !0;
      var he = G.getItemVisual(U, "liftZ"), me = this._z2;
      he != null ? me == null && (this._z2 = X.z2, X.z2 += he) : me != null && (X.z2 = me, this._z2 = null);
      var ye = Z && Z.useNameLabel;
      setLabelStyle(X, se, {
        labelFetcher: Q,
        labelDataIndex: U,
        defaultText: Ce,
        inheritColor: ve,
        defaultOpacity: fe.opacity
      });
      function Ce(Se) {
        return ye ? G.getName(Se) : getDefaultLabel(G, Se);
      }
      this._sizeX = K[0] / 2, this._sizeY = K[1] / 2;
      var Ie = X.ensureState("emphasis");
      Ie.style = ee, X.ensureState("select").style = re, X.ensureState("blur").style = te;
      var be = oe == null || oe === !0 ? Math.max(1.1, 3 / this._sizeY) : isFinite(oe) && oe > 0 ? +oe : 1;
      Ie.scaleX = this._sizeX * be, Ie.scaleY = this._sizeY * be, this.setSymbolScale(1), toggleHoverEmphasis(this, ne, ae, ie);
    }, C.prototype.setSymbolScale = function(G) {
      this.scaleX = this.scaleY = G;
    }, C.prototype.fadeOut = function(G, U, K) {
      var W = this.childAt(0), Z = getECData(this).dataIndex, X = K && K.animation;
      if (this.silent = W.silent = !0, K && K.fadeLabel) {
        var Q = W.getTextContent();
        Q && removeElement(Q, {
          style: {
            opacity: 0
          }
        }, U, {
          dataIndex: Z,
          removeOpt: X,
          cb: function() {
            W.removeTextContent();
          }
        });
      } else
        W.removeTextContent();
      removeElement(W, {
        style: {
          opacity: 0
        },
        scaleX: 0,
        scaleY: 0
      }, U, {
        dataIndex: Z,
        cb: G,
        removeOpt: X
      });
    }, C.getSymbolSize = function(G, U) {
      return normalizeSymbolSize(G.getItemVisual(U, "symbolSize"));
    }, C;
  }(Group$4)
);
function driftSymbol(H, C) {
  this.parent.drift(H, C);
}
const SymbolClz = Symbol$1;
function symbolNeedsDraw$1(H, C, G, U) {
  return C && !isNaN(C[0]) && !isNaN(C[1]) && !(U.isIgnore && U.isIgnore(G)) && !(U.clipShape && !U.clipShape.contain(C[0], C[1])) && H.getItemVisual(G, "symbol") !== "none";
}
function normalizeUpdateOpt(H) {
  return H != null && !isObject$3(H) && (H = {
    isIgnore: H
  }), H || {};
}
function makeSeriesScope$2(H) {
  var C = H.hostModel, G = C.getModel("emphasis");
  return {
    emphasisItemStyle: G.getModel("itemStyle").getItemStyle(),
    blurItemStyle: C.getModel(["blur", "itemStyle"]).getItemStyle(),
    selectItemStyle: C.getModel(["select", "itemStyle"]).getItemStyle(),
    focus: G.get("focus"),
    blurScope: G.get("blurScope"),
    emphasisDisabled: G.get("disabled"),
    hoverScale: G.get("scale"),
    labelStatesModels: getLabelStatesModels(C),
    cursorStyle: C.get("cursor")
  };
}
var SymbolDraw = (
  /** @class */
  function() {
    function H(C) {
      this.group = new Group$4(), this._SymbolCtor = C || SymbolClz;
    }
    return H.prototype.updateData = function(C, G) {
      this._progressiveEls = null, G = normalizeUpdateOpt(G);
      var U = this.group, K = C.hostModel, W = this._data, Z = this._SymbolCtor, X = G.disableAnimation, Q = makeSeriesScope$2(C), ee = {
        disableAnimation: X
      }, te = G.getSymbolPoint || function(re) {
        return C.getItemLayout(re);
      };
      W || U.removeAll(), C.diff(W).add(function(re) {
        var ne = te(re);
        if (symbolNeedsDraw$1(C, ne, re, G)) {
          var ae = new Z(C, re, Q, ee);
          ae.setPosition(ne), C.setItemGraphicEl(re, ae), U.add(ae);
        }
      }).update(function(re, ne) {
        var ae = W.getItemGraphicEl(ne), ie = te(re);
        if (!symbolNeedsDraw$1(C, ie, re, G)) {
          U.remove(ae);
          return;
        }
        var se = C.getItemVisual(re, "symbol") || "circle", oe = ae && ae.getSymbolType && ae.getSymbolType();
        if (!ae || oe && oe !== se)
          U.remove(ae), ae = new Z(C, re, Q, ee), ae.setPosition(ie);
        else {
          ae.updateData(C, re, Q, ee);
          var le = {
            x: ie[0],
            y: ie[1]
          };
          X ? ae.attr(le) : updateProps$1(ae, le, K);
        }
        U.add(ae), C.setItemGraphicEl(re, ae);
      }).remove(function(re) {
        var ne = W.getItemGraphicEl(re);
        ne && ne.fadeOut(function() {
          U.remove(ne);
        }, K);
      }).execute(), this._getSymbolPoint = te, this._data = C;
    }, H.prototype.updateLayout = function() {
      var C = this, G = this._data;
      G && G.eachItemGraphicEl(function(U, K) {
        var W = C._getSymbolPoint(K);
        U.setPosition(W), U.markRedraw();
      });
    }, H.prototype.incrementalPrepareUpdate = function(C) {
      this._seriesScope = makeSeriesScope$2(C), this._data = null, this.group.removeAll();
    }, H.prototype.incrementalUpdate = function(C, G, U) {
      this._progressiveEls = [], U = normalizeUpdateOpt(U);
      function K(Q) {
        Q.isGroup || (Q.incremental = !0, Q.ensureState("emphasis").hoverLayer = !0);
      }
      for (var W = C.start; W < C.end; W++) {
        var Z = G.getItemLayout(W);
        if (symbolNeedsDraw$1(G, Z, W, U)) {
          var X = new this._SymbolCtor(G, W, this._seriesScope);
          X.traverse(K), X.setPosition(Z), this.group.add(X), G.setItemGraphicEl(W, X), this._progressiveEls.push(X);
        }
      }
    }, H.prototype.eachRendered = function(C) {
      traverseElements(this._progressiveEls || this.group, C);
    }, H.prototype.remove = function(C) {
      var G = this.group, U = this._data;
      U && C ? U.eachItemGraphicEl(function(K) {
        K.fadeOut(function() {
          G.remove(K);
        }, U.hostModel);
      }) : G.removeAll();
    }, H;
  }()
);
const SymbolDraw$1 = SymbolDraw;
function prepareDataCoordInfo(H, C, G) {
  var U = H.getBaseAxis(), K = H.getOtherAxis(U), W = getValueStart(K, G), Z = U.dim, X = K.dim, Q = C.mapDimension(X), ee = C.mapDimension(Z), te = X === "x" || X === "radius" ? 1 : 0, re = map$1(H.dimensions, function(ie) {
    return C.mapDimension(ie);
  }), ne = !1, ae = C.getCalculationInfo("stackResultDimension");
  return isDimensionStacked(
    C,
    re[0]
    /* , dims[1] */
  ) && (ne = !0, re[0] = ae), isDimensionStacked(
    C,
    re[1]
    /* , dims[0] */
  ) && (ne = !0, re[1] = ae), {
    dataDimsForPoint: re,
    valueStart: W,
    valueAxisDim: X,
    baseAxisDim: Z,
    stacked: !!ne,
    valueDim: Q,
    baseDim: ee,
    baseDataOffset: te,
    stackedOverDimension: C.getCalculationInfo("stackedOverDimension")
  };
}
function getValueStart(H, C) {
  var G = 0, U = H.scale.getExtent();
  return C === "start" ? G = U[0] : C === "end" ? G = U[1] : isNumber(C) && !isNaN(C) ? G = C : U[0] > 0 ? G = U[0] : U[1] < 0 && (G = U[1]), G;
}
function getStackedOnPoint(H, C, G, U) {
  var K = NaN;
  H.stacked && (K = G.get(G.getCalculationInfo("stackedOverDimension"), U)), isNaN(K) && (K = H.valueStart);
  var W = H.baseDataOffset, Z = [];
  return Z[W] = G.get(H.baseDim, U), Z[1 - W] = K, C.dataToPoint(Z);
}
function diffData(H, C) {
  var G = [];
  return C.diff(H).add(function(U) {
    G.push({
      cmd: "+",
      idx: U
    });
  }).update(function(U, K) {
    G.push({
      cmd: "=",
      idx: K,
      idx1: U
    });
  }).remove(function(U) {
    G.push({
      cmd: "-",
      idx: U
    });
  }).execute(), G;
}
function lineAnimationDiff(H, C, G, U, K, W, Z, X) {
  for (var Q = diffData(H, C), ee = [], te = [], re = [], ne = [], ae = [], ie = [], se = [], oe = prepareDataCoordInfo(K, C, Z), le = H.getLayout("points") || [], ue = C.getLayout("points") || [], ce = 0; ce < Q.length; ce++) {
    var de = Q[ce], ge = !0, fe = void 0, ve = void 0;
    switch (de.cmd) {
      case "=":
        fe = de.idx * 2, ve = de.idx1 * 2;
        var pe = le[fe], he = le[fe + 1], me = ue[ve], ye = ue[ve + 1];
        (isNaN(pe) || isNaN(he)) && (pe = me, he = ye), ee.push(pe, he), te.push(me, ye), re.push(G[fe], G[fe + 1]), ne.push(U[ve], U[ve + 1]), se.push(C.getRawIndex(de.idx1));
        break;
      case "+":
        var Ce = de.idx, Ie = oe.dataDimsForPoint, be = K.dataToPoint([C.get(Ie[0], Ce), C.get(Ie[1], Ce)]);
        ve = Ce * 2, ee.push(be[0], be[1]), te.push(ue[ve], ue[ve + 1]);
        var Se = getStackedOnPoint(oe, K, C, Ce);
        re.push(Se[0], Se[1]), ne.push(U[ve], U[ve + 1]), se.push(C.getRawIndex(Ce));
        break;
      case "-":
        ge = !1;
    }
    ge && (ae.push(de), ie.push(ie.length));
  }
  ie.sort(function(Oe, Ne) {
    return se[Oe] - se[Ne];
  });
  for (var Ae = ee.length, _e = createFloat32Array(Ae), xe = createFloat32Array(Ae), Te = createFloat32Array(Ae), Pe = createFloat32Array(Ae), $e = [], ce = 0; ce < ie.length; ce++) {
    var Me = ie[ce], Ee = ce * 2, we = Me * 2;
    _e[Ee] = ee[we], _e[Ee + 1] = ee[we + 1], xe[Ee] = te[we], xe[Ee + 1] = te[we + 1], Te[Ee] = re[we], Te[Ee + 1] = re[we + 1], Pe[Ee] = ne[we], Pe[Ee + 1] = ne[we + 1], $e[ce] = ae[Me];
  }
  return {
    current: _e,
    next: xe,
    stackedOnCurrent: Te,
    stackedOnNext: Pe,
    status: $e
  };
}
var mathMin$5 = Math.min, mathMax$5 = Math.max;
function isPointNull$1(H, C) {
  return isNaN(H) || isNaN(C);
}
function drawSegment(H, C, G, U, K, W, Z, X, Q) {
  for (var ee, te, re, ne, ae, ie, se = G, oe = 0; oe < U; oe++) {
    var le = C[se * 2], ue = C[se * 2 + 1];
    if (se >= K || se < 0)
      break;
    if (isPointNull$1(le, ue)) {
      if (Q) {
        se += W;
        continue;
      }
      break;
    }
    if (se === G)
      H[W > 0 ? "moveTo" : "lineTo"](le, ue), re = le, ne = ue;
    else {
      var ce = le - ee, de = ue - te;
      if (ce * ce + de * de < 0.5) {
        se += W;
        continue;
      }
      if (Z > 0) {
        for (var ge = se + W, fe = C[ge * 2], ve = C[ge * 2 + 1]; fe === le && ve === ue && oe < U; )
          oe++, ge += W, se += W, fe = C[ge * 2], ve = C[ge * 2 + 1], le = C[se * 2], ue = C[se * 2 + 1], ce = le - ee, de = ue - te;
        var pe = oe + 1;
        if (Q)
          for (; isPointNull$1(fe, ve) && pe < U; )
            pe++, ge += W, fe = C[ge * 2], ve = C[ge * 2 + 1];
        var he = 0.5, me = 0, ye = 0, Ce = void 0, Ie = void 0;
        if (pe >= U || isPointNull$1(fe, ve))
          ae = le, ie = ue;
        else {
          me = fe - ee, ye = ve - te;
          var be = le - ee, Se = fe - le, Ae = ue - te, _e = ve - ue, xe = void 0, Te = void 0;
          if (X === "x") {
            xe = Math.abs(be), Te = Math.abs(Se);
            var Pe = me > 0 ? 1 : -1;
            ae = le - Pe * xe * Z, ie = ue, Ce = le + Pe * Te * Z, Ie = ue;
          } else if (X === "y") {
            xe = Math.abs(Ae), Te = Math.abs(_e);
            var $e = ye > 0 ? 1 : -1;
            ae = le, ie = ue - $e * xe * Z, Ce = le, Ie = ue + $e * Te * Z;
          } else
            xe = Math.sqrt(be * be + Ae * Ae), Te = Math.sqrt(Se * Se + _e * _e), he = Te / (Te + xe), ae = le - me * Z * (1 - he), ie = ue - ye * Z * (1 - he), Ce = le + me * Z * he, Ie = ue + ye * Z * he, Ce = mathMin$5(Ce, mathMax$5(fe, le)), Ie = mathMin$5(Ie, mathMax$5(ve, ue)), Ce = mathMax$5(Ce, mathMin$5(fe, le)), Ie = mathMax$5(Ie, mathMin$5(ve, ue)), me = Ce - le, ye = Ie - ue, ae = le - me * xe / Te, ie = ue - ye * xe / Te, ae = mathMin$5(ae, mathMax$5(ee, le)), ie = mathMin$5(ie, mathMax$5(te, ue)), ae = mathMax$5(ae, mathMin$5(ee, le)), ie = mathMax$5(ie, mathMin$5(te, ue)), me = le - ae, ye = ue - ie, Ce = le + me * Te / xe, Ie = ue + ye * Te / xe;
        }
        H.bezierCurveTo(re, ne, ae, ie, le, ue), re = Ce, ne = Ie;
      } else
        H.lineTo(le, ue);
    }
    ee = le, te = ue, se += W;
  }
  return oe;
}
var ECPolylineShape = (
  /** @class */
  function() {
    function H() {
      this.smooth = 0, this.smoothConstraint = !0;
    }
    return H;
  }()
), ECPolyline = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C(G) {
      var U = H.call(this, G) || this;
      return U.type = "ec-polyline", U;
    }
    return C.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    }, C.prototype.getDefaultShape = function() {
      return new ECPolylineShape();
    }, C.prototype.buildPath = function(G, U) {
      var K = U.points, W = 0, Z = K.length / 2;
      if (U.connectNulls) {
        for (; Z > 0 && isPointNull$1(K[Z * 2 - 2], K[Z * 2 - 1]); Z--)
          ;
        for (; W < Z && isPointNull$1(K[W * 2], K[W * 2 + 1]); W++)
          ;
      }
      for (; W < Z; )
        W += drawSegment(G, K, W, Z, Z, 1, U.smooth, U.smoothMonotone, U.connectNulls) + 1;
    }, C.prototype.getPointOn = function(G, U) {
      this.path || (this.createPathProxy(), this.buildPath(this.path, this.shape));
      for (var K = this.path, W = K.data, Z = PathProxy$1.CMD, X, Q, ee = U === "x", te = [], re = 0; re < W.length; ) {
        var ne = W[re++], ae = void 0, ie = void 0, se = void 0, oe = void 0, le = void 0, ue = void 0, ce = void 0;
        switch (ne) {
          case Z.M:
            X = W[re++], Q = W[re++];
            break;
          case Z.L:
            if (ae = W[re++], ie = W[re++], ce = ee ? (G - X) / (ae - X) : (G - Q) / (ie - Q), ce <= 1 && ce >= 0) {
              var de = ee ? (ie - Q) * ce + Q : (ae - X) * ce + X;
              return ee ? [G, de] : [de, G];
            }
            X = ae, Q = ie;
            break;
          case Z.C:
            ae = W[re++], ie = W[re++], se = W[re++], oe = W[re++], le = W[re++], ue = W[re++];
            var ge = ee ? cubicRootAt(X, ae, se, le, G, te) : cubicRootAt(Q, ie, oe, ue, G, te);
            if (ge > 0)
              for (var fe = 0; fe < ge; fe++) {
                var ve = te[fe];
                if (ve <= 1 && ve >= 0) {
                  var de = ee ? cubicAt(Q, ie, oe, ue, ve) : cubicAt(X, ae, se, le, ve);
                  return ee ? [G, de] : [de, G];
                }
              }
            X = le, Q = ue;
            break;
        }
      }
    }, C;
  }(Path$1)
), ECPolygonShape = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      return H !== null && H.apply(this, arguments) || this;
    }
    return C;
  }(ECPolylineShape)
), ECPolygon = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C(G) {
      var U = H.call(this, G) || this;
      return U.type = "ec-polygon", U;
    }
    return C.prototype.getDefaultShape = function() {
      return new ECPolygonShape();
    }, C.prototype.buildPath = function(G, U) {
      var K = U.points, W = U.stackedOnPoints, Z = 0, X = K.length / 2, Q = U.smoothMonotone;
      if (U.connectNulls) {
        for (; X > 0 && isPointNull$1(K[X * 2 - 2], K[X * 2 - 1]); X--)
          ;
        for (; Z < X && isPointNull$1(K[Z * 2], K[Z * 2 + 1]); Z++)
          ;
      }
      for (; Z < X; ) {
        var ee = drawSegment(G, K, Z, X, X, 1, U.smooth, Q, U.connectNulls);
        drawSegment(G, W, Z + ee - 1, ee, X, -1, U.stackedOnSmooth, Q, U.connectNulls), Z += ee + 1, G.closePath();
      }
    }, C;
  }(Path$1)
);
function createGridClipPath(H, C, G, U, K) {
  var W = H.getArea(), Z = W.x, X = W.y, Q = W.width, ee = W.height, te = G.get(["lineStyle", "width"]) || 2;
  Z -= te / 2, X -= te / 2, Q += te, ee += te, Z = Math.floor(Z), Q = Math.round(Q);
  var re = new Rect$3({
    shape: {
      x: Z,
      y: X,
      width: Q,
      height: ee
    }
  });
  if (C) {
    var ne = H.getBaseAxis(), ae = ne.isHorizontal(), ie = ne.inverse;
    ae ? (ie && (re.shape.x += Q), re.shape.width = 0) : (ie || (re.shape.y += ee), re.shape.height = 0);
    var se = isFunction(K) ? function(oe) {
      K(oe, re);
    } : null;
    initProps(re, {
      shape: {
        width: Q,
        height: ee,
        x: Z,
        y: X
      }
    }, G, null, U, se);
  }
  return re;
}
function createPolarClipPath(H, C, G) {
  var U = H.getArea(), K = round$3(U.r0, 1), W = round$3(U.r, 1), Z = new Sector$1({
    shape: {
      cx: round$3(H.cx, 1),
      cy: round$3(H.cy, 1),
      r0: K,
      r: W,
      startAngle: U.startAngle,
      endAngle: U.endAngle,
      clockwise: U.clockwise
    }
  });
  if (C) {
    var X = H.getBaseAxis().dim === "angle";
    X ? Z.shape.endAngle = U.startAngle : Z.shape.r = K, initProps(Z, {
      shape: {
        endAngle: U.endAngle,
        r: W
      }
    }, G);
  }
  return Z;
}
function createClipPath(H, C, G, U, K) {
  if (H) {
    if (H.type === "polar")
      return createPolarClipPath(H, C, G);
    if (H.type === "cartesian2d")
      return createGridClipPath(H, C, G, U, K);
  } else
    return null;
  return null;
}
function isCoordinateSystemType(H, C) {
  return H.type === C;
}
function isPointsSame(H, C) {
  if (H.length === C.length) {
    for (var G = 0; G < H.length; G++)
      if (H[G] !== C[G])
        return;
    return !0;
  }
}
function bboxFromPoints(H) {
  for (var C = 1 / 0, G = 1 / 0, U = -1 / 0, K = -1 / 0, W = 0; W < H.length; ) {
    var Z = H[W++], X = H[W++];
    isNaN(Z) || (C = Math.min(Z, C), U = Math.max(Z, U)), isNaN(X) || (G = Math.min(X, G), K = Math.max(X, K));
  }
  return [[C, G], [U, K]];
}
function getBoundingDiff(H, C) {
  var G = bboxFromPoints(H), U = G[0], K = G[1], W = bboxFromPoints(C), Z = W[0], X = W[1];
  return Math.max(Math.abs(U[0] - Z[0]), Math.abs(U[1] - Z[1]), Math.abs(K[0] - X[0]), Math.abs(K[1] - X[1]));
}
function getSmooth(H) {
  return isNumber(H) ? H : H ? 0.5 : 0;
}
function getStackedOnPoints(H, C, G) {
  if (!G.valueDim)
    return [];
  for (var U = C.count(), K = createFloat32Array(U * 2), W = 0; W < U; W++) {
    var Z = getStackedOnPoint(G, H, C, W);
    K[W * 2] = Z[0], K[W * 2 + 1] = Z[1];
  }
  return K;
}
function turnPointsIntoStep(H, C, G, U) {
  var K = C.getBaseAxis(), W = K.dim === "x" || K.dim === "radius" ? 0 : 1, Z = [], X = 0, Q = [], ee = [], te = [], re = [];
  if (U) {
    for (X = 0; X < H.length; X += 2)
      !isNaN(H[X]) && !isNaN(H[X + 1]) && re.push(H[X], H[X + 1]);
    H = re;
  }
  for (X = 0; X < H.length - 2; X += 2)
    switch (te[0] = H[X + 2], te[1] = H[X + 3], ee[0] = H[X], ee[1] = H[X + 1], Z.push(ee[0], ee[1]), G) {
      case "end":
        Q[W] = te[W], Q[1 - W] = ee[1 - W], Z.push(Q[0], Q[1]);
        break;
      case "middle":
        var ne = (ee[W] + te[W]) / 2, ae = [];
        Q[W] = ae[W] = ne, Q[1 - W] = ee[1 - W], ae[1 - W] = te[1 - W], Z.push(Q[0], Q[1]), Z.push(ae[0], ae[1]);
        break;
      default:
        Q[W] = ee[W], Q[1 - W] = te[1 - W], Z.push(Q[0], Q[1]);
    }
  return Z.push(H[X++], H[X++]), Z;
}
function clipColorStops(H, C) {
  var G = [], U = H.length, K, W;
  function Z(te, re, ne) {
    var ae = te.coord, ie = (ne - ae) / (re.coord - ae), se = lerp(ie, [te.color, re.color]);
    return {
      coord: ne,
      color: se
    };
  }
  for (var X = 0; X < U; X++) {
    var Q = H[X], ee = Q.coord;
    if (ee < 0)
      K = Q;
    else if (ee > C) {
      W ? G.push(Z(W, Q, C)) : K && G.push(Z(K, Q, 0), Z(K, Q, C));
      break;
    } else
      K && (G.push(Z(K, Q, 0)), K = null), G.push(Q), W = Q;
  }
  return G;
}
function getVisualGradient(H, C, G) {
  var U = H.getVisual("visualMeta");
  if (!(!U || !U.length || !H.count())) {
    if (C.type !== "cartesian2d") {
      process.env.NODE_ENV !== "production" && console.warn("Visual map on line style is only supported on cartesian2d.");
      return;
    }
    for (var K, W, Z = U.length - 1; Z >= 0; Z--) {
      var X = H.getDimensionInfo(U[Z].dimension);
      if (K = X && X.coordDim, K === "x" || K === "y") {
        W = U[Z];
        break;
      }
    }
    if (!W) {
      process.env.NODE_ENV !== "production" && console.warn("Visual map on line style only support x or y dimension.");
      return;
    }
    var Q = C.getAxis(K), ee = map$1(W.stops, function(ce) {
      return {
        coord: Q.toGlobalCoord(Q.dataToCoord(ce.value)),
        color: ce.color
      };
    }), te = ee.length, re = W.outerColors.slice();
    te && ee[0].coord > ee[te - 1].coord && (ee.reverse(), re.reverse());
    var ne = clipColorStops(ee, K === "x" ? G.getWidth() : G.getHeight()), ae = ne.length;
    if (!ae && te)
      return ee[0].coord < 0 ? re[1] ? re[1] : ee[te - 1].color : re[0] ? re[0] : ee[0].color;
    var ie = 10, se = ne[0].coord - ie, oe = ne[ae - 1].coord + ie, le = oe - se;
    if (le < 1e-3)
      return "transparent";
    each$f(ne, function(ce) {
      ce.offset = (ce.coord - se) / le;
    }), ne.push({
      // NOTE: inRangeStopLen may still be 0 if stoplen is zero.
      offset: ae ? ne[ae - 1].offset : 0.5,
      color: re[1] || "transparent"
    }), ne.unshift({
      offset: ae ? ne[0].offset : 0.5,
      color: re[0] || "transparent"
    });
    var ue = new LinearGradient$1(0, 0, 0, 0, ne, !0);
    return ue[K] = se, ue[K + "2"] = oe, ue;
  }
}
function getIsIgnoreFunc(H, C, G) {
  var U = H.get("showAllSymbol"), K = U === "auto";
  if (!(U && !K)) {
    var W = G.getAxesByScale("ordinal")[0];
    if (W && !(K && canShowAllSymbolForCategory(W, C))) {
      var Z = C.mapDimension(W.dim), X = {};
      return each$f(W.getViewLabels(), function(Q) {
        var ee = W.scale.getRawOrdinalNumber(Q.tickValue);
        X[ee] = 1;
      }), function(Q) {
        return !X.hasOwnProperty(C.get(Z, Q));
      };
    }
  }
}
function canShowAllSymbolForCategory(H, C) {
  var G = H.getExtent(), U = Math.abs(G[1] - G[0]) / H.scale.count();
  isNaN(U) && (U = 0);
  for (var K = C.count(), W = Math.max(1, Math.round(K / 5)), Z = 0; Z < K; Z += W)
    if (SymbolClz.getSymbolSize(
      C,
      Z
      // Only for cartesian, where `isHorizontal` exists.
    )[H.isHorizontal() ? 1 : 0] * 1.5 > U)
      return !1;
  return !0;
}
function isPointNull(H, C) {
  return isNaN(H) || isNaN(C);
}
function getLastIndexNotNull(H) {
  for (var C = H.length / 2; C > 0 && isPointNull(H[C * 2 - 2], H[C * 2 - 1]); C--)
    ;
  return C - 1;
}
function getPointAtIndex(H, C) {
  return [H[C * 2], H[C * 2 + 1]];
}
function getIndexRange(H, C, G) {
  for (var U = H.length / 2, K = G === "x" ? 0 : 1, W, Z, X = 0, Q = -1, ee = 0; ee < U; ee++)
    if (Z = H[ee * 2 + K], !(isNaN(Z) || isNaN(H[ee * 2 + 1 - K]))) {
      if (ee === 0) {
        W = Z;
        continue;
      }
      if (W <= C && Z >= C || W >= C && Z <= C) {
        Q = ee;
        break;
      }
      X = ee, W = Z;
    }
  return {
    range: [X, Q],
    t: (C - W) / (Z - W)
  };
}
function anyStateShowEndLabel(H) {
  if (H.get(["endLabel", "show"]))
    return !0;
  for (var C = 0; C < SPECIAL_STATES.length; C++)
    if (H.get([SPECIAL_STATES[C], "endLabel", "show"]))
      return !0;
  return !1;
}
function createLineClipPath(H, C, G, U) {
  if (isCoordinateSystemType(C, "cartesian2d")) {
    var K = U.getModel("endLabel"), W = K.get("valueAnimation"), Z = U.getData(), X = {
      lastFrameIndex: 0
    }, Q = anyStateShowEndLabel(U) ? function(ae, ie) {
      H._endLabelOnDuring(ae, ie, Z, X, W, K, C);
    } : null, ee = C.getBaseAxis().isHorizontal(), te = createGridClipPath(C, G, U, function() {
      var ae = H._endLabel;
      ae && G && X.originalX != null && ae.attr({
        x: X.originalX,
        y: X.originalY
      });
    }, Q);
    if (!U.get("clip", !0)) {
      var re = te.shape, ne = Math.max(re.width, re.height);
      ee ? (re.y -= ne, re.height += ne * 2) : (re.x -= ne, re.width += ne * 2);
    }
    return Q && Q(1, te), te;
  } else
    return process.env.NODE_ENV !== "production" && U.get(["endLabel", "show"]) && console.warn("endLabel is not supported for lines in polar systems."), createPolarClipPath(C, G, U);
}
function getEndLabelStateSpecified(H, C) {
  var G = C.getBaseAxis(), U = G.isHorizontal(), K = G.inverse, W = U ? K ? "right" : "left" : "center", Z = U ? "middle" : K ? "top" : "bottom";
  return {
    normal: {
      align: H.get("align") || W,
      verticalAlign: H.get("verticalAlign") || Z
    }
  };
}
var LineView = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      return H !== null && H.apply(this, arguments) || this;
    }
    return C.prototype.init = function() {
      var G = new Group$4(), U = new SymbolDraw$1();
      this.group.add(U.group), this._symbolDraw = U, this._lineGroup = G;
    }, C.prototype.render = function(G, U, K) {
      var W = this, Z = G.coordinateSystem, X = this.group, Q = G.getData(), ee = G.getModel("lineStyle"), te = G.getModel("areaStyle"), re = Q.getLayout("points") || [], ne = Z.type === "polar", ae = this._coordSys, ie = this._symbolDraw, se = this._polyline, oe = this._polygon, le = this._lineGroup, ue = G.get("animation"), ce = !te.isEmpty(), de = te.get("origin"), ge = prepareDataCoordInfo(Z, Q, de), fe = ce && getStackedOnPoints(Z, Q, ge), ve = G.get("showSymbol"), pe = G.get("connectNulls"), he = ve && !ne && getIsIgnoreFunc(G, Q, Z), me = this._data;
      me && me.eachItemGraphicEl(function(Ne, ke) {
        Ne.__temp && (X.remove(Ne), me.setItemGraphicEl(ke, null));
      }), ve || ie.remove(), X.add(le);
      var ye = ne ? !1 : G.get("step"), Ce;
      Z && Z.getArea && G.get("clip", !0) && (Ce = Z.getArea(), Ce.width != null ? (Ce.x -= 0.1, Ce.y -= 0.1, Ce.width += 0.2, Ce.height += 0.2) : Ce.r0 && (Ce.r0 -= 0.5, Ce.r += 0.5)), this._clipShapeForSymbol = Ce;
      var Ie = getVisualGradient(Q, Z, K) || Q.getVisual("style")[Q.getVisual("drawType")];
      if (!(se && ae.type === Z.type && ye === this._step))
        ve && ie.updateData(Q, {
          isIgnore: he,
          clipShape: Ce,
          disableAnimation: !0,
          getSymbolPoint: function(Ne) {
            return [re[Ne * 2], re[Ne * 2 + 1]];
          }
        }), ue && this._initSymbolLabelAnimation(Q, Z, Ce), ye && (re = turnPointsIntoStep(re, Z, ye, pe), fe && (fe = turnPointsIntoStep(fe, Z, ye, pe))), se = this._newPolyline(re), ce ? oe = this._newPolygon(re, fe) : oe && (le.remove(oe), oe = this._polygon = null), ne || this._initOrUpdateEndLabel(G, Z, convertToColorString(Ie)), le.setClipPath(createLineClipPath(this, Z, !0, G));
      else {
        ce && !oe ? oe = this._newPolygon(re, fe) : oe && !ce && (le.remove(oe), oe = this._polygon = null), ne || this._initOrUpdateEndLabel(G, Z, convertToColorString(Ie));
        var be = le.getClipPath();
        if (be) {
          var Se = createLineClipPath(this, Z, !1, G);
          initProps(be, {
            shape: Se.shape
          }, G);
        } else
          le.setClipPath(createLineClipPath(this, Z, !0, G));
        ve && ie.updateData(Q, {
          isIgnore: he,
          clipShape: Ce,
          disableAnimation: !0,
          getSymbolPoint: function(Ne) {
            return [re[Ne * 2], re[Ne * 2 + 1]];
          }
        }), (!isPointsSame(this._stackedOnPoints, fe) || !isPointsSame(this._points, re)) && (ue ? this._doUpdateAnimation(Q, fe, Z, K, ye, de, pe) : (ye && (re = turnPointsIntoStep(re, Z, ye, pe), fe && (fe = turnPointsIntoStep(fe, Z, ye, pe))), se.setShape({
          points: re
        }), oe && oe.setShape({
          points: re,
          stackedOnPoints: fe
        })));
      }
      var Ae = G.getModel("emphasis"), _e = Ae.get("focus"), xe = Ae.get("blurScope"), Te = Ae.get("disabled");
      if (se.useStyle(defaults(
        // Use color in lineStyle first
        ee.getLineStyle(),
        {
          fill: "none",
          stroke: Ie,
          lineJoin: "bevel"
        }
      )), setStatesStylesFromModel(se, G, "lineStyle"), se.style.lineWidth > 0 && G.get(["emphasis", "lineStyle", "width"]) === "bolder") {
        var Pe = se.getState("emphasis").style;
        Pe.lineWidth = +se.style.lineWidth + 1;
      }
      getECData(se).seriesIndex = G.seriesIndex, toggleHoverEmphasis(se, _e, xe, Te);
      var $e = getSmooth(G.get("smooth")), Me = G.get("smoothMonotone");
      if (se.setShape({
        smooth: $e,
        smoothMonotone: Me,
        connectNulls: pe
      }), oe) {
        var Ee = Q.getCalculationInfo("stackedOnSeries"), we = 0;
        oe.useStyle(defaults(te.getAreaStyle(), {
          fill: Ie,
          opacity: 0.7,
          lineJoin: "bevel",
          decal: Q.getVisual("style").decal
        })), Ee && (we = getSmooth(Ee.get("smooth"))), oe.setShape({
          smooth: $e,
          stackedOnSmooth: we,
          smoothMonotone: Me,
          connectNulls: pe
        }), setStatesStylesFromModel(oe, G, "areaStyle"), getECData(oe).seriesIndex = G.seriesIndex, toggleHoverEmphasis(oe, _e, xe, Te);
      }
      var Oe = function(Ne) {
        W._changePolyState(Ne);
      };
      Q.eachItemGraphicEl(function(Ne) {
        Ne && (Ne.onHoverStateChange = Oe);
      }), this._polyline.onHoverStateChange = Oe, this._data = Q, this._coordSys = Z, this._stackedOnPoints = fe, this._points = re, this._step = ye, this._valueOrigin = de, G.get("triggerLineEvent") && (this.packEventData(G, se), oe && this.packEventData(G, oe));
    }, C.prototype.packEventData = function(G, U) {
      getECData(U).eventData = {
        componentType: "series",
        componentSubType: "line",
        componentIndex: G.componentIndex,
        seriesIndex: G.seriesIndex,
        seriesName: G.name,
        seriesType: "line"
      };
    }, C.prototype.highlight = function(G, U, K, W) {
      var Z = G.getData(), X = queryDataIndex(Z, W);
      if (this._changePolyState("emphasis"), !(X instanceof Array) && X != null && X >= 0) {
        var Q = Z.getLayout("points"), ee = Z.getItemGraphicEl(X);
        if (!ee) {
          var te = Q[X * 2], re = Q[X * 2 + 1];
          if (isNaN(te) || isNaN(re) || this._clipShapeForSymbol && !this._clipShapeForSymbol.contain(te, re))
            return;
          var ne = G.get("zlevel") || 0, ae = G.get("z") || 0;
          ee = new SymbolClz(Z, X), ee.x = te, ee.y = re, ee.setZ(ne, ae);
          var ie = ee.getSymbolPath().getTextContent();
          ie && (ie.zlevel = ne, ie.z = ae, ie.z2 = this._polyline.z2 + 1), ee.__temp = !0, Z.setItemGraphicEl(X, ee), ee.stopSymbolAnimation(!0), this.group.add(ee);
        }
        ee.highlight();
      } else
        ChartView$1.prototype.highlight.call(this, G, U, K, W);
    }, C.prototype.downplay = function(G, U, K, W) {
      var Z = G.getData(), X = queryDataIndex(Z, W);
      if (this._changePolyState("normal"), X != null && X >= 0) {
        var Q = Z.getItemGraphicEl(X);
        Q && (Q.__temp ? (Z.setItemGraphicEl(X, null), this.group.remove(Q)) : Q.downplay());
      } else
        ChartView$1.prototype.downplay.call(this, G, U, K, W);
    }, C.prototype._changePolyState = function(G) {
      var U = this._polygon;
      setStatesFlag(this._polyline, G), U && setStatesFlag(U, G);
    }, C.prototype._newPolyline = function(G) {
      var U = this._polyline;
      return U && this._lineGroup.remove(U), U = new ECPolyline({
        shape: {
          points: G
        },
        segmentIgnoreThreshold: 2,
        z2: 10
      }), this._lineGroup.add(U), this._polyline = U, U;
    }, C.prototype._newPolygon = function(G, U) {
      var K = this._polygon;
      return K && this._lineGroup.remove(K), K = new ECPolygon({
        shape: {
          points: G,
          stackedOnPoints: U
        },
        segmentIgnoreThreshold: 2
      }), this._lineGroup.add(K), this._polygon = K, K;
    }, C.prototype._initSymbolLabelAnimation = function(G, U, K) {
      var W, Z, X = U.getBaseAxis(), Q = X.inverse;
      U.type === "cartesian2d" ? (W = X.isHorizontal(), Z = !1) : U.type === "polar" && (W = X.dim === "angle", Z = !0);
      var ee = G.hostModel, te = ee.get("animationDuration");
      isFunction(te) && (te = te(null));
      var re = ee.get("animationDelay") || 0, ne = isFunction(re) ? re(null) : re;
      G.eachItemGraphicEl(function(ae, ie) {
        var se = ae;
        if (se) {
          var oe = [ae.x, ae.y], le = void 0, ue = void 0, ce = void 0;
          if (K)
            if (Z) {
              var de = K, ge = U.pointToCoord(oe);
              W ? (le = de.startAngle, ue = de.endAngle, ce = -ge[1] / 180 * Math.PI) : (le = de.r0, ue = de.r, ce = ge[0]);
            } else {
              var fe = K;
              W ? (le = fe.x, ue = fe.x + fe.width, ce = ae.x) : (le = fe.y + fe.height, ue = fe.y, ce = ae.y);
            }
          var ve = ue === le ? 0 : (ce - le) / (ue - le);
          Q && (ve = 1 - ve);
          var pe = isFunction(re) ? re(ie) : te * ve + ne, he = se.getSymbolPath(), me = he.getTextContent();
          se.attr({
            scaleX: 0,
            scaleY: 0
          }), se.animateTo({
            scaleX: 1,
            scaleY: 1
          }, {
            duration: 200,
            setToFinal: !0,
            delay: pe
          }), me && me.animateFrom({
            style: {
              opacity: 0
            }
          }, {
            duration: 300,
            delay: pe
          }), he.disableLabelAnimation = !0;
        }
      });
    }, C.prototype._initOrUpdateEndLabel = function(G, U, K) {
      var W = G.getModel("endLabel");
      if (anyStateShowEndLabel(G)) {
        var Z = G.getData(), X = this._polyline, Q = Z.getLayout("points");
        if (!Q) {
          X.removeTextContent(), this._endLabel = null;
          return;
        }
        var ee = this._endLabel;
        ee || (ee = this._endLabel = new ZRText$1({
          z2: 200
          // should be higher than item symbol
        }), ee.ignoreClip = !0, X.setTextContent(this._endLabel), X.disableLabelAnimation = !0);
        var te = getLastIndexNotNull(Q);
        te >= 0 && (setLabelStyle(X, getLabelStatesModels(G, "endLabel"), {
          inheritColor: K,
          labelFetcher: G,
          labelDataIndex: te,
          defaultText: function(re, ne, ae) {
            return ae != null ? getDefaultInterpolatedLabel(Z, ae) : getDefaultLabel(Z, re);
          },
          enableTextSetter: !0
        }, getEndLabelStateSpecified(W, U)), X.textConfig.position = null);
      } else
        this._endLabel && (this._polyline.removeTextContent(), this._endLabel = null);
    }, C.prototype._endLabelOnDuring = function(G, U, K, W, Z, X, Q) {
      var ee = this._endLabel, te = this._polyline;
      if (ee) {
        G < 1 && W.originalX == null && (W.originalX = ee.x, W.originalY = ee.y);
        var re = K.getLayout("points"), ne = K.hostModel, ae = ne.get("connectNulls"), ie = X.get("precision"), se = X.get("distance") || 0, oe = Q.getBaseAxis(), le = oe.isHorizontal(), ue = oe.inverse, ce = U.shape, de = ue ? le ? ce.x : ce.y + ce.height : le ? ce.x + ce.width : ce.y, ge = (le ? se : 0) * (ue ? -1 : 1), fe = (le ? 0 : -se) * (ue ? -1 : 1), ve = le ? "x" : "y", pe = getIndexRange(re, de, ve), he = pe.range, me = he[1] - he[0], ye = void 0;
        if (me >= 1) {
          if (me > 1 && !ae) {
            var Ce = getPointAtIndex(re, he[0]);
            ee.attr({
              x: Ce[0] + ge,
              y: Ce[1] + fe
            }), Z && (ye = ne.getRawValue(he[0]));
          } else {
            var Ce = te.getPointOn(de, ve);
            Ce && ee.attr({
              x: Ce[0] + ge,
              y: Ce[1] + fe
            });
            var Ie = ne.getRawValue(he[0]), be = ne.getRawValue(he[1]);
            Z && (ye = interpolateRawValues(K, ie, Ie, be, pe.t));
          }
          W.lastFrameIndex = he[0];
        } else {
          var Se = G === 1 || W.lastFrameIndex > 0 ? he[0] : 0, Ce = getPointAtIndex(re, Se);
          Z && (ye = ne.getRawValue(Se)), ee.attr({
            x: Ce[0] + ge,
            y: Ce[1] + fe
          });
        }
        Z && labelInner(ee).setLabelText(ye);
      }
    }, C.prototype._doUpdateAnimation = function(G, U, K, W, Z, X, Q) {
      var ee = this._polyline, te = this._polygon, re = G.hostModel, ne = lineAnimationDiff(this._data, G, this._stackedOnPoints, U, this._coordSys, K, this._valueOrigin), ae = ne.current, ie = ne.stackedOnCurrent, se = ne.next, oe = ne.stackedOnNext;
      if (Z && (ae = turnPointsIntoStep(ne.current, K, Z, Q), ie = turnPointsIntoStep(ne.stackedOnCurrent, K, Z, Q), se = turnPointsIntoStep(ne.next, K, Z, Q), oe = turnPointsIntoStep(ne.stackedOnNext, K, Z, Q)), getBoundingDiff(ae, se) > 3e3 || te && getBoundingDiff(ie, oe) > 3e3) {
        ee.stopAnimation(), ee.setShape({
          points: se
        }), te && (te.stopAnimation(), te.setShape({
          points: se,
          stackedOnPoints: oe
        }));
        return;
      }
      ee.shape.__points = ne.current, ee.shape.points = ae;
      var le = {
        shape: {
          points: se
        }
      };
      ne.current !== ae && (le.shape.__points = ne.next), ee.stopAnimation(), updateProps$1(ee, le, re), te && (te.setShape({
        // Reuse the points with polyline.
        points: ae,
        stackedOnPoints: ie
      }), te.stopAnimation(), updateProps$1(te, {
        shape: {
          stackedOnPoints: oe
        }
      }, re), ee.shape.points !== te.shape.points && (te.shape.points = ee.shape.points));
      for (var ue = [], ce = ne.status, de = 0; de < ce.length; de++) {
        var ge = ce[de].cmd;
        if (ge === "=") {
          var fe = G.getItemGraphicEl(ce[de].idx1);
          fe && ue.push({
            el: fe,
            ptIdx: de
            // Index of points
          });
        }
      }
      ee.animators && ee.animators.length && ee.animators[0].during(function() {
        te && te.dirtyShape();
        for (var ve = ee.shape.__points, pe = 0; pe < ue.length; pe++) {
          var he = ue[pe].el, me = ue[pe].ptIdx * 2;
          he.x = ve[me], he.y = ve[me + 1], he.markRedraw();
        }
      });
    }, C.prototype.remove = function(G) {
      var U = this.group, K = this._data;
      this._lineGroup.removeAll(), this._symbolDraw.remove(!0), K && K.eachItemGraphicEl(function(W, Z) {
        W.__temp && (U.remove(W), K.setItemGraphicEl(Z, null));
      }), this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._endLabel = this._data = null;
    }, C.type = "line", C;
  }(ChartView$1)
);
const LineView$1 = LineView;
function pointsLayout(H, C) {
  return {
    seriesType: H,
    plan: createRenderPlanner(),
    reset: function(G) {
      var U = G.getData(), K = G.coordinateSystem, W = G.pipelineContext, Z = C || W.large;
      if (K) {
        var X = map$1(K.dimensions, function(ae) {
          return U.mapDimension(ae);
        }).slice(0, 2), Q = X.length, ee = U.getCalculationInfo("stackResultDimension");
        isDimensionStacked(U, X[0]) && (X[0] = ee), isDimensionStacked(U, X[1]) && (X[1] = ee);
        var te = U.getStore(), re = U.getDimensionIndex(X[0]), ne = U.getDimensionIndex(X[1]);
        return Q && {
          progress: function(ae, ie) {
            for (var se = ae.end - ae.start, oe = Z && createFloat32Array(se * Q), le = [], ue = [], ce = ae.start, de = 0; ce < ae.end; ce++) {
              var ge = void 0;
              if (Q === 1) {
                var fe = te.get(re, ce);
                ge = K.dataToPoint(fe, null, ue);
              } else
                le[0] = te.get(re, ce), le[1] = te.get(ne, ce), ge = K.dataToPoint(le, null, ue);
              Z ? (oe[de++] = ge[0], oe[de++] = ge[1]) : ie.setItemLayout(ce, ge.slice());
            }
            Z && ie.setLayout("points", oe);
          }
        };
      }
    }
  };
}
var samplers = {
  average: function(H) {
    for (var C = 0, G = 0, U = 0; U < H.length; U++)
      isNaN(H[U]) || (C += H[U], G++);
    return G === 0 ? NaN : C / G;
  },
  sum: function(H) {
    for (var C = 0, G = 0; G < H.length; G++)
      C += H[G] || 0;
    return C;
  },
  max: function(H) {
    for (var C = -1 / 0, G = 0; G < H.length; G++)
      H[G] > C && (C = H[G]);
    return isFinite(C) ? C : NaN;
  },
  min: function(H) {
    for (var C = 1 / 0, G = 0; G < H.length; G++)
      H[G] < C && (C = H[G]);
    return isFinite(C) ? C : NaN;
  },
  // TODO
  // Median
  nearest: function(H) {
    return H[0];
  }
}, indexSampler = function(H) {
  return Math.round(H.length / 2);
};
function dataSample(H) {
  return {
    seriesType: H,
    // FIXME:TS never used, so comment it
    // modifyOutputEnd: true,
    reset: function(C, G, U) {
      var K = C.getData(), W = C.get("sampling"), Z = C.coordinateSystem, X = K.count();
      if (X > 10 && Z.type === "cartesian2d" && W) {
        var Q = Z.getBaseAxis(), ee = Z.getOtherAxis(Q), te = Q.getExtent(), re = U.getDevicePixelRatio(), ne = Math.abs(te[1] - te[0]) * (re || 1), ae = Math.round(X / ne);
        if (isFinite(ae) && ae > 1) {
          W === "lttb" && C.setData(K.lttbDownSample(K.mapDimension(ee.dim), 1 / ae));
          var ie = void 0;
          isString(W) ? ie = samplers[W] : isFunction(W) && (ie = W), ie && C.setData(K.downSample(K.mapDimension(ee.dim), 1 / ae, ie, indexSampler));
        }
      }
    }
  };
}
function install$Q(H) {
  H.registerChartView(LineView$1), H.registerSeriesModel(LineSeries), H.registerLayout(pointsLayout("line", !0)), H.registerVisual({
    seriesType: "line",
    reset: function(C) {
      var G = C.getData(), U = C.getModel("lineStyle").getLineStyle();
      U && !U.stroke && (U.stroke = G.getVisual("style").fill), G.setVisual("legendLineStyle", U);
    }
  }), H.registerProcessor(H.PRIORITY.PROCESSOR.STATISTIC, dataSample("line"));
}
var BaseBarSeriesModel = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G;
    }
    return C.prototype.getInitialData = function(G, U) {
      return createSeriesData(null, this, {
        useEncodeDefaulter: !0
      });
    }, C.prototype.getMarkerPosition = function(G, U, K) {
      var W = this.coordinateSystem;
      if (W && W.clampData) {
        var Z = W.dataToPoint(W.clampData(G));
        if (K)
          each$f(W.getAxes(), function(re, ne) {
            if (re.type === "category") {
              var ae = re.getTicksCoords(), ie = W.clampData(G)[ne];
              U && (U[ne] === "x1" || U[ne] === "y1") && (ie += 1), ie > ae.length - 1 && (ie = ae.length - 1), ie < 0 && (ie = 0), ae[ie] && (Z[ne] = re.toGlobalCoord(ae[ie].coord));
            }
          });
        else {
          var X = this.getData(), Q = X.getLayout("offset"), ee = X.getLayout("size"), te = W.getBaseAxis().isHorizontal() ? 0 : 1;
          Z[te] += Q + ee / 2;
        }
        return Z;
      }
      return [NaN, NaN];
    }, C.type = "series.__base_bar__", C.defaultOption = {
      // zlevel: 0,
      z: 2,
      coordinateSystem: "cartesian2d",
      legendHoverLink: !0,
      // stack: null
      // Cartesian coordinate system
      // xAxisIndex: 0,
      // yAxisIndex: 0,
      barMinHeight: 0,
      barMinAngle: 0,
      // cursor: null,
      large: !1,
      largeThreshold: 400,
      progressive: 3e3,
      progressiveChunkMode: "mod"
    }, C;
  }(SeriesModel$1)
);
SeriesModel$1.registerClass(BaseBarSeriesModel);
const BaseBarSeriesModel$1 = BaseBarSeriesModel;
var BarSeriesModel = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G;
    }
    return C.prototype.getInitialData = function() {
      return createSeriesData(null, this, {
        useEncodeDefaulter: !0,
        createInvertedIndices: !!this.get("realtimeSort", !0) || null
      });
    }, C.prototype.getProgressive = function() {
      return this.get("large") ? this.get("progressive") : !1;
    }, C.prototype.getProgressiveThreshold = function() {
      var G = this.get("progressiveThreshold"), U = this.get("largeThreshold");
      return U > G && (G = U), G;
    }, C.prototype.brushSelector = function(G, U, K) {
      return K.rect(U.getItemLayout(G));
    }, C.type = "series.bar", C.dependencies = ["grid", "polar"], C.defaultOption = inheritDefaultOption(BaseBarSeriesModel$1.defaultOption, {
      // If clipped
      // Only available on cartesian2d
      clip: !0,
      roundCap: !1,
      showBackground: !1,
      backgroundStyle: {
        color: "rgba(180, 180, 180, 0.2)",
        borderColor: null,
        borderWidth: 0,
        borderType: "solid",
        borderRadius: 0,
        shadowBlur: 0,
        shadowColor: null,
        shadowOffsetX: 0,
        shadowOffsetY: 0,
        opacity: 1
      },
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      },
      realtimeSort: !1
    }), C;
  }(BaseBarSeriesModel$1)
);
const BarSeries = BarSeriesModel;
var SausageShape = (
  /** @class */
  function() {
    function H() {
      this.cx = 0, this.cy = 0, this.r0 = 0, this.r = 0, this.startAngle = 0, this.endAngle = Math.PI * 2, this.clockwise = !0;
    }
    return H;
  }()
), SausagePath = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C(G) {
      var U = H.call(this, G) || this;
      return U.type = "sausage", U;
    }
    return C.prototype.getDefaultShape = function() {
      return new SausageShape();
    }, C.prototype.buildPath = function(G, U) {
      var K = U.cx, W = U.cy, Z = Math.max(U.r0 || 0, 0), X = Math.max(U.r, 0), Q = (X - Z) * 0.5, ee = Z + Q, te = U.startAngle, re = U.endAngle, ne = U.clockwise, ae = Math.PI * 2, ie = ne ? re - te < ae : te - re < ae;
      ie || (te = re - (ne ? ae : -ae));
      var se = Math.cos(te), oe = Math.sin(te), le = Math.cos(re), ue = Math.sin(re);
      ie ? (G.moveTo(se * Z + K, oe * Z + W), G.arc(se * ee + K, oe * ee + W, Q, -Math.PI + te, te, !ne)) : G.moveTo(se * X + K, oe * X + W), G.arc(K, W, X, te, re, !ne), G.arc(le * ee + K, ue * ee + W, Q, re - Math.PI * 2, re - Math.PI, !ne), Z !== 0 && G.arc(K, W, Z, re, te, ne);
    }, C;
  }(Path$1)
);
const Sausage = SausagePath;
function createSectorCalculateTextPosition(H, C) {
  C = C || {};
  var G = C.isRoundCap;
  return function(U, K, W) {
    var Z = K.position;
    if (!Z || Z instanceof Array)
      return calculateTextPosition(U, K, W);
    var X = H(Z), Q = K.distance != null ? K.distance : 5, ee = this.shape, te = ee.cx, re = ee.cy, ne = ee.r, ae = ee.r0, ie = (ne + ae) / 2, se = ee.startAngle, oe = ee.endAngle, le = (se + oe) / 2, ue = G ? Math.abs(ne - ae) / 2 : 0, ce = Math.cos, de = Math.sin, ge = te + ne * ce(se), fe = re + ne * de(se), ve = "left", pe = "top";
    switch (X) {
      case "startArc":
        ge = te + (ae - Q) * ce(le), fe = re + (ae - Q) * de(le), ve = "center", pe = "top";
        break;
      case "insideStartArc":
        ge = te + (ae + Q) * ce(le), fe = re + (ae + Q) * de(le), ve = "center", pe = "bottom";
        break;
      case "startAngle":
        ge = te + ie * ce(se) + adjustAngleDistanceX(se, Q + ue, !1), fe = re + ie * de(se) + adjustAngleDistanceY(se, Q + ue, !1), ve = "right", pe = "middle";
        break;
      case "insideStartAngle":
        ge = te + ie * ce(se) + adjustAngleDistanceX(se, -Q + ue, !1), fe = re + ie * de(se) + adjustAngleDistanceY(se, -Q + ue, !1), ve = "left", pe = "middle";
        break;
      case "middle":
        ge = te + ie * ce(le), fe = re + ie * de(le), ve = "center", pe = "middle";
        break;
      case "endArc":
        ge = te + (ne + Q) * ce(le), fe = re + (ne + Q) * de(le), ve = "center", pe = "bottom";
        break;
      case "insideEndArc":
        ge = te + (ne - Q) * ce(le), fe = re + (ne - Q) * de(le), ve = "center", pe = "top";
        break;
      case "endAngle":
        ge = te + ie * ce(oe) + adjustAngleDistanceX(oe, Q + ue, !0), fe = re + ie * de(oe) + adjustAngleDistanceY(oe, Q + ue, !0), ve = "left", pe = "middle";
        break;
      case "insideEndAngle":
        ge = te + ie * ce(oe) + adjustAngleDistanceX(oe, -Q + ue, !0), fe = re + ie * de(oe) + adjustAngleDistanceY(oe, -Q + ue, !0), ve = "right", pe = "middle";
        break;
      default:
        return calculateTextPosition(U, K, W);
    }
    return U = U || {}, U.x = ge, U.y = fe, U.align = ve, U.verticalAlign = pe, U;
  };
}
function setSectorTextRotation(H, C, G, U) {
  if (isNumber(U)) {
    H.setTextConfig({
      rotation: U
    });
    return;
  } else if (isArray$1(C)) {
    H.setTextConfig({
      rotation: 0
    });
    return;
  }
  var K = H.shape, W = K.clockwise ? K.startAngle : K.endAngle, Z = K.clockwise ? K.endAngle : K.startAngle, X = (W + Z) / 2, Q, ee = G(C);
  switch (ee) {
    case "startArc":
    case "insideStartArc":
    case "middle":
    case "insideEndArc":
    case "endArc":
      Q = X;
      break;
    case "startAngle":
    case "insideStartAngle":
      Q = W;
      break;
    case "endAngle":
    case "insideEndAngle":
      Q = Z;
      break;
    default:
      H.setTextConfig({
        rotation: 0
      });
      return;
  }
  var te = Math.PI * 1.5 - Q;
  ee === "middle" && te > Math.PI / 2 && te < Math.PI * 1.5 && (te -= Math.PI), H.setTextConfig({
    rotation: te
  });
}
function adjustAngleDistanceX(H, C, G) {
  return C * Math.sin(H) * (G ? -1 : 1);
}
function adjustAngleDistanceY(H, C, G) {
  return C * Math.cos(H) * (G ? 1 : -1);
}
var mathMax$4 = Math.max, mathMin$4 = Math.min;
function getClipArea(H, C) {
  var G = H.getArea && H.getArea();
  if (isCoordinateSystemType(H, "cartesian2d")) {
    var U = H.getBaseAxis();
    if (U.type !== "category" || !U.onBand) {
      var K = C.getLayout("bandWidth");
      U.isHorizontal() ? (G.x -= K, G.width += K * 2) : (G.y -= K, G.height += K * 2);
    }
  }
  return G;
}
var BarView = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H.call(this) || this;
      return G.type = C.type, G._isFirstFrame = !0, G;
    }
    return C.prototype.render = function(G, U, K, W) {
      this._model = G, this._removeOnRenderedListener(K), this._updateDrawMode(G);
      var Z = G.get("coordinateSystem");
      Z === "cartesian2d" || Z === "polar" ? (this._progressiveEls = null, this._isLargeDraw ? this._renderLarge(G, U, K) : this._renderNormal(G, U, K, W)) : process.env.NODE_ENV !== "production" && warn("Only cartesian2d and polar supported for bar.");
    }, C.prototype.incrementalPrepareRender = function(G) {
      this._clear(), this._updateDrawMode(G), this._updateLargeClip(G);
    }, C.prototype.incrementalRender = function(G, U) {
      this._progressiveEls = [], this._incrementalRenderLarge(G, U);
    }, C.prototype.eachRendered = function(G) {
      traverseElements(this._progressiveEls || this.group, G);
    }, C.prototype._updateDrawMode = function(G) {
      var U = G.pipelineContext.large;
      (this._isLargeDraw == null || U !== this._isLargeDraw) && (this._isLargeDraw = U, this._clear());
    }, C.prototype._renderNormal = function(G, U, K, W) {
      var Z = this.group, X = G.getData(), Q = this._data, ee = G.coordinateSystem, te = ee.getBaseAxis(), re;
      ee.type === "cartesian2d" ? re = te.isHorizontal() : ee.type === "polar" && (re = te.dim === "angle");
      var ne = G.isAnimationEnabled() ? G : null, ae = shouldRealtimeSort(G, ee);
      ae && this._enableRealtimeSort(ae, X, K);
      var ie = G.get("clip", !0) || ae, se = getClipArea(ee, X);
      Z.removeClipPath();
      var oe = G.get("roundCap", !0), le = G.get("showBackground", !0), ue = G.getModel("backgroundStyle"), ce = ue.get("borderRadius") || 0, de = [], ge = this._backgroundEls, fe = W && W.isInitSort, ve = W && W.type === "changeAxisOrder";
      function pe(ye) {
        var Ce = getLayout[ee.type](X, ye), Ie = createBackgroundEl(ee, re, Ce);
        return Ie.useStyle(ue.getItemStyle()), ee.type === "cartesian2d" && Ie.setShape("r", ce), de[ye] = Ie, Ie;
      }
      X.diff(Q).add(function(ye) {
        var Ce = X.getItemModel(ye), Ie = getLayout[ee.type](X, ye, Ce);
        if (le && pe(ye), !(!X.hasValue(ye) || !isValidLayout[ee.type](Ie))) {
          var be = !1;
          ie && (be = clip[ee.type](se, Ie));
          var Se = elementCreator[ee.type](G, X, ye, Ie, re, ne, te.model, !1, oe);
          ae && (Se.forceLabelAnimation = !0), updateStyle(Se, X, ye, Ce, Ie, G, re, ee.type === "polar"), fe ? Se.attr({
            shape: Ie
          }) : ae ? updateRealtimeAnimation(ae, ne, Se, Ie, ye, re, !1, !1) : initProps(Se, {
            shape: Ie
          }, G, ye), X.setItemGraphicEl(ye, Se), Z.add(Se), Se.ignore = be;
        }
      }).update(function(ye, Ce) {
        var Ie = X.getItemModel(ye), be = getLayout[ee.type](X, ye, Ie);
        if (le) {
          var Se = void 0;
          ge.length === 0 ? Se = pe(Ce) : (Se = ge[Ce], Se.useStyle(ue.getItemStyle()), ee.type === "cartesian2d" && Se.setShape("r", ce), de[ye] = Se);
          var Ae = getLayout[ee.type](X, ye), _e = createBackgroundShape(re, Ae, ee);
          updateProps$1(Se, {
            shape: _e
          }, ne, ye);
        }
        var xe = Q.getItemGraphicEl(Ce);
        if (!X.hasValue(ye) || !isValidLayout[ee.type](be)) {
          Z.remove(xe);
          return;
        }
        var Te = !1;
        if (ie && (Te = clip[ee.type](se, be), Te && Z.remove(xe)), xe ? saveOldStyle(xe) : xe = elementCreator[ee.type](G, X, ye, be, re, ne, te.model, !!xe, oe), ae && (xe.forceLabelAnimation = !0), ve) {
          var Pe = xe.getTextContent();
          if (Pe) {
            var $e = labelInner(Pe);
            $e.prevValue != null && ($e.prevValue = $e.value);
          }
        } else
          updateStyle(xe, X, ye, Ie, be, G, re, ee.type === "polar");
        fe ? xe.attr({
          shape: be
        }) : ae ? updateRealtimeAnimation(ae, ne, xe, be, ye, re, !0, ve) : updateProps$1(xe, {
          shape: be
        }, G, ye, null), X.setItemGraphicEl(ye, xe), xe.ignore = Te, Z.add(xe);
      }).remove(function(ye) {
        var Ce = Q.getItemGraphicEl(ye);
        Ce && removeElementWithFadeOut(Ce, G, ye);
      }).execute();
      var he = this._backgroundGroup || (this._backgroundGroup = new Group$4());
      he.removeAll();
      for (var me = 0; me < de.length; ++me)
        he.add(de[me]);
      Z.add(he), this._backgroundEls = de, this._data = X;
    }, C.prototype._renderLarge = function(G, U, K) {
      this._clear(), createLarge$1(G, this.group), this._updateLargeClip(G);
    }, C.prototype._incrementalRenderLarge = function(G, U) {
      this._removeBackground(), createLarge$1(U, this.group, this._progressiveEls, !0);
    }, C.prototype._updateLargeClip = function(G) {
      var U = G.get("clip", !0) && createClipPath(G.coordinateSystem, !1, G), K = this.group;
      U ? K.setClipPath(U) : K.removeClipPath();
    }, C.prototype._enableRealtimeSort = function(G, U, K) {
      var W = this;
      if (U.count()) {
        var Z = G.baseAxis;
        if (this._isFirstFrame)
          this._dispatchInitSort(U, G, K), this._isFirstFrame = !1;
        else {
          var X = function(Q) {
            var ee = U.getItemGraphicEl(Q), te = ee && ee.shape;
            return te && // The result should be consistent with the initial sort by data value.
            // Do not support the case that both positive and negative exist.
            Math.abs(Z.isHorizontal() ? te.height : te.width) || 0;
          };
          this._onRendered = function() {
            W._updateSortWithinSameData(U, X, Z, K);
          }, K.getZr().on("rendered", this._onRendered);
        }
      }
    }, C.prototype._dataSort = function(G, U, K) {
      var W = [];
      return G.each(G.mapDimension(U.dim), function(Z, X) {
        var Q = K(X);
        Q = Q ?? NaN, W.push({
          dataIndex: X,
          mappedValue: Q,
          ordinalNumber: Z
        });
      }), W.sort(function(Z, X) {
        return X.mappedValue - Z.mappedValue;
      }), {
        ordinalNumbers: map$1(W, function(Z) {
          return Z.ordinalNumber;
        })
      };
    }, C.prototype._isOrderChangedWithinSameData = function(G, U, K) {
      for (var W = K.scale, Z = G.mapDimension(K.dim), X = Number.MAX_VALUE, Q = 0, ee = W.getOrdinalMeta().categories.length; Q < ee; ++Q) {
        var te = G.rawIndexOf(Z, W.getRawOrdinalNumber(Q)), re = te < 0 ? Number.MIN_VALUE : U(G.indexOfRawIndex(te));
        if (re > X)
          return !0;
        X = re;
      }
      return !1;
    }, C.prototype._isOrderDifferentInView = function(G, U) {
      for (var K = U.scale, W = K.getExtent(), Z = Math.max(0, W[0]), X = Math.min(W[1], K.getOrdinalMeta().categories.length - 1); Z <= X; ++Z)
        if (G.ordinalNumbers[Z] !== K.getRawOrdinalNumber(Z))
          return !0;
    }, C.prototype._updateSortWithinSameData = function(G, U, K, W) {
      if (this._isOrderChangedWithinSameData(G, U, K)) {
        var Z = this._dataSort(G, K, U);
        this._isOrderDifferentInView(Z, K) && (this._removeOnRenderedListener(W), W.dispatchAction({
          type: "changeAxisOrder",
          componentType: K.dim + "Axis",
          axisId: K.index,
          sortInfo: Z
        }));
      }
    }, C.prototype._dispatchInitSort = function(G, U, K) {
      var W = U.baseAxis, Z = this._dataSort(G, W, function(X) {
        return G.get(G.mapDimension(U.otherAxis.dim), X);
      });
      K.dispatchAction({
        type: "changeAxisOrder",
        componentType: W.dim + "Axis",
        isInitSort: !0,
        axisId: W.index,
        sortInfo: Z
      });
    }, C.prototype.remove = function(G, U) {
      this._clear(this._model), this._removeOnRenderedListener(U);
    }, C.prototype.dispose = function(G, U) {
      this._removeOnRenderedListener(U);
    }, C.prototype._removeOnRenderedListener = function(G) {
      this._onRendered && (G.getZr().off("rendered", this._onRendered), this._onRendered = null);
    }, C.prototype._clear = function(G) {
      var U = this.group, K = this._data;
      G && G.isAnimationEnabled() && K && !this._isLargeDraw ? (this._removeBackground(), this._backgroundEls = [], K.eachItemGraphicEl(function(W) {
        removeElementWithFadeOut(W, G, getECData(W).dataIndex);
      })) : U.removeAll(), this._data = null, this._isFirstFrame = !0;
    }, C.prototype._removeBackground = function() {
      this.group.remove(this._backgroundGroup), this._backgroundGroup = null;
    }, C.type = "bar", C;
  }(ChartView$1)
), clip = {
  cartesian2d: function(H, C) {
    var G = C.width < 0 ? -1 : 1, U = C.height < 0 ? -1 : 1;
    G < 0 && (C.x += C.width, C.width = -C.width), U < 0 && (C.y += C.height, C.height = -C.height);
    var K = H.x + H.width, W = H.y + H.height, Z = mathMax$4(C.x, H.x), X = mathMin$4(C.x + C.width, K), Q = mathMax$4(C.y, H.y), ee = mathMin$4(C.y + C.height, W), te = X < Z, re = ee < Q;
    return C.x = te && Z > K ? X : Z, C.y = re && Q > W ? ee : Q, C.width = te ? 0 : X - Z, C.height = re ? 0 : ee - Q, G < 0 && (C.x += C.width, C.width = -C.width), U < 0 && (C.y += C.height, C.height = -C.height), te || re;
  },
  polar: function(H, C) {
    var G = C.r0 <= C.r ? 1 : -1;
    if (G < 0) {
      var U = C.r;
      C.r = C.r0, C.r0 = U;
    }
    var K = mathMin$4(C.r, H.r), W = mathMax$4(C.r0, H.r0);
    C.r = K, C.r0 = W;
    var Z = K - W < 0;
    if (G < 0) {
      var U = C.r;
      C.r = C.r0, C.r0 = U;
    }
    return Z;
  }
}, elementCreator = {
  cartesian2d: function(H, C, G, U, K, W, Z, X, Q) {
    var ee = new Rect$3({
      shape: extend({}, U),
      z2: 1
    });
    if (ee.__dataIndex = G, ee.name = "item", W) {
      var te = ee.shape, re = K ? "height" : "width";
      te[re] = 0;
    }
    return ee;
  },
  polar: function(H, C, G, U, K, W, Z, X, Q) {
    var ee = !K && Q ? Sausage : Sector$1, te = new ee({
      shape: U,
      z2: 1
    });
    te.name = "item";
    var re = createPolarPositionMapping(K);
    if (te.calculateTextPosition = createSectorCalculateTextPosition(re, {
      isRoundCap: ee === Sausage
    }), W) {
      var ne = te.shape, ae = K ? "r" : "endAngle", ie = {};
      ne[ae] = K ? 0 : U.startAngle, ie[ae] = U[ae], (X ? updateProps$1 : initProps)(te, {
        shape: ie
        // __value: typeof dataValue === 'string' ? parseInt(dataValue, 10) : dataValue
      }, W);
    }
    return te;
  }
};
function shouldRealtimeSort(H, C) {
  var G = H.get("realtimeSort", !0), U = C.getBaseAxis();
  if (process.env.NODE_ENV !== "production" && G && (U.type !== "category" && warn("`realtimeSort` will not work because this bar series is not based on a category axis."), C.type !== "cartesian2d" && warn("`realtimeSort` will not work because this bar series is not on cartesian2d.")), G && U.type === "category" && C.type === "cartesian2d")
    return {
      baseAxis: U,
      otherAxis: C.getOtherAxis(U)
    };
}
function updateRealtimeAnimation(H, C, G, U, K, W, Z, X) {
  var Q, ee;
  W ? (ee = {
    x: U.x,
    width: U.width
  }, Q = {
    y: U.y,
    height: U.height
  }) : (ee = {
    y: U.y,
    height: U.height
  }, Q = {
    x: U.x,
    width: U.width
  }), X || (Z ? updateProps$1 : initProps)(G, {
    shape: Q
  }, C, K, null);
  var te = C ? H.baseAxis.model : null;
  (Z ? updateProps$1 : initProps)(G, {
    shape: ee
  }, te, K);
}
function checkPropertiesNotValid(H, C) {
  for (var G = 0; G < C.length; G++)
    if (!isFinite(H[C[G]]))
      return !0;
  return !1;
}
var rectPropties = ["x", "y", "width", "height"], polarPropties = ["cx", "cy", "r", "startAngle", "endAngle"], isValidLayout = {
  cartesian2d: function(H) {
    return !checkPropertiesNotValid(H, rectPropties);
  },
  polar: function(H) {
    return !checkPropertiesNotValid(H, polarPropties);
  }
}, getLayout = {
  // itemModel is only used to get borderWidth, which is not needed
  // when calculating bar background layout.
  cartesian2d: function(H, C, G) {
    var U = H.getItemLayout(C), K = G ? getLineWidth(G, U) : 0, W = U.width > 0 ? 1 : -1, Z = U.height > 0 ? 1 : -1;
    return {
      x: U.x + W * K / 2,
      y: U.y + Z * K / 2,
      width: U.width - W * K,
      height: U.height - Z * K
    };
  },
  polar: function(H, C, G) {
    var U = H.getItemLayout(C);
    return {
      cx: U.cx,
      cy: U.cy,
      r0: U.r0,
      r: U.r,
      startAngle: U.startAngle,
      endAngle: U.endAngle,
      clockwise: U.clockwise
    };
  }
};
function isZeroOnPolar(H) {
  return H.startAngle != null && H.endAngle != null && H.startAngle === H.endAngle;
}
function createPolarPositionMapping(H) {
  return function(C) {
    var G = C ? "Arc" : "Angle";
    return function(U) {
      switch (U) {
        case "start":
        case "insideStart":
        case "end":
        case "insideEnd":
          return U + G;
        default:
          return U;
      }
    };
  }(H);
}
function updateStyle(H, C, G, U, K, W, Z, X) {
  var Q = C.getItemVisual(G, "style");
  X || H.setShape("r", U.get(["itemStyle", "borderRadius"]) || 0), H.useStyle(Q);
  var ee = U.getShallow("cursor");
  ee && H.attr("cursor", ee);
  var te = X ? Z ? K.r >= K.r0 ? "endArc" : "startArc" : K.endAngle >= K.startAngle ? "endAngle" : "startAngle" : Z ? K.height >= 0 ? "bottom" : "top" : K.width >= 0 ? "right" : "left", re = getLabelStatesModels(U);
  setLabelStyle(H, re, {
    labelFetcher: W,
    labelDataIndex: G,
    defaultText: getDefaultLabel(W.getData(), G),
    inheritColor: Q.fill,
    defaultOpacity: Q.opacity,
    defaultOutsidePosition: te
  });
  var ne = H.getTextContent();
  if (X && ne) {
    var ae = U.get(["label", "position"]);
    H.textConfig.inside = ae === "middle" ? !0 : null, setSectorTextRotation(H, ae === "outside" ? te : ae, createPolarPositionMapping(Z), U.get(["label", "rotate"]));
  }
  setLabelValueAnimation(ne, re, W.getRawValue(G), function(se) {
    return getDefaultInterpolatedLabel(C, se);
  });
  var ie = U.getModel(["emphasis"]);
  toggleHoverEmphasis(H, ie.get("focus"), ie.get("blurScope"), ie.get("disabled")), setStatesStylesFromModel(H, U), isZeroOnPolar(K) && (H.style.fill = "none", H.style.stroke = "none", each$f(H.states, function(se) {
    se.style && (se.style.fill = se.style.stroke = "none");
  }));
}
function getLineWidth(H, C) {
  var G = H.get(["itemStyle", "borderColor"]);
  if (!G || G === "none")
    return 0;
  var U = H.get(["itemStyle", "borderWidth"]) || 0, K = isNaN(C.width) ? Number.MAX_VALUE : Math.abs(C.width), W = isNaN(C.height) ? Number.MAX_VALUE : Math.abs(C.height);
  return Math.min(U, K, W);
}
var LagePathShape = (
  /** @class */
  function() {
    function H() {
    }
    return H;
  }()
), LargePath = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C(G) {
      var U = H.call(this, G) || this;
      return U.type = "largeBar", U;
    }
    return C.prototype.getDefaultShape = function() {
      return new LagePathShape();
    }, C.prototype.buildPath = function(G, U) {
      for (var K = U.points, W = this.baseDimIdx, Z = 1 - this.baseDimIdx, X = [], Q = [], ee = this.barWidth, te = 0; te < K.length; te += 3)
        Q[W] = ee, Q[Z] = K[te + 2], X[W] = K[te + W], X[Z] = K[te + Z], G.rect(X[0], X[1], Q[0], Q[1]);
    }, C;
  }(Path$1)
);
function createLarge$1(H, C, G, U) {
  var K = H.getData(), W = K.getLayout("valueAxisHorizontal") ? 1 : 0, Z = K.getLayout("largeDataIndices"), X = K.getLayout("size"), Q = H.getModel("backgroundStyle"), ee = K.getLayout("largeBackgroundPoints");
  if (ee) {
    var te = new LargePath({
      shape: {
        points: ee
      },
      incremental: !!U,
      silent: !0,
      z2: 0
    });
    te.baseDimIdx = W, te.largeDataIndices = Z, te.barWidth = X, te.useStyle(Q.getItemStyle()), C.add(te), G && G.push(te);
  }
  var re = new LargePath({
    shape: {
      points: K.getLayout("largePoints")
    },
    incremental: !!U,
    ignoreCoarsePointer: !0,
    z2: 1
  });
  re.baseDimIdx = W, re.largeDataIndices = Z, re.barWidth = X, C.add(re), re.useStyle(K.getVisual("style")), getECData(re).seriesIndex = H.seriesIndex, H.get("silent") || (re.on("mousedown", largePathUpdateDataIndex), re.on("mousemove", largePathUpdateDataIndex)), G && G.push(re);
}
var largePathUpdateDataIndex = throttle(function(H) {
  var C = this, G = largePathFindDataIndex(C, H.offsetX, H.offsetY);
  getECData(C).dataIndex = G >= 0 ? G : null;
}, 30, !1);
function largePathFindDataIndex(H, C, G) {
  for (var U = H.baseDimIdx, K = 1 - U, W = H.shape.points, Z = H.largeDataIndices, X = [], Q = [], ee = H.barWidth, te = 0, re = W.length / 3; te < re; te++) {
    var ne = te * 3;
    if (Q[U] = ee, Q[K] = W[ne + 2], X[U] = W[ne + U], X[K] = W[ne + K], Q[K] < 0 && (X[K] += Q[K], Q[K] = -Q[K]), C >= X[0] && C <= X[0] + Q[0] && G >= X[1] && G <= X[1] + Q[1])
      return Z[te];
  }
  return -1;
}
function createBackgroundShape(H, C, G) {
  if (isCoordinateSystemType(G, "cartesian2d")) {
    var U = C, K = G.getArea();
    return {
      x: H ? U.x : K.x,
      y: H ? K.y : U.y,
      width: H ? U.width : K.width,
      height: H ? K.height : U.height
    };
  } else {
    var K = G.getArea(), W = C;
    return {
      cx: K.cx,
      cy: K.cy,
      r0: H ? K.r0 : W.r0,
      r: H ? K.r : W.r,
      startAngle: H ? W.startAngle : 0,
      endAngle: H ? W.endAngle : Math.PI * 2
    };
  }
}
function createBackgroundEl(H, C, G) {
  var U = H.type === "polar" ? Sector$1 : Rect$3;
  return new U({
    shape: createBackgroundShape(C, G, H),
    silent: !0,
    z2: 0
  });
}
const BarView$1 = BarView;
function install$P(H) {
  H.registerChartView(BarView$1), H.registerSeriesModel(BarSeries), H.registerLayout(H.PRIORITY.VISUAL.LAYOUT, curry$1(layout$3, "bar")), H.registerLayout(H.PRIORITY.VISUAL.PROGRESSIVE_LAYOUT, createProgressiveLayout("bar")), H.registerProcessor(H.PRIORITY.PROCESSOR.STATISTIC, dataSample("bar")), H.registerAction({
    type: "changeAxisOrder",
    event: "changeAxisOrder",
    update: "update"
  }, function(C, G) {
    var U = C.componentType || "series";
    G.eachComponent({
      mainType: U,
      query: C
    }, function(K) {
      C.sortInfo && K.axis.setCategorySortInfo(C.sortInfo);
    });
  });
}
var PI2 = Math.PI * 2, RADIAN$2 = Math.PI / 180;
function getViewRect$5(H, C) {
  return getLayoutRect(H.getBoxLayoutParams(), {
    width: C.getWidth(),
    height: C.getHeight()
  });
}
function getBasicPieLayout(H, C) {
  var G = getViewRect$5(H, C), U = H.get("center"), K = H.get("radius");
  isArray$1(K) || (K = [0, K]);
  var W = parsePercent(G.width, C.getWidth()), Z = parsePercent(G.height, C.getHeight()), X = Math.min(W, Z), Q = parsePercent(K[0], X / 2), ee = parsePercent(K[1], X / 2), te, re, ne = H.coordinateSystem;
  if (ne) {
    var ae = ne.dataToPoint(U);
    te = ae[0] || 0, re = ae[1] || 0;
  } else
    isArray$1(U) || (U = [U, U]), te = parsePercent(U[0], W) + G.x, re = parsePercent(U[1], Z) + G.y;
  return {
    cx: te,
    cy: re,
    r0: Q,
    r: ee
  };
}
function pieLayout(H, C, G) {
  C.eachSeriesByType(H, function(U) {
    var K = U.getData(), W = K.mapDimension("value"), Z = getViewRect$5(U, G), X = getBasicPieLayout(U, G), Q = X.cx, ee = X.cy, te = X.r, re = X.r0, ne = -U.get("startAngle") * RADIAN$2, ae = U.get("minAngle") * RADIAN$2, ie = 0;
    K.each(W, function(me) {
      !isNaN(me) && ie++;
    });
    var se = K.getSum(W), oe = Math.PI / (se || ie) * 2, le = U.get("clockwise"), ue = U.get("roseType"), ce = U.get("stillShowZeroSum"), de = K.getDataExtent(W);
    de[0] = 0;
    var ge = PI2, fe = 0, ve = ne, pe = le ? 1 : -1;
    if (K.setLayout({
      viewRect: Z,
      r: te
    }), K.each(W, function(me, ye) {
      var Ce;
      if (isNaN(me)) {
        K.setItemLayout(ye, {
          angle: NaN,
          startAngle: NaN,
          endAngle: NaN,
          clockwise: le,
          cx: Q,
          cy: ee,
          r0: re,
          r: ue ? NaN : te
        });
        return;
      }
      ue !== "area" ? Ce = se === 0 && ce ? oe : me * oe : Ce = PI2 / ie, Ce < ae ? (Ce = ae, ge -= ae) : fe += me;
      var Ie = ve + pe * Ce;
      K.setItemLayout(ye, {
        angle: Ce,
        startAngle: ve,
        endAngle: Ie,
        clockwise: le,
        cx: Q,
        cy: ee,
        r0: re,
        r: ue ? linearMap$2(me, de, [re, te]) : te
      }), ve = Ie;
    }), ge < PI2 && ie)
      if (ge <= 1e-3) {
        var he = PI2 / ie;
        K.each(W, function(me, ye) {
          if (!isNaN(me)) {
            var Ce = K.getItemLayout(ye);
            Ce.angle = he, Ce.startAngle = ne + pe * ye * he, Ce.endAngle = ne + pe * (ye + 1) * he;
          }
        });
      } else
        oe = ge / fe, ve = ne, K.each(W, function(me, ye) {
          if (!isNaN(me)) {
            var Ce = K.getItemLayout(ye), Ie = Ce.angle === ae ? ae : me * oe;
            Ce.startAngle = ve, Ce.endAngle = ve + pe * Ie, ve += pe * Ie;
          }
        });
  });
}
function dataFilter$1(H) {
  return {
    seriesType: H,
    reset: function(C, G) {
      var U = G.findComponents({
        mainType: "legend"
      });
      if (!(!U || !U.length)) {
        var K = C.getData();
        K.filterSelf(function(W) {
          for (var Z = K.getName(W), X = 0; X < U.length; X++)
            if (!U[X].isSelected(Z))
              return !1;
          return !0;
        });
      }
    }
  };
}
var RADIAN$1 = Math.PI / 180;
function adjustSingleSide(H, C, G, U, K, W, Z, X, Q, ee) {
  if (H.length < 2)
    return;
  function te(se) {
    for (var oe = se.rB, le = oe * oe, ue = 0; ue < se.list.length; ue++) {
      var ce = se.list[ue], de = Math.abs(ce.label.y - G), ge = U + ce.len, fe = ge * ge, ve = Math.sqrt((1 - Math.abs(de * de / le)) * fe), pe = C + (ve + ce.len2) * K, he = pe - ce.label.x, me = ce.targetTextWidth - he * K;
      constrainTextWidth(ce, me, !0), ce.label.x = pe;
    }
  }
  function re(se) {
    for (var oe = {
      list: [],
      maxY: 0
    }, le = {
      list: [],
      maxY: 0
    }, ue = 0; ue < se.length; ue++)
      if (se[ue].labelAlignTo === "none") {
        var ce = se[ue], de = ce.label.y > G ? le : oe, ge = Math.abs(ce.label.y - G);
        if (ge >= de.maxY) {
          var fe = ce.label.x - C - ce.len2 * K, ve = U + ce.len, pe = Math.abs(fe) < ve ? Math.sqrt(ge * ge / (1 - fe * fe / ve / ve)) : ve;
          de.rB = pe, de.maxY = ge;
        }
        de.list.push(ce);
      }
    te(oe), te(le);
  }
  for (var ne = H.length, ae = 0; ae < ne; ae++)
    if (H[ae].position === "outer" && H[ae].labelAlignTo === "labelLine") {
      var ie = H[ae].label.x - ee;
      H[ae].linePoints[1][0] += ie, H[ae].label.x = ee;
    }
  shiftLayoutOnY(H, Q, Q + Z) && re(H);
}
function avoidOverlap(H, C, G, U, K, W, Z, X) {
  for (var Q = [], ee = [], te = Number.MAX_VALUE, re = -Number.MAX_VALUE, ne = 0; ne < H.length; ne++) {
    var ae = H[ne].label;
    isPositionCenter(H[ne]) || (ae.x < C ? (te = Math.min(te, ae.x), Q.push(H[ne])) : (re = Math.max(re, ae.x), ee.push(H[ne])));
  }
  for (var ne = 0; ne < H.length; ne++) {
    var ie = H[ne];
    if (!isPositionCenter(ie) && ie.linePoints) {
      if (ie.labelStyleWidth != null)
        continue;
      var ae = ie.label, se = ie.linePoints, oe = void 0;
      ie.labelAlignTo === "edge" ? ae.x < C ? oe = se[2][0] - ie.labelDistance - Z - ie.edgeDistance : oe = Z + K - ie.edgeDistance - se[2][0] - ie.labelDistance : ie.labelAlignTo === "labelLine" ? ae.x < C ? oe = te - Z - ie.bleedMargin : oe = Z + K - re - ie.bleedMargin : ae.x < C ? oe = ae.x - Z - ie.bleedMargin : oe = Z + K - ae.x - ie.bleedMargin, ie.targetTextWidth = oe, constrainTextWidth(ie, oe);
    }
  }
  adjustSingleSide(ee, C, G, U, 1, K, W, Z, X, re), adjustSingleSide(Q, C, G, U, -1, K, W, Z, X, te);
  for (var ne = 0; ne < H.length; ne++) {
    var ie = H[ne];
    if (!isPositionCenter(ie) && ie.linePoints) {
      var ae = ie.label, se = ie.linePoints, le = ie.labelAlignTo === "edge", ue = ae.style.padding, ce = ue ? ue[1] + ue[3] : 0, de = ae.style.backgroundColor ? 0 : ce, ge = ie.rect.width + de, fe = se[1][0] - se[2][0];
      le ? ae.x < C ? se[2][0] = Z + ie.edgeDistance + ge + ie.labelDistance : se[2][0] = Z + K - ie.edgeDistance - ge - ie.labelDistance : (ae.x < C ? se[2][0] = ae.x + ie.labelDistance : se[2][0] = ae.x - ie.labelDistance, se[1][0] = se[2][0] + fe), se[1][1] = se[2][1] = ae.y;
    }
  }
}
function constrainTextWidth(H, C, G) {
  if (G === void 0 && (G = !1), H.labelStyleWidth == null) {
    var U = H.label, K = U.style, W = H.rect, Z = K.backgroundColor, X = K.padding, Q = X ? X[1] + X[3] : 0, ee = K.overflow, te = W.width + (Z ? 0 : Q);
    if (C < te || G) {
      var re = W.height;
      if (ee && ee.match("break")) {
        U.setStyle("backgroundColor", null), U.setStyle("width", C - Q);
        var ne = U.getBoundingRect();
        U.setStyle("width", Math.ceil(ne.width)), U.setStyle("backgroundColor", Z);
      } else {
        var ae = C - Q, ie = C < te ? ae : (
          // Current available width is enough, but the text may have
          // already been wrapped with a smaller available width.
          G ? ae > H.unconstrainedWidth ? null : ae : (
            // Current available width is enough, so no need to
            // constrain.
            null
          )
        );
        U.setStyle("width", ie);
      }
      var se = U.getBoundingRect();
      W.width = se.width;
      var oe = (U.style.margin || 0) + 2.1;
      W.height = se.height + oe, W.y -= (W.height - re) / 2;
    }
  }
}
function isPositionCenter(H) {
  return H.position === "center";
}
function pieLabelLayout(H) {
  var C = H.getData(), G = [], U, K, W = !1, Z = (H.get("minShowLabelAngle") || 0) * RADIAN$1, X = C.getLayout("viewRect"), Q = C.getLayout("r"), ee = X.width, te = X.x, re = X.y, ne = X.height;
  function ae(fe) {
    fe.ignore = !0;
  }
  function ie(fe) {
    if (!fe.ignore)
      return !0;
    for (var ve in fe.states)
      if (fe.states[ve].ignore === !1)
        return !0;
    return !1;
  }
  C.each(function(fe) {
    var ve = C.getItemGraphicEl(fe), pe = ve.shape, he = ve.getTextContent(), me = ve.getTextGuideLine(), ye = C.getItemModel(fe), Ce = ye.getModel("label"), Ie = Ce.get("position") || ye.get(["emphasis", "label", "position"]), be = Ce.get("distanceToLabelLine"), Se = Ce.get("alignTo"), Ae = parsePercent(Ce.get("edgeDistance"), ee), _e = Ce.get("bleedMargin"), xe = ye.getModel("labelLine"), Te = xe.get("length");
    Te = parsePercent(Te, ee);
    var Pe = xe.get("length2");
    if (Pe = parsePercent(Pe, ee), Math.abs(pe.endAngle - pe.startAngle) < Z) {
      each$f(he.states, ae), he.ignore = !0, me && (each$f(me.states, ae), me.ignore = !0);
      return;
    }
    if (ie(he)) {
      var $e = (pe.startAngle + pe.endAngle) / 2, Me = Math.cos($e), Ee = Math.sin($e), we, Oe, Ne, ke;
      U = pe.cx, K = pe.cy;
      var ze = Ie === "inside" || Ie === "inner";
      if (Ie === "center")
        we = pe.cx, Oe = pe.cy, ke = "center";
      else {
        var He = (ze ? (pe.r + pe.r0) / 2 * Me : pe.r * Me) + U, We = (ze ? (pe.r + pe.r0) / 2 * Ee : pe.r * Ee) + K;
        if (we = He + Me * 3, Oe = We + Ee * 3, !ze) {
          var Re = He + Me * (Te + Q - pe.r), Le = We + Ee * (Te + Q - pe.r), De = Re + (Me < 0 ? -1 : 1) * Pe, Ue = Le;
          Se === "edge" ? we = Me < 0 ? te + Ae : te + ee - Ae : we = De + (Me < 0 ? -be : be), Oe = Ue, Ne = [[He, We], [Re, Le], [De, Ue]];
        }
        ke = ze ? "center" : Se === "edge" ? Me > 0 ? "right" : "left" : Me > 0 ? "left" : "right";
      }
      var st = Math.PI, ot = 0, ct = Ce.get("rotate");
      if (isNumber(ct))
        ot = ct * (st / 180);
      else if (Ie === "center")
        ot = 0;
      else if (ct === "radial" || ct === !0) {
        var vt = Me < 0 ? -$e + st : -$e;
        ot = vt;
      } else if (ct === "tangential" && Ie !== "outside" && Ie !== "outer") {
        var ut = Math.atan2(Me, Ee);
        ut < 0 && (ut = st * 2 + ut);
        var at = Ee > 0;
        at && (ut = st + ut), ot = ut - st;
      }
      if (W = !!ot, he.x = we, he.y = Oe, he.rotation = ot, he.setStyle({
        verticalAlign: "middle"
      }), ze) {
        he.setStyle({
          align: ke
        });
        var qe = he.states.select;
        qe && (qe.x += he.x, qe.y += he.y);
      } else {
        var Ze = he.getBoundingRect().clone();
        Ze.applyTransform(he.getComputedTransform());
        var Xe = (he.style.margin || 0) + 2.1;
        Ze.y -= Xe / 2, Ze.height += Xe, G.push({
          label: he,
          labelLine: me,
          position: Ie,
          len: Te,
          len2: Pe,
          minTurnAngle: xe.get("minTurnAngle"),
          maxSurfaceAngle: xe.get("maxSurfaceAngle"),
          surfaceNormal: new Point$1(Me, Ee),
          linePoints: Ne,
          textAlign: ke,
          labelDistance: be,
          labelAlignTo: Se,
          edgeDistance: Ae,
          bleedMargin: _e,
          rect: Ze,
          unconstrainedWidth: Ze.width,
          labelStyleWidth: he.style.width
        });
      }
      ve.setTextConfig({
        inside: ze
      });
    }
  }), !W && H.get("avoidLabelOverlap") && avoidOverlap(G, U, K, Q, ee, ne, te, re);
  for (var se = 0; se < G.length; se++) {
    var oe = G[se], le = oe.label, ue = oe.labelLine, ce = isNaN(le.x) || isNaN(le.y);
    if (le) {
      le.setStyle({
        align: oe.textAlign
      }), ce && (each$f(le.states, ae), le.ignore = !0);
      var de = le.states.select;
      de && (de.x += le.x, de.y += le.y);
    }
    if (ue) {
      var ge = oe.linePoints;
      ce || !ge ? (each$f(ue.states, ae), ue.ignore = !0) : (limitTurnAngle(ge, oe.minTurnAngle), limitSurfaceAngle(ge, oe.surfaceNormal, oe.maxSurfaceAngle), ue.setShape({
        points: ge
      }), le.__hostTarget.textGuideLineConfig = {
        anchor: new Point$1(ge[0][0], ge[0][1])
      });
    }
  }
}
function getSectorCornerRadius(H, C, G) {
  var U = H.get("borderRadius");
  if (U == null)
    return G ? {
      cornerRadius: 0
    } : null;
  isArray$1(U) || (U = [U, U, U, U]);
  var K = Math.abs(C.r || 0 - C.r0 || 0);
  return {
    cornerRadius: map$1(U, function(W) {
      return parsePercent$1(W, K);
    })
  };
}
var PiePiece = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C(G, U, K) {
      var W = H.call(this) || this;
      W.z2 = 2;
      var Z = new ZRText$1();
      return W.setTextContent(Z), W.updateData(G, U, K, !0), W;
    }
    return C.prototype.updateData = function(G, U, K, W) {
      var Z = this, X = G.hostModel, Q = G.getItemModel(U), ee = Q.getModel("emphasis"), te = G.getItemLayout(U), re = extend(getSectorCornerRadius(Q.getModel("itemStyle"), te, !0), te);
      if (isNaN(re.startAngle)) {
        Z.setShape(re);
        return;
      }
      if (W) {
        Z.setShape(re);
        var ne = X.getShallow("animationType");
        X.ecModel.ssr ? (initProps(Z, {
          scaleX: 0,
          scaleY: 0
        }, X, {
          dataIndex: U,
          isFrom: !0
        }), Z.originX = re.cx, Z.originY = re.cy) : ne === "scale" ? (Z.shape.r = te.r0, initProps(Z, {
          shape: {
            r: te.r
          }
        }, X, U)) : K != null ? (Z.setShape({
          startAngle: K,
          endAngle: K
        }), initProps(Z, {
          shape: {
            startAngle: te.startAngle,
            endAngle: te.endAngle
          }
        }, X, U)) : (Z.shape.endAngle = te.startAngle, updateProps$1(Z, {
          shape: {
            endAngle: te.endAngle
          }
        }, X, U));
      } else
        saveOldStyle(Z), updateProps$1(Z, {
          shape: re
        }, X, U);
      Z.useStyle(G.getItemVisual(U, "style")), setStatesStylesFromModel(Z, Q);
      var ae = (te.startAngle + te.endAngle) / 2, ie = X.get("selectedOffset"), se = Math.cos(ae) * ie, oe = Math.sin(ae) * ie, le = Q.getShallow("cursor");
      le && Z.attr("cursor", le), this._updateLabel(X, G, U), Z.ensureState("emphasis").shape = extend({
        r: te.r + (ee.get("scale") && ee.get("scaleSize") || 0)
      }, getSectorCornerRadius(ee.getModel("itemStyle"), te)), extend(Z.ensureState("select"), {
        x: se,
        y: oe,
        shape: getSectorCornerRadius(Q.getModel(["select", "itemStyle"]), te)
      }), extend(Z.ensureState("blur"), {
        shape: getSectorCornerRadius(Q.getModel(["blur", "itemStyle"]), te)
      });
      var ue = Z.getTextGuideLine(), ce = Z.getTextContent();
      ue && extend(ue.ensureState("select"), {
        x: se,
        y: oe
      }), extend(ce.ensureState("select"), {
        x: se,
        y: oe
      }), toggleHoverEmphasis(this, ee.get("focus"), ee.get("blurScope"), ee.get("disabled"));
    }, C.prototype._updateLabel = function(G, U, K) {
      var W = this, Z = U.getItemModel(K), X = Z.getModel("labelLine"), Q = U.getItemVisual(K, "style"), ee = Q && Q.fill, te = Q && Q.opacity;
      setLabelStyle(W, getLabelStatesModels(Z), {
        labelFetcher: U.hostModel,
        labelDataIndex: K,
        inheritColor: ee,
        defaultOpacity: te,
        defaultText: G.getFormattedLabel(K, "normal") || U.getName(K)
      });
      var re = W.getTextContent();
      W.setTextConfig({
        // reset position, rotation
        position: null,
        rotation: null
      }), re.attr({
        z2: 10
      });
      var ne = G.get(["label", "position"]);
      if (ne !== "outside" && ne !== "outer")
        W.removeTextGuideLine();
      else {
        var ae = this.getTextGuideLine();
        ae || (ae = new Polyline$3(), this.setTextGuideLine(ae)), setLabelLineStyle(this, getLabelLineStatesModels(Z), {
          stroke: ee,
          opacity: retrieve3(X.get(["lineStyle", "opacity"]), te, 1)
        });
      }
    }, C;
  }(Sector$1)
), PieView = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.ignoreLabelLineUpdate = !0, G;
    }
    return C.prototype.render = function(G, U, K, W) {
      var Z = G.getData(), X = this._data, Q = this.group, ee;
      if (!X && Z.count() > 0) {
        for (var te = Z.getItemLayout(0), re = 1; isNaN(te && te.startAngle) && re < Z.count(); ++re)
          te = Z.getItemLayout(re);
        te && (ee = te.startAngle);
      }
      if (this._emptyCircleSector && Q.remove(this._emptyCircleSector), Z.count() === 0 && G.get("showEmptyCircle")) {
        var ne = new Sector$1({
          shape: getBasicPieLayout(G, K)
        });
        ne.useStyle(G.getModel("emptyCircleStyle").getItemStyle()), this._emptyCircleSector = ne, Q.add(ne);
      }
      Z.diff(X).add(function(ae) {
        var ie = new PiePiece(Z, ae, ee);
        Z.setItemGraphicEl(ae, ie), Q.add(ie);
      }).update(function(ae, ie) {
        var se = X.getItemGraphicEl(ie);
        se.updateData(Z, ae, ee), se.off("click"), Q.add(se), Z.setItemGraphicEl(ae, se);
      }).remove(function(ae) {
        var ie = X.getItemGraphicEl(ae);
        removeElementWithFadeOut(ie, G, ae);
      }).execute(), pieLabelLayout(G), G.get("animationTypeUpdate") !== "expansion" && (this._data = Z);
    }, C.prototype.dispose = function() {
    }, C.prototype.containPoint = function(G, U) {
      var K = U.getData(), W = K.getItemLayout(0);
      if (W) {
        var Z = G[0] - W.cx, X = G[1] - W.cy, Q = Math.sqrt(Z * Z + X * X);
        return Q <= W.r && Q >= W.r0;
      }
    }, C.type = "pie", C;
  }(ChartView$1)
);
const PieView$1 = PieView;
function createSeriesDataSimply(H, C, G) {
  C = isArray$1(C) && {
    coordDimensions: C
  } || extend({
    encodeDefine: H.getEncode()
  }, C);
  var U = H.getSource(), K = prepareSeriesDataSchema(U, C).dimensions, W = new SeriesData$1(K, H);
  return W.initData(U, G), W;
}
var LegendVisualProvider = (
  /** @class */
  function() {
    function H(C, G) {
      this._getDataWithEncodedVisual = C, this._getRawData = G;
    }
    return H.prototype.getAllNames = function() {
      var C = this._getRawData();
      return C.mapArray(C.getName);
    }, H.prototype.containName = function(C) {
      var G = this._getRawData();
      return G.indexOfName(C) >= 0;
    }, H.prototype.indexOfName = function(C) {
      var G = this._getDataWithEncodedVisual();
      return G.indexOfName(C);
    }, H.prototype.getItemVisual = function(C, G) {
      var U = this._getDataWithEncodedVisual();
      return U.getItemVisual(C, G);
    }, H;
  }()
);
const LegendVisualProvider$1 = LegendVisualProvider;
var innerData = makeInner(), PieSeriesModel = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      return H !== null && H.apply(this, arguments) || this;
    }
    return C.prototype.init = function(G) {
      H.prototype.init.apply(this, arguments), this.legendVisualProvider = new LegendVisualProvider$1(bind$1(this.getData, this), bind$1(this.getRawData, this)), this._defaultLabelLine(G);
    }, C.prototype.mergeOption = function() {
      H.prototype.mergeOption.apply(this, arguments);
    }, C.prototype.getInitialData = function() {
      return createSeriesDataSimply(this, {
        coordDimensions: ["value"],
        encodeDefaulter: curry$1(makeSeriesEncodeForNameBased, this)
      });
    }, C.prototype.getDataParams = function(G) {
      var U = this.getData(), K = innerData(U), W = K.seats;
      if (!W) {
        var Z = [];
        U.each(U.mapDimension("value"), function(Q) {
          Z.push(Q);
        }), W = K.seats = getPercentSeats(Z, U.hostModel.get("percentPrecision"));
      }
      var X = H.prototype.getDataParams.call(this, G);
      return X.percent = W[G] || 0, X.$vars.push("percent"), X;
    }, C.prototype._defaultLabelLine = function(G) {
      defaultEmphasis(G, "labelLine", ["show"]);
      var U = G.labelLine, K = G.emphasis.labelLine;
      U.show = U.show && G.label.show, K.show = K.show && G.emphasis.label.show;
    }, C.type = "series.pie", C.defaultOption = {
      // zlevel: 0,
      z: 2,
      legendHoverLink: !0,
      colorBy: "data",
      // 默认全局居中
      center: ["50%", "50%"],
      radius: [0, "75%"],
      // 默认顺时针
      clockwise: !0,
      startAngle: 90,
      // 最小角度改为0
      minAngle: 0,
      // If the angle of a sector less than `minShowLabelAngle`,
      // the label will not be displayed.
      minShowLabelAngle: 0,
      // 选中时扇区偏移量
      selectedOffset: 10,
      // 选择模式，默认关闭，可选single，multiple
      // selectedMode: false,
      // 南丁格尔玫瑰图模式，'radius'（半径） | 'area'（面积）
      // roseType: null,
      percentPrecision: 2,
      // If still show when all data zero.
      stillShowZeroSum: !0,
      // cursor: null,
      left: 0,
      top: 0,
      right: 0,
      bottom: 0,
      width: null,
      height: null,
      label: {
        // color: 'inherit',
        // If rotate around circle
        rotate: 0,
        show: !0,
        overflow: "truncate",
        // 'outer', 'inside', 'center'
        position: "outer",
        // 'none', 'labelLine', 'edge'. Works only when position is 'outer'
        alignTo: "none",
        // Closest distance between label and chart edge.
        // Works only position is 'outer' and alignTo is 'edge'.
        edgeDistance: "25%",
        // Works only position is 'outer' and alignTo is not 'edge'.
        bleedMargin: 10,
        // Distance between text and label line.
        distanceToLabelLine: 5
        // formatter: 标签文本格式器，同 tooltip.formatter，不支持异步回调
        // 默认使用全局文本样式，详见 textStyle
        // distance: 当position为inner时有效，为label位置到圆心的距离与圆半径(环状图为内外半径和)的比例系数
      },
      // Enabled when label.normal.position is 'outer'
      labelLine: {
        show: !0,
        // 引导线两段中的第一段长度
        length: 15,
        // 引导线两段中的第二段长度
        length2: 15,
        smooth: !1,
        minTurnAngle: 90,
        maxSurfaceAngle: 90,
        lineStyle: {
          // color: 各异,
          width: 1,
          type: "solid"
        }
      },
      itemStyle: {
        borderWidth: 1,
        borderJoin: "round"
      },
      showEmptyCircle: !0,
      emptyCircleStyle: {
        color: "lightgray",
        opacity: 1
      },
      labelLayout: {
        // Hide the overlapped label.
        hideOverlap: !0
      },
      emphasis: {
        scale: !0,
        scaleSize: 5
      },
      // If use strategy to avoid label overlapping
      avoidLabelOverlap: !0,
      // Animation type. Valid values: expansion, scale
      animationType: "expansion",
      animationDuration: 1e3,
      // Animation type when update. Valid values: transition, expansion
      animationTypeUpdate: "transition",
      animationEasingUpdate: "cubicInOut",
      animationDurationUpdate: 500,
      animationEasing: "cubicInOut"
    }, C;
  }(SeriesModel$1)
);
const PieSeriesModel$1 = PieSeriesModel;
function negativeDataFilter(H) {
  return {
    seriesType: H,
    reset: function(C, G) {
      var U = C.getData();
      U.filterSelf(function(K) {
        var W = U.mapDimension("value"), Z = U.get(W, K);
        return !(isNumber(Z) && !isNaN(Z) && Z < 0);
      });
    }
  };
}
function install$O(H) {
  H.registerChartView(PieView$1), H.registerSeriesModel(PieSeriesModel$1), createLegacyDataSelectAction("pie", H.registerAction), H.registerLayout(curry$1(pieLayout, "pie")), H.registerProcessor(dataFilter$1("pie")), H.registerProcessor(negativeDataFilter("pie"));
}
var ScatterSeriesModel = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G.hasSymbolVisual = !0, G;
    }
    return C.prototype.getInitialData = function(G, U) {
      return createSeriesData(null, this, {
        useEncodeDefaulter: !0
      });
    }, C.prototype.getProgressive = function() {
      var G = this.option.progressive;
      return G ?? (this.option.large ? 5e3 : this.get("progressive"));
    }, C.prototype.getProgressiveThreshold = function() {
      var G = this.option.progressiveThreshold;
      return G ?? (this.option.large ? 1e4 : this.get("progressiveThreshold"));
    }, C.prototype.brushSelector = function(G, U, K) {
      return K.point(U.getItemLayout(G));
    }, C.prototype.getZLevelKey = function() {
      return this.getData().count() > this.getProgressiveThreshold() ? this.id : "";
    }, C.type = "series.scatter", C.dependencies = ["grid", "polar", "geo", "singleAxis", "calendar"], C.defaultOption = {
      coordinateSystem: "cartesian2d",
      // zlevel: 0,
      z: 2,
      legendHoverLink: !0,
      symbolSize: 10,
      // symbolRotate: null,  // 图形旋转控制
      large: !1,
      // Available when large is true
      largeThreshold: 2e3,
      // cursor: null,
      itemStyle: {
        opacity: 0.8
        // color: 各异
      },
      emphasis: {
        scale: !0
      },
      // If clip the overflow graphics
      // Works on cartesian / polar series
      clip: !0,
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      },
      universalTransition: {
        divideShape: "clone"
      }
      // progressive: null
    }, C;
  }(SeriesModel$1)
);
const ScatterSeriesModel$1 = ScatterSeriesModel;
var BOOST_SIZE_THRESHOLD = 4, LargeSymbolPathShape = (
  /** @class */
  function() {
    function H() {
    }
    return H;
  }()
), LargeSymbolPath = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C(G) {
      var U = H.call(this, G) || this;
      return U._off = 0, U.hoverDataIdx = -1, U;
    }
    return C.prototype.getDefaultShape = function() {
      return new LargeSymbolPathShape();
    }, C.prototype.reset = function() {
      this.notClear = !1, this._off = 0;
    }, C.prototype.buildPath = function(G, U) {
      var K = U.points, W = U.size, Z = this.symbolProxy, X = Z.shape, Q = G.getContext ? G.getContext() : G, ee = Q && W[0] < BOOST_SIZE_THRESHOLD, te = this.softClipShape, re;
      if (ee) {
        this._ctx = Q;
        return;
      }
      for (this._ctx = null, re = this._off; re < K.length; ) {
        var ne = K[re++], ae = K[re++];
        isNaN(ne) || isNaN(ae) || te && !te.contain(ne, ae) || (X.x = ne - W[0] / 2, X.y = ae - W[1] / 2, X.width = W[0], X.height = W[1], Z.buildPath(G, X, !0));
      }
      this.incremental && (this._off = re, this.notClear = !0);
    }, C.prototype.afterBrush = function() {
      var G = this.shape, U = G.points, K = G.size, W = this._ctx, Z = this.softClipShape, X;
      if (W) {
        for (X = this._off; X < U.length; ) {
          var Q = U[X++], ee = U[X++];
          isNaN(Q) || isNaN(ee) || Z && !Z.contain(Q, ee) || W.fillRect(Q - K[0] / 2, ee - K[1] / 2, K[0], K[1]);
        }
        this.incremental && (this._off = X, this.notClear = !0);
      }
    }, C.prototype.findDataIndex = function(G, U) {
      for (var K = this.shape, W = K.points, Z = K.size, X = Math.max(Z[0], 4), Q = Math.max(Z[1], 4), ee = W.length / 2 - 1; ee >= 0; ee--) {
        var te = ee * 2, re = W[te] - X / 2, ne = W[te + 1] - Q / 2;
        if (G >= re && U >= ne && G <= re + X && U <= ne + Q)
          return ee;
      }
      return -1;
    }, C.prototype.contain = function(G, U) {
      var K = this.transformCoordToLocal(G, U), W = this.getBoundingRect();
      if (G = K[0], U = K[1], W.contain(G, U)) {
        var Z = this.hoverDataIdx = this.findDataIndex(G, U);
        return Z >= 0;
      }
      return this.hoverDataIdx = -1, !1;
    }, C.prototype.getBoundingRect = function() {
      var G = this._rect;
      if (!G) {
        for (var U = this.shape, K = U.points, W = U.size, Z = W[0], X = W[1], Q = 1 / 0, ee = 1 / 0, te = -1 / 0, re = -1 / 0, ne = 0; ne < K.length; ) {
          var ae = K[ne++], ie = K[ne++];
          Q = Math.min(ae, Q), te = Math.max(ae, te), ee = Math.min(ie, ee), re = Math.max(ie, re);
        }
        G = this._rect = new BoundingRect$1(Q - Z / 2, ee - X / 2, te - Q + Z, re - ee + X);
      }
      return G;
    }, C;
  }(Path$1)
), LargeSymbolDraw = (
  /** @class */
  function() {
    function H() {
      this.group = new Group$4();
    }
    return H.prototype.updateData = function(C, G) {
      this._clear();
      var U = this._create();
      U.setShape({
        points: C.getLayout("points")
      }), this._setCommon(U, C, G);
    }, H.prototype.updateLayout = function(C) {
      var G = C.getLayout("points");
      this.group.eachChild(function(U) {
        if (U.startIndex != null) {
          var K = (U.endIndex - U.startIndex) * 2, W = U.startIndex * 4 * 2;
          G = new Float32Array(G.buffer, W, K);
        }
        U.setShape("points", G), U.reset();
      });
    }, H.prototype.incrementalPrepareUpdate = function(C) {
      this._clear();
    }, H.prototype.incrementalUpdate = function(C, G, U) {
      var K = this._newAdded[0], W = G.getLayout("points"), Z = K && K.shape.points;
      if (Z && Z.length < 2e4) {
        var X = Z.length, Q = new Float32Array(X + W.length);
        Q.set(Z), Q.set(W, X), K.endIndex = C.end, K.setShape({
          points: Q
        });
      } else {
        this._newAdded = [];
        var ee = this._create();
        ee.startIndex = C.start, ee.endIndex = C.end, ee.incremental = !0, ee.setShape({
          points: W
        }), this._setCommon(ee, G, U);
      }
    }, H.prototype.eachRendered = function(C) {
      this._newAdded[0] && C(this._newAdded[0]);
    }, H.prototype._create = function() {
      var C = new LargeSymbolPath({
        cursor: "default"
      });
      return C.ignoreCoarsePointer = !0, this.group.add(C), this._newAdded.push(C), C;
    }, H.prototype._setCommon = function(C, G, U) {
      var K = G.hostModel;
      U = U || {};
      var W = G.getVisual("symbolSize");
      C.setShape("size", W instanceof Array ? W : [W, W]), C.softClipShape = U.clipShape || null, C.symbolProxy = createSymbol$1(G.getVisual("symbol"), 0, 0, 0, 0), C.setColor = C.symbolProxy.setColor;
      var Z = C.shape.size[0] < BOOST_SIZE_THRESHOLD;
      C.useStyle(
        // Draw shadow when doing fillRect is extremely slow.
        K.getModel("itemStyle").getItemStyle(Z ? ["color", "shadowBlur", "shadowColor"] : ["color"])
      );
      var X = G.getVisual("style"), Q = X && X.fill;
      Q && C.setColor(Q);
      var ee = getECData(C);
      ee.seriesIndex = K.seriesIndex, C.on("mousemove", function(te) {
        ee.dataIndex = null;
        var re = C.hoverDataIdx;
        re >= 0 && (ee.dataIndex = re + (C.startIndex || 0));
      });
    }, H.prototype.remove = function() {
      this._clear();
    }, H.prototype._clear = function() {
      this._newAdded = [], this.group.removeAll();
    }, H;
  }()
);
const LargeSymbolDraw$1 = LargeSymbolDraw;
var ScatterView = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G;
    }
    return C.prototype.render = function(G, U, K) {
      var W = G.getData(), Z = this._updateSymbolDraw(W, G);
      Z.updateData(W, {
        // TODO
        // If this parameter should be a shape or a bounding volume
        // shape will be more general.
        // But bounding volume like bounding rect will be much faster in the contain calculation
        clipShape: this._getClipShape(G)
      }), this._finished = !0;
    }, C.prototype.incrementalPrepareRender = function(G, U, K) {
      var W = G.getData(), Z = this._updateSymbolDraw(W, G);
      Z.incrementalPrepareUpdate(W), this._finished = !1;
    }, C.prototype.incrementalRender = function(G, U, K) {
      this._symbolDraw.incrementalUpdate(G, U.getData(), {
        clipShape: this._getClipShape(U)
      }), this._finished = G.end === U.getData().count();
    }, C.prototype.updateTransform = function(G, U, K) {
      var W = G.getData();
      if (this.group.dirty(), !this._finished || W.count() > 1e4)
        return {
          update: !0
        };
      var Z = pointsLayout("").reset(G, U, K);
      Z.progress && Z.progress({
        start: 0,
        end: W.count(),
        count: W.count()
      }, W), this._symbolDraw.updateLayout(W);
    }, C.prototype.eachRendered = function(G) {
      this._symbolDraw && this._symbolDraw.eachRendered(G);
    }, C.prototype._getClipShape = function(G) {
      var U = G.coordinateSystem, K = U && U.getArea && U.getArea();
      return G.get("clip", !0) ? K : null;
    }, C.prototype._updateSymbolDraw = function(G, U) {
      var K = this._symbolDraw, W = U.pipelineContext, Z = W.large;
      return (!K || Z !== this._isLargeDraw) && (K && K.remove(), K = this._symbolDraw = Z ? new LargeSymbolDraw$1() : new SymbolDraw$1(), this._isLargeDraw = Z, this.group.removeAll()), this.group.add(K.group), K;
    }, C.prototype.remove = function(G, U) {
      this._symbolDraw && this._symbolDraw.remove(!0), this._symbolDraw = null;
    }, C.prototype.dispose = function() {
    }, C.type = "scatter", C;
  }(ChartView$1)
);
const ScatterView$1 = ScatterView;
var GridModel = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      return H !== null && H.apply(this, arguments) || this;
    }
    return C.type = "grid", C.dependencies = ["xAxis", "yAxis"], C.layoutMode = "box", C.defaultOption = {
      show: !1,
      // zlevel: 0,
      z: 0,
      left: "10%",
      top: 60,
      right: "10%",
      bottom: 70,
      // If grid size contain label
      containLabel: !1,
      // width: {totalWidth} - left - right,
      // height: {totalHeight} - top - bottom,
      backgroundColor: "rgba(0,0,0,0)",
      borderWidth: 1,
      borderColor: "#ccc"
    }, C;
  }(ComponentModel$1)
);
const GridModel$1 = GridModel;
var CartesianAxisModel = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      return H !== null && H.apply(this, arguments) || this;
    }
    return C.prototype.getCoordSysModel = function() {
      return this.getReferringComponents("grid", SINGLE_REFERRING).models[0];
    }, C.type = "cartesian2dAxis", C;
  }(ComponentModel$1)
);
mixin(CartesianAxisModel, AxisModelCommonMixin);
var defaultOption$1 = {
  show: !0,
  // zlevel: 0,
  z: 0,
  // Inverse the axis.
  inverse: !1,
  // Axis name displayed.
  name: "",
  // 'start' | 'middle' | 'end'
  nameLocation: "end",
  // By degree. By default auto rotate by nameLocation.
  nameRotate: null,
  nameTruncate: {
    maxWidth: null,
    ellipsis: "...",
    placeholder: "."
  },
  // Use global text style by default.
  nameTextStyle: {},
  // The gap between axisName and axisLine.
  nameGap: 15,
  // Default `false` to support tooltip.
  silent: !1,
  // Default `false` to avoid legacy user event listener fail.
  triggerEvent: !1,
  tooltip: {
    show: !1
  },
  axisPointer: {},
  axisLine: {
    show: !0,
    onZero: !0,
    onZeroAxisIndex: null,
    lineStyle: {
      color: "#6E7079",
      width: 1,
      type: "solid"
    },
    // The arrow at both ends the the axis.
    symbol: ["none", "none"],
    symbolSize: [10, 15]
  },
  axisTick: {
    show: !0,
    // Whether axisTick is inside the grid or outside the grid.
    inside: !1,
    // The length of axisTick.
    length: 5,
    lineStyle: {
      width: 1
    }
  },
  axisLabel: {
    show: !0,
    // Whether axisLabel is inside the grid or outside the grid.
    inside: !1,
    rotate: 0,
    // true | false | null/undefined (auto)
    showMinLabel: null,
    // true | false | null/undefined (auto)
    showMaxLabel: null,
    margin: 8,
    // formatter: null,
    fontSize: 12
  },
  splitLine: {
    show: !0,
    lineStyle: {
      color: ["#E0E6F1"],
      width: 1,
      type: "solid"
    }
  },
  splitArea: {
    show: !1,
    areaStyle: {
      color: ["rgba(250,250,250,0.2)", "rgba(210,219,238,0.2)"]
    }
  }
}, categoryAxis = merge({
  // The gap at both ends of the axis. For categoryAxis, boolean.
  boundaryGap: !0,
  // Set false to faster category collection.
  deduplication: null,
  // splitArea: {
  // show: false
  // },
  splitLine: {
    show: !1
  },
  axisTick: {
    // If tick is align with label when boundaryGap is true
    alignWithLabel: !1,
    interval: "auto"
  },
  axisLabel: {
    interval: "auto"
  }
}, defaultOption$1), valueAxis = merge({
  boundaryGap: [0, 0],
  axisLine: {
    // Not shown when other axis is categoryAxis in cartesian
    show: "auto"
  },
  axisTick: {
    // Not shown when other axis is categoryAxis in cartesian
    show: "auto"
  },
  // TODO
  // min/max: [30, datamin, 60] or [20, datamin] or [datamin, 60]
  splitNumber: 5,
  minorTick: {
    // Minor tick, not available for cateogry axis.
    show: !1,
    // Split number of minor ticks. The value should be in range of (0, 100)
    splitNumber: 5,
    // Length of minor tick
    length: 3,
    // Line style
    lineStyle: {
      // Default to be same with axisTick
    }
  },
  minorSplitLine: {
    show: !1,
    lineStyle: {
      color: "#F4F7FD",
      width: 1
    }
  }
}, defaultOption$1), timeAxis = merge({
  splitNumber: 6,
  axisLabel: {
    // To eliminate labels that are not nice
    showMinLabel: !1,
    showMaxLabel: !1,
    rich: {
      primary: {
        fontWeight: "bold"
      }
    }
  },
  splitLine: {
    show: !1
  }
}, valueAxis), logAxis = defaults({
  logBase: 10
}, valueAxis);
const axisDefault = {
  category: categoryAxis,
  value: valueAxis,
  time: timeAxis,
  log: logAxis
};
var AXIS_TYPES = {
  value: 1,
  category: 1,
  time: 1,
  log: 1
};
function axisModelCreator(H, C, G, U) {
  each$f(AXIS_TYPES, function(K, W) {
    var Z = merge(merge({}, axisDefault[W], !0), U, !0), X = (
      /** @class */
      function(Q) {
        __extends$1(ee, Q);
        function ee() {
          var te = Q !== null && Q.apply(this, arguments) || this;
          return te.type = C + "Axis." + W, te;
        }
        return ee.prototype.mergeDefaultAndTheme = function(te, re) {
          var ne = fetchLayoutMode(this), ae = ne ? getLayoutParams(te) : {}, ie = re.getTheme();
          merge(te, ie.get(W + "Axis")), merge(te, this.getDefaultOption()), te.type = getAxisType(te), ne && mergeLayoutParam(te, ae, ne);
        }, ee.prototype.optionUpdated = function() {
          var te = this.option;
          te.type === "category" && (this.__ordinalMeta = OrdinalMeta$1.createByAxisModel(this));
        }, ee.prototype.getCategories = function(te) {
          var re = this.option;
          if (re.type === "category")
            return te ? re.data : this.__ordinalMeta.categories;
        }, ee.prototype.getOrdinalMeta = function() {
          return this.__ordinalMeta;
        }, ee.type = C + "Axis." + W, ee.defaultOption = Z, ee;
      }(G)
    );
    H.registerComponentModel(X);
  }), H.registerSubTypeDefaulter(C + "Axis", getAxisType);
}
function getAxisType(H) {
  return H.type || (H.data ? "category" : "value");
}
var Cartesian = (
  /** @class */
  function() {
    function H(C) {
      this.type = "cartesian", this._dimList = [], this._axes = {}, this.name = C || "";
    }
    return H.prototype.getAxis = function(C) {
      return this._axes[C];
    }, H.prototype.getAxes = function() {
      return map$1(this._dimList, function(C) {
        return this._axes[C];
      }, this);
    }, H.prototype.getAxesByScale = function(C) {
      return C = C.toLowerCase(), filter(this.getAxes(), function(G) {
        return G.scale.type === C;
      });
    }, H.prototype.addAxis = function(C) {
      var G = C.dim;
      this._axes[G] = C, this._dimList.push(G);
    }, H;
  }()
);
const Cartesian$1 = Cartesian;
var cartesian2DDimensions = ["x", "y"];
function canCalculateAffineTransform(H) {
  return H.type === "interval" || H.type === "time";
}
var Cartesian2D = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = "cartesian2d", G.dimensions = cartesian2DDimensions, G;
    }
    return C.prototype.calcAffineTransform = function() {
      this._transform = this._invTransform = null;
      var G = this.getAxis("x").scale, U = this.getAxis("y").scale;
      if (!(!canCalculateAffineTransform(G) || !canCalculateAffineTransform(U))) {
        var K = G.getExtent(), W = U.getExtent(), Z = this.dataToPoint([K[0], W[0]]), X = this.dataToPoint([K[1], W[1]]), Q = K[1] - K[0], ee = W[1] - W[0];
        if (!(!Q || !ee)) {
          var te = (X[0] - Z[0]) / Q, re = (X[1] - Z[1]) / ee, ne = Z[0] - K[0] * te, ae = Z[1] - W[0] * re, ie = this._transform = [te, 0, 0, re, ne, ae];
          this._invTransform = invert([], ie);
        }
      }
    }, C.prototype.getBaseAxis = function() {
      return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAxis("x");
    }, C.prototype.containPoint = function(G) {
      var U = this.getAxis("x"), K = this.getAxis("y");
      return U.contain(U.toLocalCoord(G[0])) && K.contain(K.toLocalCoord(G[1]));
    }, C.prototype.containData = function(G) {
      return this.getAxis("x").containData(G[0]) && this.getAxis("y").containData(G[1]);
    }, C.prototype.containZone = function(G, U) {
      var K = this.dataToPoint(G), W = this.dataToPoint(U), Z = this.getArea(), X = new BoundingRect$1(K[0], K[1], W[0] - K[0], W[1] - K[1]);
      return Z.intersect(X);
    }, C.prototype.dataToPoint = function(G, U, K) {
      K = K || [];
      var W = G[0], Z = G[1];
      if (this._transform && W != null && isFinite(W) && Z != null && isFinite(Z))
        return applyTransform$1(K, G, this._transform);
      var X = this.getAxis("x"), Q = this.getAxis("y");
      return K[0] = X.toGlobalCoord(X.dataToCoord(W, U)), K[1] = Q.toGlobalCoord(Q.dataToCoord(Z, U)), K;
    }, C.prototype.clampData = function(G, U) {
      var K = this.getAxis("x").scale, W = this.getAxis("y").scale, Z = K.getExtent(), X = W.getExtent(), Q = K.parse(G[0]), ee = W.parse(G[1]);
      return U = U || [], U[0] = Math.min(Math.max(Math.min(Z[0], Z[1]), Q), Math.max(Z[0], Z[1])), U[1] = Math.min(Math.max(Math.min(X[0], X[1]), ee), Math.max(X[0], X[1])), U;
    }, C.prototype.pointToData = function(G, U) {
      var K = [];
      if (this._invTransform)
        return applyTransform$1(K, G, this._invTransform);
      var W = this.getAxis("x"), Z = this.getAxis("y");
      return K[0] = W.coordToData(W.toLocalCoord(G[0]), U), K[1] = Z.coordToData(Z.toLocalCoord(G[1]), U), K;
    }, C.prototype.getOtherAxis = function(G) {
      return this.getAxis(G.dim === "x" ? "y" : "x");
    }, C.prototype.getArea = function() {
      var G = this.getAxis("x").getGlobalExtent(), U = this.getAxis("y").getGlobalExtent(), K = Math.min(G[0], G[1]), W = Math.min(U[0], U[1]), Z = Math.max(G[0], G[1]) - K, X = Math.max(U[0], U[1]) - W;
      return new BoundingRect$1(K, W, Z, X);
    }, C;
  }(Cartesian$1)
), Axis2D = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C(G, U, K, W, Z) {
      var X = H.call(this, G, U, K) || this;
      return X.index = 0, X.type = W || "value", X.position = Z || "bottom", X;
    }
    return C.prototype.isHorizontal = function() {
      var G = this.position;
      return G === "top" || G === "bottom";
    }, C.prototype.getGlobalExtent = function(G) {
      var U = this.getExtent();
      return U[0] = this.toGlobalCoord(U[0]), U[1] = this.toGlobalCoord(U[1]), G && U[0] > U[1] && U.reverse(), U;
    }, C.prototype.pointToData = function(G, U) {
      return this.coordToData(this.toLocalCoord(G[this.dim === "x" ? 0 : 1]), U);
    }, C.prototype.setCategorySortInfo = function(G) {
      if (this.type !== "category")
        return !1;
      this.model.option.categorySortInfo = G, this.scale.setSortInfo(G);
    }, C;
  }(Axis$1)
);
const Axis2D$1 = Axis2D;
function layout$2(H, C, G) {
  G = G || {};
  var U = H.coordinateSystem, K = C.axis, W = {}, Z = K.getAxesOnZeroOf()[0], X = K.position, Q = Z ? "onZero" : X, ee = K.dim, te = U.getRect(), re = [te.x, te.x + te.width, te.y, te.y + te.height], ne = {
    left: 0,
    right: 1,
    top: 0,
    bottom: 1,
    onZero: 2
  }, ae = C.get("offset") || 0, ie = ee === "x" ? [re[2] - ae, re[3] + ae] : [re[0] - ae, re[1] + ae];
  if (Z) {
    var se = Z.toGlobalCoord(Z.dataToCoord(0));
    ie[ne.onZero] = Math.max(Math.min(se, ie[1]), ie[0]);
  }
  W.position = [ee === "y" ? ie[ne[Q]] : re[0], ee === "x" ? ie[ne[Q]] : re[3]], W.rotation = Math.PI / 2 * (ee === "x" ? 0 : 1);
  var oe = {
    top: -1,
    bottom: 1,
    left: -1,
    right: 1
  };
  W.labelDirection = W.tickDirection = W.nameDirection = oe[X], W.labelOffset = Z ? ie[ne[X]] - ie[ne.onZero] : 0, C.get(["axisTick", "inside"]) && (W.tickDirection = -W.tickDirection), retrieve(G.labelInside, C.get(["axisLabel", "inside"])) && (W.labelDirection = -W.labelDirection);
  var le = C.get(["axisLabel", "rotate"]);
  return W.labelRotate = Q === "top" ? -le : le, W.z2 = 1, W;
}
function isCartesian2DSeries(H) {
  return H.get("coordinateSystem") === "cartesian2d";
}
function findAxisModels(H) {
  var C = {
    xAxisModel: null,
    yAxisModel: null
  };
  return each$f(C, function(G, U) {
    var K = U.replace(/Model$/, ""), W = H.getReferringComponents(K, SINGLE_REFERRING).models[0];
    if (process.env.NODE_ENV !== "production" && !W)
      throw new Error(K + ' "' + retrieve3(H.get(K + "Index"), H.get(K + "Id"), 0) + '" not found');
    C[U] = W;
  }), C;
}
var mathLog = Math.log;
function alignScaleTicks(H, C, G) {
  var U = IntervalScale$1.prototype, K = U.getTicks.call(G), W = U.getTicks.call(G, !0), Z = K.length - 1, X = U.getInterval.call(G), Q = getScaleExtent(H, C), ee = Q.extent, te = Q.fixMin, re = Q.fixMax;
  if (H.type === "log") {
    var ne = mathLog(H.base);
    ee = [mathLog(ee[0]) / ne, mathLog(ee[1]) / ne];
  }
  H.setExtent(ee[0], ee[1]), H.calcNiceExtent({
    splitNumber: Z,
    fixMin: te,
    fixMax: re
  });
  var ae = U.getExtent.call(H);
  te && (ee[0] = ae[0]), re && (ee[1] = ae[1]);
  var ie = U.getInterval.call(H), se = ee[0], oe = ee[1];
  if (te && re)
    ie = (oe - se) / Z;
  else if (te)
    for (oe = ee[0] + ie * Z; oe < ee[1] && isFinite(oe) && isFinite(ee[1]); )
      ie = increaseInterval(ie), oe = ee[0] + ie * Z;
  else if (re)
    for (se = ee[1] - ie * Z; se > ee[0] && isFinite(se) && isFinite(ee[0]); )
      ie = increaseInterval(ie), se = ee[1] - ie * Z;
  else {
    var le = H.getTicks().length - 1;
    le > Z && (ie = increaseInterval(ie));
    var ue = ie * Z;
    oe = Math.ceil(ee[1] / ie) * ie, se = round$3(oe - ue), se < 0 && ee[0] >= 0 ? (se = 0, oe = round$3(ue)) : oe > 0 && ee[1] <= 0 && (oe = 0, se = -round$3(ue));
  }
  var ce = (K[0].value - W[0].value) / X, de = (K[Z].value - W[Z].value) / X;
  if (U.setExtent.call(H, se + ie * ce, oe + ie * de), U.setInterval.call(H, ie), (ce || de) && U.setNiceExtent.call(H, se + ie, oe - ie), process.env.NODE_ENV !== "production") {
    var ge = U.getTicks.call(H);
    ge[1] && (!isValueNice(ie) || getPrecisionSafe(ge[1].value) > getPrecisionSafe(ie)) && warn(
      // eslint-disable-next-line
      "The ticks may be not readable when set min: " + C.get("min") + ", max: " + C.get("max") + " and alignTicks: true"
    );
  }
}
var Grid = (
  /** @class */
  function() {
    function H(C, G, U) {
      this.type = "grid", this._coordsMap = {}, this._coordsList = [], this._axesMap = {}, this._axesList = [], this.axisPointerEnabled = !0, this.dimensions = cartesian2DDimensions, this._initCartesian(C, G, U), this.model = C;
    }
    return H.prototype.getRect = function() {
      return this._rect;
    }, H.prototype.update = function(C, G) {
      var U = this._axesMap;
      this._updateScale(C, this.model);
      function K(Z) {
        var X, Q = keys(Z), ee = Q.length;
        if (ee) {
          for (var te = [], re = ee - 1; re >= 0; re--) {
            var ne = +Q[re], ae = Z[ne], ie = ae.model, se = ae.scale;
            // Only value and log axis without interval support alignTicks.
            isIntervalOrLogScale(se) && ie.get("alignTicks") && ie.get("interval") == null ? te.push(ae) : (niceScaleExtent(se, ie), isIntervalOrLogScale(se) && (X = ae));
          }
          te.length && (X || (X = te.pop(), niceScaleExtent(X.scale, X.model)), each$f(te, function(oe) {
            alignScaleTicks(oe.scale, oe.model, X.scale);
          }));
        }
      }
      K(U.x), K(U.y);
      var W = {};
      each$f(U.x, function(Z) {
        fixAxisOnZero(U, "y", Z, W);
      }), each$f(U.y, function(Z) {
        fixAxisOnZero(U, "x", Z, W);
      }), this.resize(this.model, G);
    }, H.prototype.resize = function(C, G, U) {
      var K = C.getBoxLayoutParams(), W = !U && C.get("containLabel"), Z = getLayoutRect(K, {
        width: G.getWidth(),
        height: G.getHeight()
      });
      this._rect = Z;
      var X = this._axesList;
      Q(), W && (each$f(X, function(ee) {
        if (!ee.model.get(["axisLabel", "inside"])) {
          var te = estimateLabelUnionRect(ee);
          if (te) {
            var re = ee.isHorizontal() ? "height" : "width", ne = ee.model.get(["axisLabel", "margin"]);
            Z[re] -= te[re] + ne, ee.position === "top" ? Z.y += te.height + ne : ee.position === "left" && (Z.x += te.width + ne);
          }
        }
      }), Q()), each$f(this._coordsList, function(ee) {
        ee.calcAffineTransform();
      });
      function Q() {
        each$f(X, function(ee) {
          var te = ee.isHorizontal(), re = te ? [0, Z.width] : [0, Z.height], ne = ee.inverse ? 1 : 0;
          ee.setExtent(re[ne], re[1 - ne]), updateAxisTransform(ee, te ? Z.x : Z.y);
        });
      }
    }, H.prototype.getAxis = function(C, G) {
      var U = this._axesMap[C];
      if (U != null)
        return U[G || 0];
    }, H.prototype.getAxes = function() {
      return this._axesList.slice();
    }, H.prototype.getCartesian = function(C, G) {
      if (C != null && G != null) {
        var U = "x" + C + "y" + G;
        return this._coordsMap[U];
      }
      isObject$3(C) && (G = C.yAxisIndex, C = C.xAxisIndex);
      for (var K = 0, W = this._coordsList; K < W.length; K++)
        if (W[K].getAxis("x").index === C || W[K].getAxis("y").index === G)
          return W[K];
    }, H.prototype.getCartesians = function() {
      return this._coordsList.slice();
    }, H.prototype.convertToPixel = function(C, G, U) {
      var K = this._findConvertTarget(G);
      return K.cartesian ? K.cartesian.dataToPoint(U) : K.axis ? K.axis.toGlobalCoord(K.axis.dataToCoord(U)) : null;
    }, H.prototype.convertFromPixel = function(C, G, U) {
      var K = this._findConvertTarget(G);
      return K.cartesian ? K.cartesian.pointToData(U) : K.axis ? K.axis.coordToData(K.axis.toLocalCoord(U)) : null;
    }, H.prototype._findConvertTarget = function(C) {
      var G = C.seriesModel, U = C.xAxisModel || G && G.getReferringComponents("xAxis", SINGLE_REFERRING).models[0], K = C.yAxisModel || G && G.getReferringComponents("yAxis", SINGLE_REFERRING).models[0], W = C.gridModel, Z = this._coordsList, X, Q;
      if (G)
        X = G.coordinateSystem, indexOf(Z, X) < 0 && (X = null);
      else if (U && K)
        X = this.getCartesian(U.componentIndex, K.componentIndex);
      else if (U)
        Q = this.getAxis("x", U.componentIndex);
      else if (K)
        Q = this.getAxis("y", K.componentIndex);
      else if (W) {
        var ee = W.coordinateSystem;
        ee === this && (X = this._coordsList[0]);
      }
      return {
        cartesian: X,
        axis: Q
      };
    }, H.prototype.containPoint = function(C) {
      var G = this._coordsList[0];
      if (G)
        return G.containPoint(C);
    }, H.prototype._initCartesian = function(C, G, U) {
      var K = this, W = this, Z = {
        left: !1,
        right: !1,
        top: !1,
        bottom: !1
      }, X = {
        x: {},
        y: {}
      }, Q = {
        x: 0,
        y: 0
      };
      if (G.eachComponent("xAxis", ee("x"), this), G.eachComponent("yAxis", ee("y"), this), !Q.x || !Q.y) {
        this._axesMap = {}, this._axesList = [];
        return;
      }
      this._axesMap = X, each$f(X.x, function(te, re) {
        each$f(X.y, function(ne, ae) {
          var ie = "x" + re + "y" + ae, se = new Cartesian2D(ie);
          se.master = K, se.model = C, K._coordsMap[ie] = se, K._coordsList.push(se), se.addAxis(te), se.addAxis(ne);
        });
      });
      function ee(te) {
        return function(re, ne) {
          if (isAxisUsedInTheGrid(re, C)) {
            var ae = re.get("position");
            te === "x" ? ae !== "top" && ae !== "bottom" && (ae = Z.bottom ? "top" : "bottom") : ae !== "left" && ae !== "right" && (ae = Z.left ? "right" : "left"), Z[ae] = !0;
            var ie = new Axis2D$1(te, createScaleByModel$1(re), [0, 0], re.get("type"), ae), se = ie.type === "category";
            ie.onBand = se && re.get("boundaryGap"), ie.inverse = re.get("inverse"), re.axis = ie, ie.model = re, ie.grid = W, ie.index = ne, W._axesList.push(ie), X[te][ne] = ie, Q[te]++;
          }
        };
      }
    }, H.prototype._updateScale = function(C, G) {
      each$f(this._axesList, function(K) {
        if (K.scale.setExtent(1 / 0, -1 / 0), K.type === "category") {
          var W = K.model.get("categorySortInfo");
          K.scale.setSortInfo(W);
        }
      }), C.eachSeries(function(K) {
        if (isCartesian2DSeries(K)) {
          var W = findAxisModels(K), Z = W.xAxisModel, X = W.yAxisModel;
          if (!isAxisUsedInTheGrid(Z, G) || !isAxisUsedInTheGrid(X, G))
            return;
          var Q = this.getCartesian(Z.componentIndex, X.componentIndex), ee = K.getData(), te = Q.getAxis("x"), re = Q.getAxis("y");
          U(ee, te), U(ee, re);
        }
      }, this);
      function U(K, W) {
        each$f(getDataDimensionsOnAxis(K, W.dim), function(Z) {
          W.scale.unionExtentFromData(K, Z);
        });
      }
    }, H.prototype.getTooltipAxes = function(C) {
      var G = [], U = [];
      return each$f(this.getCartesians(), function(K) {
        var W = C != null && C !== "auto" ? K.getAxis(C) : K.getBaseAxis(), Z = K.getOtherAxis(W);
        indexOf(G, W) < 0 && G.push(W), indexOf(U, Z) < 0 && U.push(Z);
      }), {
        baseAxes: G,
        otherAxes: U
      };
    }, H.create = function(C, G) {
      var U = [];
      return C.eachComponent("grid", function(K, W) {
        var Z = new H(K, C, G);
        Z.name = "grid_" + W, Z.resize(K, G, !0), K.coordinateSystem = Z, U.push(Z);
      }), C.eachSeries(function(K) {
        if (isCartesian2DSeries(K)) {
          var W = findAxisModels(K), Z = W.xAxisModel, X = W.yAxisModel, Q = Z.getCoordSysModel();
          if (process.env.NODE_ENV !== "production") {
            if (!Q)
              throw new Error('Grid "' + retrieve3(Z.get("gridIndex"), Z.get("gridId"), 0) + '" not found');
            if (Z.getCoordSysModel() !== X.getCoordSysModel())
              throw new Error("xAxis and yAxis must use the same grid");
          }
          var ee = Q.coordinateSystem;
          K.coordinateSystem = ee.getCartesian(Z.componentIndex, X.componentIndex);
        }
      }), U;
    }, H.dimensions = cartesian2DDimensions, H;
  }()
);
function isAxisUsedInTheGrid(H, C) {
  return H.getCoordSysModel() === C;
}
function fixAxisOnZero(H, C, G, U) {
  G.getAxesOnZeroOf = function() {
    return W ? [W] : [];
  };
  var K = H[C], W, Z = G.model, X = Z.get(["axisLine", "onZero"]), Q = Z.get(["axisLine", "onZeroAxisIndex"]);
  if (!X)
    return;
  if (Q != null)
    canOnZeroToAxis(K[Q]) && (W = K[Q]);
  else
    for (var ee in K)
      if (K.hasOwnProperty(ee) && canOnZeroToAxis(K[ee]) && !U[te(K[ee])]) {
        W = K[ee];
        break;
      }
  W && (U[te(W)] = !0);
  function te(re) {
    return re.dim + "_" + re.index;
  }
}
function canOnZeroToAxis(H) {
  return H && H.type !== "category" && H.type !== "time" && ifAxisCrossZero(H);
}
function updateAxisTransform(H, C) {
  var G = H.getExtent(), U = G[0] + G[1];
  H.toGlobalCoord = H.dim === "x" ? function(K) {
    return K + C;
  } : function(K) {
    return U - K + C;
  }, H.toLocalCoord = H.dim === "x" ? function(K) {
    return K - C;
  } : function(K) {
    return U - K + C;
  };
}
const Grid$1 = Grid;
var PI$3 = Math.PI, AxisBuilder = (
  /** @class */
  function() {
    function H(C, G) {
      this.group = new Group$4(), this.opt = G, this.axisModel = C, defaults(G, {
        labelOffset: 0,
        nameDirection: 1,
        tickDirection: 1,
        labelDirection: 1,
        silent: !0,
        handleAutoShown: function() {
          return !0;
        }
      });
      var U = new Group$4({
        x: G.position[0],
        y: G.position[1],
        rotation: G.rotation
      });
      U.updateTransform(), this._transformGroup = U;
    }
    return H.prototype.hasBuilder = function(C) {
      return !!builders[C];
    }, H.prototype.add = function(C) {
      builders[C](this.opt, this.axisModel, this.group, this._transformGroup);
    }, H.prototype.getGroup = function() {
      return this.group;
    }, H.innerTextLayout = function(C, G, U) {
      var K = remRadian(G - C), W, Z;
      return isRadianAroundZero(K) ? (Z = U > 0 ? "top" : "bottom", W = "center") : isRadianAroundZero(K - PI$3) ? (Z = U > 0 ? "bottom" : "top", W = "center") : (Z = "middle", K > 0 && K < PI$3 ? W = U > 0 ? "right" : "left" : W = U > 0 ? "left" : "right"), {
        rotation: K,
        textAlign: W,
        textVerticalAlign: Z
      };
    }, H.makeAxisEventDataBase = function(C) {
      var G = {
        componentType: C.mainType,
        componentIndex: C.componentIndex
      };
      return G[C.mainType + "Index"] = C.componentIndex, G;
    }, H.isLabelSilent = function(C) {
      var G = C.get("tooltip");
      return C.get("silent") || !(C.get("triggerEvent") || G && G.show);
    }, H;
  }()
), builders = {
  axisLine: function(H, C, G, U) {
    var K = C.get(["axisLine", "show"]);
    if (K === "auto" && H.handleAutoShown && (K = H.handleAutoShown("axisLine")), !!K) {
      var W = C.axis.getExtent(), Z = U.transform, X = [W[0], 0], Q = [W[1], 0], ee = X[0] > Q[0];
      Z && (applyTransform$1(X, X, Z), applyTransform$1(Q, Q, Z));
      var te = extend({
        lineCap: "round"
      }, C.getModel(["axisLine", "lineStyle"]).getLineStyle()), re = new Line$3({
        shape: {
          x1: X[0],
          y1: X[1],
          x2: Q[0],
          y2: Q[1]
        },
        style: te,
        strokeContainThreshold: H.strokeContainThreshold || 5,
        silent: !0,
        z2: 1
      });
      subPixelOptimizeLine(re.shape, re.style.lineWidth), re.anid = "line", G.add(re);
      var ne = C.get(["axisLine", "symbol"]);
      if (ne != null) {
        var ae = C.get(["axisLine", "symbolSize"]);
        isString(ne) && (ne = [ne, ne]), (isString(ae) || isNumber(ae)) && (ae = [ae, ae]);
        var ie = normalizeSymbolOffset(C.get(["axisLine", "symbolOffset"]) || 0, ae), se = ae[0], oe = ae[1];
        each$f([{
          rotate: H.rotation + Math.PI / 2,
          offset: ie[0],
          r: 0
        }, {
          rotate: H.rotation - Math.PI / 2,
          offset: ie[1],
          r: Math.sqrt((X[0] - Q[0]) * (X[0] - Q[0]) + (X[1] - Q[1]) * (X[1] - Q[1]))
        }], function(le, ue) {
          if (ne[ue] !== "none" && ne[ue] != null) {
            var ce = createSymbol$1(ne[ue], -se / 2, -oe / 2, se, oe, te.stroke, !0), de = le.r + le.offset, ge = ee ? Q : X;
            ce.attr({
              rotation: le.rotate,
              x: ge[0] + de * Math.cos(H.rotation),
              y: ge[1] - de * Math.sin(H.rotation),
              silent: !0,
              z2: 11
            }), G.add(ce);
          }
        });
      }
    }
  },
  axisTickLabel: function(H, C, G, U) {
    var K = buildAxisMajorTicks(G, U, C, H), W = buildAxisLabel(G, U, C, H);
    if (fixMinMaxLabelShow(C, W, K), buildAxisMinorTicks(G, U, C, H.tickDirection), C.get(["axisLabel", "hideOverlap"])) {
      var Z = prepareLayoutList(map$1(W, function(X) {
        return {
          label: X,
          priority: X.z2,
          defaultAttr: {
            ignore: X.ignore
          }
        };
      }));
      hideOverlap(Z);
    }
  },
  axisName: function(H, C, G, U) {
    var K = retrieve(H.axisName, C.get("name"));
    if (K) {
      var W = C.get("nameLocation"), Z = H.nameDirection, X = C.getModel("nameTextStyle"), Q = C.get("nameGap") || 0, ee = C.axis.getExtent(), te = ee[0] > ee[1] ? -1 : 1, re = [
        W === "start" ? ee[0] - te * Q : W === "end" ? ee[1] + te * Q : (ee[0] + ee[1]) / 2,
        // Reuse labelOffset.
        isNameLocationCenter(W) ? H.labelOffset + Z * Q : 0
      ], ne, ae = C.get("nameRotate");
      ae != null && (ae = ae * PI$3 / 180);
      var ie;
      isNameLocationCenter(W) ? ne = AxisBuilder.innerTextLayout(
        H.rotation,
        ae ?? H.rotation,
        // Adapt to axis.
        Z
      ) : (ne = endTextLayout(H.rotation, W, ae || 0, ee), ie = H.axisNameAvailableWidth, ie != null && (ie = Math.abs(ie / Math.sin(ne.rotation)), !isFinite(ie) && (ie = null)));
      var se = X.getFont(), oe = C.get("nameTruncate", !0) || {}, le = oe.ellipsis, ue = retrieve(H.nameTruncateMaxWidth, oe.maxWidth, ie), ce = new ZRText$1({
        x: re[0],
        y: re[1],
        rotation: ne.rotation,
        silent: AxisBuilder.isLabelSilent(C),
        style: createTextStyle(X, {
          text: K,
          font: se,
          overflow: "truncate",
          width: ue,
          ellipsis: le,
          fill: X.getTextColor() || C.get(["axisLine", "lineStyle", "color"]),
          align: X.get("align") || ne.textAlign,
          verticalAlign: X.get("verticalAlign") || ne.textVerticalAlign
        }),
        z2: 1
      });
      if (setTooltipConfig({
        el: ce,
        componentModel: C,
        itemName: K
      }), ce.__fullText = K, ce.anid = "name", C.get("triggerEvent")) {
        var de = AxisBuilder.makeAxisEventDataBase(C);
        de.targetType = "axisName", de.name = K, getECData(ce).eventData = de;
      }
      U.add(ce), ce.updateTransform(), G.add(ce), ce.decomposeTransform();
    }
  }
};
function endTextLayout(H, C, G, U) {
  var K = remRadian(G - H), W, Z, X = U[0] > U[1], Q = C === "start" && !X || C !== "start" && X;
  return isRadianAroundZero(K - PI$3 / 2) ? (Z = Q ? "bottom" : "top", W = "center") : isRadianAroundZero(K - PI$3 * 1.5) ? (Z = Q ? "top" : "bottom", W = "center") : (Z = "middle", K < PI$3 * 1.5 && K > PI$3 / 2 ? W = Q ? "left" : "right" : W = Q ? "right" : "left"), {
    rotation: K,
    textAlign: W,
    textVerticalAlign: Z
  };
}
function fixMinMaxLabelShow(H, C, G) {
  if (!shouldShowAllLabels(H.axis)) {
    var U = H.get(["axisLabel", "showMinLabel"]), K = H.get(["axisLabel", "showMaxLabel"]);
    C = C || [], G = G || [];
    var W = C[0], Z = C[1], X = C[C.length - 1], Q = C[C.length - 2], ee = G[0], te = G[1], re = G[G.length - 1], ne = G[G.length - 2];
    U === !1 ? (ignoreEl(W), ignoreEl(ee)) : isTwoLabelOverlapped(W, Z) && (U ? (ignoreEl(Z), ignoreEl(te)) : (ignoreEl(W), ignoreEl(ee))), K === !1 ? (ignoreEl(X), ignoreEl(re)) : isTwoLabelOverlapped(Q, X) && (K ? (ignoreEl(Q), ignoreEl(ne)) : (ignoreEl(X), ignoreEl(re)));
  }
}
function ignoreEl(H) {
  H && (H.ignore = !0);
}
function isTwoLabelOverlapped(H, C) {
  var G = H && H.getBoundingRect().clone(), U = C && C.getBoundingRect().clone();
  if (!(!G || !U)) {
    var K = identity([]);
    return rotate(K, K, -H.rotation), G.applyTransform(mul([], K, H.getLocalTransform())), U.applyTransform(mul([], K, C.getLocalTransform())), G.intersect(U);
  }
}
function isNameLocationCenter(H) {
  return H === "middle" || H === "center";
}
function createTicks(H, C, G, U, K) {
  for (var W = [], Z = [], X = [], Q = 0; Q < H.length; Q++) {
    var ee = H[Q].coord;
    Z[0] = ee, Z[1] = 0, X[0] = ee, X[1] = G, C && (applyTransform$1(Z, Z, C), applyTransform$1(X, X, C));
    var te = new Line$3({
      shape: {
        x1: Z[0],
        y1: Z[1],
        x2: X[0],
        y2: X[1]
      },
      style: U,
      z2: 2,
      autoBatch: !0,
      silent: !0
    });
    subPixelOptimizeLine(te.shape, te.style.lineWidth), te.anid = K + "_" + H[Q].tickValue, W.push(te);
  }
  return W;
}
function buildAxisMajorTicks(H, C, G, U) {
  var K = G.axis, W = G.getModel("axisTick"), Z = W.get("show");
  if (Z === "auto" && U.handleAutoShown && (Z = U.handleAutoShown("axisTick")), !(!Z || K.scale.isBlank())) {
    for (var X = W.getModel("lineStyle"), Q = U.tickDirection * W.get("length"), ee = K.getTicksCoords(), te = createTicks(ee, C.transform, Q, defaults(X.getLineStyle(), {
      stroke: G.get(["axisLine", "lineStyle", "color"])
    }), "ticks"), re = 0; re < te.length; re++)
      H.add(te[re]);
    return te;
  }
}
function buildAxisMinorTicks(H, C, G, U) {
  var K = G.axis, W = G.getModel("minorTick");
  if (!(!W.get("show") || K.scale.isBlank())) {
    var Z = K.getMinorTicksCoords();
    if (Z.length)
      for (var X = W.getModel("lineStyle"), Q = U * W.get("length"), ee = defaults(X.getLineStyle(), defaults(G.getModel("axisTick").getLineStyle(), {
        stroke: G.get(["axisLine", "lineStyle", "color"])
      })), te = 0; te < Z.length; te++)
        for (var re = createTicks(Z[te], C.transform, Q, ee, "minorticks_" + te), ne = 0; ne < re.length; ne++)
          H.add(re[ne]);
  }
}
function buildAxisLabel(H, C, G, U) {
  var K = G.axis, W = retrieve(U.axisLabelShow, G.get(["axisLabel", "show"]));
  if (!(!W || K.scale.isBlank())) {
    var Z = G.getModel("axisLabel"), X = Z.get("margin"), Q = K.getViewLabels(), ee = (retrieve(U.labelRotate, Z.get("rotate")) || 0) * PI$3 / 180, te = AxisBuilder.innerTextLayout(U.rotation, ee, U.labelDirection), re = G.getCategories && G.getCategories(!0), ne = [], ae = AxisBuilder.isLabelSilent(G), ie = G.get("triggerEvent");
    return each$f(Q, function(se, oe) {
      var le = K.scale.type === "ordinal" ? K.scale.getRawOrdinalNumber(se.tickValue) : se.tickValue, ue = se.formattedLabel, ce = se.rawLabel, de = Z;
      if (re && re[le]) {
        var ge = re[le];
        isObject$3(ge) && ge.textStyle && (de = new Model$1(ge.textStyle, Z, G.ecModel));
      }
      var fe = de.getTextColor() || G.get(["axisLine", "lineStyle", "color"]), ve = K.dataToCoord(le), pe = new ZRText$1({
        x: ve,
        y: U.labelOffset + U.labelDirection * X,
        rotation: te.rotation,
        silent: ae,
        z2: 10 + (se.level || 0),
        style: createTextStyle(de, {
          text: ue,
          align: de.getShallow("align", !0) || te.textAlign,
          verticalAlign: de.getShallow("verticalAlign", !0) || de.getShallow("baseline", !0) || te.textVerticalAlign,
          fill: isFunction(fe) ? fe(
            // (1) In category axis with data zoom, tick is not the original
            // index of axis.data. So tick should not be exposed to user
            // in category axis.
            // (2) Compatible with previous version, which always use formatted label as
            // input. But in interval scale the formatted label is like '223,445', which
            // maked user repalce ','. So we modify it to return original val but remain
            // it as 'string' to avoid error in replacing.
            K.type === "category" ? ce : K.type === "value" ? le + "" : le,
            oe
          ) : fe
        })
      });
      if (pe.anid = "label_" + le, ie) {
        var he = AxisBuilder.makeAxisEventDataBase(G);
        he.targetType = "axisLabel", he.value = ce, he.tickIndex = oe, K.type === "category" && (he.dataIndex = le), getECData(pe).eventData = he;
      }
      C.add(pe), pe.updateTransform(), ne.push(pe), H.add(pe), pe.decomposeTransform();
    }), ne;
  }
}
const AxisBuilder$1 = AxisBuilder;
function collect(H, C) {
  var G = {
    /**
     * key: makeKey(axis.model)
     * value: {
     *      axis,
     *      coordSys,
     *      axisPointerModel,
     *      triggerTooltip,
     *      involveSeries,
     *      snap,
     *      seriesModels,
     *      seriesDataCount
     * }
     */
    axesInfo: {},
    seriesInvolved: !1,
    /**
     * key: makeKey(coordSys.model)
     * value: Object: key makeKey(axis.model), value: axisInfo
     */
    coordSysAxesInfo: {},
    coordSysMap: {}
  };
  return collectAxesInfo(G, H, C), G.seriesInvolved && collectSeriesInfo(G, H), G;
}
function collectAxesInfo(H, C, G) {
  var U = C.getComponent("tooltip"), K = C.getComponent("axisPointer"), W = K.get("link", !0) || [], Z = [];
  each$f(G.getCoordinateSystems(), function(X) {
    if (!X.axisPointerEnabled)
      return;
    var Q = makeKey(X.model), ee = H.coordSysAxesInfo[Q] = {};
    H.coordSysMap[Q] = X;
    var te = X.model, re = te.getModel("tooltip", U);
    if (each$f(X.getAxes(), curry$1(se, !1, null)), X.getTooltipAxes && U && re.get("show")) {
      var ne = re.get("trigger") === "axis", ae = re.get(["axisPointer", "type"]) === "cross", ie = X.getTooltipAxes(re.get(["axisPointer", "axis"]));
      (ne || ae) && each$f(ie.baseAxes, curry$1(se, ae ? "cross" : !0, ne)), ae && each$f(ie.otherAxes, curry$1(se, "cross", !1));
    }
    function se(oe, le, ue) {
      var ce = ue.model.getModel("axisPointer", K), de = ce.get("show");
      if (!(!de || de === "auto" && !oe && !isHandleTrigger(ce))) {
        le == null && (le = ce.get("triggerTooltip")), ce = oe ? makeAxisPointerModel(ue, re, K, C, oe, le) : ce;
        var ge = ce.get("snap"), fe = makeKey(ue.model), ve = le || ge || ue.type === "category", pe = H.axesInfo[fe] = {
          key: fe,
          axis: ue,
          coordSys: X,
          axisPointerModel: ce,
          triggerTooltip: le,
          involveSeries: ve,
          snap: ge,
          useHandle: isHandleTrigger(ce),
          seriesModels: [],
          linkGroup: null
        };
        ee[fe] = pe, H.seriesInvolved = H.seriesInvolved || ve;
        var he = getLinkGroupIndex(W, ue);
        if (he != null) {
          var me = Z[he] || (Z[he] = {
            axesInfo: {}
          });
          me.axesInfo[fe] = pe, me.mapper = W[he].mapper, pe.linkGroup = me;
        }
      }
    }
  });
}
function makeAxisPointerModel(H, C, G, U, K, W) {
  var Z = C.getModel("axisPointer"), X = ["type", "snap", "lineStyle", "shadowStyle", "label", "animation", "animationDurationUpdate", "animationEasingUpdate", "z"], Q = {};
  each$f(X, function(ne) {
    Q[ne] = clone$4(Z.get(ne));
  }), Q.snap = H.type !== "category" && !!W, Z.get("type") === "cross" && (Q.type = "line");
  var ee = Q.label || (Q.label = {});
  if (ee.show == null && (ee.show = !1), K === "cross") {
    var te = Z.get(["label", "show"]);
    if (ee.show = te ?? !0, !W) {
      var re = Q.lineStyle = Z.get("crossStyle");
      re && defaults(ee, re.textStyle);
    }
  }
  return H.model.getModel("axisPointer", new Model$1(Q, G, U));
}
function collectSeriesInfo(H, C) {
  C.eachSeries(function(G) {
    var U = G.coordinateSystem, K = G.get(["tooltip", "trigger"], !0), W = G.get(["tooltip", "show"], !0);
    !U || K === "none" || K === !1 || K === "item" || W === !1 || G.get(["axisPointer", "show"], !0) === !1 || each$f(H.coordSysAxesInfo[makeKey(U.model)], function(Z) {
      var X = Z.axis;
      U.getAxis(X.dim) === X && (Z.seriesModels.push(G), Z.seriesDataCount == null && (Z.seriesDataCount = 0), Z.seriesDataCount += G.getData().count());
    });
  });
}
function getLinkGroupIndex(H, C) {
  for (var G = C.model, U = C.dim, K = 0; K < H.length; K++) {
    var W = H[K] || {};
    if (checkPropInLink(W[U + "AxisId"], G.id) || checkPropInLink(W[U + "AxisIndex"], G.componentIndex) || checkPropInLink(W[U + "AxisName"], G.name))
      return K;
  }
}
function checkPropInLink(H, C) {
  return H === "all" || isArray$1(H) && indexOf(H, C) >= 0 || H === C;
}
function fixValue(H) {
  var C = getAxisInfo$1(H);
  if (C) {
    var G = C.axisPointerModel, U = C.axis.scale, K = G.option, W = G.get("status"), Z = G.get("value");
    Z != null && (Z = U.parse(Z));
    var X = isHandleTrigger(G);
    W == null && (K.status = X ? "show" : "hide");
    var Q = U.getExtent().slice();
    Q[0] > Q[1] && Q.reverse(), // Pick a value on axis when initializing.
    (Z == null || Z > Q[1]) && (Z = Q[1]), Z < Q[0] && (Z = Q[0]), K.value = Z, X && (K.status = C.axis.scale.isBlank() ? "hide" : "show");
  }
}
function getAxisInfo$1(H) {
  var C = (H.ecModel.getComponent("axisPointer") || {}).coordSysAxesInfo;
  return C && C.axesInfo[makeKey(H)];
}
function getAxisPointerModel(H) {
  var C = getAxisInfo$1(H);
  return C && C.axisPointerModel;
}
function isHandleTrigger(H) {
  return !!H.get(["handle", "show"]);
}
function makeKey(H) {
  return H.type + "||" + H.id;
}
var axisPointerClazz = {}, AxisView = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G;
    }
    return C.prototype.render = function(G, U, K, W) {
      this.axisPointerClass && fixValue(G), H.prototype.render.apply(this, arguments), this._doUpdateAxisPointerClass(G, K, !0);
    }, C.prototype.updateAxisPointer = function(G, U, K, W) {
      this._doUpdateAxisPointerClass(G, K, !1);
    }, C.prototype.remove = function(G, U) {
      var K = this._axisPointer;
      K && K.remove(U);
    }, C.prototype.dispose = function(G, U) {
      this._disposeAxisPointer(U), H.prototype.dispose.apply(this, arguments);
    }, C.prototype._doUpdateAxisPointerClass = function(G, U, K) {
      var W = C.getAxisPointerClass(this.axisPointerClass);
      if (W) {
        var Z = getAxisPointerModel(G);
        Z ? (this._axisPointer || (this._axisPointer = new W())).render(G, Z, U, K) : this._disposeAxisPointer(U);
      }
    }, C.prototype._disposeAxisPointer = function(G) {
      this._axisPointer && this._axisPointer.dispose(G), this._axisPointer = null;
    }, C.registerAxisPointerClass = function(G, U) {
      if (process.env.NODE_ENV !== "production" && axisPointerClazz[G])
        throw new Error("axisPointer " + G + " exists");
      axisPointerClazz[G] = U;
    }, C.getAxisPointerClass = function(G) {
      return G && axisPointerClazz[G];
    }, C.type = "axis", C;
  }(ComponentView$1)
);
const AxisView$1 = AxisView;
var inner$f = makeInner();
function rectCoordAxisBuildSplitArea(H, C, G, U) {
  var K = G.axis;
  if (!K.scale.isBlank()) {
    var W = G.getModel("splitArea"), Z = W.getModel("areaStyle"), X = Z.get("color"), Q = U.coordinateSystem.getRect(), ee = K.getTicksCoords({
      tickModel: W,
      clamp: !0
    });
    if (ee.length) {
      var te = X.length, re = inner$f(H).splitAreaColors, ne = createHashMap(), ae = 0;
      if (re)
        for (var ie = 0; ie < ee.length; ie++) {
          var se = re.get(ee[ie].tickValue);
          if (se != null) {
            ae = (se + (te - 1) * ie) % te;
            break;
          }
        }
      var oe = K.toGlobalCoord(ee[0].coord), le = Z.getAreaStyle();
      X = isArray$1(X) ? X : [X];
      for (var ie = 1; ie < ee.length; ie++) {
        var ue = K.toGlobalCoord(ee[ie].coord), ce = void 0, de = void 0, ge = void 0, fe = void 0;
        K.isHorizontal() ? (ce = oe, de = Q.y, ge = ue - ce, fe = Q.height, oe = ce + ge) : (ce = Q.x, de = oe, ge = Q.width, fe = ue - de, oe = de + fe);
        var ve = ee[ie - 1].tickValue;
        ve != null && ne.set(ve, ae), C.add(new Rect$3({
          anid: ve != null ? "area_" + ve : null,
          shape: {
            x: ce,
            y: de,
            width: ge,
            height: fe
          },
          style: defaults({
            fill: X[ae]
          }, le),
          autoBatch: !0,
          silent: !0
        })), ae = (ae + 1) % te;
      }
      inner$f(H).splitAreaColors = ne;
    }
  }
}
function rectCoordAxisHandleRemove(H) {
  inner$f(H).splitAreaColors = null;
}
var axisBuilderAttrs$3 = ["axisLine", "axisTickLabel", "axisName"], selfBuilderAttrs$2 = ["splitArea", "splitLine", "minorSplitLine"], CartesianAxisView = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G.axisPointerClass = "CartesianAxisPointer", G;
    }
    return C.prototype.render = function(G, U, K, W) {
      this.group.removeAll();
      var Z = this._axisGroup;
      if (this._axisGroup = new Group$4(), this.group.add(this._axisGroup), !!G.get("show")) {
        var X = G.getCoordSysModel(), Q = layout$2(X, G), ee = new AxisBuilder$1(G, extend({
          handleAutoShown: function(re) {
            for (var ne = X.coordinateSystem.getCartesians(), ae = 0; ae < ne.length; ae++)
              if (isIntervalOrLogScale(ne[ae].getOtherAxis(G.axis).scale))
                return !0;
            return !1;
          }
        }, Q));
        each$f(axisBuilderAttrs$3, ee.add, ee), this._axisGroup.add(ee.getGroup()), each$f(selfBuilderAttrs$2, function(re) {
          G.get([re, "show"]) && axisElementBuilders$2[re](this, this._axisGroup, G, X);
        }, this);
        var te = W && W.type === "changeAxisOrder" && W.isInitSort;
        te || groupTransition(Z, this._axisGroup, G), H.prototype.render.call(this, G, U, K, W);
      }
    }, C.prototype.remove = function() {
      rectCoordAxisHandleRemove(this);
    }, C.type = "cartesianAxis", C;
  }(AxisView$1)
), axisElementBuilders$2 = {
  splitLine: function(H, C, G, U) {
    var K = G.axis;
    if (!K.scale.isBlank()) {
      var W = G.getModel("splitLine"), Z = W.getModel("lineStyle"), X = Z.get("color");
      X = isArray$1(X) ? X : [X];
      for (var Q = U.coordinateSystem.getRect(), ee = K.isHorizontal(), te = 0, re = K.getTicksCoords({
        tickModel: W
      }), ne = [], ae = [], ie = Z.getLineStyle(), se = 0; se < re.length; se++) {
        var oe = K.toGlobalCoord(re[se].coord);
        ee ? (ne[0] = oe, ne[1] = Q.y, ae[0] = oe, ae[1] = Q.y + Q.height) : (ne[0] = Q.x, ne[1] = oe, ae[0] = Q.x + Q.width, ae[1] = oe);
        var le = te++ % X.length, ue = re[se].tickValue, ce = new Line$3({
          anid: ue != null ? "line_" + re[se].tickValue : null,
          autoBatch: !0,
          shape: {
            x1: ne[0],
            y1: ne[1],
            x2: ae[0],
            y2: ae[1]
          },
          style: defaults({
            stroke: X[le]
          }, ie),
          silent: !0
        });
        subPixelOptimizeLine(ce.shape, ie.lineWidth), C.add(ce);
      }
    }
  },
  minorSplitLine: function(H, C, G, U) {
    var K = G.axis, W = G.getModel("minorSplitLine"), Z = W.getModel("lineStyle"), X = U.coordinateSystem.getRect(), Q = K.isHorizontal(), ee = K.getMinorTicksCoords();
    if (ee.length)
      for (var te = [], re = [], ne = Z.getLineStyle(), ae = 0; ae < ee.length; ae++)
        for (var ie = 0; ie < ee[ae].length; ie++) {
          var se = K.toGlobalCoord(ee[ae][ie].coord);
          Q ? (te[0] = se, te[1] = X.y, re[0] = se, re[1] = X.y + X.height) : (te[0] = X.x, te[1] = se, re[0] = X.x + X.width, re[1] = se);
          var oe = new Line$3({
            anid: "minor_line_" + ee[ae][ie].tickValue,
            autoBatch: !0,
            shape: {
              x1: te[0],
              y1: te[1],
              x2: re[0],
              y2: re[1]
            },
            style: ne,
            silent: !0
          });
          subPixelOptimizeLine(oe.shape, ne.lineWidth), C.add(oe);
        }
  },
  splitArea: function(H, C, G, U) {
    rectCoordAxisBuildSplitArea(H, C, G, U);
  }
}, CartesianXAxisView = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G;
    }
    return C.type = "xAxis", C;
  }(CartesianAxisView)
), CartesianYAxisView = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = CartesianXAxisView.type, G;
    }
    return C.type = "yAxis", C;
  }(CartesianAxisView)
), GridView = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = "grid", G;
    }
    return C.prototype.render = function(G, U) {
      this.group.removeAll(), G.get("show") && this.group.add(new Rect$3({
        shape: G.coordinateSystem.getRect(),
        style: defaults({
          fill: G.get("backgroundColor")
        }, G.getItemStyle()),
        silent: !0,
        z2: -1
      }));
    }, C.type = "grid", C;
  }(ComponentView$1)
), extraOption = {
  // gridIndex: 0,
  // gridId: '',
  offset: 0
};
function install$N(H) {
  H.registerComponentView(GridView), H.registerComponentModel(GridModel$1), H.registerCoordinateSystem("cartesian2d", Grid$1), axisModelCreator(H, "x", CartesianAxisModel, extraOption), axisModelCreator(H, "y", CartesianAxisModel, extraOption), H.registerComponentView(CartesianXAxisView), H.registerComponentView(CartesianYAxisView), H.registerPreprocessor(function(C) {
    C.xAxis && C.yAxis && !C.grid && (C.grid = {});
  });
}
function install$M(H) {
  use(install$N), H.registerSeriesModel(ScatterSeriesModel$1), H.registerChartView(ScatterView$1), H.registerLayout(pointsLayout("scatter"));
}
function radarLayout(H) {
  H.eachSeriesByType("radar", function(C) {
    var G = C.getData(), U = [], K = C.coordinateSystem;
    if (K) {
      var W = K.getIndicatorAxes();
      each$f(W, function(Z, X) {
        G.each(G.mapDimension(W[X].dim), function(Q, ee) {
          U[ee] = U[ee] || [];
          var te = K.dataToPoint(Q, X);
          U[ee][X] = isValidPoint(te) ? te : getValueMissingPoint(K);
        });
      }), G.each(function(Z) {
        var X = find(U[Z], function(Q) {
          return isValidPoint(Q);
        }) || getValueMissingPoint(K);
        U[Z].push(X.slice()), G.setItemLayout(Z, U[Z]);
      });
    }
  });
}
function isValidPoint(H) {
  return !isNaN(H[0]) && !isNaN(H[1]);
}
function getValueMissingPoint(H) {
  return [H.cx, H.cy];
}
function radarBackwardCompat(H) {
  var C = H.polar;
  if (C) {
    isArray$1(C) || (C = [C]);
    var G = [];
    each$f(C, function(U, K) {
      U.indicator ? (U.type && !U.shape && (U.shape = U.type), H.radar = H.radar || [], isArray$1(H.radar) || (H.radar = [H.radar]), H.radar.push(U)) : G.push(U);
    }), H.polar = G;
  }
  each$f(H.series, function(U) {
    U && U.type === "radar" && U.polarIndex && (U.radarIndex = U.polarIndex);
  });
}
var RadarView$2 = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G;
    }
    return C.prototype.render = function(G, U, K) {
      var W = G.coordinateSystem, Z = this.group, X = G.getData(), Q = this._data;
      function ee(ne, ae) {
        var ie = ne.getItemVisual(ae, "symbol") || "circle";
        if (ie !== "none") {
          var se = normalizeSymbolSize(ne.getItemVisual(ae, "symbolSize")), oe = createSymbol$1(ie, -1, -1, 2, 2), le = ne.getItemVisual(ae, "symbolRotate") || 0;
          return oe.attr({
            style: {
              strokeNoScale: !0
            },
            z2: 100,
            scaleX: se[0] / 2,
            scaleY: se[1] / 2,
            rotation: le * Math.PI / 180 || 0
          }), oe;
        }
      }
      function te(ne, ae, ie, se, oe, le) {
        ie.removeAll();
        for (var ue = 0; ue < ae.length - 1; ue++) {
          var ce = ee(se, oe);
          ce && (ce.__dimIdx = ue, ne[ue] ? (ce.setPosition(ne[ue]), graphic[le ? "initProps" : "updateProps"](ce, {
            x: ae[ue][0],
            y: ae[ue][1]
          }, G, oe)) : ce.setPosition(ae[ue]), ie.add(ce));
        }
      }
      function re(ne) {
        return map$1(ne, function(ae) {
          return [W.cx, W.cy];
        });
      }
      X.diff(Q).add(function(ne) {
        var ae = X.getItemLayout(ne);
        if (ae) {
          var ie = new Polygon$1(), se = new Polyline$3(), oe = {
            shape: {
              points: ae
            }
          };
          ie.shape.points = re(ae), se.shape.points = re(ae), initProps(ie, oe, G, ne), initProps(se, oe, G, ne);
          var le = new Group$4(), ue = new Group$4();
          le.add(se), le.add(ie), le.add(ue), te(se.shape.points, ae, ue, X, ne, !0), X.setItemGraphicEl(ne, le);
        }
      }).update(function(ne, ae) {
        var ie = Q.getItemGraphicEl(ae), se = ie.childAt(0), oe = ie.childAt(1), le = ie.childAt(2), ue = {
          shape: {
            points: X.getItemLayout(ne)
          }
        };
        ue.shape.points && (te(se.shape.points, ue.shape.points, le, X, ne, !1), saveOldStyle(oe), saveOldStyle(se), updateProps$1(se, ue, G), updateProps$1(oe, ue, G), X.setItemGraphicEl(ne, ie));
      }).remove(function(ne) {
        Z.remove(Q.getItemGraphicEl(ne));
      }).execute(), X.eachItemGraphicEl(function(ne, ae) {
        var ie = X.getItemModel(ae), se = ne.childAt(0), oe = ne.childAt(1), le = ne.childAt(2), ue = X.getItemVisual(ae, "style"), ce = ue.fill;
        Z.add(ne), se.useStyle(defaults(ie.getModel("lineStyle").getLineStyle(), {
          fill: "none",
          stroke: ce
        })), setStatesStylesFromModel(se, ie, "lineStyle"), setStatesStylesFromModel(oe, ie, "areaStyle");
        var de = ie.getModel("areaStyle"), ge = de.isEmpty() && de.parentModel.isEmpty();
        oe.ignore = ge, each$f(["emphasis", "select", "blur"], function(pe) {
          var he = ie.getModel([pe, "areaStyle"]), me = he.isEmpty() && he.parentModel.isEmpty();
          oe.ensureState(pe).ignore = me && ge;
        }), oe.useStyle(defaults(de.getAreaStyle(), {
          fill: ce,
          opacity: 0.7,
          decal: ue.decal
        }));
        var fe = ie.getModel("emphasis"), ve = fe.getModel("itemStyle").getItemStyle();
        le.eachChild(function(pe) {
          if (pe instanceof ZRImage$1) {
            var he = pe.style;
            pe.useStyle(extend({
              // TODO other properties like x, y ?
              image: he.image,
              x: he.x,
              y: he.y,
              width: he.width,
              height: he.height
            }, ue));
          } else
            pe.useStyle(ue), pe.setColor(ce), pe.style.strokeNoScale = !0;
          var me = pe.ensureState("emphasis");
          me.style = clone$4(ve);
          var ye = X.getStore().get(X.getDimensionIndex(pe.__dimIdx), ae);
          (ye == null || isNaN(ye)) && (ye = ""), setLabelStyle(pe, getLabelStatesModels(ie), {
            labelFetcher: X.hostModel,
            labelDataIndex: ae,
            labelDimIndex: pe.__dimIdx,
            defaultText: ye,
            inheritColor: ce,
            defaultOpacity: ue.opacity
          });
        }), toggleHoverEmphasis(ne, fe.get("focus"), fe.get("blurScope"), fe.get("disabled"));
      }), this._data = X;
    }, C.prototype.remove = function() {
      this.group.removeAll(), this._data = null;
    }, C.type = "radar", C;
  }(ChartView$1)
);
const RadarView$3 = RadarView$2;
var RadarSeriesModel = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G.hasSymbolVisual = !0, G;
    }
    return C.prototype.init = function(G) {
      H.prototype.init.apply(this, arguments), this.legendVisualProvider = new LegendVisualProvider$1(bind$1(this.getData, this), bind$1(this.getRawData, this));
    }, C.prototype.getInitialData = function(G, U) {
      return createSeriesDataSimply(this, {
        generateCoord: "indicator_",
        generateCoordCount: 1 / 0
      });
    }, C.prototype.formatTooltip = function(G, U, K) {
      var W = this.getData(), Z = this.coordinateSystem, X = Z.getIndicatorAxes(), Q = this.getData().getName(G), ee = Q === "" ? this.name : Q, te = retrieveVisualColorForTooltipMarker(this, G);
      return createTooltipMarkup("section", {
        header: ee,
        sortBlocks: !0,
        blocks: map$1(X, function(re) {
          var ne = W.get(W.mapDimension(re.dim), G);
          return createTooltipMarkup("nameValue", {
            markerType: "subItem",
            markerColor: te,
            name: re.name,
            value: ne,
            sortParam: ne
          });
        })
      });
    }, C.prototype.getTooltipPosition = function(G) {
      if (G != null) {
        for (var U = this.getData(), K = this.coordinateSystem, W = U.getValues(map$1(K.dimensions, function(ee) {
          return U.mapDimension(ee);
        }), G), Z = 0, X = W.length; Z < X; Z++)
          if (!isNaN(W[Z])) {
            var Q = K.getIndicatorAxes();
            return K.coordToPoint(Q[Z].dataToCoord(W[Z]), Z);
          }
      }
    }, C.type = "series.radar", C.dependencies = ["radar"], C.defaultOption = {
      // zlevel: 0,
      z: 2,
      colorBy: "data",
      coordinateSystem: "radar",
      legendHoverLink: !0,
      radarIndex: 0,
      lineStyle: {
        width: 2,
        type: "solid",
        join: "round"
      },
      label: {
        position: "top"
      },
      // areaStyle: {
      // },
      // itemStyle: {}
      symbolSize: 8
      // symbolRotate: null
    }, C;
  }(SeriesModel$1)
);
const RadarSeriesModel$1 = RadarSeriesModel;
var valueAxisDefault = axisDefault.value;
function defaultsShow(H, C) {
  return defaults({
    show: C
  }, H);
}
var RadarModel = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G;
    }
    return C.prototype.optionUpdated = function() {
      var G = this.get("boundaryGap"), U = this.get("splitNumber"), K = this.get("scale"), W = this.get("axisLine"), Z = this.get("axisTick"), X = this.get("axisLabel"), Q = this.get("axisName"), ee = this.get(["axisName", "show"]), te = this.get(["axisName", "formatter"]), re = this.get("axisNameGap"), ne = this.get("triggerEvent"), ae = map$1(this.get("indicator") || [], function(ie) {
        ie.max != null && ie.max > 0 && !ie.min ? ie.min = 0 : ie.min != null && ie.min < 0 && !ie.max && (ie.max = 0);
        var se = Q;
        ie.color != null && (se = defaults({
          color: ie.color
        }, Q));
        var oe = merge(clone$4(ie), {
          boundaryGap: G,
          splitNumber: U,
          scale: K,
          axisLine: W,
          axisTick: Z,
          // axisType: axisType,
          axisLabel: X,
          // Compatible with 2 and use text
          name: ie.text,
          showName: ee,
          nameLocation: "end",
          nameGap: re,
          // min: 0,
          nameTextStyle: se,
          triggerEvent: ne
        }, !1);
        if (isString(te)) {
          var le = oe.name;
          oe.name = te.replace("{value}", le ?? "");
        } else
          isFunction(te) && (oe.name = te(oe.name, oe));
        var ue = new Model$1(oe, null, this.ecModel);
        return mixin(ue, AxisModelCommonMixin.prototype), ue.mainType = "radar", ue.componentIndex = this.componentIndex, ue;
      }, this);
      this._indicatorModels = ae;
    }, C.prototype.getIndicatorModels = function() {
      return this._indicatorModels;
    }, C.type = "radar", C.defaultOption = {
      // zlevel: 0,
      z: 0,
      center: ["50%", "50%"],
      radius: "75%",
      startAngle: 90,
      axisName: {
        show: !0
        // formatter: null
        // textStyle: {}
      },
      boundaryGap: [0, 0],
      splitNumber: 5,
      axisNameGap: 15,
      scale: !1,
      // Polygon or circle
      shape: "polygon",
      axisLine: merge({
        lineStyle: {
          color: "#bbb"
        }
      }, valueAxisDefault.axisLine),
      axisLabel: defaultsShow(valueAxisDefault.axisLabel, !1),
      axisTick: defaultsShow(valueAxisDefault.axisTick, !1),
      // axisType: 'value',
      splitLine: defaultsShow(valueAxisDefault.splitLine, !0),
      splitArea: defaultsShow(valueAxisDefault.splitArea, !0),
      // {text, min, max}
      indicator: []
    }, C;
  }(ComponentModel$1)
);
const RadarModel$1 = RadarModel;
var axisBuilderAttrs$2 = ["axisLine", "axisTickLabel", "axisName"], RadarView = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G;
    }
    return C.prototype.render = function(G, U, K) {
      var W = this.group;
      W.removeAll(), this._buildAxes(G), this._buildSplitLineAndArea(G);
    }, C.prototype._buildAxes = function(G) {
      var U = G.coordinateSystem, K = U.getIndicatorAxes(), W = map$1(K, function(Z) {
        var X = Z.model.get("showName") ? Z.name : "", Q = new AxisBuilder$1(Z.model, {
          axisName: X,
          position: [U.cx, U.cy],
          rotation: Z.angle,
          labelDirection: -1,
          tickDirection: -1,
          nameDirection: 1
        });
        return Q;
      });
      each$f(W, function(Z) {
        each$f(axisBuilderAttrs$2, Z.add, Z), this.group.add(Z.getGroup());
      }, this);
    }, C.prototype._buildSplitLineAndArea = function(G) {
      var U = G.coordinateSystem, K = U.getIndicatorAxes();
      if (!K.length)
        return;
      var W = G.get("shape"), Z = G.getModel("splitLine"), X = G.getModel("splitArea"), Q = Z.getModel("lineStyle"), ee = X.getModel("areaStyle"), te = Z.get("show"), re = X.get("show"), ne = Q.get("color"), ae = ee.get("color"), ie = isArray$1(ne) ? ne : [ne], se = isArray$1(ae) ? ae : [ae], oe = [], le = [];
      function ue(Se, Ae, _e) {
        var xe = _e % Ae.length;
        return Se[xe] = Se[xe] || [], xe;
      }
      if (W === "circle")
        for (var ce = K[0].getTicksCoords(), de = U.cx, ge = U.cy, fe = 0; fe < ce.length; fe++) {
          if (te) {
            var ve = ue(oe, ie, fe);
            oe[ve].push(new Circle$1({
              shape: {
                cx: de,
                cy: ge,
                r: ce[fe].coord
              }
            }));
          }
          if (re && fe < ce.length - 1) {
            var ve = ue(le, se, fe);
            le[ve].push(new Ring$1({
              shape: {
                cx: de,
                cy: ge,
                r0: ce[fe].coord,
                r: ce[fe + 1].coord
              }
            }));
          }
        }
      else
        for (var pe, he = map$1(K, function(Se, Ae) {
          var _e = Se.getTicksCoords();
          return pe = pe == null ? _e.length - 1 : Math.min(_e.length - 1, pe), map$1(_e, function(xe) {
            return U.coordToPoint(xe.coord, Ae);
          });
        }), me = [], fe = 0; fe <= pe; fe++) {
          for (var ye = [], Ce = 0; Ce < K.length; Ce++)
            ye.push(he[Ce][fe]);
          if (ye[0] ? ye.push(ye[0].slice()) : process.env.NODE_ENV !== "production" && console.error("Can't draw value axis " + fe), te) {
            var ve = ue(oe, ie, fe);
            oe[ve].push(new Polyline$3({
              shape: {
                points: ye
              }
            }));
          }
          if (re && me) {
            var ve = ue(le, se, fe - 1);
            le[ve].push(new Polygon$1({
              shape: {
                points: ye.concat(me)
              }
            }));
          }
          me = ye.slice().reverse();
        }
      var Ie = Q.getLineStyle(), be = ee.getAreaStyle();
      each$f(le, function(Se, Ae) {
        this.group.add(mergePath(Se, {
          style: defaults({
            stroke: "none",
            fill: se[Ae % se.length]
          }, be),
          silent: !0
        }));
      }, this), each$f(oe, function(Se, Ae) {
        this.group.add(mergePath(Se, {
          style: defaults({
            fill: "none",
            stroke: ie[Ae % ie.length]
          }, Ie),
          silent: !0
        }));
      }, this);
    }, C.type = "radar", C;
  }(ComponentView$1)
);
const RadarView$1 = RadarView;
var IndicatorAxis = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C(G, U, K) {
      var W = H.call(this, G, U, K) || this;
      return W.type = "value", W.angle = 0, W.name = "", W;
    }
    return C;
  }(Axis$1)
);
const IndicatorAxis$1 = IndicatorAxis;
var Radar = (
  /** @class */
  function() {
    function H(C, G, U) {
      this.dimensions = [], this._model = C, this._indicatorAxes = map$1(C.getIndicatorModels(), function(K, W) {
        var Z = "indicator_" + W, X = new IndicatorAxis$1(
          Z,
          new IntervalScale$1()
          // (indicatorModel.get('axisType') === 'log') ? new LogScale() : new IntervalScale()
        );
        return X.name = K.get("name"), X.model = K, K.axis = X, this.dimensions.push(Z), X;
      }, this), this.resize(C, U);
    }
    return H.prototype.getIndicatorAxes = function() {
      return this._indicatorAxes;
    }, H.prototype.dataToPoint = function(C, G) {
      var U = this._indicatorAxes[G];
      return this.coordToPoint(U.dataToCoord(C), G);
    }, H.prototype.coordToPoint = function(C, G) {
      var U = this._indicatorAxes[G], K = U.angle, W = this.cx + C * Math.cos(K), Z = this.cy - C * Math.sin(K);
      return [W, Z];
    }, H.prototype.pointToData = function(C) {
      var G = C[0] - this.cx, U = C[1] - this.cy, K = Math.sqrt(G * G + U * U);
      G /= K, U /= K;
      for (var W = Math.atan2(-U, G), Z = 1 / 0, X, Q = -1, ee = 0; ee < this._indicatorAxes.length; ee++) {
        var te = this._indicatorAxes[ee], re = Math.abs(W - te.angle);
        re < Z && (X = te, Q = ee, Z = re);
      }
      return [Q, +(X && X.coordToData(K))];
    }, H.prototype.resize = function(C, G) {
      var U = C.get("center"), K = G.getWidth(), W = G.getHeight(), Z = Math.min(K, W) / 2;
      this.cx = parsePercent(U[0], K), this.cy = parsePercent(U[1], W), this.startAngle = C.get("startAngle") * Math.PI / 180;
      var X = C.get("radius");
      (isString(X) || isNumber(X)) && (X = [0, X]), this.r0 = parsePercent(X[0], Z), this.r = parsePercent(X[1], Z), each$f(this._indicatorAxes, function(Q, ee) {
        Q.setExtent(this.r0, this.r);
        var te = this.startAngle + ee * Math.PI * 2 / this._indicatorAxes.length;
        te = Math.atan2(Math.sin(te), Math.cos(te)), Q.angle = te;
      }, this);
    }, H.prototype.update = function(C, G) {
      var U = this._indicatorAxes, K = this._model;
      each$f(U, function(X) {
        X.scale.setExtent(1 / 0, -1 / 0);
      }), C.eachSeriesByType("radar", function(X, Q) {
        if (!(X.get("coordinateSystem") !== "radar" || C.getComponent("radar", X.get("radarIndex")) !== K)) {
          var ee = X.getData();
          each$f(U, function(te) {
            te.scale.unionExtentFromData(ee, ee.mapDimension(te.dim));
          });
        }
      }, this);
      var W = K.get("splitNumber"), Z = new IntervalScale$1();
      Z.setExtent(0, W), Z.setInterval(1), each$f(U, function(X, Q) {
        alignScaleTicks(X.scale, X.model, Z);
      });
    }, H.prototype.convertToPixel = function(C, G, U) {
      return console.warn("Not implemented."), null;
    }, H.prototype.convertFromPixel = function(C, G, U) {
      return console.warn("Not implemented."), null;
    }, H.prototype.containPoint = function(C) {
      return console.warn("Not implemented."), !1;
    }, H.create = function(C, G) {
      var U = [];
      return C.eachComponent("radar", function(K) {
        var W = new H(K, C, G);
        U.push(W), K.coordinateSystem = W;
      }), C.eachSeriesByType("radar", function(K) {
        K.get("coordinateSystem") === "radar" && (K.coordinateSystem = U[K.get("radarIndex") || 0]);
      }), U;
    }, H.dimensions = [], H;
  }()
);
const Radar$1 = Radar;
function install$L(H) {
  H.registerCoordinateSystem("radar", Radar$1), H.registerComponentModel(RadarModel$1), H.registerComponentView(RadarView$1), H.registerVisual({
    seriesType: "radar",
    reset: function(C) {
      var G = C.getData();
      G.each(function(U) {
        G.setItemVisual(U, "legendIcon", "roundRect");
      }), G.setVisual("legendIcon", "roundRect");
    }
  });
}
function install$K(H) {
  use(install$L), H.registerChartView(RadarView$3), H.registerSeriesModel(RadarSeriesModel$1), H.registerLayout(radarLayout), H.registerProcessor(dataFilter$1("radar")), H.registerPreprocessor(radarBackwardCompat);
}
var ATTR = "\0_ec_interaction_mutex";
function take(H, C, G) {
  var U = getStore(H);
  U[C] = G;
}
function release(H, C, G) {
  var U = getStore(H), K = U[C];
  K === G && (U[C] = null);
}
function isTaken(H, C) {
  return !!getStore(H)[C];
}
function getStore(H) {
  return H[ATTR] || (H[ATTR] = {});
}
registerAction({
  type: "takeGlobalCursor",
  event: "globalCursorTaken",
  update: "update"
}, noop);
var RoamController = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C(G) {
      var U = H.call(this) || this;
      U._zr = G;
      var K = bind$1(U._mousedownHandler, U), W = bind$1(U._mousemoveHandler, U), Z = bind$1(U._mouseupHandler, U), X = bind$1(U._mousewheelHandler, U), Q = bind$1(U._pinchHandler, U);
      return U.enable = function(ee, te) {
        this.disable(), this._opt = defaults(clone$4(te) || {}, {
          zoomOnMouseWheel: !0,
          moveOnMouseMove: !0,
          // By default, wheel do not trigger move.
          moveOnMouseWheel: !1,
          preventDefaultMouseMove: !0
        }), ee == null && (ee = !0), (ee === !0 || ee === "move" || ee === "pan") && (G.on("mousedown", K), G.on("mousemove", W), G.on("mouseup", Z)), (ee === !0 || ee === "scale" || ee === "zoom") && (G.on("mousewheel", X), G.on("pinch", Q));
      }, U.disable = function() {
        G.off("mousedown", K), G.off("mousemove", W), G.off("mouseup", Z), G.off("mousewheel", X), G.off("pinch", Q);
      }, U;
    }
    return C.prototype.isDragging = function() {
      return this._dragging;
    }, C.prototype.isPinching = function() {
      return this._pinching;
    }, C.prototype.setPointerChecker = function(G) {
      this.pointerChecker = G;
    }, C.prototype.dispose = function() {
      this.disable();
    }, C.prototype._mousedownHandler = function(G) {
      if (!isMiddleOrRightButtonOnMouseUpDown(G)) {
        for (var U = G.target; U; ) {
          if (U.draggable)
            return;
          U = U.__hostTarget || U.parent;
        }
        var K = G.offsetX, W = G.offsetY;
        this.pointerChecker && this.pointerChecker(G, K, W) && (this._x = K, this._y = W, this._dragging = !0);
      }
    }, C.prototype._mousemoveHandler = function(G) {
      if (!(!this._dragging || !isAvailableBehavior("moveOnMouseMove", G, this._opt) || G.gestureEvent === "pinch" || isTaken(this._zr, "globalPan"))) {
        var U = G.offsetX, K = G.offsetY, W = this._x, Z = this._y, X = U - W, Q = K - Z;
        this._x = U, this._y = K, this._opt.preventDefaultMouseMove && stop(G.event), trigger$1(this, "pan", "moveOnMouseMove", G, {
          dx: X,
          dy: Q,
          oldX: W,
          oldY: Z,
          newX: U,
          newY: K,
          isAvailableBehavior: null
        });
      }
    }, C.prototype._mouseupHandler = function(G) {
      isMiddleOrRightButtonOnMouseUpDown(G) || (this._dragging = !1);
    }, C.prototype._mousewheelHandler = function(G) {
      var U = isAvailableBehavior("zoomOnMouseWheel", G, this._opt), K = isAvailableBehavior("moveOnMouseWheel", G, this._opt), W = G.wheelDelta, Z = Math.abs(W), X = G.offsetX, Q = G.offsetY;
      if (!(W === 0 || !U && !K)) {
        if (U) {
          var ee = Z > 3 ? 1.4 : Z > 1 ? 1.2 : 1.1, te = W > 0 ? ee : 1 / ee;
          checkPointerAndTrigger(this, "zoom", "zoomOnMouseWheel", G, {
            scale: te,
            originX: X,
            originY: Q,
            isAvailableBehavior: null
          });
        }
        if (K) {
          var re = Math.abs(W), ne = (W > 0 ? 1 : -1) * (re > 3 ? 0.4 : re > 1 ? 0.15 : 0.05);
          checkPointerAndTrigger(this, "scrollMove", "moveOnMouseWheel", G, {
            scrollDelta: ne,
            originX: X,
            originY: Q,
            isAvailableBehavior: null
          });
        }
      }
    }, C.prototype._pinchHandler = function(G) {
      if (!isTaken(this._zr, "globalPan")) {
        var U = G.pinchScale > 1 ? 1.1 : 1 / 1.1;
        checkPointerAndTrigger(this, "zoom", null, G, {
          scale: U,
          originX: G.pinchX,
          originY: G.pinchY,
          isAvailableBehavior: null
        });
      }
    }, C;
  }(Eventful$1)
);
function checkPointerAndTrigger(H, C, G, U, K) {
  H.pointerChecker && H.pointerChecker(U, K.originX, K.originY) && (stop(U.event), trigger$1(H, C, G, U, K));
}
function trigger$1(H, C, G, U, K) {
  K.isAvailableBehavior = bind$1(isAvailableBehavior, null, G, U), H.trigger(C, K);
}
function isAvailableBehavior(H, C, G) {
  var U = G[H];
  return !H || U && (!isString(U) || C.event[U + "Key"]);
}
const RoamController$1 = RoamController;
function updateViewOnPan(H, C, G) {
  var U = H.target;
  U.x += C, U.y += G, U.dirty();
}
function updateViewOnZoom(H, C, G, U) {
  var K = H.target, W = H.zoomLimit, Z = H.zoom = H.zoom || 1;
  if (Z *= C, W) {
    var X = W.min || 0, Q = W.max || 1 / 0;
    Z = Math.max(Math.min(Q, Z), X);
  }
  var ee = Z / H.zoom;
  H.zoom = Z, K.x -= (G - K.x) * (ee - 1), K.y -= (U - K.y) * (ee - 1), K.scaleX *= ee, K.scaleY *= ee, K.dirty();
}
var IRRELEVANT_EXCLUDES = {
  axisPointer: 1,
  tooltip: 1,
  brush: 1
};
function onIrrelevantElement(H, C, G) {
  var U = C.getComponentByElement(H.topTarget), K = U && U.coordinateSystem;
  return U && U !== G && !IRRELEVANT_EXCLUDES.hasOwnProperty(U.mainType) && K && K.model !== G;
}
function parseXML(H) {
  if (isString(H)) {
    var C = new DOMParser();
    H = C.parseFromString(H, "text/xml");
  }
  var G = H;
  for (G.nodeType === 9 && (G = G.firstChild); G.nodeName.toLowerCase() !== "svg" || G.nodeType !== 1; )
    G = G.nextSibling;
  return G;
}
var nodeParsers, INHERITABLE_STYLE_ATTRIBUTES_MAP = {
  fill: "fill",
  stroke: "stroke",
  "stroke-width": "lineWidth",
  opacity: "opacity",
  "fill-opacity": "fillOpacity",
  "stroke-opacity": "strokeOpacity",
  "stroke-dasharray": "lineDash",
  "stroke-dashoffset": "lineDashOffset",
  "stroke-linecap": "lineCap",
  "stroke-linejoin": "lineJoin",
  "stroke-miterlimit": "miterLimit",
  "font-family": "fontFamily",
  "font-size": "fontSize",
  "font-style": "fontStyle",
  "font-weight": "fontWeight",
  "text-anchor": "textAlign",
  visibility: "visibility",
  display: "display"
}, INHERITABLE_STYLE_ATTRIBUTES_MAP_KEYS = keys(INHERITABLE_STYLE_ATTRIBUTES_MAP), SELF_STYLE_ATTRIBUTES_MAP = {
  "alignment-baseline": "textBaseline",
  "stop-color": "stopColor"
}, SELF_STYLE_ATTRIBUTES_MAP_KEYS = keys(SELF_STYLE_ATTRIBUTES_MAP), SVGParser = function() {
  function H() {
    this._defs = {}, this._root = null;
  }
  return H.prototype.parse = function(C, G) {
    G = G || {};
    var U = parseXML(C);
    if (process.env.NODE_ENV !== "production" && !U)
      throw new Error("Illegal svg");
    this._defsUsePending = [];
    var K = new Group$4();
    this._root = K;
    var W = [], Z = U.getAttribute("viewBox") || "", X = parseFloat(U.getAttribute("width") || G.width), Q = parseFloat(U.getAttribute("height") || G.height);
    isNaN(X) && (X = null), isNaN(Q) && (Q = null), parseAttributes(U, K, null, !0, !1);
    for (var ee = U.firstChild; ee; )
      this._parseNode(ee, K, W, null, !1, !1), ee = ee.nextSibling;
    applyDefs(this._defs, this._defsUsePending), this._defsUsePending = [];
    var te, re;
    if (Z) {
      var ne = splitNumberSequence(Z);
      ne.length >= 4 && (te = {
        x: parseFloat(ne[0] || 0),
        y: parseFloat(ne[1] || 0),
        width: parseFloat(ne[2]),
        height: parseFloat(ne[3])
      });
    }
    if (te && X != null && Q != null && (re = makeViewBoxTransform(te, { x: 0, y: 0, width: X, height: Q }), !G.ignoreViewBox)) {
      var ae = K;
      K = new Group$4(), K.add(ae), ae.scaleX = ae.scaleY = re.scale, ae.x = re.x, ae.y = re.y;
    }
    return !G.ignoreRootClip && X != null && Q != null && K.setClipPath(new Rect$3({
      shape: { x: 0, y: 0, width: X, height: Q }
    })), {
      root: K,
      width: X,
      height: Q,
      viewBoxRect: te,
      viewBoxTransform: re,
      named: W
    };
  }, H.prototype._parseNode = function(C, G, U, K, W, Z) {
    var X = C.nodeName.toLowerCase(), Q, ee = K;
    if (X === "defs" && (W = !0), X === "text" && (Z = !0), X === "defs" || X === "switch")
      Q = G;
    else {
      if (!W) {
        var te = nodeParsers[X];
        if (te && hasOwn(nodeParsers, X)) {
          Q = te.call(this, C, G);
          var re = C.getAttribute("name");
          if (re) {
            var ne = {
              name: re,
              namedFrom: null,
              svgNodeTagLower: X,
              el: Q
            };
            U.push(ne), X === "g" && (ee = ne);
          } else
            K && U.push({
              name: K.name,
              namedFrom: K,
              svgNodeTagLower: X,
              el: Q
            });
          G.add(Q);
        }
      }
      var ae = paintServerParsers[X];
      if (ae && hasOwn(paintServerParsers, X)) {
        var ie = ae.call(this, C), se = C.getAttribute("id");
        se && (this._defs[se] = ie);
      }
    }
    if (Q && Q.isGroup)
      for (var oe = C.firstChild; oe; )
        oe.nodeType === 1 ? this._parseNode(oe, Q, U, ee, W, Z) : oe.nodeType === 3 && Z && this._parseText(oe, Q), oe = oe.nextSibling;
  }, H.prototype._parseText = function(C, G) {
    var U = new TSpan$1({
      style: {
        text: C.textContent
      },
      silent: !0,
      x: this._textX || 0,
      y: this._textY || 0
    });
    inheritStyle(G, U), parseAttributes(C, U, this._defsUsePending, !1, !1), applyTextAlignment(U, G);
    var K = U.style, W = K.fontSize;
    W && W < 9 && (K.fontSize = 9, U.scaleX *= W / 9, U.scaleY *= W / 9);
    var Z = (K.fontSize || K.fontFamily) && [
      K.fontStyle,
      K.fontWeight,
      (K.fontSize || 12) + "px",
      K.fontFamily || "sans-serif"
    ].join(" ");
    K.font = Z;
    var X = U.getBoundingRect();
    return this._textX += X.width, G.add(U), U;
  }, H.internalField = function() {
    nodeParsers = {
      g: function(C, G) {
        var U = new Group$4();
        return inheritStyle(G, U), parseAttributes(C, U, this._defsUsePending, !1, !1), U;
      },
      rect: function(C, G) {
        var U = new Rect$3();
        return inheritStyle(G, U), parseAttributes(C, U, this._defsUsePending, !1, !1), U.setShape({
          x: parseFloat(C.getAttribute("x") || "0"),
          y: parseFloat(C.getAttribute("y") || "0"),
          width: parseFloat(C.getAttribute("width") || "0"),
          height: parseFloat(C.getAttribute("height") || "0")
        }), U.silent = !0, U;
      },
      circle: function(C, G) {
        var U = new Circle$1();
        return inheritStyle(G, U), parseAttributes(C, U, this._defsUsePending, !1, !1), U.setShape({
          cx: parseFloat(C.getAttribute("cx") || "0"),
          cy: parseFloat(C.getAttribute("cy") || "0"),
          r: parseFloat(C.getAttribute("r") || "0")
        }), U.silent = !0, U;
      },
      line: function(C, G) {
        var U = new Line$3();
        return inheritStyle(G, U), parseAttributes(C, U, this._defsUsePending, !1, !1), U.setShape({
          x1: parseFloat(C.getAttribute("x1") || "0"),
          y1: parseFloat(C.getAttribute("y1") || "0"),
          x2: parseFloat(C.getAttribute("x2") || "0"),
          y2: parseFloat(C.getAttribute("y2") || "0")
        }), U.silent = !0, U;
      },
      ellipse: function(C, G) {
        var U = new Ellipse$1();
        return inheritStyle(G, U), parseAttributes(C, U, this._defsUsePending, !1, !1), U.setShape({
          cx: parseFloat(C.getAttribute("cx") || "0"),
          cy: parseFloat(C.getAttribute("cy") || "0"),
          rx: parseFloat(C.getAttribute("rx") || "0"),
          ry: parseFloat(C.getAttribute("ry") || "0")
        }), U.silent = !0, U;
      },
      polygon: function(C, G) {
        var U = C.getAttribute("points"), K;
        U && (K = parsePoints(U));
        var W = new Polygon$1({
          shape: {
            points: K || []
          },
          silent: !0
        });
        return inheritStyle(G, W), parseAttributes(C, W, this._defsUsePending, !1, !1), W;
      },
      polyline: function(C, G) {
        var U = C.getAttribute("points"), K;
        U && (K = parsePoints(U));
        var W = new Polyline$3({
          shape: {
            points: K || []
          },
          silent: !0
        });
        return inheritStyle(G, W), parseAttributes(C, W, this._defsUsePending, !1, !1), W;
      },
      image: function(C, G) {
        var U = new ZRImage$1();
        return inheritStyle(G, U), parseAttributes(C, U, this._defsUsePending, !1, !1), U.setStyle({
          image: C.getAttribute("xlink:href") || C.getAttribute("href"),
          x: +C.getAttribute("x"),
          y: +C.getAttribute("y"),
          width: +C.getAttribute("width"),
          height: +C.getAttribute("height")
        }), U.silent = !0, U;
      },
      text: function(C, G) {
        var U = C.getAttribute("x") || "0", K = C.getAttribute("y") || "0", W = C.getAttribute("dx") || "0", Z = C.getAttribute("dy") || "0";
        this._textX = parseFloat(U) + parseFloat(W), this._textY = parseFloat(K) + parseFloat(Z);
        var X = new Group$4();
        return inheritStyle(G, X), parseAttributes(C, X, this._defsUsePending, !1, !0), X;
      },
      tspan: function(C, G) {
        var U = C.getAttribute("x"), K = C.getAttribute("y");
        U != null && (this._textX = parseFloat(U)), K != null && (this._textY = parseFloat(K));
        var W = C.getAttribute("dx") || "0", Z = C.getAttribute("dy") || "0", X = new Group$4();
        return inheritStyle(G, X), parseAttributes(C, X, this._defsUsePending, !1, !0), this._textX += parseFloat(W), this._textY += parseFloat(Z), X;
      },
      path: function(C, G) {
        var U = C.getAttribute("d") || "", K = createFromString(U);
        return inheritStyle(G, K), parseAttributes(C, K, this._defsUsePending, !1, !1), K.silent = !0, K;
      }
    };
  }(), H;
}(), paintServerParsers = {
  lineargradient: function(H) {
    var C = parseInt(H.getAttribute("x1") || "0", 10), G = parseInt(H.getAttribute("y1") || "0", 10), U = parseInt(H.getAttribute("x2") || "10", 10), K = parseInt(H.getAttribute("y2") || "0", 10), W = new LinearGradient$1(C, G, U, K);
    return parsePaintServerUnit(H, W), parseGradientColorStops(H, W), W;
  },
  radialgradient: function(H) {
    var C = parseInt(H.getAttribute("cx") || "0", 10), G = parseInt(H.getAttribute("cy") || "0", 10), U = parseInt(H.getAttribute("r") || "0", 10), K = new RadialGradient$1(C, G, U);
    return parsePaintServerUnit(H, K), parseGradientColorStops(H, K), K;
  }
};
function parsePaintServerUnit(H, C) {
  var G = H.getAttribute("gradientUnits");
  G === "userSpaceOnUse" && (C.global = !0);
}
function parseGradientColorStops(H, C) {
  for (var G = H.firstChild; G; ) {
    if (G.nodeType === 1 && G.nodeName.toLocaleLowerCase() === "stop") {
      var U = G.getAttribute("offset"), K = void 0;
      U && U.indexOf("%") > 0 ? K = parseInt(U, 10) / 100 : U ? K = parseFloat(U) : K = 0;
      var W = {};
      parseInlineStyle(G, W, W);
      var Z = W.stopColor || G.getAttribute("stop-color") || "#000000";
      C.colorStops.push({
        offset: K,
        color: Z
      });
    }
    G = G.nextSibling;
  }
}
function inheritStyle(H, C) {
  H && H.__inheritedStyle && (C.__inheritedStyle || (C.__inheritedStyle = {}), defaults(C.__inheritedStyle, H.__inheritedStyle));
}
function parsePoints(H) {
  for (var C = splitNumberSequence(H), G = [], U = 0; U < C.length; U += 2) {
    var K = parseFloat(C[U]), W = parseFloat(C[U + 1]);
    G.push([K, W]);
  }
  return G;
}
function parseAttributes(H, C, G, U, K) {
  var W = C, Z = W.__inheritedStyle = W.__inheritedStyle || {}, X = {};
  H.nodeType === 1 && (parseTransformAttribute(H, C), parseInlineStyle(H, Z, X), U || parseAttributeStyle(H, Z, X)), W.style = W.style || {}, Z.fill != null && (W.style.fill = getFillStrokeStyle(W, "fill", Z.fill, G)), Z.stroke != null && (W.style.stroke = getFillStrokeStyle(W, "stroke", Z.stroke, G)), each$f([
    "lineWidth",
    "opacity",
    "fillOpacity",
    "strokeOpacity",
    "miterLimit",
    "fontSize"
  ], function(Q) {
    Z[Q] != null && (W.style[Q] = parseFloat(Z[Q]));
  }), each$f([
    "lineDashOffset",
    "lineCap",
    "lineJoin",
    "fontWeight",
    "fontFamily",
    "fontStyle",
    "textAlign"
  ], function(Q) {
    Z[Q] != null && (W.style[Q] = Z[Q]);
  }), K && (W.__selfStyle = X), Z.lineDash && (W.style.lineDash = map$1(splitNumberSequence(Z.lineDash), function(Q) {
    return parseFloat(Q);
  })), (Z.visibility === "hidden" || Z.visibility === "collapse") && (W.invisible = !0), Z.display === "none" && (W.ignore = !0);
}
function applyTextAlignment(H, C) {
  var G = C.__selfStyle;
  if (G) {
    var U = G.textBaseline, K = U;
    !U || U === "auto" || U === "baseline" ? K = "alphabetic" : U === "before-edge" || U === "text-before-edge" ? K = "top" : U === "after-edge" || U === "text-after-edge" ? K = "bottom" : (U === "central" || U === "mathematical") && (K = "middle"), H.style.textBaseline = K;
  }
  var W = C.__inheritedStyle;
  if (W) {
    var Z = W.textAlign, X = Z;
    Z && (Z === "middle" && (X = "center"), H.style.textAlign = X);
  }
}
var urlRegex = /^url\(\s*#(.*?)\)/;
function getFillStrokeStyle(H, C, G, U) {
  var K = G && G.match(urlRegex);
  if (K) {
    var W = trim$1(K[1]);
    U.push([H, C, W]);
    return;
  }
  return G === "none" && (G = null), G;
}
function applyDefs(H, C) {
  for (var G = 0; G < C.length; G++) {
    var U = C[G];
    U[0].style[U[1]] = H[U[2]];
  }
}
var numberReg = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g;
function splitNumberSequence(H) {
  return H.match(numberReg) || [];
}
var transformRegex = /(translate|scale|rotate|skewX|skewY|matrix)\(([\-\s0-9\.eE,]*)\)/g, DEGREE_TO_ANGLE = Math.PI / 180;
function parseTransformAttribute(H, C) {
  var G = H.getAttribute("transform");
  if (G) {
    G = G.replace(/,/g, " ");
    var U = [], K = null;
    G.replace(transformRegex, function(re, ne, ae) {
      return U.push(ne, ae), "";
    });
    for (var W = U.length - 1; W > 0; W -= 2) {
      var Z = U[W], X = U[W - 1], Q = splitNumberSequence(Z);
      switch (K = K || create$1(), X) {
        case "translate":
          translate(K, K, [parseFloat(Q[0]), parseFloat(Q[1] || "0")]);
          break;
        case "scale":
          scale$1(K, K, [parseFloat(Q[0]), parseFloat(Q[1] || Q[0])]);
          break;
        case "rotate":
          rotate(K, K, -parseFloat(Q[0]) * DEGREE_TO_ANGLE);
          break;
        case "skewX":
          var ee = Math.tan(parseFloat(Q[0]) * DEGREE_TO_ANGLE);
          mul(K, [1, 0, ee, 1, 0, 0], K);
          break;
        case "skewY":
          var te = Math.tan(parseFloat(Q[0]) * DEGREE_TO_ANGLE);
          mul(K, [1, te, 0, 1, 0, 0], K);
          break;
        case "matrix":
          K[0] = parseFloat(Q[0]), K[1] = parseFloat(Q[1]), K[2] = parseFloat(Q[2]), K[3] = parseFloat(Q[3]), K[4] = parseFloat(Q[4]), K[5] = parseFloat(Q[5]);
          break;
      }
    }
    C.setLocalTransform(K);
  }
}
var styleRegex = /([^\s:;]+)\s*:\s*([^:;]+)/g;
function parseInlineStyle(H, C, G) {
  var U = H.getAttribute("style");
  if (U) {
    styleRegex.lastIndex = 0;
    for (var K; (K = styleRegex.exec(U)) != null; ) {
      var W = K[1], Z = hasOwn(INHERITABLE_STYLE_ATTRIBUTES_MAP, W) ? INHERITABLE_STYLE_ATTRIBUTES_MAP[W] : null;
      Z && (C[Z] = K[2]);
      var X = hasOwn(SELF_STYLE_ATTRIBUTES_MAP, W) ? SELF_STYLE_ATTRIBUTES_MAP[W] : null;
      X && (G[X] = K[2]);
    }
  }
}
function parseAttributeStyle(H, C, G) {
  for (var U = 0; U < INHERITABLE_STYLE_ATTRIBUTES_MAP_KEYS.length; U++) {
    var K = INHERITABLE_STYLE_ATTRIBUTES_MAP_KEYS[U], W = H.getAttribute(K);
    W != null && (C[INHERITABLE_STYLE_ATTRIBUTES_MAP[K]] = W);
  }
  for (var U = 0; U < SELF_STYLE_ATTRIBUTES_MAP_KEYS.length; U++) {
    var K = SELF_STYLE_ATTRIBUTES_MAP_KEYS[U], W = H.getAttribute(K);
    W != null && (G[SELF_STYLE_ATTRIBUTES_MAP[K]] = W);
  }
}
function makeViewBoxTransform(H, C) {
  var G = C.width / H.width, U = C.height / H.height, K = Math.min(G, U);
  return {
    scale: K,
    x: -(H.x + H.width / 2) * K + (C.x + C.width / 2),
    y: -(H.y + H.height / 2) * K + (C.y + C.height / 2)
  };
}
function parseSVG(H, C) {
  var G = new SVGParser();
  return G.parse(H, C);
}
var REGION_AVAILABLE_SVG_TAG_MAP = createHashMap([
  "rect",
  "circle",
  "line",
  "ellipse",
  "polygon",
  "polyline",
  "path",
  // <text> <tspan> are also enabled because some SVG might paint text itself,
  // but still need to trigger events or tooltip.
  "text",
  "tspan",
  // <g> is also enabled because this case: if multiple tags share one name
  // and need label displayed, every tags will display the name, which is not
  // expected. So we can put them into a <g name="xxx">. Thereby only one label
  // displayed and located based on the bounding rect of the <g>.
  "g"
]), GeoSVGResource = (
  /** @class */
  function() {
    function H(C, G) {
      this.type = "geoSVG", this._usedGraphicMap = createHashMap(), this._freedGraphics = [], this._mapName = C, this._parsedXML = parseXML(G);
    }
    return H.prototype.load = function() {
      var C = this._firstGraphic;
      if (!C) {
        C = this._firstGraphic = this._buildGraphic(this._parsedXML), this._freedGraphics.push(C), this._boundingRect = this._firstGraphic.boundingRect.clone();
        var G = createRegions(C.named), U = G.regions, K = G.regionsMap;
        this._regions = U, this._regionsMap = K;
      }
      return {
        boundingRect: this._boundingRect,
        regions: this._regions,
        regionsMap: this._regionsMap
      };
    }, H.prototype._buildGraphic = function(C) {
      var G, U;
      try {
        G = C && parseSVG(C, {
          ignoreViewBox: !0,
          ignoreRootClip: !0
        }) || {}, U = G.root, assert(U != null);
      } catch (oe) {
        throw new Error(`Invalid svg format
` + oe.message);
      }
      var K = new Group$4();
      K.add(U), K.isGeoSVGGraphicRoot = !0;
      var W = G.width, Z = G.height, X = G.viewBoxRect, Q = this._boundingRect;
      if (!Q) {
        var ee = void 0, te = void 0, re = void 0, ne = void 0;
        if (W != null ? (ee = 0, re = W) : X && (ee = X.x, re = X.width), Z != null ? (te = 0, ne = Z) : X && (te = X.y, ne = X.height), ee == null || te == null) {
          var ae = U.getBoundingRect();
          ee == null && (ee = ae.x, re = ae.width), te == null && (te = ae.y, ne = ae.height);
        }
        Q = this._boundingRect = new BoundingRect$1(ee, te, re, ne);
      }
      if (X) {
        var ie = makeViewBoxTransform(X, Q);
        U.scaleX = U.scaleY = ie.scale, U.x = ie.x, U.y = ie.y;
      }
      K.setClipPath(new Rect$3({
        shape: Q.plain()
      }));
      var se = [];
      return each$f(G.named, function(oe) {
        REGION_AVAILABLE_SVG_TAG_MAP.get(oe.svgNodeTagLower) != null && (se.push(oe), setSilent(oe.el));
      }), {
        root: K,
        boundingRect: Q,
        named: se
      };
    }, H.prototype.useGraphic = function(C) {
      var G = this._usedGraphicMap, U = G.get(C);
      return U || (U = this._freedGraphics.pop() || this._buildGraphic(this._parsedXML), G.set(C, U), U);
    }, H.prototype.freeGraphic = function(C) {
      var G = this._usedGraphicMap, U = G.get(C);
      U && (G.removeKey(C), this._freedGraphics.push(U));
    }, H;
  }()
);
function setSilent(H) {
  H.silent = !1, H.isGroup && H.traverse(function(C) {
    C.silent = !1;
  });
}
function createRegions(H) {
  var C = [], G = createHashMap();
  return each$f(H, function(U) {
    if (U.namedFrom == null) {
      var K = new GeoSVGRegion(U.name, U.el);
      C.push(K), G.set(U.name, K);
    }
  }), {
    regions: C,
    regionsMap: G
  };
}
var geoCoord = [126, 25], nanhaiName = "南海诸岛", points$1 = [[[0, 3.5], [7, 11.2], [15, 11.9], [30, 7], [42, 0.7], [52, 0.7], [56, 7.7], [59, 0.7], [64, 0.7], [64, 0], [5, 0], [0, 3.5]], [[13, 16.1], [19, 14.7], [16, 21.7], [11, 23.1], [13, 16.1]], [[12, 32.2], [14, 38.5], [15, 38.5], [13, 32.2], [12, 32.2]], [[16, 47.6], [12, 53.2], [13, 53.2], [18, 47.6], [16, 47.6]], [[6, 64.4], [8, 70], [9, 70], [8, 64.4], [6, 64.4]], [[23, 82.6], [29, 79.8], [30, 79.8], [25, 82.6], [23, 82.6]], [[37, 70.7], [43, 62.3], [44, 62.3], [39, 70.7], [37, 70.7]], [[48, 51.1], [51, 45.5], [53, 45.5], [50, 51.1], [48, 51.1]], [[51, 35], [51, 28.7], [53, 28.7], [53, 35], [51, 35]], [[52, 22.4], [55, 17.5], [56, 17.5], [53, 22.4], [52, 22.4]], [[58, 12.6], [62, 7], [63, 7], [60, 12.6], [58, 12.6]], [[0, 3.5], [0, 93.1], [64, 93.1], [64, 0], [63, 0], [63, 92.4], [1, 92.4], [1, 3.5], [0, 3.5]]];
for (var i = 0; i < points$1.length; i++)
  for (var k = 0; k < points$1[i].length; k++)
    points$1[i][k][0] /= 10.5, points$1[i][k][1] /= -10.5 / 0.75, points$1[i][k][0] += geoCoord[0], points$1[i][k][1] += geoCoord[1];
function fixNanhai(H, C) {
  if (H === "china") {
    for (var G = 0; G < C.length; G++)
      if (C[G].name === nanhaiName)
        return;
    C.push(new GeoJSONRegion(nanhaiName, map$1(points$1, function(U) {
      return {
        type: "polygon",
        exterior: U
      };
    }), geoCoord));
  }
}
var coordsOffsetMap = {
  南海诸岛: [32, 80],
  // 全国
  广东: [0, -10],
  香港: [10, 5],
  澳门: [-10, 10],
  // '北京': [-10, 0],
  天津: [5, 5]
};
function fixTextCoords(H, C) {
  if (H === "china") {
    var G = coordsOffsetMap[C.name];
    if (G) {
      var U = C.getCenter();
      U[0] += G[0] / 10.5, U[1] += -G[1] / (10.5 / 0.75), C.setCenter(U);
    }
  }
}
var points = [[[123.45165252685547, 25.73527164402261], [123.49731445312499, 25.73527164402261], [123.49731445312499, 25.750734064600884], [123.45165252685547, 25.750734064600884], [123.45165252685547, 25.73527164402261]]];
function fixDiaoyuIsland(H, C) {
  H === "china" && C.name === "台湾" && C.geometries.push({
    type: "polygon",
    exterior: points[0]
  });
}
var DEFAULT_NAME_PROPERTY = "name", GeoJSONResource = (
  /** @class */
  function() {
    function H(C, G, U) {
      this.type = "geoJSON", this._parsedMap = createHashMap(), this._mapName = C, this._specialAreas = U, this._geoJSON = parseInput(G);
    }
    return H.prototype.load = function(C, G) {
      G = G || DEFAULT_NAME_PROPERTY;
      var U = this._parsedMap.get(G);
      if (!U) {
        var K = this._parseToRegions(G);
        U = this._parsedMap.set(G, {
          regions: K,
          boundingRect: calculateBoundingRect(K)
        });
      }
      var W = createHashMap(), Z = [];
      return each$f(U.regions, function(X) {
        var Q = X.name;
        C && hasOwn(C, Q) && (X = X.cloneShallow(Q = C[Q])), Z.push(X), W.set(Q, X);
      }), {
        regions: Z,
        boundingRect: U.boundingRect || new BoundingRect$1(0, 0, 0, 0),
        regionsMap: W
      };
    }, H.prototype._parseToRegions = function(C) {
      var G = this._mapName, U = this._geoJSON, K;
      try {
        K = U ? parseGeoJSON(U, C) : [];
      } catch (W) {
        throw new Error(`Invalid geoJson format
` + W.message);
      }
      return fixNanhai(G, K), each$f(K, function(W) {
        var Z = W.name;
        fixTextCoords(G, W), fixDiaoyuIsland(G, W);
        var X = this._specialAreas && this._specialAreas[Z];
        X && W.transformTo(X.left, X.top, X.width, X.height);
      }, this), K;
    }, H.prototype.getMapForUser = function() {
      return {
        // For backward compatibility, use geoJson
        // PENDING: it has been returning them without clone.
        // do we need to avoid outsite modification?
        geoJson: this._geoJSON,
        geoJSON: this._geoJSON,
        specialAreas: this._specialAreas
      };
    }, H;
  }()
);
function calculateBoundingRect(H) {
  for (var C, G = 0; G < H.length; G++) {
    var U = H[G].getBoundingRect();
    C = C || U.clone(), C.union(U);
  }
  return C;
}
function parseInput(H) {
  return isString(H) ? typeof JSON < "u" && JSON.parse ? JSON.parse(H) : new Function("return (" + H + ");")() : H;
}
var storage = createHashMap();
const geoSourceManager = {
  /**
   * Compatible with previous `echarts.registerMap`.
   *
   * @usage
   * ```js
   *
   * echarts.registerMap('USA', geoJson, specialAreas);
   *
   * echarts.registerMap('USA', {
   *     geoJson: geoJson,
   *     specialAreas: {...}
   * });
   * echarts.registerMap('USA', {
   *     geoJSON: geoJson,
   *     specialAreas: {...}
   * });
   *
   * echarts.registerMap('airport', {
   *     svg: svg
   * }
   * ```
   *
   * Note:
   * Do not support that register multiple geoJSON or SVG
   * one map name. Because different geoJSON and SVG have
   * different unit. It's not easy to make sure how those
   * units are mapping/normalize.
   * If intending to use multiple geoJSON or SVG, we can
   * use multiple geo coordinate system.
   */
  registerMap: function(H, C, G) {
    if (C.svg) {
      var U = new GeoSVGResource(H, C.svg);
      storage.set(H, U);
    } else {
      var K = C.geoJson || C.geoJSON;
      K && !C.features ? G = C.specialAreas : K = C;
      var U = new GeoJSONResource(H, K, G);
      storage.set(H, U);
    }
  },
  getGeoResource: function(H) {
    return storage.get(H);
  },
  /**
   * Only for exporting to users.
   * **MUST NOT** used internally.
   */
  getMapForUser: function(H) {
    var C = storage.get(H);
    return C && C.type === "geoJSON" && C.getMapForUser();
  },
  load: function(H, C, G) {
    var U = storage.get(H);
    if (!U) {
      process.env.NODE_ENV !== "production" && console.error("Map " + H + " not exists. The GeoJSON of the map must be provided.");
      return;
    }
    return U.load(C, G);
  }
};
var OPTION_STYLE_ENABLED_TAGS = ["rect", "circle", "line", "ellipse", "polygon", "polyline", "path"], OPTION_STYLE_ENABLED_TAG_MAP = createHashMap(OPTION_STYLE_ENABLED_TAGS), STATE_TRIGGER_TAG_MAP = createHashMap(OPTION_STYLE_ENABLED_TAGS.concat(["g"])), LABEL_HOST_MAP = createHashMap(OPTION_STYLE_ENABLED_TAGS.concat(["g"])), mapLabelRaw = makeInner();
function getFixedItemStyle(H) {
  var C = H.getItemStyle(), G = H.get("areaColor");
  return G != null && (C.fill = G), C;
}
function fixLineStyle(H) {
  var C = H.style;
  C && (C.stroke = C.stroke || C.fill, C.fill = null);
}
var MapDraw = (
  /** @class */
  function() {
    function H(C) {
      var G = new Group$4();
      this.uid = getUID("ec_map_draw"), this._controller = new RoamController$1(C.getZr()), this._controllerHost = {
        target: G
      }, this.group = G, G.add(this._regionsGroup = new Group$4()), G.add(this._svgGroup = new Group$4());
    }
    return H.prototype.draw = function(C, G, U, K, W) {
      var Z = C.mainType === "geo", X = C.getData && C.getData();
      Z && G.eachComponent({
        mainType: "series",
        subType: "map"
      }, function(le) {
        !X && le.getHostGeoModel() === C && (X = le.getData());
      });
      var Q = C.coordinateSystem, ee = this._regionsGroup, te = this.group, re = Q.getTransformInfo(), ne = re.raw, ae = re.roam, ie = !ee.childAt(0) || W;
      ie ? (te.x = ae.x, te.y = ae.y, te.scaleX = ae.scaleX, te.scaleY = ae.scaleY, te.dirty()) : updateProps$1(te, ae, C);
      var se = X && X.getVisual("visualMeta") && X.getVisual("visualMeta").length > 0, oe = {
        api: U,
        geo: Q,
        mapOrGeoModel: C,
        data: X,
        isVisualEncodedByVisualMap: se,
        isGeo: Z,
        transformInfoRaw: ne
      };
      Q.resourceType === "geoJSON" ? this._buildGeoJSON(oe) : Q.resourceType === "geoSVG" && this._buildSVG(oe), this._updateController(C, G, U), this._updateMapSelectHandler(C, ee, U, K);
    }, H.prototype._buildGeoJSON = function(C) {
      var G = this._regionsGroupByName = createHashMap(), U = createHashMap(), K = this._regionsGroup, W = C.transformInfoRaw, Z = C.mapOrGeoModel, X = C.data, Q = C.geo.projection, ee = Q && Q.stream;
      function te(ae, ie) {
        return ie && (ae = ie(ae)), ae && [ae[0] * W.scaleX + W.x, ae[1] * W.scaleY + W.y];
      }
      function re(ae) {
        for (var ie = [], se = !ee && Q && Q.project, oe = 0; oe < ae.length; ++oe) {
          var le = te(ae[oe], se);
          le && ie.push(le);
        }
        return ie;
      }
      function ne(ae) {
        return {
          shape: {
            points: re(ae)
          }
        };
      }
      K.removeAll(), each$f(C.geo.regions, function(ae) {
        var ie = ae.name, se = G.get(ie), oe = U.get(ie) || {}, le = oe.dataIdx, ue = oe.regionModel;
        se || (se = G.set(ie, new Group$4()), K.add(se), le = X ? X.indexOfName(ie) : null, ue = C.isGeo ? Z.getRegionModel(ie) : X ? X.getItemModel(le) : null, U.set(ie, {
          dataIdx: le,
          regionModel: ue
        }));
        var ce = [], de = [];
        each$f(ae.geometries, function(ve) {
          if (ve.type === "polygon") {
            var pe = [ve.exterior].concat(ve.interiors || []);
            ee && (pe = projectPolys(pe, ee)), each$f(pe, function(me) {
              ce.push(new Polygon$1(ne(me)));
            });
          } else {
            var he = ve.points;
            ee && (he = projectPolys(he, ee, !0)), each$f(he, function(me) {
              de.push(new Polyline$3(ne(me)));
            });
          }
        });
        var ge = te(ae.getCenter(), Q && Q.project);
        function fe(ve, pe) {
          if (ve.length) {
            var he = new CompoundPath$1({
              culling: !0,
              segmentIgnoreThreshold: 1,
              shape: {
                paths: ve
              }
            });
            se.add(he), applyOptionStyleForRegion(C, he, le, ue), resetLabelForRegion(C, he, ie, ue, Z, le, ge), pe && (fixLineStyle(he), each$f(he.states, fixLineStyle));
          }
        }
        fe(ce), fe(de, !0);
      }), G.each(function(ae, ie) {
        var se = U.get(ie), oe = se.dataIdx, le = se.regionModel;
        resetEventTriggerForRegion(C, ae, ie, le, Z, oe), resetTooltipForRegion(C, ae, ie, le, Z), resetStateTriggerForRegion(C, ae, ie, le, Z);
      }, this);
    }, H.prototype._buildSVG = function(C) {
      var G = C.geo.map, U = C.transformInfoRaw;
      this._svgGroup.x = U.x, this._svgGroup.y = U.y, this._svgGroup.scaleX = U.scaleX, this._svgGroup.scaleY = U.scaleY, this._svgResourceChanged(G) && (this._freeSVG(), this._useSVG(G));
      var K = this._svgDispatcherMap = createHashMap(), W = !1;
      each$f(this._svgGraphicRecord.named, function(Z) {
        var X = Z.name, Q = C.mapOrGeoModel, ee = C.data, te = Z.svgNodeTagLower, re = Z.el, ne = ee ? ee.indexOfName(X) : null, ae = Q.getRegionModel(X);
        if (OPTION_STYLE_ENABLED_TAG_MAP.get(te) != null && re instanceof Displayable$1 && applyOptionStyleForRegion(C, re, ne, ae), re instanceof Displayable$1 && (re.culling = !0), re.z2EmphasisLift = 0, !Z.namedFrom && (LABEL_HOST_MAP.get(te) != null && resetLabelForRegion(C, re, X, ae, Q, ne, null), resetEventTriggerForRegion(C, re, X, ae, Q, ne), resetTooltipForRegion(C, re, X, ae, Q), STATE_TRIGGER_TAG_MAP.get(te) != null)) {
          var ie = resetStateTriggerForRegion(C, re, X, ae, Q);
          ie === "self" && (W = !0);
          var se = K.get(X) || K.set(X, []);
          se.push(re);
        }
      }, this), this._enableBlurEntireSVG(W, C);
    }, H.prototype._enableBlurEntireSVG = function(C, G) {
      if (C && G.isGeo) {
        var U = G.mapOrGeoModel.getModel(["blur", "itemStyle"]).getItemStyle(), K = U.opacity;
        this._svgGraphicRecord.root.traverse(function(W) {
          if (!W.isGroup) {
            setDefaultStateProxy(W);
            var Z = W.ensureState("blur").style || {};
            Z.opacity == null && K != null && (Z.opacity = K), W.ensureState("emphasis");
          }
        });
      }
    }, H.prototype.remove = function() {
      this._regionsGroup.removeAll(), this._regionsGroupByName = null, this._svgGroup.removeAll(), this._freeSVG(), this._controller.dispose(), this._controllerHost = null;
    }, H.prototype.findHighDownDispatchers = function(C, G) {
      if (C == null)
        return [];
      var U = G.coordinateSystem;
      if (U.resourceType === "geoJSON") {
        var K = this._regionsGroupByName;
        if (K) {
          var W = K.get(C);
          return W ? [W] : [];
        }
      } else if (U.resourceType === "geoSVG")
        return this._svgDispatcherMap && this._svgDispatcherMap.get(C) || [];
    }, H.prototype._svgResourceChanged = function(C) {
      return this._svgMapName !== C;
    }, H.prototype._useSVG = function(C) {
      var G = geoSourceManager.getGeoResource(C);
      if (G && G.type === "geoSVG") {
        var U = G.useGraphic(this.uid);
        this._svgGroup.add(U.root), this._svgGraphicRecord = U, this._svgMapName = C;
      }
    }, H.prototype._freeSVG = function() {
      var C = this._svgMapName;
      if (C != null) {
        var G = geoSourceManager.getGeoResource(C);
        G && G.type === "geoSVG" && G.freeGraphic(this.uid), this._svgGraphicRecord = null, this._svgDispatcherMap = null, this._svgGroup.removeAll(), this._svgMapName = null;
      }
    }, H.prototype._updateController = function(C, G, U) {
      var K = C.coordinateSystem, W = this._controller, Z = this._controllerHost;
      Z.zoomLimit = C.get("scaleLimit"), Z.zoom = K.getZoom(), W.enable(C.get("roam") || !1);
      var X = C.mainType;
      function Q() {
        var ee = {
          type: "geoRoam",
          componentType: X
        };
        return ee[X + "Id"] = C.id, ee;
      }
      W.off("pan").on("pan", function(ee) {
        this._mouseDownFlag = !1, updateViewOnPan(Z, ee.dx, ee.dy), U.dispatchAction(extend(Q(), {
          dx: ee.dx,
          dy: ee.dy,
          animation: {
            duration: 0
          }
        }));
      }, this), W.off("zoom").on("zoom", function(ee) {
        this._mouseDownFlag = !1, updateViewOnZoom(Z, ee.scale, ee.originX, ee.originY), U.dispatchAction(extend(Q(), {
          zoom: ee.scale,
          originX: ee.originX,
          originY: ee.originY,
          animation: {
            duration: 0
          }
        }));
      }, this), W.setPointerChecker(function(ee, te, re) {
        return K.containPoint([te, re]) && !onIrrelevantElement(ee, U, C);
      });
    }, H.prototype.resetForLabelLayout = function() {
      this.group.traverse(function(C) {
        var G = C.getTextContent();
        G && (G.ignore = mapLabelRaw(G).ignore);
      });
    }, H.prototype._updateMapSelectHandler = function(C, G, U, K) {
      var W = this;
      G.off("mousedown"), G.off("click"), C.get("selectedMode") && (G.on("mousedown", function() {
        W._mouseDownFlag = !0;
      }), G.on("click", function(Z) {
        W._mouseDownFlag && (W._mouseDownFlag = !1);
      }));
    }, H;
  }()
);
function applyOptionStyleForRegion(H, C, G, U) {
  var K = U.getModel("itemStyle"), W = U.getModel(["emphasis", "itemStyle"]), Z = U.getModel(["blur", "itemStyle"]), X = U.getModel(["select", "itemStyle"]), Q = getFixedItemStyle(K), ee = getFixedItemStyle(W), te = getFixedItemStyle(X), re = getFixedItemStyle(Z), ne = H.data;
  if (ne) {
    var ae = ne.getItemVisual(G, "style"), ie = ne.getItemVisual(G, "decal");
    H.isVisualEncodedByVisualMap && ae.fill && (Q.fill = ae.fill), ie && (Q.decal = createOrUpdatePatternFromDecal(ie, H.api));
  }
  C.setStyle(Q), C.style.strokeNoScale = !0, C.ensureState("emphasis").style = ee, C.ensureState("select").style = te, C.ensureState("blur").style = re, setDefaultStateProxy(C);
}
function resetLabelForRegion(H, C, G, U, K, W, Z) {
  var X = H.data, Q = H.isGeo, ee = X && isNaN(X.get(X.mapDimension("value"), W)), te = X && X.getItemLayout(W);
  if (Q || ee || te && te.showLabel) {
    var re = Q ? G : W, ne = void 0;
    (!X || W >= 0) && (ne = K);
    var ae = Z ? {
      normal: {
        align: "center",
        verticalAlign: "middle"
      }
    } : null;
    setLabelStyle(C, getLabelStatesModels(U), {
      labelFetcher: ne,
      labelDataIndex: re,
      defaultText: G
    }, ae);
    var ie = C.getTextContent();
    if (ie && (mapLabelRaw(ie).ignore = ie.ignore, C.textConfig && Z)) {
      var se = C.getBoundingRect().clone();
      C.textConfig.layoutRect = se, C.textConfig.position = [(Z[0] - se.x) / se.width * 100 + "%", (Z[1] - se.y) / se.height * 100 + "%"];
    }
    C.disableLabelAnimation = !0;
  } else
    C.removeTextContent(), C.removeTextConfig(), C.disableLabelAnimation = null;
}
function resetEventTriggerForRegion(H, C, G, U, K, W) {
  H.data ? H.data.setItemGraphicEl(W, C) : getECData(C).eventData = {
    componentType: "geo",
    componentIndex: K.componentIndex,
    geoIndex: K.componentIndex,
    name: G,
    region: U && U.option || {}
  };
}
function resetTooltipForRegion(H, C, G, U, K) {
  H.data || setTooltipConfig({
    el: C,
    componentModel: K,
    itemName: G,
    // @ts-ignore FIXME:TS fix the "compatible with each other"?
    itemTooltipOption: U.get("tooltip")
  });
}
function resetStateTriggerForRegion(H, C, G, U, K) {
  C.highDownSilentOnTouch = !!K.get("selectedMode");
  var W = U.getModel("emphasis"), Z = W.get("focus");
  return toggleHoverEmphasis(C, Z, W.get("blurScope"), W.get("disabled")), H.isGeo && enableComponentHighDownFeatures(C, K, G), Z;
}
function projectPolys(H, C, G) {
  var U = [], K;
  function W() {
    K = [];
  }
  function Z() {
    K.length && (U.push(K), K = []);
  }
  var X = C({
    polygonStart: W,
    polygonEnd: Z,
    lineStart: W,
    lineEnd: Z,
    point: function(Q, ee) {
      isFinite(Q) && isFinite(ee) && K.push([Q, ee]);
    },
    sphere: function() {
    }
  });
  return !G && X.polygonStart(), each$f(H, function(Q) {
    X.lineStart();
    for (var ee = 0; ee < Q.length; ee++)
      X.point(Q[ee][0], Q[ee][1]);
    X.lineEnd();
  }), !G && X.polygonEnd(), U;
}
const MapDraw$1 = MapDraw;
var MapView = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G;
    }
    return C.prototype.render = function(G, U, K, W) {
      if (!(W && W.type === "mapToggleSelect" && W.from === this.uid)) {
        var Z = this.group;
        if (Z.removeAll(), !G.getHostGeoModel()) {
          if (this._mapDraw && W && W.type === "geoRoam" && this._mapDraw.resetForLabelLayout(), W && W.type === "geoRoam" && W.componentType === "series" && W.seriesId === G.id) {
            var X = this._mapDraw;
            X && Z.add(X.group);
          } else if (G.needsDrawMap) {
            var X = this._mapDraw || new MapDraw$1(K);
            Z.add(X.group), X.draw(G, U, K, this, W), this._mapDraw = X;
          } else
            this._mapDraw && this._mapDraw.remove(), this._mapDraw = null;
          G.get("showLegendSymbol") && U.getComponent("legend") && this._renderSymbols(G, U, K);
        }
      }
    }, C.prototype.remove = function() {
      this._mapDraw && this._mapDraw.remove(), this._mapDraw = null, this.group.removeAll();
    }, C.prototype.dispose = function() {
      this._mapDraw && this._mapDraw.remove(), this._mapDraw = null;
    }, C.prototype._renderSymbols = function(G, U, K) {
      var W = G.originalData, Z = this.group;
      W.each(W.mapDimension("value"), function(X, Q) {
        if (!isNaN(X)) {
          var ee = W.getItemLayout(Q);
          if (!(!ee || !ee.point)) {
            var te = ee.point, re = ee.offset, ne = new Circle$1({
              style: {
                // Because the special of map draw.
                // Which needs statistic of multiple series and draw on one map.
                // And each series also need a symbol with legend color
                //
                // Layout and visual are put one the different data
                // TODO
                fill: G.getData().getVisual("style").fill
              },
              shape: {
                cx: te[0] + re * 9,
                cy: te[1],
                r: 3
              },
              silent: !0,
              // Do not overlap the first series, on which labels are displayed.
              z2: 8 + (re ? 0 : Z2_EMPHASIS_LIFT + 1)
            });
            if (!re) {
              var ae = G.mainSeries.getData(), ie = W.getName(Q), se = ae.indexOfName(ie), oe = W.getItemModel(Q), le = oe.getModel("label"), ue = ae.getItemGraphicEl(se);
              setLabelStyle(ne, getLabelStatesModels(oe), {
                labelFetcher: {
                  getFormattedLabel: function(ce, de) {
                    return G.getFormattedLabel(se, de);
                  }
                },
                defaultText: ie
              }), ne.disableLabelAnimation = !0, le.get("position") || ne.setTextConfig({
                position: "bottom"
              }), ue.onHoverStateChange = function(ce) {
                setStatesFlag(ne, ce);
              };
            }
            Z.add(ne);
          }
        }
      });
    }, C.type = "map", C;
  }(ChartView$1)
);
const MapView$1 = MapView;
var MapSeries = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G.needsDrawMap = !1, G.seriesGroup = [], G.getTooltipPosition = function(U) {
        if (U != null) {
          var K = this.getData().getName(U), W = this.coordinateSystem, Z = W.getRegion(K);
          return Z && W.dataToPoint(Z.getCenter());
        }
      }, G;
    }
    return C.prototype.getInitialData = function(G) {
      for (var U = createSeriesDataSimply(this, {
        coordDimensions: ["value"],
        encodeDefaulter: curry$1(makeSeriesEncodeForNameBased, this)
      }), K = createHashMap(), W = [], Z = 0, X = U.count(); Z < X; Z++) {
        var Q = U.getName(Z);
        K.set(Q, !0);
      }
      var ee = geoSourceManager.load(this.getMapType(), this.option.nameMap, this.option.nameProperty);
      return each$f(ee.regions, function(te) {
        var re = te.name;
        K.get(re) || W.push(re);
      }), U.appendValues([], W), U;
    }, C.prototype.getHostGeoModel = function() {
      var G = this.option.geoIndex;
      return G != null ? this.ecModel.getComponent("geo", G) : null;
    }, C.prototype.getMapType = function() {
      return (this.getHostGeoModel() || this).option.map;
    }, C.prototype.getRawValue = function(G) {
      var U = this.getData();
      return U.get(U.mapDimension("value"), G);
    }, C.prototype.getRegionModel = function(G) {
      var U = this.getData();
      return U.getItemModel(U.indexOfName(G));
    }, C.prototype.formatTooltip = function(G, U, K) {
      for (var W = this.getData(), Z = this.getRawValue(G), X = W.getName(G), Q = this.seriesGroup, ee = [], te = 0; te < Q.length; te++) {
        var re = Q[te].originalData.indexOfName(X), ne = W.mapDimension("value");
        isNaN(Q[te].originalData.get(ne, re)) || ee.push(Q[te].name);
      }
      return createTooltipMarkup("section", {
        header: ee.join(", "),
        noHeader: !ee.length,
        blocks: [createTooltipMarkup("nameValue", {
          name: X,
          value: Z
        })]
      });
    }, C.prototype.setZoom = function(G) {
      this.option.zoom = G;
    }, C.prototype.setCenter = function(G) {
      this.option.center = G;
    }, C.prototype.getLegendIcon = function(G) {
      var U = G.icon || "roundRect", K = createSymbol$1(U, 0, 0, G.itemWidth, G.itemHeight, G.itemStyle.fill);
      return K.setStyle(G.itemStyle), K.style.stroke = "none", U.indexOf("empty") > -1 && (K.style.stroke = K.style.fill, K.style.fill = "#fff", K.style.lineWidth = 2), K;
    }, C.type = "series.map", C.dependencies = ["geo"], C.layoutMode = "box", C.defaultOption = {
      // 一级层叠
      // zlevel: 0,
      // 二级层叠
      z: 2,
      coordinateSystem: "geo",
      // map should be explicitly specified since ec3.
      map: "",
      // If `geoIndex` is not specified, a exclusive geo will be
      // created. Otherwise use the specified geo component, and
      // `map` and `mapType` are ignored.
      // geoIndex: 0,
      // 'center' | 'left' | 'right' | 'x%' | {number}
      left: "center",
      // 'center' | 'top' | 'bottom' | 'x%' | {number}
      top: "center",
      // right
      // bottom
      // width:
      // height
      // Aspect is width / height. Inited to be geoJson bbox aspect
      // This parameter is used for scale this aspect
      // Default value:
      // for geoSVG source: 1,
      // for geoJSON source: 0.75.
      aspectScale: null,
      // Layout with center and size
      // If you want to put map in a fixed size box with right aspect ratio
      // This two properties may be more convenient.
      // layoutCenter: [50%, 50%]
      // layoutSize: 100
      showLegendSymbol: !0,
      // Define left-top, right-bottom coords to control view
      // For example, [ [180, 90], [-180, -90] ],
      // higher priority than center and zoom
      boundingCoords: null,
      // Default on center of map
      center: null,
      zoom: 1,
      scaleLimit: null,
      selectedMode: !0,
      label: {
        show: !1,
        color: "#000"
      },
      // scaleLimit: null,
      itemStyle: {
        borderWidth: 0.5,
        borderColor: "#444",
        areaColor: "#eee"
      },
      emphasis: {
        label: {
          show: !0,
          color: "rgb(100,0,0)"
        },
        itemStyle: {
          areaColor: "rgba(255,215,0,0.8)"
        }
      },
      select: {
        label: {
          show: !0,
          color: "rgb(100,0,0)"
        },
        itemStyle: {
          color: "rgba(255,215,0,0.8)"
        }
      },
      nameProperty: "name"
    }, C;
  }(SeriesModel$1)
);
const MapSeries$1 = MapSeries;
function dataStatistics(H, C) {
  var G = {};
  return each$f(H, function(U) {
    U.each(U.mapDimension("value"), function(K, W) {
      var Z = "ec-" + U.getName(W);
      G[Z] = G[Z] || [], isNaN(K) || G[Z].push(K);
    });
  }), H[0].map(H[0].mapDimension("value"), function(U, K) {
    for (var W = "ec-" + H[0].getName(K), Z = 0, X = 1 / 0, Q = -1 / 0, ee = G[W].length, te = 0; te < ee; te++)
      X = Math.min(X, G[W][te]), Q = Math.max(Q, G[W][te]), Z += G[W][te];
    var re;
    return C === "min" ? re = X : C === "max" ? re = Q : C === "average" ? re = Z / ee : re = Z, ee === 0 ? NaN : re;
  });
}
function mapDataStatistic(H) {
  var C = {};
  H.eachSeriesByType("map", function(G) {
    var U = G.getHostGeoModel(), K = U ? "o" + U.id : "i" + G.getMapType();
    (C[K] = C[K] || []).push(G);
  }), each$f(C, function(G, U) {
    for (var K = dataStatistics(map$1(G, function(Z) {
      return Z.getData();
    }), G[0].get("mapValueCalculation")), W = 0; W < G.length; W++)
      G[W].originalData = G[W].getData();
    for (var W = 0; W < G.length; W++)
      G[W].seriesGroup = G, G[W].needsDrawMap = W === 0 && !G[W].getHostGeoModel(), G[W].setData(K.cloneShallow()), G[W].mainSeries = G[0];
  });
}
function mapSymbolLayout(H) {
  var C = {};
  H.eachSeriesByType("map", function(G) {
    var U = G.getMapType();
    if (!(G.getHostGeoModel() || C[U])) {
      var K = {};
      each$f(G.seriesGroup, function(Z) {
        var X = Z.coordinateSystem, Q = Z.originalData;
        Z.get("showLegendSymbol") && H.getComponent("legend") && Q.each(Q.mapDimension("value"), function(ee, te) {
          var re = Q.getName(te), ne = X.getRegion(re);
          if (!(!ne || isNaN(ee))) {
            var ae = K[re] || 0, ie = X.dataToPoint(ne.getCenter());
            K[re] = ae + 1, Q.setItemLayout(te, {
              point: ie,
              offset: ae
            });
          }
        });
      });
      var W = G.getData();
      W.each(function(Z) {
        var X = W.getName(Z), Q = W.getItemLayout(Z) || {};
        Q.showLabel = !K[X], W.setItemLayout(Z, Q);
      }), C[U] = !0;
    }
  });
}
var v2ApplyTransform = applyTransform$1, View = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C(G) {
      var U = H.call(this) || this;
      return U.type = "view", U.dimensions = ["x", "y"], U._roamTransformable = new Transformable(), U._rawTransformable = new Transformable(), U.name = G, U;
    }
    return C.prototype.setBoundingRect = function(G, U, K, W) {
      return this._rect = new BoundingRect$1(G, U, K, W), this._rect;
    }, C.prototype.getBoundingRect = function() {
      return this._rect;
    }, C.prototype.setViewRect = function(G, U, K, W) {
      this._transformTo(G, U, K, W), this._viewRect = new BoundingRect$1(G, U, K, W);
    }, C.prototype._transformTo = function(G, U, K, W) {
      var Z = this.getBoundingRect(), X = this._rawTransformable;
      X.transform = Z.calculateTransform(new BoundingRect$1(G, U, K, W));
      var Q = X.parent;
      X.parent = null, X.decomposeTransform(), X.parent = Q, this._updateTransform();
    }, C.prototype.setCenter = function(G, U) {
      G && (this._center = [parsePercent(G[0], U.getWidth()), parsePercent(G[1], U.getHeight())], this._updateCenterAndZoom());
    }, C.prototype.setZoom = function(G) {
      G = G || 1;
      var U = this.zoomLimit;
      U && (U.max != null && (G = Math.min(U.max, G)), U.min != null && (G = Math.max(U.min, G))), this._zoom = G, this._updateCenterAndZoom();
    }, C.prototype.getDefaultCenter = function() {
      var G = this.getBoundingRect(), U = G.x + G.width / 2, K = G.y + G.height / 2;
      return [U, K];
    }, C.prototype.getCenter = function() {
      return this._center || this.getDefaultCenter();
    }, C.prototype.getZoom = function() {
      return this._zoom || 1;
    }, C.prototype.getRoamTransform = function() {
      return this._roamTransformable.getLocalTransform();
    }, C.prototype._updateCenterAndZoom = function() {
      var G = this._rawTransformable.getLocalTransform(), U = this._roamTransformable, K = this.getDefaultCenter(), W = this.getCenter(), Z = this.getZoom();
      W = applyTransform$1([], W, G), K = applyTransform$1([], K, G), U.originX = W[0], U.originY = W[1], U.x = K[0] - W[0], U.y = K[1] - W[1], U.scaleX = U.scaleY = Z, this._updateTransform();
    }, C.prototype._updateTransform = function() {
      var G = this._roamTransformable, U = this._rawTransformable;
      U.parent = G, G.updateTransform(), U.updateTransform(), copy(this.transform || (this.transform = []), U.transform || create$1()), this._rawTransform = U.getLocalTransform(), this.invTransform = this.invTransform || [], invert(this.invTransform, this.transform), this.decomposeTransform();
    }, C.prototype.getTransformInfo = function() {
      var G = this._rawTransformable, U = this._roamTransformable, K = new Transformable();
      return K.transform = U.transform, K.decomposeTransform(), {
        roam: {
          x: K.x,
          y: K.y,
          scaleX: K.scaleX,
          scaleY: K.scaleY
        },
        raw: {
          x: G.x,
          y: G.y,
          scaleX: G.scaleX,
          scaleY: G.scaleY
        }
      };
    }, C.prototype.getViewRect = function() {
      return this._viewRect;
    }, C.prototype.getViewRectAfterRoam = function() {
      var G = this.getBoundingRect().clone();
      return G.applyTransform(this.transform), G;
    }, C.prototype.dataToPoint = function(G, U, K) {
      var W = U ? this._rawTransform : this.transform;
      return K = K || [], W ? v2ApplyTransform(K, G, W) : copy$1(K, G);
    }, C.prototype.pointToData = function(G) {
      var U = this.invTransform;
      return U ? v2ApplyTransform([], G, U) : [G[0], G[1]];
    }, C.prototype.convertToPixel = function(G, U, K) {
      var W = getCoordSys$4(U);
      return W === this ? W.dataToPoint(K) : null;
    }, C.prototype.convertFromPixel = function(G, U, K) {
      var W = getCoordSys$4(U);
      return W === this ? W.pointToData(K) : null;
    }, C.prototype.containPoint = function(G) {
      return this.getViewRectAfterRoam().contain(G[0], G[1]);
    }, C.dimensions = ["x", "y"], C;
  }(Transformable)
);
function getCoordSys$4(H) {
  var C = H.seriesModel;
  return C ? C.coordinateSystem : null;
}
const View$1 = View;
var GEO_DEFAULT_PARAMS = {
  geoJSON: {
    aspectScale: 0.75,
    invertLongitute: !0
  },
  geoSVG: {
    aspectScale: 1,
    invertLongitute: !1
  }
}, geo2DDimensions = ["lng", "lat"], Geo = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C(G, U, K) {
      var W = H.call(this, G) || this;
      W.dimensions = geo2DDimensions, W.type = "geo", W._nameCoordMap = createHashMap(), W.map = U;
      var Z = K.projection, X = geoSourceManager.load(U, K.nameMap, K.nameProperty), Q = geoSourceManager.getGeoResource(U), ee = W.resourceType = Q ? Q.type : null, te = W.regions = X.regions, re = GEO_DEFAULT_PARAMS[Q.type];
      W._regionsMap = X.regionsMap, W.regions = X.regions, process.env.NODE_ENV !== "production" && Z && (ee === "geoSVG" && (process.env.NODE_ENV !== "production" && warn("Map " + U + " with SVG source can't use projection. Only GeoJSON source supports projection."), Z = null), Z.project && Z.unproject || (process.env.NODE_ENV !== "production" && warn("project and unproject must be both provided in the projeciton."), Z = null)), W.projection = Z;
      var ne;
      if (Z)
        for (var ae = 0; ae < te.length; ae++) {
          var ie = te[ae].getBoundingRect(Z);
          ne = ne || ie.clone(), ne.union(ie);
        }
      else
        ne = X.boundingRect;
      return W.setBoundingRect(ne.x, ne.y, ne.width, ne.height), W.aspectScale = Z ? 1 : retrieve2(K.aspectScale, re.aspectScale), W._invertLongitute = Z ? !1 : re.invertLongitute, W;
    }
    return C.prototype._transformTo = function(G, U, K, W) {
      var Z = this.getBoundingRect(), X = this._invertLongitute;
      Z = Z.clone(), X && (Z.y = -Z.y - Z.height);
      var Q = this._rawTransformable;
      Q.transform = Z.calculateTransform(new BoundingRect$1(G, U, K, W));
      var ee = Q.parent;
      Q.parent = null, Q.decomposeTransform(), Q.parent = ee, X && (Q.scaleY = -Q.scaleY), this._updateTransform();
    }, C.prototype.getRegion = function(G) {
      return this._regionsMap.get(G);
    }, C.prototype.getRegionByCoord = function(G) {
      for (var U = this.regions, K = 0; K < U.length; K++) {
        var W = U[K];
        if (W.type === "geoJSON" && W.contain(G))
          return U[K];
      }
    }, C.prototype.addGeoCoord = function(G, U) {
      this._nameCoordMap.set(G, U);
    }, C.prototype.getGeoCoord = function(G) {
      var U = this._regionsMap.get(G);
      return this._nameCoordMap.get(G) || U && U.getCenter();
    }, C.prototype.dataToPoint = function(G, U, K) {
      if (isString(G) && (G = this.getGeoCoord(G)), G) {
        var W = this.projection;
        return W && (G = W.project(G)), G && this.projectedToPoint(G, U, K);
      }
    }, C.prototype.pointToData = function(G) {
      var U = this.projection;
      return U && (G = U.unproject(G)), G && this.pointToProjected(G);
    }, C.prototype.pointToProjected = function(G) {
      return H.prototype.pointToData.call(this, G);
    }, C.prototype.projectedToPoint = function(G, U, K) {
      return H.prototype.dataToPoint.call(this, G, U, K);
    }, C.prototype.convertToPixel = function(G, U, K) {
      var W = getCoordSys$3(U);
      return W === this ? W.dataToPoint(K) : null;
    }, C.prototype.convertFromPixel = function(G, U, K) {
      var W = getCoordSys$3(U);
      return W === this ? W.pointToData(K) : null;
    }, C;
  }(View$1)
);
mixin(Geo, View$1);
function getCoordSys$3(H) {
  var C = H.geoModel, G = H.seriesModel;
  return C ? C.coordinateSystem : G ? G.coordinateSystem || (G.getReferringComponents("geo", SINGLE_REFERRING).models[0] || {}).coordinateSystem : null;
}
const Geo$1 = Geo;
function resizeGeo(H, C) {
  var G = H.get("boundingCoords");
  if (G != null) {
    var U = G[0], K = G[1];
    if (!(isFinite(U[0]) && isFinite(U[1]) && isFinite(K[0]) && isFinite(K[1])))
      process.env.NODE_ENV !== "production" && console.error("Invalid boundingCoords");
    else {
      var W = this.projection;
      if (W) {
        var Z = U[0], X = U[1], Q = K[0], ee = K[1];
        U = [1 / 0, 1 / 0], K = [-1 / 0, -1 / 0];
        var te = function(fe, ve, pe, he) {
          for (var me = pe - fe, ye = he - ve, Ce = 0; Ce <= 100; Ce++) {
            var Ie = Ce / 100, be = W.project([fe + me * Ie, ve + ye * Ie]);
            min$1(U, U, be), max$1(K, K, be);
          }
        };
        te(Z, X, Q, X), te(Q, X, Q, ee), te(Q, ee, Z, ee), te(Z, ee, Q, X);
      }
      this.setBoundingRect(U[0], U[1], K[0] - U[0], K[1] - U[1]);
    }
  }
  var re = this.getBoundingRect(), ne = H.get("layoutCenter"), ae = H.get("layoutSize"), ie = C.getWidth(), se = C.getHeight(), oe = re.width / re.height * this.aspectScale, le = !1, ue, ce;
  ne && ae && (ue = [parsePercent(ne[0], ie), parsePercent(ne[1], se)], ce = parsePercent(ae, Math.min(ie, se)), !isNaN(ue[0]) && !isNaN(ue[1]) && !isNaN(ce) ? le = !0 : process.env.NODE_ENV !== "production" && console.warn("Given layoutCenter or layoutSize data are invalid. Use left/top/width/height instead."));
  var de;
  if (le)
    de = {}, oe > 1 ? (de.width = ce, de.height = ce / oe) : (de.height = ce, de.width = ce * oe), de.y = ue[1] - de.height / 2, de.x = ue[0] - de.width / 2;
  else {
    var ge = H.getBoxLayoutParams();
    ge.aspect = oe, de = getLayoutRect(ge, {
      width: ie,
      height: se
    });
  }
  this.setViewRect(de.x, de.y, de.width, de.height), this.setCenter(H.get("center"), C), this.setZoom(H.get("zoom"));
}
function setGeoCoords(H, C) {
  each$f(C.get("geoCoord"), function(G, U) {
    H.addGeoCoord(U, G);
  });
}
var GeoCreator = (
  /** @class */
  function() {
    function H() {
      this.dimensions = geo2DDimensions;
    }
    return H.prototype.create = function(C, G) {
      var U = [];
      function K(Z) {
        return {
          nameProperty: Z.get("nameProperty"),
          aspectScale: Z.get("aspectScale"),
          projection: Z.get("projection")
        };
      }
      C.eachComponent("geo", function(Z, X) {
        var Q = Z.get("map"), ee = new Geo$1(Q + X, Q, extend({
          nameMap: Z.get("nameMap")
        }, K(Z)));
        ee.zoomLimit = Z.get("scaleLimit"), U.push(ee), Z.coordinateSystem = ee, ee.model = Z, ee.resize = resizeGeo, ee.resize(Z, G);
      }), C.eachSeries(function(Z) {
        var X = Z.get("coordinateSystem");
        if (X === "geo") {
          var Q = Z.get("geoIndex") || 0;
          Z.coordinateSystem = U[Q];
        }
      });
      var W = {};
      return C.eachSeriesByType("map", function(Z) {
        if (!Z.getHostGeoModel()) {
          var X = Z.getMapType();
          W[X] = W[X] || [], W[X].push(Z);
        }
      }), each$f(W, function(Z, X) {
        var Q = map$1(Z, function(te) {
          return te.get("nameMap");
        }), ee = new Geo$1(X, X, extend({
          nameMap: mergeAll(Q)
        }, K(Z[0])));
        ee.zoomLimit = retrieve.apply(null, map$1(Z, function(te) {
          return te.get("scaleLimit");
        })), U.push(ee), ee.resize = resizeGeo, ee.resize(Z[0], G), each$f(Z, function(te) {
          te.coordinateSystem = ee, setGeoCoords(ee, te);
        });
      }), U;
    }, H.prototype.getFilledRegions = function(C, G, U, K) {
      for (var W = (C || []).slice(), Z = createHashMap(), X = 0; X < W.length; X++)
        Z.set(W[X].name, W[X]);
      var Q = geoSourceManager.load(G, U, K);
      return each$f(Q.regions, function(ee) {
        var te = ee.name;
        !Z.get(te) && W.push({
          name: te
        });
      }), W;
    }, H;
  }()
), geoCreator = new GeoCreator();
const geoCreator$1 = geoCreator;
var GeoModel = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G;
    }
    return C.prototype.init = function(G, U, K) {
      var W = geoSourceManager.getGeoResource(G.map);
      if (W && W.type === "geoJSON") {
        var Z = G.itemStyle = G.itemStyle || {};
        "color" in Z || (Z.color = "#eee");
      }
      this.mergeDefaultAndTheme(G, K), defaultEmphasis(G, "label", ["show"]);
    }, C.prototype.optionUpdated = function() {
      var G = this, U = this.option;
      U.regions = geoCreator$1.getFilledRegions(U.regions, U.map, U.nameMap, U.nameProperty);
      var K = {};
      this._optionModelMap = reduce(U.regions || [], function(W, Z) {
        var X = Z.name;
        return X && (W.set(X, new Model$1(Z, G, G.ecModel)), Z.selected && (K[X] = !0)), W;
      }, createHashMap()), U.selectedMap || (U.selectedMap = K);
    }, C.prototype.getRegionModel = function(G) {
      return this._optionModelMap.get(G) || new Model$1(null, this, this.ecModel);
    }, C.prototype.getFormattedLabel = function(G, U) {
      var K = this.getRegionModel(G), W = U === "normal" ? K.get(["label", "formatter"]) : K.get(["emphasis", "label", "formatter"]), Z = {
        name: G
      };
      if (isFunction(W))
        return Z.status = U, W(Z);
      if (isString(W))
        return W.replace("{a}", G ?? "");
    }, C.prototype.setZoom = function(G) {
      this.option.zoom = G;
    }, C.prototype.setCenter = function(G) {
      this.option.center = G;
    }, C.prototype.select = function(G) {
      var U = this.option, K = U.selectedMode;
      if (K) {
        K !== "multiple" && (U.selectedMap = null);
        var W = U.selectedMap || (U.selectedMap = {});
        W[G] = !0;
      }
    }, C.prototype.unSelect = function(G) {
      var U = this.option.selectedMap;
      U && (U[G] = !1);
    }, C.prototype.toggleSelected = function(G) {
      this[this.isSelected(G) ? "unSelect" : "select"](G);
    }, C.prototype.isSelected = function(G) {
      var U = this.option.selectedMap;
      return !!(U && U[G]);
    }, C.type = "geo", C.layoutMode = "box", C.defaultOption = {
      // zlevel: 0,
      z: 0,
      show: !0,
      left: "center",
      top: "center",
      // Default value:
      // for geoSVG source: 1,
      // for geoJSON source: 0.75.
      aspectScale: null,
      // /// Layout with center and size
      // If you want to put map in a fixed size box with right aspect ratio
      // This two properties may be more convenient
      // layoutCenter: [50%, 50%]
      // layoutSize: 100
      silent: !1,
      // Map type
      map: "",
      // Define left-top, right-bottom coords to control view
      // For example, [ [180, 90], [-180, -90] ]
      boundingCoords: null,
      // Default on center of map
      center: null,
      zoom: 1,
      scaleLimit: null,
      // selectedMode: false
      label: {
        show: !1,
        color: "#000"
      },
      itemStyle: {
        borderWidth: 0.5,
        borderColor: "#444"
        // Default color:
        // + geoJSON: #eee
        // + geoSVG: null (use SVG original `fill`)
        // color: '#eee'
      },
      emphasis: {
        label: {
          show: !0,
          color: "rgb(100,0,0)"
        },
        itemStyle: {
          color: "rgba(255,215,0,0.8)"
        }
      },
      select: {
        label: {
          show: !0,
          color: "rgb(100,0,0)"
        },
        itemStyle: {
          color: "rgba(255,215,0,0.8)"
        }
      },
      regions: []
      // tooltip: {
      //     show: false
      // }
    }, C;
  }(ComponentModel$1)
);
const GeoModel$1 = GeoModel;
function getCenterCoord(H, C) {
  return H.pointToProjected ? H.pointToProjected(C) : H.pointToData(C);
}
function updateCenterAndZoom(H, C, G, U) {
  var K = H.getZoom(), W = H.getCenter(), Z = C.zoom, X = H.projectedToPoint ? H.projectedToPoint(W) : H.dataToPoint(W);
  if (C.dx != null && C.dy != null && (X[0] -= C.dx, X[1] -= C.dy, H.setCenter(getCenterCoord(H, X), U)), Z != null) {
    if (G) {
      var Q = G.min || 0, ee = G.max || 1 / 0;
      Z = Math.max(Math.min(K * Z, ee), Q) / K;
    }
    H.scaleX *= Z, H.scaleY *= Z;
    var te = (C.originX - H.x) * (Z - 1), re = (C.originY - H.y) * (Z - 1);
    H.x -= te, H.y -= re, H.updateTransform(), H.setCenter(getCenterCoord(H, X), U), H.setZoom(Z * K);
  }
  return {
    center: H.getCenter(),
    zoom: H.getZoom()
  };
}
var GeoView = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G.focusBlurEnabled = !0, G;
    }
    return C.prototype.init = function(G, U) {
      this._api = U;
    }, C.prototype.render = function(G, U, K, W) {
      if (this._model = G, !G.get("show")) {
        this._mapDraw && this._mapDraw.remove(), this._mapDraw = null;
        return;
      }
      this._mapDraw || (this._mapDraw = new MapDraw$1(K));
      var Z = this._mapDraw;
      Z.draw(G, U, K, this, W), Z.group.on("click", this._handleRegionClick, this), Z.group.silent = G.get("silent"), this.group.add(Z.group), this.updateSelectStatus(G, U, K);
    }, C.prototype._handleRegionClick = function(G) {
      var U;
      findEventDispatcher(G.target, function(K) {
        return (U = getECData(K).eventData) != null;
      }, !0), U && this._api.dispatchAction({
        type: "geoToggleSelect",
        geoId: this._model.id,
        name: U.name
      });
    }, C.prototype.updateSelectStatus = function(G, U, K) {
      var W = this;
      this._mapDraw.group.traverse(function(Z) {
        var X = getECData(Z).eventData;
        if (X)
          return W._model.isSelected(X.name) ? K.enterSelect(Z) : K.leaveSelect(Z), !0;
      });
    }, C.prototype.findHighDownDispatchers = function(G) {
      return this._mapDraw && this._mapDraw.findHighDownDispatchers(G, this._model);
    }, C.prototype.dispose = function() {
      this._mapDraw && this._mapDraw.remove();
    }, C.type = "geo", C;
  }(ComponentView$1)
);
const GeoView$1 = GeoView;
function registerMap(H, C, G) {
  geoSourceManager.registerMap(H, C, G);
}
function install$J(H) {
  H.registerCoordinateSystem("geo", geoCreator$1), H.registerComponentModel(GeoModel$1), H.registerComponentView(GeoView$1), H.registerImpl("registerMap", registerMap), H.registerImpl("getMap", function(G) {
    return geoSourceManager.getMapForUser(G);
  });
  function C(G, U) {
    U.update = "geo:updateSelectStatus", H.registerAction(U, function(K, W) {
      var Z = {}, X = [];
      return W.eachComponent({
        mainType: "geo",
        query: K
      }, function(Q) {
        Q[G](K.name);
        var ee = Q.coordinateSystem;
        each$f(ee.regions, function(re) {
          Z[re.name] = Q.isSelected(re.name) || !1;
        });
        var te = [];
        each$f(Z, function(re, ne) {
          Z[ne] && te.push(ne);
        }), X.push({
          geoIndex: Q.componentIndex,
          // Use singular, the same naming convention as the event `selectchanged`.
          name: te
        });
      }), {
        selected: Z,
        allSelected: X,
        name: K.name
      };
    });
  }
  C("toggleSelected", {
    type: "geoToggleSelect",
    event: "geoselectchanged"
  }), C("select", {
    type: "geoSelect",
    event: "geoselected"
  }), C("unSelect", {
    type: "geoUnSelect",
    event: "geounselected"
  }), H.registerAction({
    type: "geoRoam",
    event: "geoRoam",
    update: "updateTransform"
  }, function(G, U, K) {
    var W = G.componentType || "series";
    U.eachComponent({
      mainType: W,
      query: G
    }, function(Z) {
      var X = Z.coordinateSystem;
      if (X.type === "geo") {
        var Q = updateCenterAndZoom(X, G, Z.get("scaleLimit"), K);
        Z.setCenter && Z.setCenter(Q.center), Z.setZoom && Z.setZoom(Q.zoom), W === "series" && each$f(Z.seriesGroup, function(ee) {
          ee.setCenter(Q.center), ee.setZoom(Q.zoom);
        });
      }
    });
  });
}
function install$I(H) {
  use(install$J), H.registerChartView(MapView$1), H.registerSeriesModel(MapSeries$1), H.registerLayout(mapSymbolLayout), H.registerProcessor(H.PRIORITY.PROCESSOR.STATISTIC, mapDataStatistic), createLegacyDataSelectAction("map", H.registerAction);
}
function init(H) {
  var C = H;
  C.hierNode = {
    defaultAncestor: null,
    ancestor: C,
    prelim: 0,
    modifier: 0,
    change: 0,
    shift: 0,
    i: 0,
    thread: null
  };
  for (var G = [C], U, K; U = G.pop(); )
    if (K = U.children, U.isExpand && K.length)
      for (var W = K.length, Z = W - 1; Z >= 0; Z--) {
        var X = K[Z];
        X.hierNode = {
          defaultAncestor: null,
          ancestor: X,
          prelim: 0,
          modifier: 0,
          change: 0,
          shift: 0,
          i: Z,
          thread: null
        }, G.push(X);
      }
}
function firstWalk(H, C) {
  var G = H.isExpand ? H.children : [], U = H.parentNode.children, K = H.hierNode.i ? U[H.hierNode.i - 1] : null;
  if (G.length) {
    executeShifts(H);
    var W = (G[0].hierNode.prelim + G[G.length - 1].hierNode.prelim) / 2;
    K ? (H.hierNode.prelim = K.hierNode.prelim + C(H, K), H.hierNode.modifier = H.hierNode.prelim - W) : H.hierNode.prelim = W;
  } else
    K && (H.hierNode.prelim = K.hierNode.prelim + C(H, K));
  H.parentNode.hierNode.defaultAncestor = apportion(H, K, H.parentNode.hierNode.defaultAncestor || U[0], C);
}
function secondWalk(H) {
  var C = H.hierNode.prelim + H.parentNode.hierNode.modifier;
  H.setLayout({
    x: C
  }, !0), H.hierNode.modifier += H.parentNode.hierNode.modifier;
}
function separation(H) {
  return arguments.length ? H : defaultSeparation;
}
function radialCoordinate(H, C) {
  return H -= Math.PI / 2, {
    x: C * Math.cos(H),
    y: C * Math.sin(H)
  };
}
function getViewRect$4(H, C) {
  return getLayoutRect(H.getBoxLayoutParams(), {
    width: C.getWidth(),
    height: C.getHeight()
  });
}
function executeShifts(H) {
  for (var C = H.children, G = C.length, U = 0, K = 0; --G >= 0; ) {
    var W = C[G];
    W.hierNode.prelim += U, W.hierNode.modifier += U, K += W.hierNode.change, U += W.hierNode.shift + K;
  }
}
function apportion(H, C, G, U) {
  if (C) {
    for (var K = H, W = H, Z = W.parentNode.children[0], X = C, Q = K.hierNode.modifier, ee = W.hierNode.modifier, te = Z.hierNode.modifier, re = X.hierNode.modifier; X = nextRight(X), W = nextLeft(W), X && W; ) {
      K = nextRight(K), Z = nextLeft(Z), K.hierNode.ancestor = H;
      var ne = X.hierNode.prelim + re - W.hierNode.prelim - ee + U(X, W);
      ne > 0 && (moveSubtree(nextAncestor(X, H, G), H, ne), ee += ne, Q += ne), re += X.hierNode.modifier, ee += W.hierNode.modifier, Q += K.hierNode.modifier, te += Z.hierNode.modifier;
    }
    X && !nextRight(K) && (K.hierNode.thread = X, K.hierNode.modifier += re - Q), W && !nextLeft(Z) && (Z.hierNode.thread = W, Z.hierNode.modifier += ee - te, G = H);
  }
  return G;
}
function nextRight(H) {
  var C = H.children;
  return C.length && H.isExpand ? C[C.length - 1] : H.hierNode.thread;
}
function nextLeft(H) {
  var C = H.children;
  return C.length && H.isExpand ? C[0] : H.hierNode.thread;
}
function nextAncestor(H, C, G) {
  return H.hierNode.ancestor.parentNode === C.parentNode ? H.hierNode.ancestor : G;
}
function moveSubtree(H, C, G) {
  var U = G / (C.hierNode.i - H.hierNode.i);
  C.hierNode.change -= U, C.hierNode.shift += G, C.hierNode.modifier += G, C.hierNode.prelim += G, H.hierNode.change += U;
}
function defaultSeparation(H, C) {
  return H.parentNode === C.parentNode ? 1 : 2;
}
var TreeEdgeShape = (
  /** @class */
  function() {
    function H() {
      this.parentPoint = [], this.childPoints = [];
    }
    return H;
  }()
), TreePath = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C(G) {
      return H.call(this, G) || this;
    }
    return C.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    }, C.prototype.getDefaultShape = function() {
      return new TreeEdgeShape();
    }, C.prototype.buildPath = function(G, U) {
      var K = U.childPoints, W = K.length, Z = U.parentPoint, X = K[0], Q = K[W - 1];
      if (W === 1) {
        G.moveTo(Z[0], Z[1]), G.lineTo(X[0], X[1]);
        return;
      }
      var ee = U.orient, te = ee === "TB" || ee === "BT" ? 0 : 1, re = 1 - te, ne = parsePercent(U.forkPosition, 1), ae = [];
      ae[te] = Z[te], ae[re] = Z[re] + (Q[re] - Z[re]) * ne, G.moveTo(Z[0], Z[1]), G.lineTo(ae[0], ae[1]), G.moveTo(X[0], X[1]), ae[te] = X[te], G.lineTo(ae[0], ae[1]), ae[te] = Q[te], G.lineTo(ae[0], ae[1]), G.lineTo(Q[0], Q[1]);
      for (var ie = 1; ie < W - 1; ie++) {
        var se = K[ie];
        G.moveTo(se[0], se[1]), ae[te] = se[te], G.lineTo(ae[0], ae[1]);
      }
    }, C;
  }(Path$1)
), TreeView = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G._mainGroup = new Group$4(), G;
    }
    return C.prototype.init = function(G, U) {
      this._controller = new RoamController$1(U.getZr()), this._controllerHost = {
        target: this.group
      }, this.group.add(this._mainGroup);
    }, C.prototype.render = function(G, U, K) {
      var W = G.getData(), Z = G.layoutInfo, X = this._mainGroup, Q = G.get("layout");
      Q === "radial" ? (X.x = Z.x + Z.width / 2, X.y = Z.y + Z.height / 2) : (X.x = Z.x, X.y = Z.y), this._updateViewCoordSys(G, K), this._updateController(G, U, K);
      var ee = this._data;
      W.diff(ee).add(function(te) {
        symbolNeedsDraw(W, te) && updateNode(W, te, null, X, G);
      }).update(function(te, re) {
        var ne = ee.getItemGraphicEl(re);
        if (!symbolNeedsDraw(W, te)) {
          ne && removeNode(ee, re, ne, X, G);
          return;
        }
        updateNode(W, te, ne, X, G);
      }).remove(function(te) {
        var re = ee.getItemGraphicEl(te);
        re && removeNode(ee, te, re, X, G);
      }).execute(), this._nodeScaleRatio = G.get("nodeScaleRatio"), this._updateNodeAndLinkScale(G), G.get("expandAndCollapse") === !0 && W.eachItemGraphicEl(function(te, re) {
        te.off("click").on("click", function() {
          K.dispatchAction({
            type: "treeExpandAndCollapse",
            seriesId: G.id,
            dataIndex: re
          });
        });
      }), this._data = W;
    }, C.prototype._updateViewCoordSys = function(G, U) {
      var K = G.getData(), W = [];
      K.each(function(re) {
        var ne = K.getItemLayout(re);
        ne && !isNaN(ne.x) && !isNaN(ne.y) && W.push([+ne.x, +ne.y]);
      });
      var Z = [], X = [];
      fromPoints(W, Z, X);
      var Q = this._min, ee = this._max;
      X[0] - Z[0] === 0 && (Z[0] = Q ? Q[0] : Z[0] - 1, X[0] = ee ? ee[0] : X[0] + 1), X[1] - Z[1] === 0 && (Z[1] = Q ? Q[1] : Z[1] - 1, X[1] = ee ? ee[1] : X[1] + 1);
      var te = G.coordinateSystem = new View$1();
      te.zoomLimit = G.get("scaleLimit"), te.setBoundingRect(Z[0], Z[1], X[0] - Z[0], X[1] - Z[1]), te.setCenter(G.get("center"), U), te.setZoom(G.get("zoom")), this.group.attr({
        x: te.x,
        y: te.y,
        scaleX: te.scaleX,
        scaleY: te.scaleY
      }), this._min = Z, this._max = X;
    }, C.prototype._updateController = function(G, U, K) {
      var W = this, Z = this._controller, X = this._controllerHost, Q = this.group;
      Z.setPointerChecker(function(ee, te, re) {
        var ne = Q.getBoundingRect();
        return ne.applyTransform(Q.transform), ne.contain(te, re) && !onIrrelevantElement(ee, K, G);
      }), Z.enable(G.get("roam")), X.zoomLimit = G.get("scaleLimit"), X.zoom = G.coordinateSystem.getZoom(), Z.off("pan").off("zoom").on("pan", function(ee) {
        updateViewOnPan(X, ee.dx, ee.dy), K.dispatchAction({
          seriesId: G.id,
          type: "treeRoam",
          dx: ee.dx,
          dy: ee.dy
        });
      }).on("zoom", function(ee) {
        updateViewOnZoom(X, ee.scale, ee.originX, ee.originY), K.dispatchAction({
          seriesId: G.id,
          type: "treeRoam",
          zoom: ee.scale,
          originX: ee.originX,
          originY: ee.originY
        }), W._updateNodeAndLinkScale(G), K.updateLabelLayout();
      });
    }, C.prototype._updateNodeAndLinkScale = function(G) {
      var U = G.getData(), K = this._getNodeGlobalScale(G);
      U.eachItemGraphicEl(function(W, Z) {
        W.setSymbolScale(K);
      });
    }, C.prototype._getNodeGlobalScale = function(G) {
      var U = G.coordinateSystem;
      if (U.type !== "view")
        return 1;
      var K = this._nodeScaleRatio, W = U.scaleX || 1, Z = U.getZoom(), X = (Z - 1) * K + 1;
      return X / W;
    }, C.prototype.dispose = function() {
      this._controller && this._controller.dispose(), this._controllerHost = null;
    }, C.prototype.remove = function() {
      this._mainGroup.removeAll(), this._data = null;
    }, C.type = "tree", C;
  }(ChartView$1)
);
function symbolNeedsDraw(H, C) {
  var G = H.getItemLayout(C);
  return G && !isNaN(G.x) && !isNaN(G.y);
}
function updateNode(H, C, G, U, K) {
  var W = !G, Z = H.tree.getNodeByDataIndex(C), X = Z.getModel(), Q = Z.getVisual("style").fill, ee = Z.isExpand === !1 && Z.children.length !== 0 ? Q : "#fff", te = H.tree.root, re = Z.parentNode === te ? Z : Z.parentNode || Z, ne = H.getItemGraphicEl(re.dataIndex), ae = re.getLayout(), ie = ne ? {
    x: ne.__oldX,
    y: ne.__oldY,
    rawX: ne.__radialOldRawX,
    rawY: ne.__radialOldRawY
  } : ae, se = Z.getLayout();
  W ? (G = new SymbolClz(H, C, null, {
    symbolInnerColor: ee,
    useNameLabel: !0
  }), G.x = ie.x, G.y = ie.y) : G.updateData(H, C, null, {
    symbolInnerColor: ee,
    useNameLabel: !0
  }), G.__radialOldRawX = G.__radialRawX, G.__radialOldRawY = G.__radialRawY, G.__radialRawX = se.rawX, G.__radialRawY = se.rawY, U.add(G), H.setItemGraphicEl(C, G), G.__oldX = G.x, G.__oldY = G.y, updateProps$1(G, {
    x: se.x,
    y: se.y
  }, K);
  var oe = G.getSymbolPath();
  if (K.get("layout") === "radial") {
    var le = te.children[0], ue = le.getLayout(), ce = le.children.length, de = void 0, ge = void 0;
    if (se.x === ue.x && Z.isExpand === !0 && le.children.length) {
      var fe = {
        x: (le.children[0].getLayout().x + le.children[ce - 1].getLayout().x) / 2,
        y: (le.children[0].getLayout().y + le.children[ce - 1].getLayout().y) / 2
      };
      de = Math.atan2(fe.y - ue.y, fe.x - ue.x), de < 0 && (de = Math.PI * 2 + de), ge = fe.x < ue.x, ge && (de = de - Math.PI);
    } else
      de = Math.atan2(se.y - ue.y, se.x - ue.x), de < 0 && (de = Math.PI * 2 + de), Z.children.length === 0 || Z.children.length !== 0 && Z.isExpand === !1 ? (ge = se.x < ue.x, ge && (de = de - Math.PI)) : (ge = se.x > ue.x, ge || (de = de - Math.PI));
    var ve = ge ? "left" : "right", pe = X.getModel("label"), he = pe.get("rotate"), me = he * (Math.PI / 180), ye = oe.getTextContent();
    ye && (oe.setTextConfig({
      position: pe.get("position") || ve,
      rotation: he == null ? -de : me,
      origin: "center"
    }), ye.setStyle("verticalAlign", "middle"));
  }
  var Ce = X.get(["emphasis", "focus"]), Ie = Ce === "relative" ? concatArray(Z.getAncestorsIndices(), Z.getDescendantIndices()) : Ce === "ancestor" ? Z.getAncestorsIndices() : Ce === "descendant" ? Z.getDescendantIndices() : null;
  Ie && (getECData(G).focus = Ie), drawEdge(K, Z, te, G, ie, ae, se, U), G.__edge && (G.onHoverStateChange = function(be) {
    if (be !== "blur") {
      var Se = Z.parentNode && H.getItemGraphicEl(Z.parentNode.dataIndex);
      Se && Se.hoverState === HOVER_STATE_BLUR || setStatesFlag(G.__edge, be);
    }
  });
}
function drawEdge(H, C, G, U, K, W, Z, X) {
  var Q = C.getModel(), ee = H.get("edgeShape"), te = H.get("layout"), re = H.getOrient(), ne = H.get(["lineStyle", "curveness"]), ae = H.get("edgeForkPosition"), ie = Q.getModel("lineStyle").getLineStyle(), se = U.__edge;
  if (ee === "curve")
    C.parentNode && C.parentNode !== G && (se || (se = U.__edge = new BezierCurve$1({
      shape: getEdgeShape(te, re, ne, K, K)
    })), updateProps$1(se, {
      shape: getEdgeShape(te, re, ne, W, Z)
    }, H));
  else if (ee === "polyline") {
    if (te === "orthogonal") {
      if (C !== G && C.children && C.children.length !== 0 && C.isExpand === !0) {
        for (var oe = C.children, le = [], ue = 0; ue < oe.length; ue++) {
          var ce = oe[ue].getLayout();
          le.push([ce.x, ce.y]);
        }
        se || (se = U.__edge = new TreePath({
          shape: {
            parentPoint: [Z.x, Z.y],
            childPoints: [[Z.x, Z.y]],
            orient: re,
            forkPosition: ae
          }
        })), updateProps$1(se, {
          shape: {
            parentPoint: [Z.x, Z.y],
            childPoints: le
          }
        }, H);
      }
    } else if (process.env.NODE_ENV !== "production")
      throw new Error("The polyline edgeShape can only be used in orthogonal layout");
  }
  se && !(ee === "polyline" && !C.isExpand) && (se.useStyle(defaults({
    strokeNoScale: !0,
    fill: null
  }, ie)), setStatesStylesFromModel(se, Q, "lineStyle"), setDefaultStateProxy(se), X.add(se));
}
function removeNodeEdge(H, C, G, U, K) {
  var W = C.tree.root, Z = getSourceNode(W, H), X = Z.source, Q = Z.sourceLayout, ee = C.getItemGraphicEl(H.dataIndex);
  if (ee) {
    var te = C.getItemGraphicEl(X.dataIndex), re = te.__edge, ne = ee.__edge || (X.isExpand === !1 || X.children.length === 1 ? re : void 0), ae = U.get("edgeShape"), ie = U.get("layout"), se = U.get("orient"), oe = U.get(["lineStyle", "curveness"]);
    ne && (ae === "curve" ? removeElement(ne, {
      shape: getEdgeShape(ie, se, oe, Q, Q),
      style: {
        opacity: 0
      }
    }, U, {
      cb: function() {
        G.remove(ne);
      },
      removeOpt: K
    }) : ae === "polyline" && U.get("layout") === "orthogonal" && removeElement(ne, {
      shape: {
        parentPoint: [Q.x, Q.y],
        childPoints: [[Q.x, Q.y]]
      },
      style: {
        opacity: 0
      }
    }, U, {
      cb: function() {
        G.remove(ne);
      },
      removeOpt: K
    }));
  }
}
function getSourceNode(H, C) {
  for (var G = C.parentNode === H ? C : C.parentNode || C, U; U = G.getLayout(), U == null; )
    G = G.parentNode === H ? G : G.parentNode || G;
  return {
    source: G,
    sourceLayout: U
  };
}
function removeNode(H, C, G, U, K) {
  var W = H.tree.getNodeByDataIndex(C), Z = H.tree.root, X = getSourceNode(Z, W).sourceLayout, Q = {
    duration: K.get("animationDurationUpdate"),
    easing: K.get("animationEasingUpdate")
  };
  removeElement(G, {
    x: X.x + 1,
    y: X.y + 1
  }, K, {
    cb: function() {
      U.remove(G), H.setItemGraphicEl(C, null);
    },
    removeOpt: Q
  }), G.fadeOut(null, H.hostModel, {
    fadeLabel: !0,
    animation: Q
  }), W.children.forEach(function(ee) {
    removeNodeEdge(ee, H, U, K, Q);
  }), removeNodeEdge(W, H, U, K, Q);
}
function getEdgeShape(H, C, G, U, K) {
  var W, Z, X, Q, ee, te, re, ne;
  if (H === "radial") {
    ee = U.rawX, re = U.rawY, te = K.rawX, ne = K.rawY;
    var ae = radialCoordinate(ee, re), ie = radialCoordinate(ee, re + (ne - re) * G), se = radialCoordinate(te, ne + (re - ne) * G), oe = radialCoordinate(te, ne);
    return {
      x1: ae.x || 0,
      y1: ae.y || 0,
      x2: oe.x || 0,
      y2: oe.y || 0,
      cpx1: ie.x || 0,
      cpy1: ie.y || 0,
      cpx2: se.x || 0,
      cpy2: se.y || 0
    };
  } else
    ee = U.x, re = U.y, te = K.x, ne = K.y, (C === "LR" || C === "RL") && (W = ee + (te - ee) * G, Z = re, X = te + (ee - te) * G, Q = ne), (C === "TB" || C === "BT") && (W = ee, Z = re + (ne - re) * G, X = te, Q = ne + (re - ne) * G);
  return {
    x1: ee,
    y1: re,
    x2: te,
    y2: ne,
    cpx1: W,
    cpy1: Z,
    cpx2: X,
    cpy2: Q
  };
}
const TreeView$1 = TreeView;
var inner$e = makeInner();
function linkSeriesData(H) {
  var C = H.mainData, G = H.datas;
  G || (G = {
    main: C
  }, H.datasAttr = {
    main: "data"
  }), H.datas = H.mainData = null, linkAll(C, G, H), each$f(G, function(U) {
    each$f(C.TRANSFERABLE_METHODS, function(K) {
      U.wrapMethod(K, curry$1(transferInjection, H));
    });
  }), C.wrapMethod("cloneShallow", curry$1(cloneShallowInjection, H)), each$f(C.CHANGABLE_METHODS, function(U) {
    C.wrapMethod(U, curry$1(changeInjection, H));
  }), assert(G[C.dataType] === C);
}
function transferInjection(H, C) {
  if (isMainData(this)) {
    var G = extend({}, inner$e(this).datas);
    G[this.dataType] = C, linkAll(C, G, H);
  } else
    linkSingle(C, this.dataType, inner$e(this).mainData, H);
  return C;
}
function changeInjection(H, C) {
  return H.struct && H.struct.update(), C;
}
function cloneShallowInjection(H, C) {
  return each$f(inner$e(C).datas, function(G, U) {
    G !== C && linkSingle(G.cloneShallow(), U, C, H);
  }), C;
}
function getLinkedData(H) {
  var C = inner$e(this).mainData;
  return H == null || C == null ? C : inner$e(C).datas[H];
}
function getLinkedDataAll() {
  var H = inner$e(this).mainData;
  return H == null ? [{
    data: H
  }] : map$1(keys(inner$e(H).datas), function(C) {
    return {
      type: C,
      data: inner$e(H).datas[C]
    };
  });
}
function isMainData(H) {
  return inner$e(H).mainData === H;
}
function linkAll(H, C, G) {
  inner$e(H).datas = {}, each$f(C, function(U, K) {
    linkSingle(U, K, H, G);
  });
}
function linkSingle(H, C, G, U) {
  inner$e(G).datas[C] = H, inner$e(H).mainData = G, H.dataType = C, U.struct && (H[U.structAttr] = U.struct, U.struct[U.datasAttr[C]] = H), H.getLinkedData = getLinkedData, H.getLinkedDataAll = getLinkedDataAll;
}
var TreeNode = (
  /** @class */
  function() {
    function H(C, G) {
      this.depth = 0, this.height = 0, this.dataIndex = -1, this.children = [], this.viewChildren = [], this.isExpand = !1, this.name = C || "", this.hostTree = G;
    }
    return H.prototype.isRemoved = function() {
      return this.dataIndex < 0;
    }, H.prototype.eachNode = function(C, G, U) {
      isFunction(C) && (U = G, G = C, C = null), C = C || {}, isString(C) && (C = {
        order: C
      });
      var K = C.order || "preorder", W = this[C.attr || "children"], Z;
      K === "preorder" && (Z = G.call(U, this));
      for (var X = 0; !Z && X < W.length; X++)
        W[X].eachNode(C, G, U);
      K === "postorder" && G.call(U, this);
    }, H.prototype.updateDepthAndHeight = function(C) {
      var G = 0;
      this.depth = C;
      for (var U = 0; U < this.children.length; U++) {
        var K = this.children[U];
        K.updateDepthAndHeight(C + 1), K.height > G && (G = K.height);
      }
      this.height = G + 1;
    }, H.prototype.getNodeById = function(C) {
      if (this.getId() === C)
        return this;
      for (var G = 0, U = this.children, K = U.length; G < K; G++) {
        var W = U[G].getNodeById(C);
        if (W)
          return W;
      }
    }, H.prototype.contains = function(C) {
      if (C === this)
        return !0;
      for (var G = 0, U = this.children, K = U.length; G < K; G++) {
        var W = U[G].contains(C);
        if (W)
          return W;
      }
    }, H.prototype.getAncestors = function(C) {
      for (var G = [], U = C ? this : this.parentNode; U; )
        G.push(U), U = U.parentNode;
      return G.reverse(), G;
    }, H.prototype.getAncestorsIndices = function() {
      for (var C = [], G = this; G; )
        C.push(G.dataIndex), G = G.parentNode;
      return C.reverse(), C;
    }, H.prototype.getDescendantIndices = function() {
      var C = [];
      return this.eachNode(function(G) {
        C.push(G.dataIndex);
      }), C;
    }, H.prototype.getValue = function(C) {
      var G = this.hostTree.data;
      return G.getStore().get(G.getDimensionIndex(C || "value"), this.dataIndex);
    }, H.prototype.setLayout = function(C, G) {
      this.dataIndex >= 0 && this.hostTree.data.setItemLayout(this.dataIndex, C, G);
    }, H.prototype.getLayout = function() {
      return this.hostTree.data.getItemLayout(this.dataIndex);
    }, H.prototype.getModel = function(C) {
      if (!(this.dataIndex < 0)) {
        var G = this.hostTree, U = G.data.getItemModel(this.dataIndex);
        return U.getModel(C);
      }
    }, H.prototype.getLevelModel = function() {
      return (this.hostTree.levelModels || [])[this.depth];
    }, H.prototype.setVisual = function(C, G) {
      this.dataIndex >= 0 && this.hostTree.data.setItemVisual(this.dataIndex, C, G);
    }, H.prototype.getVisual = function(C) {
      return this.hostTree.data.getItemVisual(this.dataIndex, C);
    }, H.prototype.getRawIndex = function() {
      return this.hostTree.data.getRawIndex(this.dataIndex);
    }, H.prototype.getId = function() {
      return this.hostTree.data.getId(this.dataIndex);
    }, H.prototype.getChildIndex = function() {
      if (this.parentNode) {
        for (var C = this.parentNode.children, G = 0; G < C.length; ++G)
          if (C[G] === this)
            return G;
        return -1;
      }
      return -1;
    }, H.prototype.isAncestorOf = function(C) {
      for (var G = C.parentNode; G; ) {
        if (G === this)
          return !0;
        G = G.parentNode;
      }
      return !1;
    }, H.prototype.isDescendantOf = function(C) {
      return C !== this && C.isAncestorOf(this);
    }, H;
  }()
), Tree = (
  /** @class */
  function() {
    function H(C) {
      this.type = "tree", this._nodes = [], this.hostModel = C;
    }
    return H.prototype.eachNode = function(C, G, U) {
      this.root.eachNode(C, G, U);
    }, H.prototype.getNodeByDataIndex = function(C) {
      var G = this.data.getRawIndex(C);
      return this._nodes[G];
    }, H.prototype.getNodeById = function(C) {
      return this.root.getNodeById(C);
    }, H.prototype.update = function() {
      for (var C = this.data, G = this._nodes, U = 0, K = G.length; U < K; U++)
        G[U].dataIndex = -1;
      for (var U = 0, K = C.count(); U < K; U++)
        G[C.getRawIndex(U)].dataIndex = U;
    }, H.prototype.clearLayouts = function() {
      this.data.clearItemLayouts();
    }, H.createTree = function(C, G, U) {
      var K = new H(G), W = [], Z = 1;
      X(C);
      function X(te, re) {
        var ne = te.value;
        Z = Math.max(Z, isArray$1(ne) ? ne.length : 1), W.push(te);
        var ae = new TreeNode(convertOptionIdName(te.name, ""), K);
        re ? addChild(ae, re) : K.root = ae, K._nodes.push(ae);
        var ie = te.children;
        if (ie)
          for (var se = 0; se < ie.length; se++)
            X(ie[se], ae);
      }
      K.root.updateDepthAndHeight(0);
      var Q = prepareSeriesDataSchema(W, {
        coordDimensions: ["value"],
        dimensionsCount: Z
      }).dimensions, ee = new SeriesData$1(Q, G);
      return ee.initData(W), U && U(ee), linkSeriesData({
        mainData: ee,
        struct: K,
        structAttr: "tree"
      }), K.update(), K;
    }, H;
  }()
);
function addChild(H, C) {
  var G = C.children;
  H.parentNode !== C && (G.push(H), H.parentNode = C);
}
const Tree$1 = Tree;
function retrieveTargetInfo(H, C, G) {
  if (H && indexOf(C, H.type) >= 0) {
    var U = G.getData().tree.root, K = H.targetNode;
    if (isString(K) && (K = U.getNodeById(K)), K && U.contains(K))
      return {
        node: K
      };
    var W = H.targetNodeId;
    if (W != null && (K = U.getNodeById(W)))
      return {
        node: K
      };
  }
}
function getPathToRoot(H) {
  for (var C = []; H; )
    H = H.parentNode, H && C.push(H);
  return C.reverse();
}
function aboveViewRoot(H, C) {
  var G = getPathToRoot(H);
  return indexOf(G, C) >= 0;
}
function wrapTreePathInfo(H, C) {
  for (var G = []; H; ) {
    var U = H.dataIndex;
    G.push({
      name: H.name,
      dataIndex: U,
      value: C.getRawValue(U)
    }), H = H.parentNode;
  }
  return G.reverse(), G;
}
var TreeSeriesModel = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.hasSymbolVisual = !0, G.ignoreStyleOnData = !0, G;
    }
    return C.prototype.getInitialData = function(G) {
      var U = {
        name: G.name,
        children: G.data
      }, K = G.leaves || {}, W = new Model$1(K, this, this.ecModel), Z = Tree$1.createTree(U, this, X);
      function X(re) {
        re.wrapMethod("getItemModel", function(ne, ae) {
          var ie = Z.getNodeByDataIndex(ae);
          return ie && ie.children.length && ie.isExpand || (ne.parentModel = W), ne;
        });
      }
      var Q = 0;
      Z.eachNode("preorder", function(re) {
        re.depth > Q && (Q = re.depth);
      });
      var ee = G.expandAndCollapse, te = ee && G.initialTreeDepth >= 0 ? G.initialTreeDepth : Q;
      return Z.root.eachNode("preorder", function(re) {
        var ne = re.hostTree.data.getRawDataItem(re.dataIndex);
        re.isExpand = ne && ne.collapsed != null ? !ne.collapsed : re.depth <= te;
      }), Z.data;
    }, C.prototype.getOrient = function() {
      var G = this.get("orient");
      return G === "horizontal" ? G = "LR" : G === "vertical" && (G = "TB"), G;
    }, C.prototype.setZoom = function(G) {
      this.option.zoom = G;
    }, C.prototype.setCenter = function(G) {
      this.option.center = G;
    }, C.prototype.formatTooltip = function(G, U, K) {
      for (var W = this.getData().tree, Z = W.root.children[0], X = W.getNodeByDataIndex(G), Q = X.getValue(), ee = X.name; X && X !== Z; )
        ee = X.parentNode.name + "." + ee, X = X.parentNode;
      return createTooltipMarkup("nameValue", {
        name: ee,
        value: Q,
        noValue: isNaN(Q) || Q == null
      });
    }, C.prototype.getDataParams = function(G) {
      var U = H.prototype.getDataParams.apply(this, arguments), K = this.getData().tree.getNodeByDataIndex(G);
      return U.treeAncestors = wrapTreePathInfo(K, this), U.collapsed = !K.isExpand, U;
    }, C.type = "series.tree", C.layoutMode = "box", C.defaultOption = {
      // zlevel: 0,
      z: 2,
      coordinateSystem: "view",
      // the position of the whole view
      left: "12%",
      top: "12%",
      right: "12%",
      bottom: "12%",
      // the layout of the tree, two value can be selected, 'orthogonal' or 'radial'
      layout: "orthogonal",
      // value can be 'polyline'
      edgeShape: "curve",
      edgeForkPosition: "50%",
      // true | false | 'move' | 'scale', see module:component/helper/RoamController.
      roam: !1,
      // Symbol size scale ratio in roam
      nodeScaleRatio: 0.4,
      // Default on center of graph
      center: null,
      zoom: 1,
      orient: "LR",
      symbol: "emptyCircle",
      symbolSize: 7,
      expandAndCollapse: !0,
      initialTreeDepth: 2,
      lineStyle: {
        color: "#ccc",
        width: 1.5,
        curveness: 0.5
      },
      itemStyle: {
        color: "lightsteelblue",
        // borderColor: '#c23531',
        borderWidth: 1.5
      },
      label: {
        show: !0
      },
      animationEasing: "linear",
      animationDuration: 700,
      animationDurationUpdate: 500
    }, C;
  }(SeriesModel$1)
);
const TreeSeriesModel$1 = TreeSeriesModel;
function eachAfter(H, C, G) {
  for (var U = [H], K = [], W; W = U.pop(); )
    if (K.push(W), W.isExpand) {
      var Z = W.children;
      if (Z.length)
        for (var X = 0; X < Z.length; X++)
          U.push(Z[X]);
    }
  for (; W = K.pop(); )
    C(W, G);
}
function eachBefore(H, C) {
  for (var G = [H], U; U = G.pop(); )
    if (C(U), U.isExpand) {
      var K = U.children;
      if (K.length)
        for (var W = K.length - 1; W >= 0; W--)
          G.push(K[W]);
    }
}
function treeLayout(H, C) {
  H.eachSeriesByType("tree", function(G) {
    commonLayout(G, C);
  });
}
function commonLayout(H, C) {
  var G = getViewRect$4(H, C);
  H.layoutInfo = G;
  var U = H.get("layout"), K = 0, W = 0, Z = null;
  U === "radial" ? (K = 2 * Math.PI, W = Math.min(G.height, G.width) / 2, Z = separation(function(ce, de) {
    return (ce.parentNode === de.parentNode ? 1 : 2) / ce.depth;
  })) : (K = G.width, W = G.height, Z = separation());
  var X = H.getData().tree.root, Q = X.children[0];
  if (Q) {
    init(X), eachAfter(Q, firstWalk, Z), X.hierNode.modifier = -Q.hierNode.prelim, eachBefore(Q, secondWalk);
    var ee = Q, te = Q, re = Q;
    eachBefore(Q, function(ce) {
      var de = ce.getLayout().x;
      de < ee.getLayout().x && (ee = ce), de > te.getLayout().x && (te = ce), ce.depth > re.depth && (re = ce);
    });
    var ne = ee === te ? 1 : Z(ee, te) / 2, ae = ne - ee.getLayout().x, ie = 0, se = 0, oe = 0, le = 0;
    if (U === "radial")
      ie = K / (te.getLayout().x + ne + ae), se = W / (re.depth - 1 || 1), eachBefore(Q, function(ce) {
        oe = (ce.getLayout().x + ae) * ie, le = (ce.depth - 1) * se;
        var de = radialCoordinate(oe, le);
        ce.setLayout({
          x: de.x,
          y: de.y,
          rawX: oe,
          rawY: le
        }, !0);
      });
    else {
      var ue = H.getOrient();
      ue === "RL" || ue === "LR" ? (se = W / (te.getLayout().x + ne + ae), ie = K / (re.depth - 1 || 1), eachBefore(Q, function(ce) {
        le = (ce.getLayout().x + ae) * se, oe = ue === "LR" ? (ce.depth - 1) * ie : K - (ce.depth - 1) * ie, ce.setLayout({
          x: oe,
          y: le
        }, !0);
      })) : (ue === "TB" || ue === "BT") && (ie = K / (te.getLayout().x + ne + ae), se = W / (re.depth - 1 || 1), eachBefore(Q, function(ce) {
        oe = (ce.getLayout().x + ae) * ie, le = ue === "TB" ? (ce.depth - 1) * se : W - (ce.depth - 1) * se, ce.setLayout({
          x: oe,
          y: le
        }, !0);
      }));
    }
  }
}
function treeVisual(H) {
  H.eachSeriesByType("tree", function(C) {
    var G = C.getData(), U = G.tree;
    U.eachNode(function(K) {
      var W = K.getModel(), Z = W.getModel("itemStyle").getItemStyle(), X = G.ensureUniqueItemVisual(K.dataIndex, "style");
      extend(X, Z);
    });
  });
}
function installTreeAction(H) {
  H.registerAction({
    type: "treeExpandAndCollapse",
    event: "treeExpandAndCollapse",
    update: "update"
  }, function(C, G) {
    G.eachComponent({
      mainType: "series",
      subType: "tree",
      query: C
    }, function(U) {
      var K = C.dataIndex, W = U.getData().tree, Z = W.getNodeByDataIndex(K);
      Z.isExpand = !Z.isExpand;
    });
  }), H.registerAction({
    type: "treeRoam",
    event: "treeRoam",
    // Here we set 'none' instead of 'update', because roam action
    // just need to update the transform matrix without having to recalculate
    // the layout. So don't need to go through the whole update process, such
    // as 'dataPrcocess', 'coordSystemUpdate', 'layout' and so on.
    update: "none"
  }, function(C, G, U) {
    G.eachComponent({
      mainType: "series",
      subType: "tree",
      query: C
    }, function(K) {
      var W = K.coordinateSystem, Z = updateCenterAndZoom(W, C, void 0, U);
      K.setCenter && K.setCenter(Z.center), K.setZoom && K.setZoom(Z.zoom);
    });
  });
}
function install$H(H) {
  H.registerChartView(TreeView$1), H.registerSeriesModel(TreeSeriesModel$1), H.registerLayout(treeLayout), H.registerVisual(treeVisual), installTreeAction(H);
}
var actionTypes = ["treemapZoomToNode", "treemapRender", "treemapMove"];
function installTreemapAction(H) {
  for (var C = 0; C < actionTypes.length; C++)
    H.registerAction({
      type: actionTypes[C],
      update: "updateView"
    }, noop);
  H.registerAction({
    type: "treemapRootToNode",
    update: "updateView"
  }, function(G, U) {
    U.eachComponent({
      mainType: "series",
      subType: "treemap",
      query: G
    }, K);
    function K(W, Z) {
      var X = ["treemapZoomToNode", "treemapRootToNode"], Q = retrieveTargetInfo(G, X, W);
      if (Q) {
        var ee = W.getViewRoot();
        ee && (G.direction = aboveViewRoot(ee, Q.node) ? "rollUp" : "drillDown"), W.resetViewRoot(Q.node);
      }
    }
  });
}
function enableAriaDecalForTree(H) {
  var C = H.getData(), G = C.tree, U = {};
  G.eachNode(function(K) {
    for (var W = K; W && W.depth > 1; )
      W = W.parentNode;
    var Z = getDecalFromPalette(H.ecModel, W.name || W.dataIndex + "", U);
    K.setVisual("decal", Z);
  });
}
var TreemapSeriesModel = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G.preventUsingHoverLayer = !0, G;
    }
    return C.prototype.getInitialData = function(G, U) {
      var K = {
        name: G.name,
        children: G.data
      };
      completeTreeValue$1(K);
      var W = G.levels || [], Z = this.designatedVisualItemStyle = {}, X = new Model$1({
        itemStyle: Z
      }, this, U);
      W = G.levels = setDefault(W, U);
      var Q = map$1(W || [], function(re) {
        return new Model$1(re, X, U);
      }, this), ee = Tree$1.createTree(K, this, te);
      function te(re) {
        re.wrapMethod("getItemModel", function(ne, ae) {
          var ie = ee.getNodeByDataIndex(ae), se = ie ? Q[ie.depth] : null;
          return ne.parentModel = se || X, ne;
        });
      }
      return ee.data;
    }, C.prototype.optionUpdated = function() {
      this.resetViewRoot();
    }, C.prototype.formatTooltip = function(G, U, K) {
      var W = this.getData(), Z = this.getRawValue(G), X = W.getName(G);
      return createTooltipMarkup("nameValue", {
        name: X,
        value: Z
      });
    }, C.prototype.getDataParams = function(G) {
      var U = H.prototype.getDataParams.apply(this, arguments), K = this.getData().tree.getNodeByDataIndex(G);
      return U.treeAncestors = wrapTreePathInfo(K, this), U.treePathInfo = U.treeAncestors, U;
    }, C.prototype.setLayoutInfo = function(G) {
      this.layoutInfo = this.layoutInfo || {}, extend(this.layoutInfo, G);
    }, C.prototype.mapIdToIndex = function(G) {
      var U = this._idIndexMap;
      U || (U = this._idIndexMap = createHashMap(), this._idIndexMapCount = 0);
      var K = U.get(G);
      return K == null && U.set(G, K = this._idIndexMapCount++), K;
    }, C.prototype.getViewRoot = function() {
      return this._viewRoot;
    }, C.prototype.resetViewRoot = function(G) {
      G ? this._viewRoot = G : G = this._viewRoot;
      var U = this.getRawData().tree.root;
      (!G || G !== U && !U.contains(G)) && (this._viewRoot = U);
    }, C.prototype.enableAriaDecal = function() {
      enableAriaDecalForTree(this);
    }, C.type = "series.treemap", C.layoutMode = "box", C.defaultOption = {
      // Disable progressive rendering
      progressive: 0,
      // size: ['80%', '80%'],            // deprecated, compatible with ec2.
      left: "center",
      top: "middle",
      width: "80%",
      height: "80%",
      sort: !0,
      clipWindow: "origin",
      squareRatio: 0.5 * (1 + Math.sqrt(5)),
      leafDepth: null,
      drillDownIcon: "▶",
      // to align specialized icon. ▷▶❒❐▼✚
      zoomToNodeRatio: 0.32 * 0.32,
      roam: !0,
      nodeClick: "zoomToNode",
      animation: !0,
      animationDurationUpdate: 900,
      animationEasing: "quinticInOut",
      breadcrumb: {
        show: !0,
        height: 22,
        left: "center",
        top: "bottom",
        // right
        // bottom
        emptyItemWidth: 25,
        itemStyle: {
          color: "rgba(0,0,0,0.7)",
          textStyle: {
            color: "#fff"
          }
        },
        emphasis: {
          itemStyle: {
            color: "rgba(0,0,0,0.9)"
            // '#5793f3',
          }
        }
      },
      label: {
        show: !0,
        // Do not use textDistance, for ellipsis rect just the same as treemap node rect.
        distance: 0,
        padding: 5,
        position: "inside",
        // formatter: null,
        color: "#fff",
        overflow: "truncate"
        // align
        // verticalAlign
      },
      upperLabel: {
        show: !1,
        position: [0, "50%"],
        height: 20,
        // formatter: null,
        // color: '#fff',
        overflow: "truncate",
        // align: null,
        verticalAlign: "middle"
      },
      itemStyle: {
        color: null,
        colorAlpha: null,
        colorSaturation: null,
        borderWidth: 0,
        gapWidth: 0,
        borderColor: "#fff",
        borderColorSaturation: null
        // If specified, borderColor will be ineffective, and the
        // border color is evaluated by color of current node and
        // borderColorSaturation.
      },
      emphasis: {
        upperLabel: {
          show: !0,
          position: [0, "50%"],
          overflow: "truncate",
          verticalAlign: "middle"
        }
      },
      visualDimension: 0,
      visualMin: null,
      visualMax: null,
      color: [],
      // level[n].color (if necessary).
      // + Specify color list of each level. level[0].color would be global
      // color list if not specified. (see method `setDefault`).
      // + But set as a empty array to forbid fetch color from global palette
      // when using nodeModel.get('color'), otherwise nodes on deep level
      // will always has color palette set and are not able to inherit color
      // from parent node.
      // + TreemapSeries.color can not be set as 'none', otherwise effect
      // legend color fetching (see seriesColor.js).
      colorAlpha: null,
      colorSaturation: null,
      colorMappingBy: "index",
      visibleMin: 10,
      // be rendered. Only works when sort is 'asc' or 'desc'.
      childrenVisibleMin: null,
      // grandchildren will not show.
      // Why grandchildren? If not grandchildren but children,
      // some siblings show children and some not,
      // the appearance may be mess and not consistent,
      levels: []
      // Each item: {
      //     visibleMin, itemStyle, visualDimension, label
      // }
    }, C;
  }(SeriesModel$1)
);
function completeTreeValue$1(H) {
  var C = 0;
  each$f(H.children, function(U) {
    completeTreeValue$1(U);
    var K = U.value;
    isArray$1(K) && (K = K[0]), C += K;
  });
  var G = H.value;
  isArray$1(G) && (G = G[0]), (G == null || isNaN(G)) && (G = C), G < 0 && (G = 0), isArray$1(H.value) ? H.value[0] = G : H.value = G;
}
function setDefault(H, C) {
  var G = normalizeToArray(C.get("color")), U = normalizeToArray(C.get(["aria", "decal", "decals"]));
  if (G) {
    H = H || [];
    var K, W;
    each$f(H, function(X) {
      var Q = new Model$1(X), ee = Q.get("color"), te = Q.get("decal");
      (Q.get(["itemStyle", "color"]) || ee && ee !== "none") && (K = !0), (Q.get(["itemStyle", "decal"]) || te && te !== "none") && (W = !0);
    });
    var Z = H[0] || (H[0] = {});
    return K || (Z.color = G.slice()), !W && U && (Z.decal = U.slice()), H;
  }
}
const TreemapSeriesModel$1 = TreemapSeriesModel;
var TEXT_PADDING = 8, ITEM_GAP = 8, ARRAY_LENGTH = 5, Breadcrumb = (
  /** @class */
  function() {
    function H(C) {
      this.group = new Group$4(), C.add(this.group);
    }
    return H.prototype.render = function(C, G, U, K) {
      var W = C.getModel("breadcrumb"), Z = this.group;
      if (Z.removeAll(), !(!W.get("show") || !U)) {
        var X = W.getModel("itemStyle"), Q = W.getModel("emphasis"), ee = X.getModel("textStyle"), te = Q.getModel(["itemStyle", "textStyle"]), re = {
          pos: {
            left: W.get("left"),
            right: W.get("right"),
            top: W.get("top"),
            bottom: W.get("bottom")
          },
          box: {
            width: G.getWidth(),
            height: G.getHeight()
          },
          emptyItemWidth: W.get("emptyItemWidth"),
          totalWidth: 0,
          renderList: []
        };
        this._prepare(U, re, ee), this._renderContent(C, re, X, Q, ee, te, K), positionElement(Z, re.pos, re.box);
      }
    }, H.prototype._prepare = function(C, G, U) {
      for (var K = C; K; K = K.parentNode) {
        var W = convertOptionIdName(K.getModel().get("name"), ""), Z = U.getTextRect(W), X = Math.max(Z.width + TEXT_PADDING * 2, G.emptyItemWidth);
        G.totalWidth += X + ITEM_GAP, G.renderList.push({
          node: K,
          text: W,
          width: X
        });
      }
    }, H.prototype._renderContent = function(C, G, U, K, W, Z, X) {
      for (var Q = 0, ee = G.emptyItemWidth, te = C.get(["breadcrumb", "height"]), re = getAvailableSize(G.pos, G.box), ne = G.totalWidth, ae = G.renderList, ie = K.getModel("itemStyle").getItemStyle(), se = ae.length - 1; se >= 0; se--) {
        var oe = ae[se], le = oe.node, ue = oe.width, ce = oe.text;
        ne > re.width && (ne -= ue - ee, ue = ee, ce = null);
        var de = new Polygon$1({
          shape: {
            points: makeItemPoints(Q, 0, ue, te, se === ae.length - 1, se === 0)
          },
          style: defaults(U.getItemStyle(), {
            lineJoin: "bevel"
          }),
          textContent: new ZRText$1({
            style: createTextStyle(W, {
              text: ce
            })
          }),
          textConfig: {
            position: "inside"
          },
          z2: Z2_EMPHASIS_LIFT * 1e4,
          onclick: curry$1(X, le)
        });
        de.disableLabelAnimation = !0, de.getTextContent().ensureState("emphasis").style = createTextStyle(Z, {
          text: ce
        }), de.ensureState("emphasis").style = ie, toggleHoverEmphasis(de, K.get("focus"), K.get("blurScope"), K.get("disabled")), this.group.add(de), packEventData(de, C, le), Q += ue + ITEM_GAP;
      }
    }, H.prototype.remove = function() {
      this.group.removeAll();
    }, H;
  }()
);
function makeItemPoints(H, C, G, U, K, W) {
  var Z = [[K ? H : H - ARRAY_LENGTH, C], [H + G, C], [H + G, C + U], [K ? H : H - ARRAY_LENGTH, C + U]];
  return !W && Z.splice(2, 0, [H + G + ARRAY_LENGTH, C + U / 2]), !K && Z.push([H, C + U / 2]), Z;
}
function packEventData(H, C, G) {
  getECData(H).eventData = {
    componentType: "series",
    componentSubType: "treemap",
    componentIndex: C.componentIndex,
    seriesIndex: C.seriesIndex,
    seriesName: C.name,
    seriesType: "treemap",
    selfType: "breadcrumb",
    nodeData: {
      dataIndex: G && G.dataIndex,
      name: G && G.name
    },
    treePathInfo: G && wrapTreePathInfo(G, C)
  };
}
const Breadcrumb$1 = Breadcrumb;
var AnimationWrap = (
  /** @class */
  function() {
    function H() {
      this._storage = [], this._elExistsMap = {};
    }
    return H.prototype.add = function(C, G, U, K, W) {
      return this._elExistsMap[C.id] ? !1 : (this._elExistsMap[C.id] = !0, this._storage.push({
        el: C,
        target: G,
        duration: U,
        delay: K,
        easing: W
      }), !0);
    }, H.prototype.finished = function(C) {
      return this._finishedCallback = C, this;
    }, H.prototype.start = function() {
      for (var C = this, G = this._storage.length, U = function() {
        G--, G <= 0 && (C._storage.length = 0, C._elExistsMap = {}, C._finishedCallback && C._finishedCallback());
      }, K = 0, W = this._storage.length; K < W; K++) {
        var Z = this._storage[K];
        Z.el.animateTo(Z.target, {
          duration: Z.duration,
          delay: Z.delay,
          easing: Z.easing,
          setToFinal: !0,
          done: U,
          aborted: U
        });
      }
      return this;
    }, H;
  }()
);
function createWrap() {
  return new AnimationWrap();
}
var Group$2 = Group$4, Rect$1 = Rect$3, DRAG_THRESHOLD = 3, PATH_LABEL_NOAMAL = "label", PATH_UPPERLABEL_NORMAL = "upperLabel", Z2_BASE = Z2_EMPHASIS_LIFT * 10, Z2_BG = Z2_EMPHASIS_LIFT * 2, Z2_CONTENT = Z2_EMPHASIS_LIFT * 3, getStateItemStyle = makeStyleMapper([
  ["fill", "color"],
  // `borderColor` and `borderWidth` has been occupied,
  // so use `stroke` to indicate the stroke of the rect.
  ["stroke", "strokeColor"],
  ["lineWidth", "strokeWidth"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["shadowColor"]
  // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
  // So do not transfer decal directly.
]), getItemStyleNormal = function(H) {
  var C = getStateItemStyle(H);
  return C.stroke = C.fill = C.lineWidth = null, C;
}, inner$d = makeInner(), TreemapView = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G._state = "ready", G._storage = createStorage(), G;
    }
    return C.prototype.render = function(G, U, K, W) {
      var Z = U.findComponents({
        mainType: "series",
        subType: "treemap",
        query: W
      });
      if (!(indexOf(Z, G) < 0)) {
        this.seriesModel = G, this.api = K, this.ecModel = U;
        var X = ["treemapZoomToNode", "treemapRootToNode"], Q = retrieveTargetInfo(W, X, G), ee = W && W.type, te = G.layoutInfo, re = !this._oldTree, ne = this._storage, ae = ee === "treemapRootToNode" && Q && ne ? {
          rootNodeGroup: ne.nodeGroup[Q.node.getRawIndex()],
          direction: W.direction
        } : null, ie = this._giveContainerGroup(te), se = G.get("animation"), oe = this._doRender(ie, G, ae);
        se && !re && (!ee || ee === "treemapZoomToNode" || ee === "treemapRootToNode") ? this._doAnimation(ie, oe, G, ae) : oe.renderFinally(), this._resetController(K), this._renderBreadcrumb(G, K, Q);
      }
    }, C.prototype._giveContainerGroup = function(G) {
      var U = this._containerGroup;
      return U || (U = this._containerGroup = new Group$2(), this._initEvents(U), this.group.add(U)), U.x = G.x, U.y = G.y, U;
    }, C.prototype._doRender = function(G, U, K) {
      var W = U.getData().tree, Z = this._oldTree, X = createStorage(), Q = createStorage(), ee = this._storage, te = [];
      function re(oe, le, ue, ce) {
        return renderNode(U, Q, ee, K, X, te, oe, le, ue, ce);
      }
      ae(W.root ? [W.root] : [], Z && Z.root ? [Z.root] : [], G, W === Z || !Z, 0);
      var ne = ie(ee);
      return this._oldTree = W, this._storage = Q, {
        lastsForAnimation: X,
        willDeleteEls: ne,
        renderFinally: se
      };
      function ae(oe, le, ue, ce, de) {
        ce ? (le = oe, each$f(oe, function(ve, pe) {
          !ve.isRemoved() && fe(pe, pe);
        })) : new DataDiffer$1(le, oe, ge, ge).add(fe).update(fe).remove(curry$1(fe, null)).execute();
        function ge(ve) {
          return ve.getId();
        }
        function fe(ve, pe) {
          var he = ve != null ? oe[ve] : null, me = pe != null ? le[pe] : null, ye = re(he, me, ue, de);
          ye && ae(he && he.viewChildren || [], me && me.viewChildren || [], ye, ce, de + 1);
        }
      }
      function ie(oe) {
        var le = createStorage();
        return oe && each$f(oe, function(ue, ce) {
          var de = le[ce];
          each$f(ue, function(ge) {
            ge && (de.push(ge), inner$d(ge).willDelete = !0);
          });
        }), le;
      }
      function se() {
        each$f(ne, function(oe) {
          each$f(oe, function(le) {
            le.parent && le.parent.remove(le);
          });
        }), each$f(te, function(oe) {
          oe.invisible = !0, oe.dirty();
        });
      }
    }, C.prototype._doAnimation = function(G, U, K, W) {
      var Z = K.get("animationDurationUpdate"), X = K.get("animationEasing"), Q = (isFunction(Z) ? 0 : Z) || 0, ee = (isFunction(X) ? null : X) || "cubicOut", te = createWrap();
      each$f(U.willDeleteEls, function(re, ne) {
        each$f(re, function(ae, ie) {
          if (!ae.invisible) {
            var se = ae.parent, oe, le = inner$d(se);
            if (W && W.direction === "drillDown")
              oe = se === W.rootNodeGroup ? {
                shape: {
                  x: 0,
                  y: 0,
                  width: le.nodeWidth,
                  height: le.nodeHeight
                },
                style: {
                  opacity: 0
                }
              } : {
                style: {
                  opacity: 0
                }
              };
            else {
              var ue = 0, ce = 0;
              le.willDelete || (ue = le.nodeWidth / 2, ce = le.nodeHeight / 2), oe = ne === "nodeGroup" ? {
                x: ue,
                y: ce,
                style: {
                  opacity: 0
                }
              } : {
                shape: {
                  x: ue,
                  y: ce,
                  width: 0,
                  height: 0
                },
                style: {
                  opacity: 0
                }
              };
            }
            oe && te.add(ae, oe, Q, 0, ee);
          }
        });
      }), each$f(this._storage, function(re, ne) {
        each$f(re, function(ae, ie) {
          var se = U.lastsForAnimation[ne][ie], oe = {};
          se && (ae instanceof Group$4 ? se.oldX != null && (oe.x = ae.x, oe.y = ae.y, ae.x = se.oldX, ae.y = se.oldY) : (se.oldShape && (oe.shape = extend({}, ae.shape), ae.setShape(se.oldShape)), se.fadein ? (ae.setStyle("opacity", 0), oe.style = {
            opacity: 1
          }) : ae.style.opacity !== 1 && (oe.style = {
            opacity: 1
          })), te.add(ae, oe, Q, 0, ee));
        });
      }, this), this._state = "animating", te.finished(bind$1(function() {
        this._state = "ready", U.renderFinally();
      }, this)).start();
    }, C.prototype._resetController = function(G) {
      var U = this._controller;
      U || (U = this._controller = new RoamController$1(G.getZr()), U.enable(this.seriesModel.get("roam")), U.on("pan", bind$1(this._onPan, this)), U.on("zoom", bind$1(this._onZoom, this)));
      var K = new BoundingRect$1(0, 0, G.getWidth(), G.getHeight());
      U.setPointerChecker(function(W, Z, X) {
        return K.contain(Z, X);
      });
    }, C.prototype._clearController = function() {
      var G = this._controller;
      G && (G.dispose(), G = null);
    }, C.prototype._onPan = function(G) {
      if (this._state !== "animating" && (Math.abs(G.dx) > DRAG_THRESHOLD || Math.abs(G.dy) > DRAG_THRESHOLD)) {
        var U = this.seriesModel.getData().tree.root;
        if (!U)
          return;
        var K = U.getLayout();
        if (!K)
          return;
        this.api.dispatchAction({
          type: "treemapMove",
          from: this.uid,
          seriesId: this.seriesModel.id,
          rootRect: {
            x: K.x + G.dx,
            y: K.y + G.dy,
            width: K.width,
            height: K.height
          }
        });
      }
    }, C.prototype._onZoom = function(G) {
      var U = G.originX, K = G.originY;
      if (this._state !== "animating") {
        var W = this.seriesModel.getData().tree.root;
        if (!W)
          return;
        var Z = W.getLayout();
        if (!Z)
          return;
        var X = new BoundingRect$1(Z.x, Z.y, Z.width, Z.height), Q = this.seriesModel.layoutInfo;
        U -= Q.x, K -= Q.y;
        var ee = create$1();
        translate(ee, ee, [-U, -K]), scale$1(ee, ee, [G.scale, G.scale]), translate(ee, ee, [U, K]), X.applyTransform(ee), this.api.dispatchAction({
          type: "treemapRender",
          from: this.uid,
          seriesId: this.seriesModel.id,
          rootRect: {
            x: X.x,
            y: X.y,
            width: X.width,
            height: X.height
          }
        });
      }
    }, C.prototype._initEvents = function(G) {
      var U = this;
      G.on("click", function(K) {
        if (U._state === "ready") {
          var W = U.seriesModel.get("nodeClick", !0);
          if (W) {
            var Z = U.findTarget(K.offsetX, K.offsetY);
            if (Z) {
              var X = Z.node;
              if (X.getLayout().isLeafRoot)
                U._rootToNode(Z);
              else if (W === "zoomToNode")
                U._zoomToNode(Z);
              else if (W === "link") {
                var Q = X.hostTree.data.getItemModel(X.dataIndex), ee = Q.get("link", !0), te = Q.get("target", !0) || "blank";
                ee && windowOpen(ee, te);
              }
            }
          }
        }
      }, this);
    }, C.prototype._renderBreadcrumb = function(G, U, K) {
      var W = this;
      K || (K = G.get("leafDepth", !0) != null ? {
        node: G.getViewRoot()
      } : this.findTarget(U.getWidth() / 2, U.getHeight() / 2), K || (K = {
        node: G.getData().tree.root
      })), (this._breadcrumb || (this._breadcrumb = new Breadcrumb$1(this.group))).render(G, U, K.node, function(Z) {
        W._state !== "animating" && (aboveViewRoot(G.getViewRoot(), Z) ? W._rootToNode({
          node: Z
        }) : W._zoomToNode({
          node: Z
        }));
      });
    }, C.prototype.remove = function() {
      this._clearController(), this._containerGroup && this._containerGroup.removeAll(), this._storage = createStorage(), this._state = "ready", this._breadcrumb && this._breadcrumb.remove();
    }, C.prototype.dispose = function() {
      this._clearController();
    }, C.prototype._zoomToNode = function(G) {
      this.api.dispatchAction({
        type: "treemapZoomToNode",
        from: this.uid,
        seriesId: this.seriesModel.id,
        targetNode: G.node
      });
    }, C.prototype._rootToNode = function(G) {
      this.api.dispatchAction({
        type: "treemapRootToNode",
        from: this.uid,
        seriesId: this.seriesModel.id,
        targetNode: G.node
      });
    }, C.prototype.findTarget = function(G, U) {
      var K, W = this.seriesModel.getViewRoot();
      return W.eachNode({
        attr: "viewChildren",
        order: "preorder"
      }, function(Z) {
        var X = this._storage.background[Z.getRawIndex()];
        if (X) {
          var Q = X.transformCoordToLocal(G, U), ee = X.shape;
          if (ee.x <= Q[0] && Q[0] <= ee.x + ee.width && ee.y <= Q[1] && Q[1] <= ee.y + ee.height)
            K = {
              node: Z,
              offsetX: Q[0],
              offsetY: Q[1]
            };
          else
            return !1;
        }
      }, this), K;
    }, C.type = "treemap", C;
  }(ChartView$1)
);
function createStorage() {
  return {
    nodeGroup: [],
    background: [],
    content: []
  };
}
function renderNode(H, C, G, U, K, W, Z, X, Q, ee) {
  if (!Z)
    return;
  var te = Z.getLayout(), re = H.getData(), ne = Z.getModel();
  if (re.setItemGraphicEl(Z.dataIndex, null), !te || !te.isInView)
    return;
  var ae = te.width, ie = te.height, se = te.borderWidth, oe = te.invisible, le = Z.getRawIndex(), ue = X && X.getRawIndex(), ce = Z.viewChildren, de = te.upperHeight, ge = ce && ce.length, fe = ne.getModel("itemStyle"), ve = ne.getModel(["emphasis", "itemStyle"]), pe = ne.getModel(["blur", "itemStyle"]), he = ne.getModel(["select", "itemStyle"]), me = fe.get("borderRadius") || 0, ye = we("nodeGroup", Group$2);
  if (!ye)
    return;
  if (Q.add(ye), ye.x = te.x || 0, ye.y = te.y || 0, ye.markRedraw(), inner$d(ye).nodeWidth = ae, inner$d(ye).nodeHeight = ie, te.isAboveViewRoot)
    return ye;
  var Ce = we("background", Rect$1, ee, Z2_BG);
  Ce && Te(ye, Ce, ge && te.upperLabelHeight);
  var Ie = ne.getModel("emphasis"), be = Ie.get("focus"), Se = Ie.get("blurScope"), Ae = Ie.get("disabled"), _e = be === "ancestor" ? Z.getAncestorsIndices() : be === "descendant" ? Z.getDescendantIndices() : be;
  if (ge)
    isHighDownDispatcher(ye) && setAsHighDownDispatcher(ye, !1), Ce && (setAsHighDownDispatcher(Ce, !Ae), re.setItemGraphicEl(Z.dataIndex, Ce), enableHoverFocus(Ce, _e, Se));
  else {
    var xe = we("content", Rect$1, ee, Z2_CONTENT);
    xe && Pe(ye, xe), Ce.disableMorphing = !0, Ce && isHighDownDispatcher(Ce) && setAsHighDownDispatcher(Ce, !1), setAsHighDownDispatcher(ye, !Ae), re.setItemGraphicEl(Z.dataIndex, ye), enableHoverFocus(ye, _e, Se);
  }
  return ye;
  function Te(ke, ze, He) {
    var We = getECData(ze);
    if (We.dataIndex = Z.dataIndex, We.seriesIndex = H.seriesIndex, ze.setShape({
      x: 0,
      y: 0,
      width: ae,
      height: ie,
      r: me
    }), oe)
      $e(ze);
    else {
      ze.invisible = !1;
      var Re = Z.getVisual("style"), Le = Re.stroke, De = getItemStyleNormal(fe);
      De.fill = Le;
      var Ue = getStateItemStyle(ve);
      Ue.fill = ve.get("borderColor");
      var st = getStateItemStyle(pe);
      st.fill = pe.get("borderColor");
      var ot = getStateItemStyle(he);
      if (ot.fill = he.get("borderColor"), He) {
        var ct = ae - 2 * se;
        Me(
          // PENDING: convert ZRColor to ColorString for text.
          ze,
          Le,
          Re.opacity,
          {
            x: se,
            y: 0,
            width: ct,
            height: de
          }
        );
      } else
        ze.removeTextContent();
      ze.setStyle(De), ze.ensureState("emphasis").style = Ue, ze.ensureState("blur").style = st, ze.ensureState("select").style = ot, setDefaultStateProxy(ze);
    }
    ke.add(ze);
  }
  function Pe(ke, ze) {
    var He = getECData(ze);
    He.dataIndex = Z.dataIndex, He.seriesIndex = H.seriesIndex;
    var We = Math.max(ae - 2 * se, 0), Re = Math.max(ie - 2 * se, 0);
    if (ze.culling = !0, ze.setShape({
      x: se,
      y: se,
      width: We,
      height: Re,
      r: me
    }), oe)
      $e(ze);
    else {
      ze.invisible = !1;
      var Le = Z.getVisual("style"), De = Le.fill, Ue = getItemStyleNormal(fe);
      Ue.fill = De, Ue.decal = Le.decal;
      var st = getStateItemStyle(ve), ot = getStateItemStyle(pe), ct = getStateItemStyle(he);
      Me(ze, De, Le.opacity, null), ze.setStyle(Ue), ze.ensureState("emphasis").style = st, ze.ensureState("blur").style = ot, ze.ensureState("select").style = ct, setDefaultStateProxy(ze);
    }
    ke.add(ze);
  }
  function $e(ke) {
    !ke.invisible && W.push(ke);
  }
  function Me(ke, ze, He, We) {
    var Re = ne.getModel(We ? PATH_UPPERLABEL_NORMAL : PATH_LABEL_NOAMAL), Le = convertOptionIdName(ne.get("name"), null), De = Re.getShallow("show");
    setLabelStyle(ke, getLabelStatesModels(ne, We ? PATH_UPPERLABEL_NORMAL : PATH_LABEL_NOAMAL), {
      defaultText: De ? Le : null,
      inheritColor: ze,
      defaultOpacity: He,
      labelFetcher: H,
      labelDataIndex: Z.dataIndex
    });
    var Ue = ke.getTextContent();
    if (Ue) {
      var st = Ue.style, ot = normalizeCssArray$1(st.padding || 0);
      We && (ke.setTextConfig({
        layoutRect: We
      }), Ue.disableLabelLayout = !0), Ue.beforeUpdate = function() {
        var vt = Math.max((We ? We.width : ke.shape.width) - ot[1] - ot[3], 0), ut = Math.max((We ? We.height : ke.shape.height) - ot[0] - ot[2], 0);
        (st.width !== vt || st.height !== ut) && Ue.setStyle({
          width: vt,
          height: ut
        });
      }, st.truncateMinChar = 2, st.lineOverflow = "truncate", Ee(st, We, te);
      var ct = Ue.getState("emphasis");
      Ee(ct ? ct.style : null, We, te);
    }
  }
  function Ee(ke, ze, He) {
    var We = ke ? ke.text : null;
    if (!ze && He.isLeafRoot && We != null) {
      var Re = H.get("drillDownIcon", !0);
      ke.text = Re ? Re + " " + We : We;
    }
  }
  function we(ke, ze, He, We) {
    var Re = ue != null && G[ke][ue], Le = K[ke];
    return Re ? (G[ke][ue] = null, Oe(Le, Re)) : oe || (Re = new ze(), Re instanceof Displayable$1 && (Re.z2 = calculateZ2(He, We)), Ne(Le, Re)), C[ke][le] = Re;
  }
  function Oe(ke, ze) {
    var He = ke[le] = {};
    ze instanceof Group$2 ? (He.oldX = ze.x, He.oldY = ze.y) : He.oldShape = extend({}, ze.shape);
  }
  function Ne(ke, ze) {
    var He = ke[le] = {}, We = Z.parentNode, Re = ze instanceof Group$4;
    if (We && (!U || U.direction === "drillDown")) {
      var Le = 0, De = 0, Ue = K.background[We.getRawIndex()];
      !U && Ue && Ue.oldShape && (Le = Ue.oldShape.width, De = Ue.oldShape.height), Re ? (He.oldX = 0, He.oldY = De) : He.oldShape = {
        x: Le,
        y: De,
        width: 0,
        height: 0
      };
    }
    He.fadein = !Re;
  }
}
function calculateZ2(H, C) {
  return H * Z2_BASE + C;
}
const TreemapView$1 = TreemapView;
var each$c = each$f, isObject = isObject$3, CATEGORY_DEFAULT_VISUAL_INDEX = -1, VisualMapping = (
  /** @class */
  function() {
    function H(C) {
      var G = C.mappingMethod, U = C.type, K = this.option = clone$4(C);
      this.type = U, this.mappingMethod = G, this._normalizeData = normalizers[G];
      var W = H.visualHandlers[U];
      this.applyVisual = W.applyVisual, this.getColorMapper = W.getColorMapper, this._normalizedToVisual = W._normalizedToVisual[G], G === "piecewise" ? (normalizeVisualRange(K), preprocessForPiecewise(K)) : G === "category" ? K.categories ? preprocessForSpecifiedCategory(K) : normalizeVisualRange(K, !0) : (assert(G !== "linear" || K.dataExtent), normalizeVisualRange(K));
    }
    return H.prototype.mapValueToVisual = function(C) {
      var G = this._normalizeData(C);
      return this._normalizedToVisual(G, C);
    }, H.prototype.getNormalizer = function() {
      return bind$1(this._normalizeData, this);
    }, H.listVisualTypes = function() {
      return keys(H.visualHandlers);
    }, H.isValidType = function(C) {
      return H.visualHandlers.hasOwnProperty(C);
    }, H.eachVisual = function(C, G, U) {
      isObject$3(C) ? each$f(C, G, U) : G.call(U, C);
    }, H.mapVisual = function(C, G, U) {
      var K, W = isArray$1(C) ? [] : isObject$3(C) ? {} : (K = !0, null);
      return H.eachVisual(C, function(Z, X) {
        var Q = G.call(U, Z, X);
        K ? W = Q : W[X] = Q;
      }), W;
    }, H.retrieveVisuals = function(C) {
      var G = {}, U;
      return C && each$c(H.visualHandlers, function(K, W) {
        C.hasOwnProperty(W) && (G[W] = C[W], U = !0);
      }), U ? G : null;
    }, H.prepareVisualTypes = function(C) {
      if (isArray$1(C))
        C = C.slice();
      else if (isObject(C)) {
        var G = [];
        each$c(C, function(U, K) {
          G.push(K);
        }), C = G;
      } else
        return [];
      return C.sort(function(U, K) {
        return K === "color" && U !== "color" && U.indexOf("color") === 0 ? 1 : -1;
      }), C;
    }, H.dependsOn = function(C, G) {
      return G === "color" ? !!(C && C.indexOf(G) === 0) : C === G;
    }, H.findPieceIndex = function(C, G, U) {
      for (var K, W = 1 / 0, Z = 0, X = G.length; Z < X; Z++) {
        var Q = G[Z].value;
        if (Q != null) {
          if (Q === C || isString(Q) && Q === C + "")
            return Z;
          U && ne(Q, Z);
        }
      }
      for (var Z = 0, X = G.length; Z < X; Z++) {
        var ee = G[Z], te = ee.interval, re = ee.close;
        if (te) {
          if (te[0] === -1 / 0) {
            if (littleThan(re[1], C, te[1]))
              return Z;
          } else if (te[1] === 1 / 0) {
            if (littleThan(re[0], te[0], C))
              return Z;
          } else if (littleThan(re[0], te[0], C) && littleThan(re[1], C, te[1]))
            return Z;
          U && ne(te[0], Z), U && ne(te[1], Z);
        }
      }
      if (U)
        return C === 1 / 0 ? G.length - 1 : C === -1 / 0 ? 0 : K;
      function ne(ae, ie) {
        var se = Math.abs(ae - C);
        se < W && (W = se, K = ie);
      }
    }, H.visualHandlers = {
      color: {
        applyVisual: makeApplyVisual("color"),
        getColorMapper: function() {
          var C = this.option;
          return bind$1(C.mappingMethod === "category" ? function(G, U) {
            return !U && (G = this._normalizeData(G)), doMapCategory.call(this, G);
          } : function(G, U, K) {
            var W = !!K;
            return !U && (G = this._normalizeData(G)), K = fastLerp(G, C.parsedVisual, K), W ? K : stringify(K, "rgba");
          }, this);
        },
        _normalizedToVisual: {
          linear: function(C) {
            return stringify(fastLerp(C, this.option.parsedVisual), "rgba");
          },
          category: doMapCategory,
          piecewise: function(C, G) {
            var U = getSpecifiedVisual.call(this, G);
            return U == null && (U = stringify(fastLerp(C, this.option.parsedVisual), "rgba")), U;
          },
          fixed: doMapFixed
        }
      },
      colorHue: makePartialColorVisualHandler(function(C, G) {
        return modifyHSL(C, G);
      }),
      colorSaturation: makePartialColorVisualHandler(function(C, G) {
        return modifyHSL(C, null, G);
      }),
      colorLightness: makePartialColorVisualHandler(function(C, G) {
        return modifyHSL(C, null, null, G);
      }),
      colorAlpha: makePartialColorVisualHandler(function(C, G) {
        return modifyAlpha(C, G);
      }),
      decal: {
        applyVisual: makeApplyVisual("decal"),
        _normalizedToVisual: {
          linear: null,
          category: doMapCategory,
          piecewise: null,
          fixed: null
        }
      },
      opacity: {
        applyVisual: makeApplyVisual("opacity"),
        _normalizedToVisual: createNormalizedToNumericVisual([0, 1])
      },
      liftZ: {
        applyVisual: makeApplyVisual("liftZ"),
        _normalizedToVisual: {
          linear: doMapFixed,
          category: doMapFixed,
          piecewise: doMapFixed,
          fixed: doMapFixed
        }
      },
      symbol: {
        applyVisual: function(C, G, U) {
          var K = this.mapValueToVisual(C);
          U("symbol", K);
        },
        _normalizedToVisual: {
          linear: doMapToArray,
          category: doMapCategory,
          piecewise: function(C, G) {
            var U = getSpecifiedVisual.call(this, G);
            return U == null && (U = doMapToArray.call(this, C)), U;
          },
          fixed: doMapFixed
        }
      },
      symbolSize: {
        applyVisual: makeApplyVisual("symbolSize"),
        _normalizedToVisual: createNormalizedToNumericVisual([0, 1])
      }
    }, H;
  }()
);
function preprocessForPiecewise(H) {
  var C = H.pieceList;
  H.hasSpecialVisual = !1, each$f(C, function(G, U) {
    G.originIndex = U, G.visual != null && (H.hasSpecialVisual = !0);
  });
}
function preprocessForSpecifiedCategory(H) {
  var C = H.categories, G = H.categoryMap = {}, U = H.visual;
  if (each$c(C, function(Z, X) {
    G[Z] = X;
  }), !isArray$1(U)) {
    var K = [];
    isObject$3(U) ? each$c(U, function(Z, X) {
      var Q = G[X];
      K[Q ?? CATEGORY_DEFAULT_VISUAL_INDEX] = Z;
    }) : K[CATEGORY_DEFAULT_VISUAL_INDEX] = U, U = setVisualToOption(H, K);
  }
  for (var W = C.length - 1; W >= 0; W--)
    U[W] == null && (delete G[C[W]], C.pop());
}
function normalizeVisualRange(H, C) {
  var G = H.visual, U = [];
  isObject$3(G) ? each$c(G, function(W) {
    U.push(W);
  }) : G != null && U.push(G);
  var K = {
    color: 1,
    symbol: 1
  };
  !C && U.length === 1 && !K.hasOwnProperty(H.type) && (U[1] = U[0]), setVisualToOption(H, U);
}
function makePartialColorVisualHandler(H) {
  return {
    applyVisual: function(C, G, U) {
      var K = this.mapValueToVisual(C);
      U("color", H(G("color"), K));
    },
    _normalizedToVisual: createNormalizedToNumericVisual([0, 1])
  };
}
function doMapToArray(H) {
  var C = this.option.visual;
  return C[Math.round(linearMap$2(H, [0, 1], [0, C.length - 1], !0))] || {};
}
function makeApplyVisual(H) {
  return function(C, G, U) {
    U(H, this.mapValueToVisual(C));
  };
}
function doMapCategory(H) {
  var C = this.option.visual;
  return C[this.option.loop && H !== CATEGORY_DEFAULT_VISUAL_INDEX ? H % C.length : H];
}
function doMapFixed() {
  return this.option.visual[0];
}
function createNormalizedToNumericVisual(H) {
  return {
    linear: function(C) {
      return linearMap$2(C, H, this.option.visual, !0);
    },
    category: doMapCategory,
    piecewise: function(C, G) {
      var U = getSpecifiedVisual.call(this, G);
      return U == null && (U = linearMap$2(C, H, this.option.visual, !0)), U;
    },
    fixed: doMapFixed
  };
}
function getSpecifiedVisual(H) {
  var C = this.option, G = C.pieceList;
  if (C.hasSpecialVisual) {
    var U = VisualMapping.findPieceIndex(H, G), K = G[U];
    if (K && K.visual)
      return K.visual[this.type];
  }
}
function setVisualToOption(H, C) {
  return H.visual = C, H.type === "color" && (H.parsedVisual = map$1(C, function(G) {
    var U = parse(G);
    return !U && process.env.NODE_ENV !== "production" && warn("'" + G + "' is an illegal color, fallback to '#000000'", !0), U || [0, 0, 0, 1];
  })), C;
}
var normalizers = {
  linear: function(H) {
    return linearMap$2(H, this.option.dataExtent, [0, 1], !0);
  },
  piecewise: function(H) {
    var C = this.option.pieceList, G = VisualMapping.findPieceIndex(H, C, !0);
    if (G != null)
      return linearMap$2(G, [0, C.length - 1], [0, 1], !0);
  },
  category: function(H) {
    var C = this.option.categories ? this.option.categoryMap[H] : H;
    return C ?? CATEGORY_DEFAULT_VISUAL_INDEX;
  },
  fixed: noop
};
function littleThan(H, C, G) {
  return H ? C <= G : C < G;
}
const VisualMapping$1 = VisualMapping;
var ITEM_STYLE_NORMAL = "itemStyle", inner$c = makeInner();
const treemapVisual = {
  seriesType: "treemap",
  reset: function(H) {
    var C = H.getData().tree, G = C.root;
    G.isRemoved() || travelTree(
      G,
      // Visual should calculate from tree root but not view root.
      {},
      H.getViewRoot().getAncestors(),
      H
    );
  }
};
function travelTree(H, C, G, U) {
  var K = H.getModel(), W = H.getLayout(), Z = H.hostTree.data;
  if (!(!W || W.invisible || !W.isInView)) {
    var X = K.getModel(ITEM_STYLE_NORMAL), Q = buildVisuals(X, C, U), ee = Z.ensureUniqueItemVisual(H.dataIndex, "style"), te = X.get("borderColor"), re = X.get("borderColorSaturation"), ne;
    re != null && (ne = calculateColor(Q), te = calculateBorderColor(re, ne)), ee.stroke = te;
    var ae = H.viewChildren;
    if (!ae || !ae.length)
      ne = calculateColor(Q), ee.fill = ne;
    else {
      var ie = buildVisualMapping(H, K, W, X, Q, ae);
      each$f(ae, function(se, oe) {
        if (se.depth >= G.length || se === G[se.depth]) {
          var le = mapVisual$1(K, Q, se, oe, ie, U);
          travelTree(se, le, G, U);
        }
      });
    }
  }
}
function buildVisuals(H, C, G) {
  var U = extend({}, C), K = G.designatedVisualItemStyle;
  return each$f(["color", "colorAlpha", "colorSaturation"], function(W) {
    K[W] = C[W];
    var Z = H.get(W);
    K[W] = null, Z != null && (U[W] = Z);
  }), U;
}
function calculateColor(H) {
  var C = getValueVisualDefine(H, "color");
  if (C) {
    var G = getValueVisualDefine(H, "colorAlpha"), U = getValueVisualDefine(H, "colorSaturation");
    return U && (C = modifyHSL(C, null, null, U)), G && (C = modifyAlpha(C, G)), C;
  }
}
function calculateBorderColor(H, C) {
  return C != null ? modifyHSL(C, null, null, H) : null;
}
function getValueVisualDefine(H, C) {
  var G = H[C];
  if (G != null && G !== "none")
    return G;
}
function buildVisualMapping(H, C, G, U, K, W) {
  if (!(!W || !W.length)) {
    var Z = getRangeVisual(C, "color") || K.color != null && K.color !== "none" && (getRangeVisual(C, "colorAlpha") || getRangeVisual(C, "colorSaturation"));
    if (Z) {
      var X = C.get("visualMin"), Q = C.get("visualMax"), ee = G.dataExtent.slice();
      X != null && X < ee[0] && (ee[0] = X), Q != null && Q > ee[1] && (ee[1] = Q);
      var te = C.get("colorMappingBy"), re = {
        type: Z.name,
        dataExtent: ee,
        visual: Z.range
      };
      re.type === "color" && (te === "index" || te === "id") ? (re.mappingMethod = "category", re.loop = !0) : re.mappingMethod = "linear";
      var ne = new VisualMapping$1(re);
      return inner$c(ne).drColorMappingBy = te, ne;
    }
  }
}
function getRangeVisual(H, C) {
  var G = H.get(C);
  return isArray$1(G) && G.length ? {
    name: C,
    range: G
  } : null;
}
function mapVisual$1(H, C, G, U, K, W) {
  var Z = extend({}, C);
  if (K) {
    var X = K.type, Q = X === "color" && inner$c(K).drColorMappingBy, ee = Q === "index" ? U : Q === "id" ? W.mapIdToIndex(G.getId()) : G.getValue(H.get("visualDimension"));
    Z[X] = K.mapValueToVisual(ee);
  }
  return Z;
}
var mathMax$3 = Math.max, mathMin$3 = Math.min, retrieveValue = retrieve, each$b = each$f, PATH_BORDER_WIDTH = ["itemStyle", "borderWidth"], PATH_GAP_WIDTH = ["itemStyle", "gapWidth"], PATH_UPPER_LABEL_SHOW = ["upperLabel", "show"], PATH_UPPER_LABEL_HEIGHT = ["upperLabel", "height"];
const treemapLayout = {
  seriesType: "treemap",
  reset: function(H, C, G, U) {
    var K = G.getWidth(), W = G.getHeight(), Z = H.option, X = getLayoutRect(H.getBoxLayoutParams(), {
      width: G.getWidth(),
      height: G.getHeight()
    }), Q = Z.size || [], ee = parsePercent(retrieveValue(X.width, Q[0]), K), te = parsePercent(retrieveValue(X.height, Q[1]), W), re = U && U.type, ne = ["treemapZoomToNode", "treemapRootToNode"], ae = retrieveTargetInfo(U, ne, H), ie = re === "treemapRender" || re === "treemapMove" ? U.rootRect : null, se = H.getViewRoot(), oe = getPathToRoot(se);
    if (re !== "treemapMove") {
      var le = re === "treemapZoomToNode" ? estimateRootSize(H, ae, se, ee, te) : ie ? [ie.width, ie.height] : [ee, te], ue = Z.sort;
      ue && ue !== "asc" && ue !== "desc" && (ue = "desc");
      var ce = {
        squareRatio: Z.squareRatio,
        sort: ue,
        leafDepth: Z.leafDepth
      };
      se.hostTree.clearLayouts();
      var de = {
        x: 0,
        y: 0,
        width: le[0],
        height: le[1],
        area: le[0] * le[1]
      };
      se.setLayout(de), squarify(se, ce, !1, 0), de = se.getLayout(), each$b(oe, function(fe, ve) {
        var pe = (oe[ve + 1] || se).getValue();
        fe.setLayout(extend({
          dataExtent: [pe, pe],
          borderWidth: 0,
          upperHeight: 0
        }, de));
      });
    }
    var ge = H.getData().tree.root;
    ge.setLayout(calculateRootPosition(X, ie, ae), !0), H.setLayoutInfo(X), prunning(
      ge,
      // Transform to base element coordinate system.
      new BoundingRect$1(-X.x, -X.y, K, W),
      oe,
      se,
      0
    );
  }
};
function squarify(H, C, G, U) {
  var K, W;
  if (!H.isRemoved()) {
    var Z = H.getLayout();
    K = Z.width, W = Z.height;
    var X = H.getModel(), Q = X.get(PATH_BORDER_WIDTH), ee = X.get(PATH_GAP_WIDTH) / 2, te = getUpperLabelHeight(X), re = Math.max(Q, te), ne = Q - ee, ae = re - ee;
    H.setLayout({
      borderWidth: Q,
      upperHeight: re,
      upperLabelHeight: te
    }, !0), K = mathMax$3(K - 2 * ne, 0), W = mathMax$3(W - ne - ae, 0);
    var ie = K * W, se = initChildren$1(H, X, ie, C, G, U);
    if (se.length) {
      var oe = {
        x: ne,
        y: ae,
        width: K,
        height: W
      }, le = mathMin$3(K, W), ue = 1 / 0, ce = [];
      ce.area = 0;
      for (var de = 0, ge = se.length; de < ge; ) {
        var fe = se[de];
        ce.push(fe), ce.area += fe.getLayout().area;
        var ve = worst(ce, le, C.squareRatio);
        ve <= ue ? (de++, ue = ve) : (ce.area -= ce.pop().getLayout().area, position(ce, le, oe, ee, !1), le = mathMin$3(oe.width, oe.height), ce.length = ce.area = 0, ue = 1 / 0);
      }
      if (ce.length && position(ce, le, oe, ee, !0), !G) {
        var pe = X.get("childrenVisibleMin");
        pe != null && ie < pe && (G = !0);
      }
      for (var de = 0, ge = se.length; de < ge; de++)
        squarify(se[de], C, G, U + 1);
    }
  }
}
function initChildren$1(H, C, G, U, K, W) {
  var Z = H.children || [], X = U.sort;
  X !== "asc" && X !== "desc" && (X = null);
  var Q = U.leafDepth != null && U.leafDepth <= W;
  if (K && !Q)
    return H.viewChildren = [];
  Z = filter(Z, function(ae) {
    return !ae.isRemoved();
  }), sort$1(Z, X);
  var ee = statistic(C, Z, X);
  if (ee.sum === 0)
    return H.viewChildren = [];
  if (ee.sum = filterByThreshold(C, G, ee.sum, X, Z), ee.sum === 0)
    return H.viewChildren = [];
  for (var te = 0, re = Z.length; te < re; te++) {
    var ne = Z[te].getValue() / ee.sum * G;
    Z[te].setLayout({
      area: ne
    });
  }
  return Q && (Z.length && H.setLayout({
    isLeafRoot: !0
  }, !0), Z.length = 0), H.viewChildren = Z, H.setLayout({
    dataExtent: ee.dataExtent
  }, !0), Z;
}
function filterByThreshold(H, C, G, U, K) {
  if (!U)
    return G;
  for (var W = H.get("visibleMin"), Z = K.length, X = Z, Q = Z - 1; Q >= 0; Q--) {
    var ee = K[U === "asc" ? Z - Q - 1 : Q].getValue();
    ee / G * C < W && (X = Q, G -= ee);
  }
  return U === "asc" ? K.splice(0, Z - X) : K.splice(X, Z - X), G;
}
function sort$1(H, C) {
  return C && H.sort(function(G, U) {
    var K = C === "asc" ? G.getValue() - U.getValue() : U.getValue() - G.getValue();
    return K === 0 ? C === "asc" ? G.dataIndex - U.dataIndex : U.dataIndex - G.dataIndex : K;
  }), H;
}
function statistic(H, C, G) {
  for (var U = 0, K = 0, W = C.length; K < W; K++)
    U += C[K].getValue();
  var Z = H.get("visualDimension"), X;
  return !C || !C.length ? X = [NaN, NaN] : Z === "value" && G ? (X = [C[C.length - 1].getValue(), C[0].getValue()], G === "asc" && X.reverse()) : (X = [1 / 0, -1 / 0], each$b(C, function(Q) {
    var ee = Q.getValue(Z);
    ee < X[0] && (X[0] = ee), ee > X[1] && (X[1] = ee);
  })), {
    sum: U,
    dataExtent: X
  };
}
function worst(H, C, G) {
  for (var U = 0, K = 1 / 0, W = 0, Z = void 0, X = H.length; W < X; W++)
    Z = H[W].getLayout().area, Z && (Z < K && (K = Z), Z > U && (U = Z));
  var Q = H.area * H.area, ee = C * C * G;
  return Q ? mathMax$3(ee * U / Q, Q / (ee * K)) : 1 / 0;
}
function position(H, C, G, U, K) {
  var W = C === G.width ? 0 : 1, Z = 1 - W, X = ["x", "y"], Q = ["width", "height"], ee = G[X[W]], te = C ? H.area / C : 0;
  (K || te > G[Q[Z]]) && (te = G[Q[Z]]);
  for (var re = 0, ne = H.length; re < ne; re++) {
    var ae = H[re], ie = {}, se = te ? ae.getLayout().area / te : 0, oe = ie[Q[Z]] = mathMax$3(te - 2 * U, 0), le = G[X[W]] + G[Q[W]] - ee, ue = re === ne - 1 || le < se ? le : se, ce = ie[Q[W]] = mathMax$3(ue - 2 * U, 0);
    ie[X[Z]] = G[X[Z]] + mathMin$3(U, oe / 2), ie[X[W]] = ee + mathMin$3(U, ce / 2), ee += ue, ae.setLayout(ie, !0);
  }
  G[X[Z]] += te, G[Q[Z]] -= te;
}
function estimateRootSize(H, C, G, U, K) {
  var W = (C || {}).node, Z = [U, K];
  if (!W || W === G)
    return Z;
  for (var X, Q = U * K, ee = Q * H.option.zoomToNodeRatio; X = W.parentNode; ) {
    for (var te = 0, re = X.children, ne = 0, ae = re.length; ne < ae; ne++)
      te += re[ne].getValue();
    var ie = W.getValue();
    if (ie === 0)
      return Z;
    ee *= te / ie;
    var se = X.getModel(), oe = se.get(PATH_BORDER_WIDTH), le = Math.max(oe, getUpperLabelHeight(se));
    ee += 4 * oe * oe + (3 * oe + le) * Math.pow(ee, 0.5), ee > MAX_SAFE_INTEGER && (ee = MAX_SAFE_INTEGER), W = X;
  }
  ee < Q && (ee = Q);
  var ue = Math.pow(ee / Q, 0.5);
  return [U * ue, K * ue];
}
function calculateRootPosition(H, C, G) {
  if (C)
    return {
      x: C.x,
      y: C.y
    };
  var U = {
    x: 0,
    y: 0
  };
  if (!G)
    return U;
  var K = G.node, W = K.getLayout();
  if (!W)
    return U;
  for (var Z = [W.width / 2, W.height / 2], X = K; X; ) {
    var Q = X.getLayout();
    Z[0] += Q.x, Z[1] += Q.y, X = X.parentNode;
  }
  return {
    x: H.width / 2 - Z[0],
    y: H.height / 2 - Z[1]
  };
}
function prunning(H, C, G, U, K) {
  var W = H.getLayout(), Z = G[K], X = Z && Z === H;
  if (!(Z && !X || K === G.length && H !== U)) {
    H.setLayout({
      // isInView means: viewRoot sub tree + viewAbovePath
      isInView: !0,
      // invisible only means: outside view clip so that the node can not
      // see but still layout for animation preparation but not render.
      invisible: !X && !C.intersect(W),
      isAboveViewRoot: X
    }, !0);
    var Q = new BoundingRect$1(C.x - W.x, C.y - W.y, C.width, C.height);
    each$b(H.viewChildren || [], function(ee) {
      prunning(ee, Q, G, U, K + 1);
    });
  }
}
function getUpperLabelHeight(H) {
  return H.get(PATH_UPPER_LABEL_SHOW) ? H.get(PATH_UPPER_LABEL_HEIGHT) : 0;
}
function install$G(H) {
  H.registerSeriesModel(TreemapSeriesModel$1), H.registerChartView(TreemapView$1), H.registerVisual(treemapVisual), H.registerLayout(treemapLayout), installTreemapAction(H);
}
function categoryFilter(H) {
  var C = H.findComponents({
    mainType: "legend"
  });
  !C || !C.length || H.eachSeriesByType("graph", function(G) {
    var U = G.getCategoriesData(), K = G.getGraph(), W = K.data, Z = U.mapArray(U.getName);
    W.filterSelf(function(X) {
      var Q = W.getItemModel(X), ee = Q.getShallow("category");
      if (ee != null) {
        isNumber(ee) && (ee = Z[ee]);
        for (var te = 0; te < C.length; te++)
          if (!C[te].isSelected(ee))
            return !1;
      }
      return !0;
    });
  });
}
function categoryVisual(H) {
  var C = {};
  H.eachSeriesByType("graph", function(G) {
    var U = G.getCategoriesData(), K = G.getData(), W = {};
    U.each(function(Z) {
      var X = U.getName(Z);
      W["ec-" + X] = Z;
      var Q = U.getItemModel(Z), ee = Q.getModel("itemStyle").getItemStyle();
      ee.fill || (ee.fill = G.getColorFromPalette(X, C)), U.setItemVisual(Z, "style", ee);
      for (var te = ["symbol", "symbolSize", "symbolKeepAspect"], re = 0; re < te.length; re++) {
        var ne = Q.getShallow(te[re], !0);
        ne != null && U.setItemVisual(Z, te[re], ne);
      }
    }), U.count() && K.each(function(Z) {
      var X = K.getItemModel(Z), Q = X.getShallow("category");
      if (Q != null) {
        isString(Q) && (Q = W["ec-" + Q]);
        var ee = U.getItemVisual(Q, "style"), te = K.ensureUniqueItemVisual(Z, "style");
        extend(te, ee);
        for (var re = ["symbol", "symbolSize", "symbolKeepAspect"], ne = 0; ne < re.length; ne++)
          K.setItemVisual(Z, re[ne], U.getItemVisual(Q, re[ne]));
      }
    });
  });
}
function normalize$1(H) {
  return H instanceof Array || (H = [H, H]), H;
}
function graphEdgeVisual(H) {
  H.eachSeriesByType("graph", function(C) {
    var G = C.getGraph(), U = C.getEdgeData(), K = normalize$1(C.get("edgeSymbol")), W = normalize$1(C.get("edgeSymbolSize"));
    U.setVisual("fromSymbol", K && K[0]), U.setVisual("toSymbol", K && K[1]), U.setVisual("fromSymbolSize", W && W[0]), U.setVisual("toSymbolSize", W && W[1]), U.setVisual("style", C.getModel("lineStyle").getLineStyle()), U.each(function(Z) {
      var X = U.getItemModel(Z), Q = G.getEdgeByIndex(Z), ee = normalize$1(X.getShallow("symbol", !0)), te = normalize$1(X.getShallow("symbolSize", !0)), re = X.getModel("lineStyle").getLineStyle(), ne = U.ensureUniqueItemVisual(Z, "style");
      switch (extend(ne, re), ne.stroke) {
        case "source": {
          var ae = Q.node1.getVisual("style");
          ne.stroke = ae && ae.fill;
          break;
        }
        case "target": {
          var ae = Q.node2.getVisual("style");
          ne.stroke = ae && ae.fill;
          break;
        }
      }
      ee[0] && Q.setVisual("fromSymbol", ee[0]), ee[1] && Q.setVisual("toSymbol", ee[1]), te[0] && Q.setVisual("fromSymbolSize", te[0]), te[1] && Q.setVisual("toSymbolSize", te[1]);
    });
  });
}
var KEY_DELIMITER = "-->", getAutoCurvenessParams = function(H) {
  return H.get("autoCurveness") || null;
}, createCurveness = function(H, C) {
  var G = getAutoCurvenessParams(H), U = 20, K = [];
  if (isNumber(G))
    U = G;
  else if (isArray$1(G)) {
    H.__curvenessList = G;
    return;
  }
  C > U && (U = C);
  var W = U % 2 ? U + 2 : U + 3;
  K = [];
  for (var Z = 0; Z < W; Z++)
    K.push((Z % 2 ? Z + 1 : Z) / 10 * (Z % 2 ? -1 : 1));
  H.__curvenessList = K;
}, getKeyOfEdges = function(H, C, G) {
  var U = [H.id, H.dataIndex].join("."), K = [C.id, C.dataIndex].join(".");
  return [G.uid, U, K].join(KEY_DELIMITER);
}, getOppositeKey = function(H) {
  var C = H.split(KEY_DELIMITER);
  return [C[0], C[2], C[1]].join(KEY_DELIMITER);
}, getEdgeFromMap = function(H, C) {
  var G = getKeyOfEdges(H.node1, H.node2, C);
  return C.__edgeMap[G];
}, getTotalLengthBetweenNodes = function(H, C) {
  var G = getEdgeMapLengthWithKey(getKeyOfEdges(H.node1, H.node2, C), C), U = getEdgeMapLengthWithKey(getKeyOfEdges(H.node2, H.node1, C), C);
  return G + U;
}, getEdgeMapLengthWithKey = function(H, C) {
  var G = C.__edgeMap;
  return G[H] ? G[H].length : 0;
};
function initCurvenessList(H) {
  getAutoCurvenessParams(H) && (H.__curvenessList = [], H.__edgeMap = {}, createCurveness(H));
}
function createEdgeMapForCurveness(H, C, G, U) {
  if (getAutoCurvenessParams(G)) {
    var K = getKeyOfEdges(H, C, G), W = G.__edgeMap, Z = W[getOppositeKey(K)];
    W[K] && !Z ? W[K].isForward = !0 : Z && W[K] && (Z.isForward = !0, W[K].isForward = !1), W[K] = W[K] || [], W[K].push(U);
  }
}
function getCurvenessForEdge(H, C, G, U) {
  var K = getAutoCurvenessParams(C), W = isArray$1(K);
  if (!K)
    return null;
  var Z = getEdgeFromMap(H, C);
  if (!Z)
    return null;
  for (var X = -1, Q = 0; Q < Z.length; Q++)
    if (Z[Q] === G) {
      X = Q;
      break;
    }
  var ee = getTotalLengthBetweenNodes(H, C);
  createCurveness(C, ee), H.lineStyle = H.lineStyle || {};
  var te = getKeyOfEdges(H.node1, H.node2, C), re = C.__curvenessList, ne = W || ee % 2 ? 0 : 1;
  if (Z.isForward)
    return re[ne + X];
  var ae = getOppositeKey(te), ie = getEdgeMapLengthWithKey(ae, C), se = re[X + ie + ne];
  return U ? W ? K && K[0] === 0 ? (ie + ne) % 2 ? se : -se : ((ie % 2 ? 0 : 1) + ne) % 2 ? se : -se : (ie + ne) % 2 ? se : -se : re[X + ie + ne];
}
function simpleLayout(H) {
  var C = H.coordinateSystem;
  if (!(C && C.type !== "view")) {
    var G = H.getGraph();
    G.eachNode(function(U) {
      var K = U.getModel();
      U.setLayout([+K.get("x"), +K.get("y")]);
    }), simpleLayoutEdge(G, H);
  }
}
function simpleLayoutEdge(H, C) {
  H.eachEdge(function(G, U) {
    var K = retrieve3(G.getModel().get(["lineStyle", "curveness"]), -getCurvenessForEdge(G, C, U, !0), 0), W = clone$3(G.node1.getLayout()), Z = clone$3(G.node2.getLayout()), X = [W, Z];
    +K && X.push([(W[0] + Z[0]) / 2 - (W[1] - Z[1]) * K, (W[1] + Z[1]) / 2 - (Z[0] - W[0]) * K]), G.setLayout(X);
  });
}
function graphSimpleLayout(H, C) {
  H.eachSeriesByType("graph", function(G) {
    var U = G.get("layout"), K = G.coordinateSystem;
    if (K && K.type !== "view") {
      var W = G.getData(), Z = [];
      each$f(K.dimensions, function(ne) {
        Z = Z.concat(W.mapDimensionsAll(ne));
      });
      for (var X = 0; X < W.count(); X++) {
        for (var Q = [], ee = !1, te = 0; te < Z.length; te++) {
          var re = W.get(Z[te], X);
          isNaN(re) || (ee = !0), Q.push(re);
        }
        ee ? W.setItemLayout(X, K.dataToPoint(Q)) : W.setItemLayout(X, [NaN, NaN]);
      }
      simpleLayoutEdge(W.graph, G);
    } else
      (!U || U === "none") && simpleLayout(G);
  });
}
function getNodeGlobalScale(H) {
  var C = H.coordinateSystem;
  if (C.type !== "view")
    return 1;
  var G = H.option.nodeScaleRatio, U = C.scaleX, K = C.getZoom(), W = (K - 1) * G + 1;
  return W / U;
}
function getSymbolSize(H) {
  var C = H.getVisual("symbolSize");
  return C instanceof Array && (C = (C[0] + C[1]) / 2), +C;
}
var PI$2 = Math.PI, _symbolRadiansHalf = [];
function circularLayout(H, C, G, U) {
  var K = H.coordinateSystem;
  if (!(K && K.type !== "view")) {
    var W = K.getBoundingRect(), Z = H.getData(), X = Z.graph, Q = W.width / 2 + W.x, ee = W.height / 2 + W.y, te = Math.min(W.width, W.height) / 2, re = Z.count();
    if (Z.setLayout({
      cx: Q,
      cy: ee
    }), !!re) {
      if (G) {
        var ne = K.pointToData(U), ae = ne[0], ie = ne[1], se = [ae - Q, ie - ee];
        normalize$3(se, se), scale$2(se, se, te), G.setLayout([Q + se[0], ee + se[1]], !0);
        var oe = H.get(["circular", "rotateLabel"]);
        rotateNodeLabel(G, oe, Q, ee);
      }
      _layoutNodesBasedOn[C](H, X, Z, te, Q, ee, re), X.eachEdge(function(le, ue) {
        var ce = retrieve3(le.getModel().get(["lineStyle", "curveness"]), getCurvenessForEdge(le, H, ue), 0), de = clone$3(le.node1.getLayout()), ge = clone$3(le.node2.getLayout()), fe, ve = (de[0] + ge[0]) / 2, pe = (de[1] + ge[1]) / 2;
        +ce && (ce *= 3, fe = [Q * ce + ve * (1 - ce), ee * ce + pe * (1 - ce)]), le.setLayout([de, ge, fe]);
      });
    }
  }
}
var _layoutNodesBasedOn = {
  value: function(H, C, G, U, K, W, Z) {
    var X = 0, Q = G.getSum("value"), ee = Math.PI * 2 / (Q || Z);
    C.eachNode(function(te) {
      var re = te.getValue("value"), ne = ee * (Q ? re : 1) / 2;
      X += ne, te.setLayout([U * Math.cos(X) + K, U * Math.sin(X) + W]), X += ne;
    });
  },
  symbolSize: function(H, C, G, U, K, W, Z) {
    var X = 0;
    _symbolRadiansHalf.length = Z;
    var Q = getNodeGlobalScale(H);
    C.eachNode(function(re) {
      var ne = getSymbolSize(re);
      isNaN(ne) && (ne = 2), ne < 0 && (ne = 0), ne *= Q;
      var ae = Math.asin(ne / 2 / U);
      isNaN(ae) && (ae = PI$2 / 2), _symbolRadiansHalf[re.dataIndex] = ae, X += ae * 2;
    });
    var ee = (2 * PI$2 - X) / Z / 2, te = 0;
    C.eachNode(function(re) {
      var ne = ee + _symbolRadiansHalf[re.dataIndex];
      te += ne, (!re.getLayout() || !re.getLayout().fixed) && re.setLayout([U * Math.cos(te) + K, U * Math.sin(te) + W]), te += ne;
    });
  }
};
function rotateNodeLabel(H, C, G, U) {
  var K = H.getGraphicEl();
  if (K) {
    var W = H.getModel(), Z = W.get(["label", "rotate"]) || 0, X = K.getSymbolPath();
    if (C) {
      var Q = H.getLayout(), ee = Math.atan2(Q[1] - U, Q[0] - G);
      ee < 0 && (ee = Math.PI * 2 + ee);
      var te = Q[0] < G;
      te && (ee = ee - Math.PI);
      var re = te ? "left" : "right";
      X.setTextConfig({
        rotation: -ee,
        position: re,
        origin: "center"
      });
      var ne = X.ensureState("emphasis");
      extend(ne.textConfig || (ne.textConfig = {}), {
        position: re
      });
    } else
      X.setTextConfig({
        rotation: Z *= Math.PI / 180
      });
  }
}
function graphCircularLayout(H) {
  H.eachSeriesByType("graph", function(C) {
    C.get("layout") === "circular" && circularLayout(C, "symbolSize");
  });
}
var scaleAndAdd = scaleAndAdd$1;
function forceLayout(H, C, G) {
  for (var U = H, K = C, W = G.rect, Z = W.width, X = W.height, Q = [W.x + Z / 2, W.y + X / 2], ee = G.gravity == null ? 0.1 : G.gravity, te = 0; te < U.length; te++) {
    var re = U[te];
    re.p || (re.p = create$2(Z * (Math.random() - 0.5) + Q[0], X * (Math.random() - 0.5) + Q[1])), re.pp = clone$3(re.p), re.edges = null;
  }
  var ne = G.friction == null ? 0.6 : G.friction, ae = ne, ie, se;
  return {
    warmUp: function() {
      ae = ne * 0.8;
    },
    setFixed: function(oe) {
      U[oe].fixed = !0;
    },
    setUnfixed: function(oe) {
      U[oe].fixed = !1;
    },
    /**
     * Before step hook
     */
    beforeStep: function(oe) {
      ie = oe;
    },
    /**
     * After step hook
     */
    afterStep: function(oe) {
      se = oe;
    },
    /**
     * Some formulas were originally copied from "d3.js"
     * https://github.com/d3/d3/blob/b516d77fb8566b576088e73410437494717ada26/src/layout/force.js
     * with some modifications made for this project.
     * See the license statement at the head of this file.
     */
    step: function(oe) {
      ie && ie(U, K);
      for (var le = [], ue = U.length, ce = 0; ce < K.length; ce++) {
        var de = K[ce];
        if (!de.ignoreForceLayout) {
          var ge = de.n1, fe = de.n2;
          sub(le, fe.p, ge.p);
          var ve = len(le) - de.d, pe = fe.w / (ge.w + fe.w);
          isNaN(pe) && (pe = 0), normalize$3(le, le), !ge.fixed && scaleAndAdd(ge.p, ge.p, le, pe * ve * ae), !fe.fixed && scaleAndAdd(fe.p, fe.p, le, -(1 - pe) * ve * ae);
        }
      }
      for (var ce = 0; ce < ue; ce++) {
        var he = U[ce];
        he.fixed || (sub(le, Q, he.p), scaleAndAdd(he.p, he.p, le, ee * ae));
      }
      for (var ce = 0; ce < ue; ce++)
        for (var ge = U[ce], me = ce + 1; me < ue; me++) {
          var fe = U[me];
          sub(le, fe.p, ge.p);
          var ve = len(le);
          ve === 0 && (set$1(le, Math.random() - 0.5, Math.random() - 0.5), ve = 1);
          var ye = (ge.rep + fe.rep) / ve / ve;
          !ge.fixed && scaleAndAdd(ge.pp, ge.pp, le, ye), !fe.fixed && scaleAndAdd(fe.pp, fe.pp, le, -ye);
        }
      for (var Ce = [], ce = 0; ce < ue; ce++) {
        var he = U[ce];
        he.fixed || (sub(Ce, he.p, he.pp), scaleAndAdd(he.p, he.p, Ce, ae), copy$1(he.pp, he.p));
      }
      ae = ae * 0.992;
      var Ie = ae < 0.01;
      se && se(U, K, Ie), oe && oe(Ie);
    }
  };
}
function graphForceLayout(H) {
  H.eachSeriesByType("graph", function(C) {
    var G = C.coordinateSystem;
    if (!(G && G.type !== "view"))
      if (C.get("layout") === "force") {
        var U = C.preservedPoints || {}, K = C.getGraph(), W = K.data, Z = K.edgeData, X = C.getModel("force"), Q = X.get("initLayout");
        C.preservedPoints ? W.each(function(ce) {
          var de = W.getId(ce);
          W.setItemLayout(ce, U[de] || [NaN, NaN]);
        }) : !Q || Q === "none" ? simpleLayout(C) : Q === "circular" && circularLayout(C, "value");
        var ee = W.getDataExtent("value"), te = Z.getDataExtent("value"), re = X.get("repulsion"), ne = X.get("edgeLength"), ae = isArray$1(re) ? re : [re, re], ie = isArray$1(ne) ? ne : [ne, ne];
        ie = [ie[1], ie[0]];
        var se = W.mapArray("value", function(ce, de) {
          var ge = W.getItemLayout(de), fe = linearMap$2(ce, ee, ae);
          return isNaN(fe) && (fe = (ae[0] + ae[1]) / 2), {
            w: fe,
            rep: fe,
            fixed: W.getItemModel(de).get("fixed"),
            p: !ge || isNaN(ge[0]) || isNaN(ge[1]) ? null : ge
          };
        }), oe = Z.mapArray("value", function(ce, de) {
          var ge = K.getEdgeByIndex(de), fe = linearMap$2(ce, te, ie);
          isNaN(fe) && (fe = (ie[0] + ie[1]) / 2);
          var ve = ge.getModel(), pe = retrieve3(ge.getModel().get(["lineStyle", "curveness"]), -getCurvenessForEdge(ge, C, de, !0), 0);
          return {
            n1: se[ge.node1.dataIndex],
            n2: se[ge.node2.dataIndex],
            d: fe,
            curveness: pe,
            ignoreForceLayout: ve.get("ignoreForceLayout")
          };
        }), le = G.getBoundingRect(), ue = forceLayout(se, oe, {
          rect: le,
          gravity: X.get("gravity"),
          friction: X.get("friction")
        });
        ue.beforeStep(function(ce, de) {
          for (var ge = 0, fe = ce.length; ge < fe; ge++)
            ce[ge].fixed && copy$1(ce[ge].p, K.getNodeByIndex(ge).getLayout());
        }), ue.afterStep(function(ce, de, ge) {
          for (var fe = 0, ve = ce.length; fe < ve; fe++)
            ce[fe].fixed || K.getNodeByIndex(fe).setLayout(ce[fe].p), U[W.getId(fe)] = ce[fe].p;
          for (var fe = 0, ve = de.length; fe < ve; fe++) {
            var pe = de[fe], he = K.getEdgeByIndex(fe), me = pe.n1.p, ye = pe.n2.p, Ce = he.getLayout();
            Ce = Ce ? Ce.slice() : [], Ce[0] = Ce[0] || [], Ce[1] = Ce[1] || [], copy$1(Ce[0], me), copy$1(Ce[1], ye), +pe.curveness && (Ce[2] = [(me[0] + ye[0]) / 2 - (me[1] - ye[1]) * pe.curveness, (me[1] + ye[1]) / 2 - (ye[0] - me[0]) * pe.curveness]), he.setLayout(Ce);
          }
        }), C.forceLayout = ue, C.preservedPoints = U, ue.step();
      } else
        C.forceLayout = null;
  });
}
function getViewRect$3(H, C, G) {
  var U = extend(H.getBoxLayoutParams(), {
    aspect: G
  });
  return getLayoutRect(U, {
    width: C.getWidth(),
    height: C.getHeight()
  });
}
function createViewCoordSys(H, C) {
  var G = [];
  return H.eachSeriesByType("graph", function(U) {
    var K = U.get("coordinateSystem");
    if (!K || K === "view") {
      var W = U.getData(), Z = W.mapArray(function(oe) {
        var le = W.getItemModel(oe);
        return [+le.get("x"), +le.get("y")];
      }), X = [], Q = [];
      fromPoints(Z, X, Q), Q[0] - X[0] === 0 && (Q[0] += 1, X[0] -= 1), Q[1] - X[1] === 0 && (Q[1] += 1, X[1] -= 1);
      var ee = (Q[0] - X[0]) / (Q[1] - X[1]), te = getViewRect$3(U, C, ee);
      isNaN(ee) && (X = [te.x, te.y], Q = [te.x + te.width, te.y + te.height]);
      var re = Q[0] - X[0], ne = Q[1] - X[1], ae = te.width, ie = te.height, se = U.coordinateSystem = new View$1();
      se.zoomLimit = U.get("scaleLimit"), se.setBoundingRect(X[0], X[1], re, ne), se.setViewRect(te.x, te.y, ae, ie), se.setCenter(U.get("center"), C), se.setZoom(U.get("zoom")), G.push(se);
    }
  }), G;
}
var straightLineProto = Line$3.prototype, bezierCurveProto = BezierCurve$1.prototype, StraightLineShape = (
  /** @class */
  function() {
    function H() {
      this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.percent = 1;
    }
    return H;
  }()
);
(function(H) {
  __extends$1(C, H);
  function C() {
    return H !== null && H.apply(this, arguments) || this;
  }
  return C;
})(StraightLineShape);
function isStraightLine(H) {
  return isNaN(+H.cpx1) || isNaN(+H.cpy1);
}
var ECLinePath = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C(G) {
      var U = H.call(this, G) || this;
      return U.type = "ec-line", U;
    }
    return C.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    }, C.prototype.getDefaultShape = function() {
      return new StraightLineShape();
    }, C.prototype.buildPath = function(G, U) {
      isStraightLine(U) ? straightLineProto.buildPath.call(this, G, U) : bezierCurveProto.buildPath.call(this, G, U);
    }, C.prototype.pointAt = function(G) {
      return isStraightLine(this.shape) ? straightLineProto.pointAt.call(this, G) : bezierCurveProto.pointAt.call(this, G);
    }, C.prototype.tangentAt = function(G) {
      var U = this.shape, K = isStraightLine(U) ? [U.x2 - U.x1, U.y2 - U.y1] : bezierCurveProto.tangentAt.call(this, G);
      return normalize$3(K, K);
    }, C;
  }(Path$1)
);
const ECLinePath$1 = ECLinePath;
var SYMBOL_CATEGORIES = ["fromSymbol", "toSymbol"];
function makeSymbolTypeKey(H) {
  return "_" + H + "Type";
}
function createSymbol(H, C, G) {
  var U = C.getItemVisual(G, H);
  if (!(!U || U === "none")) {
    var K = C.getItemVisual(G, H + "Size"), W = C.getItemVisual(G, H + "Rotate"), Z = C.getItemVisual(G, H + "Offset"), X = C.getItemVisual(G, H + "KeepAspect"), Q = normalizeSymbolSize(K), ee = normalizeSymbolOffset(Z || 0, Q), te = createSymbol$1(U, -Q[0] / 2 + ee[0], -Q[1] / 2 + ee[1], Q[0], Q[1], null, X);
    return te.__specifiedRotation = W == null || isNaN(W) ? void 0 : +W * Math.PI / 180 || 0, te.name = H, te;
  }
}
function createLine(H) {
  var C = new ECLinePath$1({
    name: "line",
    subPixelOptimize: !0
  });
  return setLinePoints(C.shape, H), C;
}
function setLinePoints(H, C) {
  H.x1 = C[0][0], H.y1 = C[0][1], H.x2 = C[1][0], H.y2 = C[1][1], H.percent = 1;
  var G = C[2];
  G ? (H.cpx1 = G[0], H.cpy1 = G[1]) : (H.cpx1 = NaN, H.cpy1 = NaN);
}
var Line = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C(G, U, K) {
      var W = H.call(this) || this;
      return W._createLine(G, U, K), W;
    }
    return C.prototype._createLine = function(G, U, K) {
      var W = G.hostModel, Z = G.getItemLayout(U), X = createLine(Z);
      X.shape.percent = 0, initProps(X, {
        shape: {
          percent: 1
        }
      }, W, U), this.add(X), each$f(SYMBOL_CATEGORIES, function(Q) {
        var ee = createSymbol(Q, G, U);
        this.add(ee), this[makeSymbolTypeKey(Q)] = G.getItemVisual(U, Q);
      }, this), this._updateCommonStl(G, U, K);
    }, C.prototype.updateData = function(G, U, K) {
      var W = G.hostModel, Z = this.childOfName("line"), X = G.getItemLayout(U), Q = {
        shape: {}
      };
      setLinePoints(Q.shape, X), updateProps$1(Z, Q, W, U), each$f(SYMBOL_CATEGORIES, function(ee) {
        var te = G.getItemVisual(U, ee), re = makeSymbolTypeKey(ee);
        if (this[re] !== te) {
          this.remove(this.childOfName(ee));
          var ne = createSymbol(ee, G, U);
          this.add(ne);
        }
        this[re] = te;
      }, this), this._updateCommonStl(G, U, K);
    }, C.prototype.getLinePath = function() {
      return this.childAt(0);
    }, C.prototype._updateCommonStl = function(G, U, K) {
      var W = G.hostModel, Z = this.childOfName("line"), X = K && K.emphasisLineStyle, Q = K && K.blurLineStyle, ee = K && K.selectLineStyle, te = K && K.labelStatesModels, re = K && K.emphasisDisabled, ne = K && K.focus, ae = K && K.blurScope;
      if (!K || G.hasItemOption) {
        var ie = G.getItemModel(U), se = ie.getModel("emphasis");
        X = se.getModel("lineStyle").getLineStyle(), Q = ie.getModel(["blur", "lineStyle"]).getLineStyle(), ee = ie.getModel(["select", "lineStyle"]).getLineStyle(), re = se.get("disabled"), ne = se.get("focus"), ae = se.get("blurScope"), te = getLabelStatesModels(ie);
      }
      var oe = G.getItemVisual(U, "style"), le = oe.stroke;
      Z.useStyle(oe), Z.style.fill = null, Z.style.strokeNoScale = !0, Z.ensureState("emphasis").style = X, Z.ensureState("blur").style = Q, Z.ensureState("select").style = ee, each$f(SYMBOL_CATEGORIES, function(fe) {
        var ve = this.childOfName(fe);
        if (ve) {
          ve.setColor(le), ve.style.opacity = oe.opacity;
          for (var pe = 0; pe < SPECIAL_STATES.length; pe++) {
            var he = SPECIAL_STATES[pe], me = Z.getState(he);
            if (me) {
              var ye = me.style || {}, Ce = ve.ensureState(he), Ie = Ce.style || (Ce.style = {});
              ye.stroke != null && (Ie[ve.__isEmptyBrush ? "stroke" : "fill"] = ye.stroke), ye.opacity != null && (Ie.opacity = ye.opacity);
            }
          }
          ve.markRedraw();
        }
      }, this);
      var ue = W.getRawValue(U);
      setLabelStyle(this, te, {
        labelDataIndex: U,
        labelFetcher: {
          getFormattedLabel: function(fe, ve) {
            return W.getFormattedLabel(fe, ve, G.dataType);
          }
        },
        inheritColor: le || "#000",
        defaultOpacity: oe.opacity,
        defaultText: (ue == null ? G.getName(U) : isFinite(ue) ? round$3(ue) : ue) + ""
      });
      var ce = this.getTextContent();
      if (ce) {
        var de = te.normal;
        ce.__align = ce.style.align, ce.__verticalAlign = ce.style.verticalAlign, ce.__position = de.get("position") || "middle";
        var ge = de.get("distance");
        isArray$1(ge) || (ge = [ge, ge]), ce.__labelDistance = ge;
      }
      this.setTextConfig({
        position: null,
        local: !0,
        inside: !1
        // Can't be inside for stroke element.
      }), toggleHoverEmphasis(this, ne, ae, re);
    }, C.prototype.highlight = function() {
      enterEmphasis(this);
    }, C.prototype.downplay = function() {
      leaveEmphasis(this);
    }, C.prototype.updateLayout = function(G, U) {
      this.setLinePoints(G.getItemLayout(U));
    }, C.prototype.setLinePoints = function(G) {
      var U = this.childOfName("line");
      setLinePoints(U.shape, G), U.dirty();
    }, C.prototype.beforeUpdate = function() {
      var G = this, U = G.childOfName("fromSymbol"), K = G.childOfName("toSymbol"), W = G.getTextContent();
      if (!U && !K && (!W || W.ignore))
        return;
      for (var Z = 1, X = this.parent; X; )
        X.scaleX && (Z /= X.scaleX), X = X.parent;
      var Q = G.childOfName("line");
      if (!this.__dirty && !Q.__dirty)
        return;
      var ee = Q.shape.percent, te = Q.pointAt(0), re = Q.pointAt(ee), ne = sub([], re, te);
      normalize$3(ne, ne);
      function ae(me, ye) {
        var Ce = me.__specifiedRotation;
        if (Ce == null) {
          var Ie = Q.tangentAt(ye);
          me.attr("rotation", (ye === 1 ? -1 : 1) * Math.PI / 2 - Math.atan2(Ie[1], Ie[0]));
        } else
          me.attr("rotation", Ce);
      }
      if (U && (U.setPosition(te), ae(U, 0), U.scaleX = U.scaleY = Z * ee, U.markRedraw()), K && (K.setPosition(re), ae(K, 1), K.scaleX = K.scaleY = Z * ee, K.markRedraw()), W && !W.ignore) {
        W.x = W.y = 0, W.originX = W.originY = 0;
        var ie = void 0, se = void 0, oe = W.__labelDistance, le = oe[0] * Z, ue = oe[1] * Z, ce = ee / 2, de = Q.tangentAt(ce), ge = [de[1], -de[0]], fe = Q.pointAt(ce);
        ge[1] > 0 && (ge[0] = -ge[0], ge[1] = -ge[1]);
        var ve = de[0] < 0 ? -1 : 1;
        if (W.__position !== "start" && W.__position !== "end") {
          var pe = -Math.atan2(de[1], de[0]);
          re[0] < te[0] && (pe = Math.PI + pe), W.rotation = pe;
        }
        var he = void 0;
        switch (W.__position) {
          case "insideStartTop":
          case "insideMiddleTop":
          case "insideEndTop":
          case "middle":
            he = -ue, se = "bottom";
            break;
          case "insideStartBottom":
          case "insideMiddleBottom":
          case "insideEndBottom":
            he = ue, se = "top";
            break;
          default:
            he = 0, se = "middle";
        }
        switch (W.__position) {
          case "end":
            W.x = ne[0] * le + re[0], W.y = ne[1] * ue + re[1], ie = ne[0] > 0.8 ? "left" : ne[0] < -0.8 ? "right" : "center", se = ne[1] > 0.8 ? "top" : ne[1] < -0.8 ? "bottom" : "middle";
            break;
          case "start":
            W.x = -ne[0] * le + te[0], W.y = -ne[1] * ue + te[1], ie = ne[0] > 0.8 ? "right" : ne[0] < -0.8 ? "left" : "center", se = ne[1] > 0.8 ? "bottom" : ne[1] < -0.8 ? "top" : "middle";
            break;
          case "insideStartTop":
          case "insideStart":
          case "insideStartBottom":
            W.x = le * ve + te[0], W.y = te[1] + he, ie = de[0] < 0 ? "right" : "left", W.originX = -le * ve, W.originY = -he;
            break;
          case "insideMiddleTop":
          case "insideMiddle":
          case "insideMiddleBottom":
          case "middle":
            W.x = fe[0], W.y = fe[1] + he, ie = "center", W.originY = -he;
            break;
          case "insideEndTop":
          case "insideEnd":
          case "insideEndBottom":
            W.x = -le * ve + re[0], W.y = re[1] + he, ie = de[0] >= 0 ? "right" : "left", W.originX = le * ve, W.originY = -he;
            break;
        }
        W.scaleX = W.scaleY = Z, W.setStyle({
          // Use the user specified text align and baseline first
          verticalAlign: W.__verticalAlign || se,
          align: W.__align || ie
        });
      }
    }, C;
  }(Group$4)
);
const Line$1 = Line;
var LineDraw = (
  /** @class */
  function() {
    function H(C) {
      this.group = new Group$4(), this._LineCtor = C || Line$1;
    }
    return H.prototype.updateData = function(C) {
      var G = this;
      this._progressiveEls = null;
      var U = this, K = U.group, W = U._lineData;
      U._lineData = C, W || K.removeAll();
      var Z = makeSeriesScope$1(C);
      C.diff(W).add(function(X) {
        G._doAdd(C, X, Z);
      }).update(function(X, Q) {
        G._doUpdate(W, C, Q, X, Z);
      }).remove(function(X) {
        K.remove(W.getItemGraphicEl(X));
      }).execute();
    }, H.prototype.updateLayout = function() {
      var C = this._lineData;
      C && C.eachItemGraphicEl(function(G, U) {
        G.updateLayout(C, U);
      }, this);
    }, H.prototype.incrementalPrepareUpdate = function(C) {
      this._seriesScope = makeSeriesScope$1(C), this._lineData = null, this.group.removeAll();
    }, H.prototype.incrementalUpdate = function(C, G) {
      this._progressiveEls = [];
      function U(X) {
        !X.isGroup && !isEffectObject(X) && (X.incremental = !0, X.ensureState("emphasis").hoverLayer = !0);
      }
      for (var K = C.start; K < C.end; K++) {
        var W = G.getItemLayout(K);
        if (lineNeedsDraw(W)) {
          var Z = new this._LineCtor(G, K, this._seriesScope);
          Z.traverse(U), this.group.add(Z), G.setItemGraphicEl(K, Z), this._progressiveEls.push(Z);
        }
      }
    }, H.prototype.remove = function() {
      this.group.removeAll();
    }, H.prototype.eachRendered = function(C) {
      traverseElements(this._progressiveEls || this.group, C);
    }, H.prototype._doAdd = function(C, G, U) {
      var K = C.getItemLayout(G);
      if (lineNeedsDraw(K)) {
        var W = new this._LineCtor(C, G, U);
        C.setItemGraphicEl(G, W), this.group.add(W);
      }
    }, H.prototype._doUpdate = function(C, G, U, K, W) {
      var Z = C.getItemGraphicEl(U);
      if (!lineNeedsDraw(G.getItemLayout(K))) {
        this.group.remove(Z);
        return;
      }
      Z ? Z.updateData(G, K, W) : Z = new this._LineCtor(G, K, W), G.setItemGraphicEl(K, Z), this.group.add(Z);
    }, H;
  }()
);
function isEffectObject(H) {
  return H.animators && H.animators.length > 0;
}
function makeSeriesScope$1(H) {
  var C = H.hostModel, G = C.getModel("emphasis");
  return {
    lineStyle: C.getModel("lineStyle").getLineStyle(),
    emphasisLineStyle: G.getModel(["lineStyle"]).getLineStyle(),
    blurLineStyle: C.getModel(["blur", "lineStyle"]).getLineStyle(),
    selectLineStyle: C.getModel(["select", "lineStyle"]).getLineStyle(),
    emphasisDisabled: G.get("disabled"),
    blurScope: G.get("blurScope"),
    focus: G.get("focus"),
    labelStatesModels: getLabelStatesModels(C)
  };
}
function isPointNaN(H) {
  return isNaN(H[0]) || isNaN(H[1]);
}
function lineNeedsDraw(H) {
  return H && !isPointNaN(H[0]) && !isPointNaN(H[1]);
}
const LineDraw$1 = LineDraw;
var v1 = [], v2 = [], v3 = [], quadraticAt = quadraticAt$1, v2DistSquare = distSquare, mathAbs = Math.abs;
function intersectCurveCircle(H, C, G) {
  for (var U = H[0], K = H[1], W = H[2], Z = 1 / 0, X, Q = G * G, ee = 0.1, te = 0.1; te <= 0.9; te += 0.1) {
    v1[0] = quadraticAt(U[0], K[0], W[0], te), v1[1] = quadraticAt(U[1], K[1], W[1], te);
    var re = mathAbs(v2DistSquare(v1, C) - Q);
    re < Z && (Z = re, X = te);
  }
  for (var ne = 0; ne < 32; ne++) {
    var ae = X + ee;
    v2[0] = quadraticAt(U[0], K[0], W[0], X), v2[1] = quadraticAt(U[1], K[1], W[1], X), v3[0] = quadraticAt(U[0], K[0], W[0], ae), v3[1] = quadraticAt(U[1], K[1], W[1], ae);
    var re = v2DistSquare(v2, C) - Q;
    if (mathAbs(re) < 0.01)
      break;
    var ie = v2DistSquare(v3, C) - Q;
    ee /= 2, re < 0 ? ie >= 0 ? X = X + ee : X = X - ee : ie >= 0 ? X = X - ee : X = X + ee;
  }
  return X;
}
function adjustEdge(H, C) {
  var G = [], U = quadraticSubdivide, K = [[], [], []], W = [[], []], Z = [];
  C /= 2, H.eachEdge(function(X, Q) {
    var ee = X.getLayout(), te = X.getVisual("fromSymbol"), re = X.getVisual("toSymbol");
    ee.__original || (ee.__original = [clone$3(ee[0]), clone$3(ee[1])], ee[2] && ee.__original.push(clone$3(ee[2])));
    var ne = ee.__original;
    if (ee[2] != null) {
      if (copy$1(K[0], ne[0]), copy$1(K[1], ne[2]), copy$1(K[2], ne[1]), te && te !== "none") {
        var ae = getSymbolSize(X.node1), ie = intersectCurveCircle(K, ne[0], ae * C);
        U(K[0][0], K[1][0], K[2][0], ie, G), K[0][0] = G[3], K[1][0] = G[4], U(K[0][1], K[1][1], K[2][1], ie, G), K[0][1] = G[3], K[1][1] = G[4];
      }
      if (re && re !== "none") {
        var ae = getSymbolSize(X.node2), ie = intersectCurveCircle(K, ne[1], ae * C);
        U(K[0][0], K[1][0], K[2][0], ie, G), K[1][0] = G[1], K[2][0] = G[2], U(K[0][1], K[1][1], K[2][1], ie, G), K[1][1] = G[1], K[2][1] = G[2];
      }
      copy$1(ee[0], K[0]), copy$1(ee[1], K[2]), copy$1(ee[2], K[1]);
    } else {
      if (copy$1(W[0], ne[0]), copy$1(W[1], ne[1]), sub(Z, W[1], W[0]), normalize$3(Z, Z), te && te !== "none") {
        var ae = getSymbolSize(X.node1);
        scaleAndAdd$1(W[0], W[0], Z, ae * C);
      }
      if (re && re !== "none") {
        var ae = getSymbolSize(X.node2);
        scaleAndAdd$1(W[1], W[1], Z, -ae * C);
      }
      copy$1(ee[0], W[0]), copy$1(ee[1], W[1]);
    }
  });
}
function isViewCoordSys(H) {
  return H.type === "view";
}
var GraphView = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G;
    }
    return C.prototype.init = function(G, U) {
      var K = new SymbolDraw$1(), W = new LineDraw$1(), Z = this.group;
      this._controller = new RoamController$1(U.getZr()), this._controllerHost = {
        target: Z
      }, Z.add(K.group), Z.add(W.group), this._symbolDraw = K, this._lineDraw = W, this._firstRender = !0;
    }, C.prototype.render = function(G, U, K) {
      var W = this, Z = G.coordinateSystem;
      this._model = G;
      var X = this._symbolDraw, Q = this._lineDraw, ee = this.group;
      if (isViewCoordSys(Z)) {
        var te = {
          x: Z.x,
          y: Z.y,
          scaleX: Z.scaleX,
          scaleY: Z.scaleY
        };
        this._firstRender ? ee.attr(te) : updateProps$1(ee, te, G);
      }
      adjustEdge(G.getGraph(), getNodeGlobalScale(G));
      var re = G.getData();
      X.updateData(re);
      var ne = G.getEdgeData();
      Q.updateData(ne), this._updateNodeAndLinkScale(), this._updateController(G, U, K), clearTimeout(this._layoutTimeout);
      var ae = G.forceLayout, ie = G.get(["force", "layoutAnimation"]);
      ae && this._startForceLayoutIteration(ae, ie);
      var se = G.get("layout");
      re.graph.eachNode(function(ce) {
        var de = ce.dataIndex, ge = ce.getGraphicEl(), fe = ce.getModel();
        if (ge) {
          ge.off("drag").off("dragend");
          var ve = fe.get("draggable");
          ve && ge.on("drag", function(he) {
            switch (se) {
              case "force":
                ae.warmUp(), !W._layouting && W._startForceLayoutIteration(ae, ie), ae.setFixed(de), re.setItemLayout(de, [ge.x, ge.y]);
                break;
              case "circular":
                re.setItemLayout(de, [ge.x, ge.y]), ce.setLayout({
                  fixed: !0
                }, !0), circularLayout(G, "symbolSize", ce, [he.offsetX, he.offsetY]), W.updateLayout(G);
                break;
              case "none":
              default:
                re.setItemLayout(de, [ge.x, ge.y]), simpleLayoutEdge(G.getGraph(), G), W.updateLayout(G);
                break;
            }
          }).on("dragend", function() {
            ae && ae.setUnfixed(de);
          }), ge.setDraggable(ve, !!fe.get("cursor"));
          var pe = fe.get(["emphasis", "focus"]);
          pe === "adjacency" && (getECData(ge).focus = ce.getAdjacentDataIndices());
        }
      }), re.graph.eachEdge(function(ce) {
        var de = ce.getGraphicEl(), ge = ce.getModel().get(["emphasis", "focus"]);
        de && ge === "adjacency" && (getECData(de).focus = {
          edge: [ce.dataIndex],
          node: [ce.node1.dataIndex, ce.node2.dataIndex]
        });
      });
      var oe = G.get("layout") === "circular" && G.get(["circular", "rotateLabel"]), le = re.getLayout("cx"), ue = re.getLayout("cy");
      re.graph.eachNode(function(ce) {
        rotateNodeLabel(ce, oe, le, ue);
      }), this._firstRender = !1;
    }, C.prototype.dispose = function() {
      this._controller && this._controller.dispose(), this._controllerHost = null;
    }, C.prototype._startForceLayoutIteration = function(G, U) {
      var K = this;
      (function W() {
        G.step(function(Z) {
          K.updateLayout(K._model), (K._layouting = !Z) && (U ? K._layoutTimeout = setTimeout(W, 16) : W());
        });
      })();
    }, C.prototype._updateController = function(G, U, K) {
      var W = this, Z = this._controller, X = this._controllerHost, Q = this.group;
      if (Z.setPointerChecker(function(ee, te, re) {
        var ne = Q.getBoundingRect();
        return ne.applyTransform(Q.transform), ne.contain(te, re) && !onIrrelevantElement(ee, K, G);
      }), !isViewCoordSys(G.coordinateSystem)) {
        Z.disable();
        return;
      }
      Z.enable(G.get("roam")), X.zoomLimit = G.get("scaleLimit"), X.zoom = G.coordinateSystem.getZoom(), Z.off("pan").off("zoom").on("pan", function(ee) {
        updateViewOnPan(X, ee.dx, ee.dy), K.dispatchAction({
          seriesId: G.id,
          type: "graphRoam",
          dx: ee.dx,
          dy: ee.dy
        });
      }).on("zoom", function(ee) {
        updateViewOnZoom(X, ee.scale, ee.originX, ee.originY), K.dispatchAction({
          seriesId: G.id,
          type: "graphRoam",
          zoom: ee.scale,
          originX: ee.originX,
          originY: ee.originY
        }), W._updateNodeAndLinkScale(), adjustEdge(G.getGraph(), getNodeGlobalScale(G)), W._lineDraw.updateLayout(), K.updateLabelLayout();
      });
    }, C.prototype._updateNodeAndLinkScale = function() {
      var G = this._model, U = G.getData(), K = getNodeGlobalScale(G);
      U.eachItemGraphicEl(function(W, Z) {
        W && W.setSymbolScale(K);
      });
    }, C.prototype.updateLayout = function(G) {
      adjustEdge(G.getGraph(), getNodeGlobalScale(G)), this._symbolDraw.updateLayout(), this._lineDraw.updateLayout();
    }, C.prototype.remove = function(G, U) {
      this._symbolDraw && this._symbolDraw.remove(), this._lineDraw && this._lineDraw.remove();
    }, C.type = "graph", C;
  }(ChartView$1)
);
const GraphView$1 = GraphView;
function generateNodeKey(H) {
  return "_EC_" + H;
}
var Graph = (
  /** @class */
  function() {
    function H(C) {
      this.type = "graph", this.nodes = [], this.edges = [], this._nodesMap = {}, this._edgesMap = {}, this._directed = C || !1;
    }
    return H.prototype.isDirected = function() {
      return this._directed;
    }, H.prototype.addNode = function(C, G) {
      C = C == null ? "" + G : "" + C;
      var U = this._nodesMap;
      if (U[generateNodeKey(C)]) {
        process.env.NODE_ENV !== "production" && console.error("Graph nodes have duplicate name or id");
        return;
      }
      var K = new GraphNode(C, G);
      return K.hostGraph = this, this.nodes.push(K), U[generateNodeKey(C)] = K, K;
    }, H.prototype.getNodeByIndex = function(C) {
      var G = this.data.getRawIndex(C);
      return this.nodes[G];
    }, H.prototype.getNodeById = function(C) {
      return this._nodesMap[generateNodeKey(C)];
    }, H.prototype.addEdge = function(C, G, U) {
      var K = this._nodesMap, W = this._edgesMap;
      if (isNumber(C) && (C = this.nodes[C]), isNumber(G) && (G = this.nodes[G]), C instanceof GraphNode || (C = K[generateNodeKey(C)]), G instanceof GraphNode || (G = K[generateNodeKey(G)]), !(!C || !G)) {
        var Z = C.id + "-" + G.id, X = new GraphEdge(C, G, U);
        return X.hostGraph = this, this._directed && (C.outEdges.push(X), G.inEdges.push(X)), C.edges.push(X), C !== G && G.edges.push(X), this.edges.push(X), W[Z] = X, X;
      }
    }, H.prototype.getEdgeByIndex = function(C) {
      var G = this.edgeData.getRawIndex(C);
      return this.edges[G];
    }, H.prototype.getEdge = function(C, G) {
      C instanceof GraphNode && (C = C.id), G instanceof GraphNode && (G = G.id);
      var U = this._edgesMap;
      return this._directed ? U[C + "-" + G] : U[C + "-" + G] || U[G + "-" + C];
    }, H.prototype.eachNode = function(C, G) {
      for (var U = this.nodes, K = U.length, W = 0; W < K; W++)
        U[W].dataIndex >= 0 && C.call(G, U[W], W);
    }, H.prototype.eachEdge = function(C, G) {
      for (var U = this.edges, K = U.length, W = 0; W < K; W++)
        U[W].dataIndex >= 0 && U[W].node1.dataIndex >= 0 && U[W].node2.dataIndex >= 0 && C.call(G, U[W], W);
    }, H.prototype.breadthFirstTraverse = function(C, G, U, K) {
      if (G instanceof GraphNode || (G = this._nodesMap[generateNodeKey(G)]), !!G) {
        for (var W = U === "out" ? "outEdges" : U === "in" ? "inEdges" : "edges", Z = 0; Z < this.nodes.length; Z++)
          this.nodes[Z].__visited = !1;
        if (!C.call(K, G, null))
          for (var X = [G]; X.length; )
            for (var Q = X.shift(), ee = Q[W], Z = 0; Z < ee.length; Z++) {
              var te = ee[Z], re = te.node1 === Q ? te.node2 : te.node1;
              if (!re.__visited) {
                if (C.call(K, re, Q))
                  return;
                X.push(re), re.__visited = !0;
              }
            }
      }
    }, H.prototype.update = function() {
      for (var C = this.data, G = this.edgeData, U = this.nodes, K = this.edges, W = 0, Z = U.length; W < Z; W++)
        U[W].dataIndex = -1;
      for (var W = 0, Z = C.count(); W < Z; W++)
        U[C.getRawIndex(W)].dataIndex = W;
      G.filterSelf(function(X) {
        var Q = K[G.getRawIndex(X)];
        return Q.node1.dataIndex >= 0 && Q.node2.dataIndex >= 0;
      });
      for (var W = 0, Z = K.length; W < Z; W++)
        K[W].dataIndex = -1;
      for (var W = 0, Z = G.count(); W < Z; W++)
        K[G.getRawIndex(W)].dataIndex = W;
    }, H.prototype.clone = function() {
      for (var C = new H(this._directed), G = this.nodes, U = this.edges, K = 0; K < G.length; K++)
        C.addNode(G[K].id, G[K].dataIndex);
      for (var K = 0; K < U.length; K++) {
        var W = U[K];
        C.addEdge(W.node1.id, W.node2.id, W.dataIndex);
      }
      return C;
    }, H;
  }()
), GraphNode = (
  /** @class */
  function() {
    function H(C, G) {
      this.inEdges = [], this.outEdges = [], this.edges = [], this.dataIndex = -1, this.id = C ?? "", this.dataIndex = G ?? -1;
    }
    return H.prototype.degree = function() {
      return this.edges.length;
    }, H.prototype.inDegree = function() {
      return this.inEdges.length;
    }, H.prototype.outDegree = function() {
      return this.outEdges.length;
    }, H.prototype.getModel = function(C) {
      if (!(this.dataIndex < 0)) {
        var G = this.hostGraph, U = G.data.getItemModel(this.dataIndex);
        return U.getModel(C);
      }
    }, H.prototype.getAdjacentDataIndices = function() {
      for (var C = {
        edge: [],
        node: []
      }, G = 0; G < this.edges.length; G++) {
        var U = this.edges[G];
        U.dataIndex < 0 || (C.edge.push(U.dataIndex), C.node.push(U.node1.dataIndex, U.node2.dataIndex));
      }
      return C;
    }, H;
  }()
), GraphEdge = (
  /** @class */
  function() {
    function H(C, G, U) {
      this.dataIndex = -1, this.node1 = C, this.node2 = G, this.dataIndex = U ?? -1;
    }
    return H.prototype.getModel = function(C) {
      if (!(this.dataIndex < 0)) {
        var G = this.hostGraph, U = G.edgeData.getItemModel(this.dataIndex);
        return U.getModel(C);
      }
    }, H.prototype.getAdjacentDataIndices = function() {
      return {
        edge: [this.dataIndex],
        node: [this.node1.dataIndex, this.node2.dataIndex]
      };
    }, H;
  }()
);
function createGraphDataProxyMixin(H, C) {
  return {
    /**
     * @param Default 'value'. can be 'a', 'b', 'c', 'd', 'e'.
     */
    getValue: function(G) {
      var U = this[H][C];
      return U.getStore().get(U.getDimensionIndex(G || "value"), this.dataIndex);
    },
    // TODO: TYPE stricter type.
    setVisual: function(G, U) {
      this.dataIndex >= 0 && this[H][C].setItemVisual(this.dataIndex, G, U);
    },
    getVisual: function(G) {
      return this[H][C].getItemVisual(this.dataIndex, G);
    },
    setLayout: function(G, U) {
      this.dataIndex >= 0 && this[H][C].setItemLayout(this.dataIndex, G, U);
    },
    getLayout: function() {
      return this[H][C].getItemLayout(this.dataIndex);
    },
    getGraphicEl: function() {
      return this[H][C].getItemGraphicEl(this.dataIndex);
    },
    getRawIndex: function() {
      return this[H][C].getRawIndex(this.dataIndex);
    }
  };
}
mixin(GraphNode, createGraphDataProxyMixin("hostGraph", "data"));
mixin(GraphEdge, createGraphDataProxyMixin("hostGraph", "edgeData"));
const Graph$1 = Graph;
function createGraphFromNodeEdge(H, C, G, U, K) {
  for (var W = new Graph$1(U), Z = 0; Z < H.length; Z++)
    W.addNode(retrieve(
      // Id, name, dataIndex
      H[Z].id,
      H[Z].name,
      Z
    ), Z);
  for (var X = [], Q = [], ee = 0, Z = 0; Z < C.length; Z++) {
    var te = C[Z], re = te.source, ne = te.target;
    W.addEdge(re, ne, ee) && (Q.push(te), X.push(retrieve(convertOptionIdName(te.id, null), re + " > " + ne)), ee++);
  }
  var ae = G.get("coordinateSystem"), ie;
  if (ae === "cartesian2d" || ae === "polar")
    ie = createSeriesData(H, G);
  else {
    var se = CoordinateSystem.get(ae), oe = se ? se.dimensions || [] : [];
    indexOf(oe, "value") < 0 && oe.concat(["value"]);
    var le = prepareSeriesDataSchema(H, {
      coordDimensions: oe,
      encodeDefine: G.getEncode()
    }).dimensions;
    ie = new SeriesData$1(le, G), ie.initData(H);
  }
  var ue = new SeriesData$1(["value"], G);
  return ue.initData(Q, X), K && K(ie, ue), linkSeriesData({
    mainData: ie,
    struct: W,
    structAttr: "graph",
    datas: {
      node: ie,
      edge: ue
    },
    datasAttr: {
      node: "data",
      edge: "edgeData"
    }
  }), W.update(), W;
}
var GraphSeriesModel = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G.hasSymbolVisual = !0, G;
    }
    return C.prototype.init = function(G) {
      H.prototype.init.apply(this, arguments);
      var U = this;
      function K() {
        return U._categoriesData;
      }
      this.legendVisualProvider = new LegendVisualProvider$1(K, K), this.fillDataTextStyle(G.edges || G.links), this._updateCategoriesData();
    }, C.prototype.mergeOption = function(G) {
      H.prototype.mergeOption.apply(this, arguments), this.fillDataTextStyle(G.edges || G.links), this._updateCategoriesData();
    }, C.prototype.mergeDefaultAndTheme = function(G) {
      H.prototype.mergeDefaultAndTheme.apply(this, arguments), defaultEmphasis(G, "edgeLabel", ["show"]);
    }, C.prototype.getInitialData = function(G, U) {
      var K = G.edges || G.links || [], W = G.data || G.nodes || [], Z = this;
      if (W && K) {
        initCurvenessList(this);
        var X = createGraphFromNodeEdge(W, K, this, !0, Q);
        return each$f(X.edges, function(ee) {
          createEdgeMapForCurveness(ee.node1, ee.node2, this, ee.dataIndex);
        }, this), X.data;
      }
      function Q(ee, te) {
        ee.wrapMethod("getItemModel", function(ie) {
          var se = Z._categoriesModels, oe = ie.getShallow("category"), le = se[oe];
          return le && (le.parentModel = ie.parentModel, ie.parentModel = le), ie;
        });
        var re = Model$1.prototype.getModel;
        function ne(ie, se) {
          var oe = re.call(this, ie, se);
          return oe.resolveParentPath = ae, oe;
        }
        te.wrapMethod("getItemModel", function(ie) {
          return ie.resolveParentPath = ae, ie.getModel = ne, ie;
        });
        function ae(ie) {
          if (ie && (ie[0] === "label" || ie[1] === "label")) {
            var se = ie.slice();
            return ie[0] === "label" ? se[0] = "edgeLabel" : ie[1] === "label" && (se[1] = "edgeLabel"), se;
          }
          return ie;
        }
      }
    }, C.prototype.getGraph = function() {
      return this.getData().graph;
    }, C.prototype.getEdgeData = function() {
      return this.getGraph().edgeData;
    }, C.prototype.getCategoriesData = function() {
      return this._categoriesData;
    }, C.prototype.formatTooltip = function(G, U, K) {
      if (K === "edge") {
        var W = this.getData(), Z = this.getDataParams(G, K), X = W.graph.getEdgeByIndex(G), Q = W.getName(X.node1.dataIndex), ee = W.getName(X.node2.dataIndex), te = [];
        return Q != null && te.push(Q), ee != null && te.push(ee), createTooltipMarkup("nameValue", {
          name: te.join(" > "),
          value: Z.value,
          noValue: Z.value == null
        });
      }
      var re = defaultSeriesFormatTooltip({
        series: this,
        dataIndex: G,
        multipleSeries: U
      });
      return re;
    }, C.prototype._updateCategoriesData = function() {
      var G = map$1(this.option.categories || [], function(K) {
        return K.value != null ? K : extend({
          value: 0
        }, K);
      }), U = new SeriesData$1(["value"], this);
      U.initData(G), this._categoriesData = U, this._categoriesModels = U.mapArray(function(K) {
        return U.getItemModel(K);
      });
    }, C.prototype.setZoom = function(G) {
      this.option.zoom = G;
    }, C.prototype.setCenter = function(G) {
      this.option.center = G;
    }, C.prototype.isAnimationEnabled = function() {
      return H.prototype.isAnimationEnabled.call(this) && !(this.get("layout") === "force" && this.get(["force", "layoutAnimation"]));
    }, C.type = "series.graph", C.dependencies = ["grid", "polar", "geo", "singleAxis", "calendar"], C.defaultOption = {
      // zlevel: 0,
      z: 2,
      coordinateSystem: "view",
      // Default option for all coordinate systems
      // xAxisIndex: 0,
      // yAxisIndex: 0,
      // polarIndex: 0,
      // geoIndex: 0,
      legendHoverLink: !0,
      layout: null,
      // Configuration of circular layout
      circular: {
        rotateLabel: !1
      },
      // Configuration of force directed layout
      force: {
        initLayout: null,
        // Node repulsion. Can be an array to represent range.
        repulsion: [0, 50],
        gravity: 0.1,
        // Initial friction
        friction: 0.6,
        // Edge length. Can be an array to represent range.
        edgeLength: 30,
        layoutAnimation: !0
      },
      left: "center",
      top: "center",
      // right: null,
      // bottom: null,
      // width: '80%',
      // height: '80%',
      symbol: "circle",
      symbolSize: 10,
      edgeSymbol: ["none", "none"],
      edgeSymbolSize: 10,
      edgeLabel: {
        position: "middle",
        distance: 5
      },
      draggable: !1,
      roam: !1,
      // Default on center of graph
      center: null,
      zoom: 1,
      // Symbol size scale ratio in roam
      nodeScaleRatio: 0.6,
      // cursor: null,
      // categories: [],
      // data: []
      // Or
      // nodes: []
      //
      // links: []
      // Or
      // edges: []
      label: {
        show: !1,
        formatter: "{b}"
      },
      itemStyle: {},
      lineStyle: {
        color: "#aaa",
        width: 1,
        opacity: 0.5
      },
      emphasis: {
        scale: !0,
        label: {
          show: !0
        }
      },
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      }
    }, C;
  }(SeriesModel$1)
);
const GraphSeriesModel$1 = GraphSeriesModel;
var actionInfo$1 = {
  type: "graphRoam",
  event: "graphRoam",
  update: "none"
};
function install$F(H) {
  H.registerChartView(GraphView$1), H.registerSeriesModel(GraphSeriesModel$1), H.registerProcessor(categoryFilter), H.registerVisual(categoryVisual), H.registerVisual(graphEdgeVisual), H.registerLayout(graphSimpleLayout), H.registerLayout(H.PRIORITY.VISUAL.POST_CHART_LAYOUT, graphCircularLayout), H.registerLayout(graphForceLayout), H.registerCoordinateSystem("graphView", {
    dimensions: View$1.dimensions,
    create: createViewCoordSys
  }), H.registerAction({
    type: "focusNodeAdjacency",
    event: "focusNodeAdjacency",
    update: "series:focusNodeAdjacency"
  }, noop), H.registerAction({
    type: "unfocusNodeAdjacency",
    event: "unfocusNodeAdjacency",
    update: "series:unfocusNodeAdjacency"
  }, noop), H.registerAction(actionInfo$1, function(C, G, U) {
    G.eachComponent({
      mainType: "series",
      query: C
    }, function(K) {
      var W = K.coordinateSystem, Z = updateCenterAndZoom(W, C, void 0, U);
      K.setCenter && K.setCenter(Z.center), K.setZoom && K.setZoom(Z.zoom);
    });
  });
}
var PointerShape = (
  /** @class */
  function() {
    function H() {
      this.angle = 0, this.width = 10, this.r = 10, this.x = 0, this.y = 0;
    }
    return H;
  }()
), PointerPath = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C(G) {
      var U = H.call(this, G) || this;
      return U.type = "pointer", U;
    }
    return C.prototype.getDefaultShape = function() {
      return new PointerShape();
    }, C.prototype.buildPath = function(G, U) {
      var K = Math.cos, W = Math.sin, Z = U.r, X = U.width, Q = U.angle, ee = U.x - K(Q) * X * (X >= Z / 3 ? 1 : 2), te = U.y - W(Q) * X * (X >= Z / 3 ? 1 : 2);
      Q = U.angle - Math.PI / 2, G.moveTo(ee, te), G.lineTo(U.x + K(Q) * X, U.y + W(Q) * X), G.lineTo(U.x + K(U.angle) * Z, U.y + W(U.angle) * Z), G.lineTo(U.x - K(Q) * X, U.y - W(Q) * X), G.lineTo(ee, te);
    }, C;
  }(Path$1)
);
const PointerPath$1 = PointerPath;
function parsePosition(H, C) {
  var G = H.get("center"), U = C.getWidth(), K = C.getHeight(), W = Math.min(U, K), Z = parsePercent(G[0], C.getWidth()), X = parsePercent(G[1], C.getHeight()), Q = parsePercent(H.get("radius"), W / 2);
  return {
    cx: Z,
    cy: X,
    r: Q
  };
}
function formatLabel(H, C) {
  var G = H == null ? "" : H + "";
  return C && (isString(C) ? G = C.replace("{value}", G) : isFunction(C) && (G = C(H))), G;
}
var GaugeView = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G;
    }
    return C.prototype.render = function(G, U, K) {
      this.group.removeAll();
      var W = G.get(["axisLine", "lineStyle", "color"]), Z = parsePosition(G, K);
      this._renderMain(G, U, K, W, Z), this._data = G.getData();
    }, C.prototype.dispose = function() {
    }, C.prototype._renderMain = function(G, U, K, W, Z) {
      var X = this.group, Q = G.get("clockwise"), ee = -G.get("startAngle") / 180 * Math.PI, te = -G.get("endAngle") / 180 * Math.PI, re = G.getModel("axisLine"), ne = re.get("roundCap"), ae = ne ? Sausage : Sector$1, ie = re.get("show"), se = re.getModel("lineStyle"), oe = se.get("width"), le = [ee, te];
      normalizeArcAngles(le, !Q), ee = le[0], te = le[1];
      for (var ue = te - ee, ce = ee, de = [], ge = 0; ie && ge < W.length; ge++) {
        var fe = Math.min(Math.max(W[ge][0], 0), 1);
        te = ee + ue * fe;
        var ve = new ae({
          shape: {
            startAngle: ce,
            endAngle: te,
            cx: Z.cx,
            cy: Z.cy,
            clockwise: Q,
            r0: Z.r - oe,
            r: Z.r
          },
          silent: !0
        });
        ve.setStyle({
          fill: W[ge][1]
        }), ve.setStyle(se.getLineStyle(
          // Because we use sector to simulate arc
          // so the properties for stroking are useless
          ["color", "width"]
        )), de.push(ve), ce = te;
      }
      de.reverse(), each$f(de, function(he) {
        return X.add(he);
      });
      var pe = function(he) {
        if (he <= 0)
          return W[0][1];
        var me;
        for (me = 0; me < W.length; me++)
          if (W[me][0] >= he && (me === 0 ? 0 : W[me - 1][0]) < he)
            return W[me][1];
        return W[me - 1][1];
      };
      this._renderTicks(G, U, K, pe, Z, ee, te, Q, oe), this._renderTitleAndDetail(G, U, K, pe, Z), this._renderAnchor(G, Z), this._renderPointer(G, U, K, pe, Z, ee, te, Q, oe);
    }, C.prototype._renderTicks = function(G, U, K, W, Z, X, Q, ee, te) {
      for (var re = this.group, ne = Z.cx, ae = Z.cy, ie = Z.r, se = +G.get("min"), oe = +G.get("max"), le = G.getModel("splitLine"), ue = G.getModel("axisTick"), ce = G.getModel("axisLabel"), de = G.get("splitNumber"), ge = ue.get("splitNumber"), fe = parsePercent(le.get("length"), ie), ve = parsePercent(ue.get("length"), ie), pe = X, he = (Q - X) / de, me = he / ge, ye = le.getModel("lineStyle").getLineStyle(), Ce = ue.getModel("lineStyle").getLineStyle(), Ie = le.get("distance"), be, Se, Ae = 0; Ae <= de; Ae++) {
        if (be = Math.cos(pe), Se = Math.sin(pe), le.get("show")) {
          var _e = Ie ? Ie + te : te, xe = new Line$3({
            shape: {
              x1: be * (ie - _e) + ne,
              y1: Se * (ie - _e) + ae,
              x2: be * (ie - fe - _e) + ne,
              y2: Se * (ie - fe - _e) + ae
            },
            style: ye,
            silent: !0
          });
          ye.stroke === "auto" && xe.setStyle({
            stroke: W(Ae / de)
          }), re.add(xe);
        }
        if (ce.get("show")) {
          var _e = ce.get("distance") + Ie, Te = formatLabel(round$3(Ae / de * (oe - se) + se), ce.get("formatter")), Pe = W(Ae / de), $e = be * (ie - fe - _e) + ne, Me = Se * (ie - fe - _e) + ae, Ee = ce.get("rotate"), we = 0;
          Ee === "radial" ? (we = -pe + 2 * Math.PI, we > Math.PI / 2 && (we += Math.PI)) : Ee === "tangential" ? we = -pe - Math.PI / 2 : isNumber(Ee) && (we = Ee * Math.PI / 180), we === 0 ? re.add(new ZRText$1({
            style: createTextStyle(ce, {
              text: Te,
              x: $e,
              y: Me,
              verticalAlign: Se < -0.8 ? "top" : Se > 0.8 ? "bottom" : "middle",
              align: be < -0.4 ? "left" : be > 0.4 ? "right" : "center"
            }, {
              inheritColor: Pe
            }),
            silent: !0
          })) : re.add(new ZRText$1({
            style: createTextStyle(ce, {
              text: Te,
              x: $e,
              y: Me,
              verticalAlign: "middle",
              align: "center"
            }, {
              inheritColor: Pe
            }),
            silent: !0,
            originX: $e,
            originY: Me,
            rotation: we
          }));
        }
        if (ue.get("show") && Ae !== de) {
          var _e = ue.get("distance");
          _e = _e ? _e + te : te;
          for (var Oe = 0; Oe <= ge; Oe++) {
            be = Math.cos(pe), Se = Math.sin(pe);
            var Ne = new Line$3({
              shape: {
                x1: be * (ie - _e) + ne,
                y1: Se * (ie - _e) + ae,
                x2: be * (ie - ve - _e) + ne,
                y2: Se * (ie - ve - _e) + ae
              },
              silent: !0,
              style: Ce
            });
            Ce.stroke === "auto" && Ne.setStyle({
              stroke: W((Ae + Oe / ge) / de)
            }), re.add(Ne), pe += me;
          }
          pe -= me;
        } else
          pe += he;
      }
    }, C.prototype._renderPointer = function(G, U, K, W, Z, X, Q, ee, te) {
      var re = this.group, ne = this._data, ae = this._progressEls, ie = [], se = G.get(["pointer", "show"]), oe = G.getModel("progress"), le = oe.get("show"), ue = G.getData(), ce = ue.mapDimension("value"), de = +G.get("min"), ge = +G.get("max"), fe = [de, ge], ve = [X, Q];
      function pe(me, ye) {
        var Ce = ue.getItemModel(me), Ie = Ce.getModel("pointer"), be = parsePercent(Ie.get("width"), Z.r), Se = parsePercent(Ie.get("length"), Z.r), Ae = G.get(["pointer", "icon"]), _e = Ie.get("offsetCenter"), xe = parsePercent(_e[0], Z.r), Te = parsePercent(_e[1], Z.r), Pe = Ie.get("keepAspect"), $e;
        return Ae ? $e = createSymbol$1(Ae, xe - be / 2, Te - Se, be, Se, null, Pe) : $e = new PointerPath$1({
          shape: {
            angle: -Math.PI / 2,
            width: be,
            r: Se,
            x: xe,
            y: Te
          }
        }), $e.rotation = -(ye + Math.PI / 2), $e.x = Z.cx, $e.y = Z.cy, $e;
      }
      function he(me, ye) {
        var Ce = oe.get("roundCap"), Ie = Ce ? Sausage : Sector$1, be = oe.get("overlap"), Se = be ? oe.get("width") : te / ue.count(), Ae = be ? Z.r - Se : Z.r - (me + 1) * Se, _e = be ? Z.r : Z.r - me * Se, xe = new Ie({
          shape: {
            startAngle: X,
            endAngle: ye,
            cx: Z.cx,
            cy: Z.cy,
            clockwise: ee,
            r0: Ae,
            r: _e
          }
        });
        return be && (xe.z2 = ge - ue.get(ce, me) % ge), xe;
      }
      (le || se) && (ue.diff(ne).add(function(me) {
        var ye = ue.get(ce, me);
        if (se) {
          var Ce = pe(me, X);
          initProps(Ce, {
            rotation: -((isNaN(+ye) ? ve[0] : linearMap$2(ye, fe, ve, !0)) + Math.PI / 2)
          }, G), re.add(Ce), ue.setItemGraphicEl(me, Ce);
        }
        if (le) {
          var Ie = he(me, X), be = oe.get("clip");
          initProps(Ie, {
            shape: {
              endAngle: linearMap$2(ye, fe, ve, be)
            }
          }, G), re.add(Ie), setCommonECData(G.seriesIndex, ue.dataType, me, Ie), ie[me] = Ie;
        }
      }).update(function(me, ye) {
        var Ce = ue.get(ce, me);
        if (se) {
          var Ie = ne.getItemGraphicEl(ye), be = Ie ? Ie.rotation : X, Se = pe(me, be);
          Se.rotation = be, updateProps$1(Se, {
            rotation: -((isNaN(+Ce) ? ve[0] : linearMap$2(Ce, fe, ve, !0)) + Math.PI / 2)
          }, G), re.add(Se), ue.setItemGraphicEl(me, Se);
        }
        if (le) {
          var Ae = ae[ye], _e = Ae ? Ae.shape.endAngle : X, xe = he(me, _e), Te = oe.get("clip");
          updateProps$1(xe, {
            shape: {
              endAngle: linearMap$2(Ce, fe, ve, Te)
            }
          }, G), re.add(xe), setCommonECData(G.seriesIndex, ue.dataType, me, xe), ie[me] = xe;
        }
      }).execute(), ue.each(function(me) {
        var ye = ue.getItemModel(me), Ce = ye.getModel("emphasis"), Ie = Ce.get("focus"), be = Ce.get("blurScope"), Se = Ce.get("disabled");
        if (se) {
          var Ae = ue.getItemGraphicEl(me), _e = ue.getItemVisual(me, "style"), xe = _e.fill;
          if (Ae instanceof ZRImage$1) {
            var Te = Ae.style;
            Ae.useStyle(extend({
              image: Te.image,
              x: Te.x,
              y: Te.y,
              width: Te.width,
              height: Te.height
            }, _e));
          } else
            Ae.useStyle(_e), Ae.type !== "pointer" && Ae.setColor(xe);
          Ae.setStyle(ye.getModel(["pointer", "itemStyle"]).getItemStyle()), Ae.style.fill === "auto" && Ae.setStyle("fill", W(linearMap$2(ue.get(ce, me), fe, [0, 1], !0))), Ae.z2EmphasisLift = 0, setStatesStylesFromModel(Ae, ye), toggleHoverEmphasis(Ae, Ie, be, Se);
        }
        if (le) {
          var Pe = ie[me];
          Pe.useStyle(ue.getItemVisual(me, "style")), Pe.setStyle(ye.getModel(["progress", "itemStyle"]).getItemStyle()), Pe.z2EmphasisLift = 0, setStatesStylesFromModel(Pe, ye), toggleHoverEmphasis(Pe, Ie, be, Se);
        }
      }), this._progressEls = ie);
    }, C.prototype._renderAnchor = function(G, U) {
      var K = G.getModel("anchor"), W = K.get("show");
      if (W) {
        var Z = K.get("size"), X = K.get("icon"), Q = K.get("offsetCenter"), ee = K.get("keepAspect"), te = createSymbol$1(X, U.cx - Z / 2 + parsePercent(Q[0], U.r), U.cy - Z / 2 + parsePercent(Q[1], U.r), Z, Z, null, ee);
        te.z2 = K.get("showAbove") ? 1 : 0, te.setStyle(K.getModel("itemStyle").getItemStyle()), this.group.add(te);
      }
    }, C.prototype._renderTitleAndDetail = function(G, U, K, W, Z) {
      var X = this, Q = G.getData(), ee = Q.mapDimension("value"), te = +G.get("min"), re = +G.get("max"), ne = new Group$4(), ae = [], ie = [], se = G.isAnimationEnabled(), oe = G.get(["pointer", "showAbove"]);
      Q.diff(this._data).add(function(le) {
        ae[le] = new ZRText$1({
          silent: !0
        }), ie[le] = new ZRText$1({
          silent: !0
        });
      }).update(function(le, ue) {
        ae[le] = X._titleEls[ue], ie[le] = X._detailEls[ue];
      }).execute(), Q.each(function(le) {
        var ue = Q.getItemModel(le), ce = Q.get(ee, le), de = new Group$4(), ge = W(linearMap$2(ce, [te, re], [0, 1], !0)), fe = ue.getModel("title");
        if (fe.get("show")) {
          var ve = fe.get("offsetCenter"), pe = Z.cx + parsePercent(ve[0], Z.r), he = Z.cy + parsePercent(ve[1], Z.r), me = ae[le];
          me.attr({
            z2: oe ? 0 : 2,
            style: createTextStyle(fe, {
              x: pe,
              y: he,
              text: Q.getName(le),
              align: "center",
              verticalAlign: "middle"
            }, {
              inheritColor: ge
            })
          }), de.add(me);
        }
        var ye = ue.getModel("detail");
        if (ye.get("show")) {
          var Ce = ye.get("offsetCenter"), Ie = Z.cx + parsePercent(Ce[0], Z.r), be = Z.cy + parsePercent(Ce[1], Z.r), Se = parsePercent(ye.get("width"), Z.r), Ae = parsePercent(ye.get("height"), Z.r), _e = G.get(["progress", "show"]) ? Q.getItemVisual(le, "style").fill : ge, me = ie[le], xe = ye.get("formatter");
          me.attr({
            z2: oe ? 0 : 2,
            style: createTextStyle(ye, {
              x: Ie,
              y: be,
              text: formatLabel(ce, xe),
              width: isNaN(Se) ? null : Se,
              height: isNaN(Ae) ? null : Ae,
              align: "center",
              verticalAlign: "middle"
            }, {
              inheritColor: _e
            })
          }), setLabelValueAnimation(me, {
            normal: ye
          }, ce, function(Pe) {
            return formatLabel(Pe, xe);
          }), se && animateLabelValue(me, le, Q, G, {
            getFormattedLabel: function(Pe, $e, Me, Ee, we, Oe) {
              return formatLabel(Oe ? Oe.interpolatedValue : ce, xe);
            }
          }), de.add(me);
        }
        ne.add(de);
      }), this.group.add(ne), this._titleEls = ae, this._detailEls = ie;
    }, C.type = "gauge", C;
  }(ChartView$1)
);
const GaugeView$1 = GaugeView;
var GaugeSeriesModel = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G.visualStyleAccessPath = "itemStyle", G;
    }
    return C.prototype.getInitialData = function(G, U) {
      return createSeriesDataSimply(this, ["value"]);
    }, C.type = "series.gauge", C.defaultOption = {
      // zlevel: 0,
      z: 2,
      colorBy: "data",
      // 默认全局居中
      center: ["50%", "50%"],
      legendHoverLink: !0,
      radius: "75%",
      startAngle: 225,
      endAngle: -45,
      clockwise: !0,
      // 最小值
      min: 0,
      // 最大值
      max: 100,
      // 分割段数，默认为10
      splitNumber: 10,
      // 坐标轴线
      axisLine: {
        // 默认显示，属性show控制显示与否
        show: !0,
        roundCap: !1,
        lineStyle: {
          color: [[1, "#E6EBF8"]],
          width: 10
        }
      },
      // 坐标轴线
      progress: {
        // 默认显示，属性show控制显示与否
        show: !1,
        overlap: !0,
        width: 10,
        roundCap: !1,
        clip: !0
      },
      // 分隔线
      splitLine: {
        // 默认显示，属性show控制显示与否
        show: !0,
        // 属性length控制线长
        length: 10,
        distance: 10,
        // 属性lineStyle（详见lineStyle）控制线条样式
        lineStyle: {
          color: "#63677A",
          width: 3,
          type: "solid"
        }
      },
      // 坐标轴小标记
      axisTick: {
        // 属性show控制显示与否，默认不显示
        show: !0,
        // 每份split细分多少段
        splitNumber: 5,
        // 属性length控制线长
        length: 6,
        distance: 10,
        // 属性lineStyle控制线条样式
        lineStyle: {
          color: "#63677A",
          width: 1,
          type: "solid"
        }
      },
      axisLabel: {
        show: !0,
        distance: 15,
        // formatter: null,
        color: "#464646",
        fontSize: 12,
        rotate: 0
      },
      pointer: {
        icon: null,
        offsetCenter: [0, 0],
        show: !0,
        showAbove: !0,
        length: "60%",
        width: 6,
        keepAspect: !1
      },
      anchor: {
        show: !1,
        showAbove: !1,
        size: 6,
        icon: "circle",
        offsetCenter: [0, 0],
        keepAspect: !1,
        itemStyle: {
          color: "#fff",
          borderWidth: 0,
          borderColor: "#5470c6"
        }
      },
      title: {
        show: !0,
        // x, y，单位px
        offsetCenter: [0, "20%"],
        // 其余属性默认使用全局文本样式，详见TEXTSTYLE
        color: "#464646",
        fontSize: 16,
        valueAnimation: !1
      },
      detail: {
        show: !0,
        backgroundColor: "rgba(0,0,0,0)",
        borderWidth: 0,
        borderColor: "#ccc",
        width: 100,
        height: null,
        padding: [5, 10],
        // x, y，单位px
        offsetCenter: [0, "40%"],
        // formatter: null,
        // 其余属性默认使用全局文本样式，详见TEXTSTYLE
        color: "#464646",
        fontSize: 30,
        fontWeight: "bold",
        lineHeight: 30,
        valueAnimation: !1
      }
    }, C;
  }(SeriesModel$1)
);
const GaugeSeriesModel$1 = GaugeSeriesModel;
function install$E(H) {
  H.registerChartView(GaugeView$1), H.registerSeriesModel(GaugeSeriesModel$1);
}
var opacityAccessPath$1 = ["itemStyle", "opacity"], FunnelPiece = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C(G, U) {
      var K = H.call(this) || this, W = K, Z = new Polyline$3(), X = new ZRText$1();
      return W.setTextContent(X), K.setTextGuideLine(Z), K.updateData(G, U, !0), K;
    }
    return C.prototype.updateData = function(G, U, K) {
      var W = this, Z = G.hostModel, X = G.getItemModel(U), Q = G.getItemLayout(U), ee = X.getModel("emphasis"), te = X.get(opacityAccessPath$1);
      te = te ?? 1, K || saveOldStyle(W), W.useStyle(G.getItemVisual(U, "style")), W.style.lineJoin = "round", K ? (W.setShape({
        points: Q.points
      }), W.style.opacity = 0, initProps(W, {
        style: {
          opacity: te
        }
      }, Z, U)) : updateProps$1(W, {
        style: {
          opacity: te
        },
        shape: {
          points: Q.points
        }
      }, Z, U), setStatesStylesFromModel(W, X), this._updateLabel(G, U), toggleHoverEmphasis(this, ee.get("focus"), ee.get("blurScope"), ee.get("disabled"));
    }, C.prototype._updateLabel = function(G, U) {
      var K = this, W = this.getTextGuideLine(), Z = K.getTextContent(), X = G.hostModel, Q = G.getItemModel(U), ee = G.getItemLayout(U), te = ee.label, re = G.getItemVisual(U, "style"), ne = re.fill;
      setLabelStyle(
        // position will not be used in setLabelStyle
        Z,
        getLabelStatesModels(Q),
        {
          labelFetcher: G.hostModel,
          labelDataIndex: U,
          defaultOpacity: re.opacity,
          defaultText: G.getName(U)
        },
        {
          normal: {
            align: te.textAlign,
            verticalAlign: te.verticalAlign
          }
        }
      ), K.setTextConfig({
        local: !0,
        inside: !!te.inside,
        insideStroke: ne,
        // insideFill: 'auto',
        outsideFill: ne
      });
      var ae = te.linePoints;
      W.setShape({
        points: ae
      }), K.textGuideLineConfig = {
        anchor: ae ? new Point$1(ae[0][0], ae[0][1]) : null
      }, updateProps$1(Z, {
        style: {
          x: te.x,
          y: te.y
        }
      }, X, U), Z.attr({
        rotation: te.rotation,
        originX: te.x,
        originY: te.y,
        z2: 10
      }), setLabelLineStyle(K, getLabelLineStatesModels(Q), {
        // Default use item visual color
        stroke: ne
      });
    }, C;
  }(Polygon$1)
), FunnelView = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G.ignoreLabelLineUpdate = !0, G;
    }
    return C.prototype.render = function(G, U, K) {
      var W = G.getData(), Z = this._data, X = this.group;
      W.diff(Z).add(function(Q) {
        var ee = new FunnelPiece(W, Q);
        W.setItemGraphicEl(Q, ee), X.add(ee);
      }).update(function(Q, ee) {
        var te = Z.getItemGraphicEl(ee);
        te.updateData(W, Q), X.add(te), W.setItemGraphicEl(Q, te);
      }).remove(function(Q) {
        var ee = Z.getItemGraphicEl(Q);
        removeElementWithFadeOut(ee, G, Q);
      }).execute(), this._data = W;
    }, C.prototype.remove = function() {
      this.group.removeAll(), this._data = null;
    }, C.prototype.dispose = function() {
    }, C.type = "funnel", C;
  }(ChartView$1)
);
const FunnelView$1 = FunnelView;
var FunnelSeriesModel = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G;
    }
    return C.prototype.init = function(G) {
      H.prototype.init.apply(this, arguments), this.legendVisualProvider = new LegendVisualProvider$1(bind$1(this.getData, this), bind$1(this.getRawData, this)), this._defaultLabelLine(G);
    }, C.prototype.getInitialData = function(G, U) {
      return createSeriesDataSimply(this, {
        coordDimensions: ["value"],
        encodeDefaulter: curry$1(makeSeriesEncodeForNameBased, this)
      });
    }, C.prototype._defaultLabelLine = function(G) {
      defaultEmphasis(G, "labelLine", ["show"]);
      var U = G.labelLine, K = G.emphasis.labelLine;
      U.show = U.show && G.label.show, K.show = K.show && G.emphasis.label.show;
    }, C.prototype.getDataParams = function(G) {
      var U = this.getData(), K = H.prototype.getDataParams.call(this, G), W = U.mapDimension("value"), Z = U.getSum(W);
      return K.percent = Z ? +(U.get(W, G) / Z * 100).toFixed(2) : 0, K.$vars.push("percent"), K;
    }, C.type = "series.funnel", C.defaultOption = {
      // zlevel: 0,                  // 一级层叠
      z: 2,
      legendHoverLink: !0,
      colorBy: "data",
      left: 80,
      top: 60,
      right: 80,
      bottom: 60,
      // width: {totalWidth} - left - right,
      // height: {totalHeight} - top - bottom,
      // 默认取数据最小最大值
      // min: 0,
      // max: 100,
      minSize: "0%",
      maxSize: "100%",
      sort: "descending",
      orient: "vertical",
      gap: 0,
      funnelAlign: "center",
      label: {
        show: !0,
        position: "outer"
        // formatter: 标签文本格式器，同Tooltip.formatter，不支持异步回调
      },
      labelLine: {
        show: !0,
        length: 20,
        lineStyle: {
          // color: 各异,
          width: 1
        }
      },
      itemStyle: {
        // color: 各异,
        borderColor: "#fff",
        borderWidth: 1
      },
      emphasis: {
        label: {
          show: !0
        }
      },
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      }
    }, C;
  }(SeriesModel$1)
);
const FunnelSeriesModel$1 = FunnelSeriesModel;
function getViewRect$2(H, C) {
  return getLayoutRect(H.getBoxLayoutParams(), {
    width: C.getWidth(),
    height: C.getHeight()
  });
}
function getSortedIndices(H, C) {
  for (var G = H.mapDimension("value"), U = H.mapArray(G, function(Q) {
    return Q;
  }), K = [], W = C === "ascending", Z = 0, X = H.count(); Z < X; Z++)
    K[Z] = Z;
  return isFunction(C) ? K.sort(C) : C !== "none" && K.sort(function(Q, ee) {
    return W ? U[Q] - U[ee] : U[ee] - U[Q];
  }), K;
}
function labelLayout(H) {
  var C = H.hostModel, G = C.get("orient");
  H.each(function(U) {
    var K = H.getItemModel(U), W = K.getModel("label"), Z = W.get("position"), X = K.getModel("labelLine"), Q = H.getItemLayout(U), ee = Q.points, te = Z === "inner" || Z === "inside" || Z === "center" || Z === "insideLeft" || Z === "insideRight", re, ne, ae, ie;
    if (te)
      Z === "insideLeft" ? (ne = (ee[0][0] + ee[3][0]) / 2 + 5, ae = (ee[0][1] + ee[3][1]) / 2, re = "left") : Z === "insideRight" ? (ne = (ee[1][0] + ee[2][0]) / 2 - 5, ae = (ee[1][1] + ee[2][1]) / 2, re = "right") : (ne = (ee[0][0] + ee[1][0] + ee[2][0] + ee[3][0]) / 4, ae = (ee[0][1] + ee[1][1] + ee[2][1] + ee[3][1]) / 4, re = "center"), ie = [[ne, ae], [ne, ae]];
    else {
      var se = void 0, oe = void 0, le = void 0, ue = void 0, ce = X.get("length");
      process.env.NODE_ENV !== "production" && (G === "vertical" && ["top", "bottom"].indexOf(Z) > -1 && (Z = "left", console.warn("Position error: Funnel chart on vertical orient dose not support top and bottom.")), G === "horizontal" && ["left", "right"].indexOf(Z) > -1 && (Z = "bottom", console.warn("Position error: Funnel chart on horizontal orient dose not support left and right."))), Z === "left" ? (se = (ee[3][0] + ee[0][0]) / 2, oe = (ee[3][1] + ee[0][1]) / 2, le = se - ce, ne = le - 5, re = "right") : Z === "right" ? (se = (ee[1][0] + ee[2][0]) / 2, oe = (ee[1][1] + ee[2][1]) / 2, le = se + ce, ne = le + 5, re = "left") : Z === "top" ? (se = (ee[3][0] + ee[0][0]) / 2, oe = (ee[3][1] + ee[0][1]) / 2, ue = oe - ce, ae = ue - 5, re = "center") : Z === "bottom" ? (se = (ee[1][0] + ee[2][0]) / 2, oe = (ee[1][1] + ee[2][1]) / 2, ue = oe + ce, ae = ue + 5, re = "center") : Z === "rightTop" ? (se = G === "horizontal" ? ee[3][0] : ee[1][0], oe = G === "horizontal" ? ee[3][1] : ee[1][1], G === "horizontal" ? (ue = oe - ce, ae = ue - 5, re = "center") : (le = se + ce, ne = le + 5, re = "top")) : Z === "rightBottom" ? (se = ee[2][0], oe = ee[2][1], G === "horizontal" ? (ue = oe + ce, ae = ue + 5, re = "center") : (le = se + ce, ne = le + 5, re = "bottom")) : Z === "leftTop" ? (se = ee[0][0], oe = G === "horizontal" ? ee[0][1] : ee[1][1], G === "horizontal" ? (ue = oe - ce, ae = ue - 5, re = "center") : (le = se - ce, ne = le - 5, re = "right")) : Z === "leftBottom" ? (se = G === "horizontal" ? ee[1][0] : ee[3][0], oe = G === "horizontal" ? ee[1][1] : ee[2][1], G === "horizontal" ? (ue = oe + ce, ae = ue + 5, re = "center") : (le = se - ce, ne = le - 5, re = "right")) : (se = (ee[1][0] + ee[2][0]) / 2, oe = (ee[1][1] + ee[2][1]) / 2, G === "horizontal" ? (ue = oe + ce, ae = ue + 5, re = "center") : (le = se + ce, ne = le + 5, re = "left")), G === "horizontal" ? (le = se, ne = le) : (ue = oe, ae = ue), ie = [[se, oe], [le, ue]];
    }
    Q.label = {
      linePoints: ie,
      x: ne,
      y: ae,
      verticalAlign: "middle",
      textAlign: re,
      inside: te
    };
  });
}
function funnelLayout(H, C) {
  H.eachSeriesByType("funnel", function(G) {
    var U = G.getData(), K = U.mapDimension("value"), W = G.get("sort"), Z = getViewRect$2(G, C), X = G.get("orient"), Q = Z.width, ee = Z.height, te = getSortedIndices(U, W), re = Z.x, ne = Z.y, ae = X === "horizontal" ? [parsePercent(G.get("minSize"), ee), parsePercent(G.get("maxSize"), ee)] : [parsePercent(G.get("minSize"), Q), parsePercent(G.get("maxSize"), Q)], ie = U.getDataExtent(K), se = G.get("min"), oe = G.get("max");
    se == null && (se = Math.min(ie[0], 0)), oe == null && (oe = ie[1]);
    var le = G.get("funnelAlign"), ue = G.get("gap"), ce = X === "horizontal" ? Q : ee, de = (ce - ue * (U.count() - 1)) / U.count(), ge = function(be, Se) {
      if (X === "horizontal") {
        var Ae = U.get(K, be) || 0, _e = linearMap$2(Ae, [se, oe], ae, !0), xe = void 0;
        switch (le) {
          case "top":
            xe = ne;
            break;
          case "center":
            xe = ne + (ee - _e) / 2;
            break;
          case "bottom":
            xe = ne + (ee - _e);
            break;
        }
        return [[Se, xe], [Se, xe + _e]];
      }
      var Te = U.get(K, be) || 0, Pe = linearMap$2(Te, [se, oe], ae, !0), $e;
      switch (le) {
        case "left":
          $e = re;
          break;
        case "center":
          $e = re + (Q - Pe) / 2;
          break;
        case "right":
          $e = re + Q - Pe;
          break;
      }
      return [[$e, Se], [$e + Pe, Se]];
    };
    W === "ascending" && (de = -de, ue = -ue, X === "horizontal" ? re += Q : ne += ee, te = te.reverse());
    for (var fe = 0; fe < te.length; fe++) {
      var ve = te[fe], pe = te[fe + 1], he = U.getItemModel(ve);
      if (X === "horizontal") {
        var me = he.get(["itemStyle", "width"]);
        me == null ? me = de : (me = parsePercent(me, Q), W === "ascending" && (me = -me));
        var ye = ge(ve, re), Ce = ge(pe, re + me);
        re += me + ue, U.setItemLayout(ve, {
          points: ye.concat(Ce.slice().reverse())
        });
      } else {
        var Ie = he.get(["itemStyle", "height"]);
        Ie == null ? Ie = de : (Ie = parsePercent(Ie, ee), W === "ascending" && (Ie = -Ie));
        var ye = ge(ve, ne), Ce = ge(pe, ne + Ie);
        ne += Ie + ue, U.setItemLayout(ve, {
          points: ye.concat(Ce.slice().reverse())
        });
      }
    }
    labelLayout(U);
  });
}
function install$D(H) {
  H.registerChartView(FunnelView$1), H.registerSeriesModel(FunnelSeriesModel$1), H.registerLayout(funnelLayout), H.registerProcessor(dataFilter$1("funnel"));
}
var DEFAULT_SMOOTH = 0.3, ParallelView$2 = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G._dataGroup = new Group$4(), G._initialized = !1, G;
    }
    return C.prototype.init = function() {
      this.group.add(this._dataGroup);
    }, C.prototype.render = function(G, U, K, W) {
      this._progressiveEls = null;
      var Z = this._dataGroup, X = G.getData(), Q = this._data, ee = G.coordinateSystem, te = ee.dimensions, re = makeSeriesScope(G);
      X.diff(Q).add(ne).update(ae).remove(ie).execute();
      function ne(oe) {
        var le = addEl(X, Z, oe, te, ee);
        updateElCommon(le, X, oe, re);
      }
      function ae(oe, le) {
        var ue = Q.getItemGraphicEl(le), ce = createLinePoints(X, oe, te, ee);
        X.setItemGraphicEl(oe, ue), updateProps$1(ue, {
          shape: {
            points: ce
          }
        }, G, oe), saveOldStyle(ue), updateElCommon(ue, X, oe, re);
      }
      function ie(oe) {
        var le = Q.getItemGraphicEl(oe);
        Z.remove(le);
      }
      if (!this._initialized) {
        this._initialized = !0;
        var se = createGridClipShape$2(ee, G, function() {
          setTimeout(function() {
            Z.removeClipPath();
          });
        });
        Z.setClipPath(se);
      }
      this._data = X;
    }, C.prototype.incrementalPrepareRender = function(G, U, K) {
      this._initialized = !0, this._data = null, this._dataGroup.removeAll();
    }, C.prototype.incrementalRender = function(G, U, K) {
      for (var W = U.getData(), Z = U.coordinateSystem, X = Z.dimensions, Q = makeSeriesScope(U), ee = this._progressiveEls = [], te = G.start; te < G.end; te++) {
        var re = addEl(W, this._dataGroup, te, X, Z);
        re.incremental = !0, updateElCommon(re, W, te, Q), ee.push(re);
      }
    }, C.prototype.remove = function() {
      this._dataGroup && this._dataGroup.removeAll(), this._data = null;
    }, C.type = "parallel", C;
  }(ChartView$1)
);
function createGridClipShape$2(H, C, G) {
  var U = H.model, K = H.getRect(), W = new Rect$3({
    shape: {
      x: K.x,
      y: K.y,
      width: K.width,
      height: K.height
    }
  }), Z = U.get("layout") === "horizontal" ? "width" : "height";
  return W.setShape(Z, 0), initProps(W, {
    shape: {
      width: K.width,
      height: K.height
    }
  }, C, G), W;
}
function createLinePoints(H, C, G, U) {
  for (var K = [], W = 0; W < G.length; W++) {
    var Z = G[W], X = H.get(H.mapDimension(Z), C);
    isEmptyValue(X, U.getAxis(Z).type) || K.push(U.dataToPoint(X, Z));
  }
  return K;
}
function addEl(H, C, G, U, K) {
  var W = createLinePoints(H, G, U, K), Z = new Polyline$3({
    shape: {
      points: W
    },
    // silent: true,
    z2: 10
  });
  return C.add(Z), H.setItemGraphicEl(G, Z), Z;
}
function makeSeriesScope(H) {
  var C = H.get("smooth", !0);
  return C === !0 && (C = DEFAULT_SMOOTH), C = numericToNumber(C), eqNaN(C) && (C = 0), {
    smooth: C
  };
}
function updateElCommon(H, C, G, U) {
  H.useStyle(C.getItemVisual(G, "style")), H.style.fill = null, H.setShape("smooth", U.smooth);
  var K = C.getItemModel(G), W = K.getModel("emphasis");
  setStatesStylesFromModel(H, K, "lineStyle"), toggleHoverEmphasis(H, W.get("focus"), W.get("blurScope"), W.get("disabled"));
}
function isEmptyValue(H, C) {
  return C === "category" ? H == null : H == null || isNaN(H);
}
const ParallelView$3 = ParallelView$2;
var ParallelSeriesModel = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G.visualStyleAccessPath = "lineStyle", G.visualDrawType = "stroke", G;
    }
    return C.prototype.getInitialData = function(G, U) {
      return createSeriesData(null, this, {
        useEncodeDefaulter: bind$1(makeDefaultEncode, null, this)
      });
    }, C.prototype.getRawIndicesByActiveState = function(G) {
      var U = this.coordinateSystem, K = this.getData(), W = [];
      return U.eachActiveState(K, function(Z, X) {
        G === Z && W.push(K.getRawIndex(X));
      }), W;
    }, C.type = "series.parallel", C.dependencies = ["parallel"], C.defaultOption = {
      // zlevel: 0,
      z: 2,
      coordinateSystem: "parallel",
      parallelIndex: 0,
      label: {
        show: !1
      },
      inactiveOpacity: 0.05,
      activeOpacity: 1,
      lineStyle: {
        width: 1,
        opacity: 0.45,
        type: "solid"
      },
      emphasis: {
        label: {
          show: !1
        }
      },
      progressive: 500,
      smooth: !1,
      animationEasing: "linear"
    }, C;
  }(SeriesModel$1)
);
function makeDefaultEncode(H) {
  var C = H.ecModel.getComponent("parallel", H.get("parallelIndex"));
  if (C) {
    var G = {};
    return each$f(C.dimensions, function(U) {
      var K = convertDimNameToNumber(U);
      G[U] = K;
    }), G;
  }
}
function convertDimNameToNumber(H) {
  return +H.replace("dim", "");
}
const ParallelSeriesModel$1 = ParallelSeriesModel;
var opacityAccessPath = ["lineStyle", "opacity"], parallelVisual = {
  seriesType: "parallel",
  reset: function(H, C) {
    var G = H.coordinateSystem, U = {
      normal: H.get(["lineStyle", "opacity"]),
      active: H.get("activeOpacity"),
      inactive: H.get("inactiveOpacity")
    };
    return {
      progress: function(K, W) {
        G.eachActiveState(W, function(Z, X) {
          var Q = U[Z];
          if (Z === "normal" && W.hasItemOption) {
            var ee = W.getItemModel(X).get(opacityAccessPath, !0);
            ee != null && (Q = ee);
          }
          var te = W.ensureUniqueItemVisual(X, "style");
          te.opacity = Q;
        }, K.start, K.end);
      }
    };
  }
};
const parallelVisual$1 = parallelVisual;
function parallelPreprocessor(H) {
  createParallelIfNeeded(H), mergeAxisOptionFromParallel(H);
}
function createParallelIfNeeded(H) {
  if (!H.parallel) {
    var C = !1;
    each$f(H.series, function(G) {
      G && G.type === "parallel" && (C = !0);
    }), C && (H.parallel = [{}]);
  }
}
function mergeAxisOptionFromParallel(H) {
  var C = normalizeToArray(H.parallelAxis);
  each$f(C, function(G) {
    if (isObject$3(G)) {
      var U = G.parallelIndex || 0, K = normalizeToArray(H.parallel)[U];
      K && K.parallelAxisDefault && merge(G, K.parallelAxisDefault, !1);
    }
  });
}
var CLICK_THRESHOLD = 5, ParallelView = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G;
    }
    return C.prototype.render = function(G, U, K) {
      this._model = G, this._api = K, this._handlers || (this._handlers = {}, each$f(handlers$1, function(W, Z) {
        K.getZr().on(Z, this._handlers[Z] = bind$1(W, this));
      }, this)), createOrUpdate(this, "_throttledDispatchExpand", G.get("axisExpandRate"), "fixRate");
    }, C.prototype.dispose = function(G, U) {
      clear$1(this, "_throttledDispatchExpand"), each$f(this._handlers, function(K, W) {
        U.getZr().off(W, K);
      }), this._handlers = null;
    }, C.prototype._throttledDispatchExpand = function(G) {
      this._dispatchExpand(G);
    }, C.prototype._dispatchExpand = function(G) {
      G && this._api.dispatchAction(extend({
        type: "parallelAxisExpand"
      }, G));
    }, C.type = "parallel", C;
  }(ComponentView$1)
), handlers$1 = {
  mousedown: function(H) {
    checkTrigger(this, "click") && (this._mouseDownPoint = [H.offsetX, H.offsetY]);
  },
  mouseup: function(H) {
    var C = this._mouseDownPoint;
    if (checkTrigger(this, "click") && C) {
      var G = [H.offsetX, H.offsetY], U = Math.pow(C[0] - G[0], 2) + Math.pow(C[1] - G[1], 2);
      if (U > CLICK_THRESHOLD)
        return;
      var K = this._model.coordinateSystem.getSlidedAxisExpandWindow([H.offsetX, H.offsetY]);
      K.behavior !== "none" && this._dispatchExpand({
        axisExpandWindow: K.axisExpandWindow
      });
    }
    this._mouseDownPoint = null;
  },
  mousemove: function(H) {
    if (!(this._mouseDownPoint || !checkTrigger(this, "mousemove"))) {
      var C = this._model, G = C.coordinateSystem.getSlidedAxisExpandWindow([H.offsetX, H.offsetY]), U = G.behavior;
      U === "jump" && this._throttledDispatchExpand.debounceNextCall(C.get("axisExpandDebounce")), this._throttledDispatchExpand(U === "none" ? null : {
        axisExpandWindow: G.axisExpandWindow,
        // Jumping uses animation, and sliding suppresses animation.
        animation: U === "jump" ? null : {
          duration: 0
          // Disable animation.
        }
      });
    }
  }
};
function checkTrigger(H, C) {
  var G = H._model;
  return G.get("axisExpandable") && G.get("axisExpandTriggerOn") === C;
}
const ParallelView$1 = ParallelView;
var ParallelModel = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G;
    }
    return C.prototype.init = function() {
      H.prototype.init.apply(this, arguments), this.mergeOption({});
    }, C.prototype.mergeOption = function(G) {
      var U = this.option;
      G && merge(U, G, !0), this._initDimensions();
    }, C.prototype.contains = function(G, U) {
      var K = G.get("parallelIndex");
      return K != null && U.getComponent("parallel", K) === this;
    }, C.prototype.setAxisExpand = function(G) {
      each$f(["axisExpandable", "axisExpandCenter", "axisExpandCount", "axisExpandWidth", "axisExpandWindow"], function(U) {
        G.hasOwnProperty(U) && (this.option[U] = G[U]);
      }, this);
    }, C.prototype._initDimensions = function() {
      var G = this.dimensions = [], U = this.parallelAxisIndex = [], K = filter(this.ecModel.queryComponents({
        mainType: "parallelAxis"
      }), function(W) {
        return (W.get("parallelIndex") || 0) === this.componentIndex;
      }, this);
      each$f(K, function(W) {
        G.push("dim" + W.get("dim")), U.push(W.componentIndex);
      });
    }, C.type = "parallel", C.dependencies = ["parallelAxis"], C.layoutMode = "box", C.defaultOption = {
      // zlevel: 0,
      z: 0,
      left: 80,
      top: 60,
      right: 80,
      bottom: 60,
      // width: {totalWidth} - left - right,
      // height: {totalHeight} - top - bottom,
      layout: "horizontal",
      // FIXME
      // naming?
      axisExpandable: !1,
      axisExpandCenter: null,
      axisExpandCount: 0,
      axisExpandWidth: 50,
      axisExpandRate: 17,
      axisExpandDebounce: 50,
      // [out, in, jumpTarget]. In percentage. If use [null, 0.05], null means full.
      // Do not doc to user until necessary.
      axisExpandSlideTriggerArea: [-0.15, 0.05, 0.4],
      axisExpandTriggerOn: "click",
      parallelAxisDefault: null
    }, C;
  }(ComponentModel$1)
);
const ParallelModel$1 = ParallelModel;
var ParallelAxis = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C(G, U, K, W, Z) {
      var X = H.call(this, G, U, K) || this;
      return X.type = W || "value", X.axisIndex = Z, X;
    }
    return C.prototype.isHorizontal = function() {
      return this.coordinateSystem.getModel().get("layout") !== "horizontal";
    }, C;
  }(Axis$1)
);
const ParallelAxis$1 = ParallelAxis;
function sliderMove(H, C, G, U, K, W) {
  H = H || 0;
  var Z = G[1] - G[0];
  if (K != null && (K = restrict$1(K, [0, Z])), W != null && (W = Math.max(W, K ?? 0)), U === "all") {
    var X = Math.abs(C[1] - C[0]);
    X = restrict$1(X, [0, Z]), K = W = restrict$1(X, [K, W]), U = 0;
  }
  C[0] = restrict$1(C[0], G), C[1] = restrict$1(C[1], G);
  var Q = getSpanSign(C, U);
  C[U] += H;
  var ee = K || 0, te = G.slice();
  Q.sign < 0 ? te[0] += ee : te[1] -= ee, C[U] = restrict$1(C[U], te);
  var re;
  return re = getSpanSign(C, U), K != null && (re.sign !== Q.sign || re.span < K) && (C[1 - U] = C[U] + Q.sign * K), re = getSpanSign(C, U), W != null && re.span > W && (C[1 - U] = C[U] + re.sign * W), C;
}
function getSpanSign(H, C) {
  var G = H[C] - H[1 - C];
  return {
    span: Math.abs(G),
    sign: G > 0 ? -1 : G < 0 ? 1 : C ? -1 : 1
  };
}
function restrict$1(H, C) {
  return Math.min(C[1] != null ? C[1] : 1 / 0, Math.max(C[0] != null ? C[0] : -1 / 0, H));
}
var each$a = each$f, mathMin$2 = Math.min, mathMax$2 = Math.max, mathFloor = Math.floor, mathCeil = Math.ceil, round = round$3, PI$1 = Math.PI, Parallel = (
  /** @class */
  function() {
    function H(C, G, U) {
      this.type = "parallel", this._axesMap = createHashMap(), this._axesLayout = {}, this.dimensions = C.dimensions, this._model = C, this._init(C, G, U);
    }
    return H.prototype._init = function(C, G, U) {
      var K = C.dimensions, W = C.parallelAxisIndex;
      each$a(K, function(Z, X) {
        var Q = W[X], ee = G.getComponent("parallelAxis", Q), te = this._axesMap.set(Z, new ParallelAxis$1(Z, createScaleByModel$1(ee), [0, 0], ee.get("type"), Q)), re = te.type === "category";
        te.onBand = re && ee.get("boundaryGap"), te.inverse = ee.get("inverse"), ee.axis = te, te.model = ee, te.coordinateSystem = ee.coordinateSystem = this;
      }, this);
    }, H.prototype.update = function(C, G) {
      this._updateAxesFromSeries(this._model, C);
    }, H.prototype.containPoint = function(C) {
      var G = this._makeLayoutInfo(), U = G.axisBase, K = G.layoutBase, W = G.pixelDimIndex, Z = C[1 - W], X = C[W];
      return Z >= U && Z <= U + G.axisLength && X >= K && X <= K + G.layoutLength;
    }, H.prototype.getModel = function() {
      return this._model;
    }, H.prototype._updateAxesFromSeries = function(C, G) {
      G.eachSeries(function(U) {
        if (C.contains(U, G)) {
          var K = U.getData();
          each$a(this.dimensions, function(W) {
            var Z = this._axesMap.get(W);
            Z.scale.unionExtentFromData(K, K.mapDimension(W)), niceScaleExtent(Z.scale, Z.model);
          }, this);
        }
      }, this);
    }, H.prototype.resize = function(C, G) {
      this._rect = getLayoutRect(C.getBoxLayoutParams(), {
        width: G.getWidth(),
        height: G.getHeight()
      }), this._layoutAxes();
    }, H.prototype.getRect = function() {
      return this._rect;
    }, H.prototype._makeLayoutInfo = function() {
      var C = this._model, G = this._rect, U = ["x", "y"], K = ["width", "height"], W = C.get("layout"), Z = W === "horizontal" ? 0 : 1, X = G[K[Z]], Q = [0, X], ee = this.dimensions.length, te = restrict(C.get("axisExpandWidth"), Q), re = restrict(C.get("axisExpandCount") || 0, [0, ee]), ne = C.get("axisExpandable") && ee > 3 && ee > re && re > 1 && te > 0 && X > 0, ae = C.get("axisExpandWindow"), ie;
      if (ae)
        ie = restrict(ae[1] - ae[0], Q), ae[1] = ae[0] + ie;
      else {
        ie = restrict(te * (re - 1), Q);
        var se = C.get("axisExpandCenter") || mathFloor(ee / 2);
        ae = [te * se - ie / 2], ae[1] = ae[0] + ie;
      }
      var oe = (X - ie) / (ee - re);
      oe < 3 && (oe = 0);
      var le = [mathFloor(round(ae[0] / te, 1)) + 1, mathCeil(round(ae[1] / te, 1)) - 1], ue = oe / te * ae[0];
      return {
        layout: W,
        pixelDimIndex: Z,
        layoutBase: G[U[Z]],
        layoutLength: X,
        axisBase: G[U[1 - Z]],
        axisLength: G[K[1 - Z]],
        axisExpandable: ne,
        axisExpandWidth: te,
        axisCollapseWidth: oe,
        axisExpandWindow: ae,
        axisCount: ee,
        winInnerIndices: le,
        axisExpandWindow0Pos: ue
      };
    }, H.prototype._layoutAxes = function() {
      var C = this._rect, G = this._axesMap, U = this.dimensions, K = this._makeLayoutInfo(), W = K.layout;
      G.each(function(Z) {
        var X = [0, K.axisLength], Q = Z.inverse ? 1 : 0;
        Z.setExtent(X[Q], X[1 - Q]);
      }), each$a(U, function(Z, X) {
        var Q = (K.axisExpandable ? layoutAxisWithExpand : layoutAxisWithoutExpand)(X, K), ee = {
          horizontal: {
            x: Q.position,
            y: K.axisLength
          },
          vertical: {
            x: 0,
            y: Q.position
          }
        }, te = {
          horizontal: PI$1 / 2,
          vertical: 0
        }, re = [ee[W].x + C.x, ee[W].y + C.y], ne = te[W], ae = create$1();
        rotate(ae, ae, ne), translate(ae, ae, re), this._axesLayout[Z] = {
          position: re,
          rotation: ne,
          transform: ae,
          axisNameAvailableWidth: Q.axisNameAvailableWidth,
          axisLabelShow: Q.axisLabelShow,
          nameTruncateMaxWidth: Q.nameTruncateMaxWidth,
          tickDirection: 1,
          labelDirection: 1
        };
      }, this);
    }, H.prototype.getAxis = function(C) {
      return this._axesMap.get(C);
    }, H.prototype.dataToPoint = function(C, G) {
      return this.axisCoordToPoint(this._axesMap.get(G).dataToCoord(C), G);
    }, H.prototype.eachActiveState = function(C, G, U, K) {
      U == null && (U = 0), K == null && (K = C.count());
      var W = this._axesMap, Z = this.dimensions, X = [], Q = [];
      each$f(Z, function(oe) {
        X.push(C.mapDimension(oe)), Q.push(W.get(oe).model);
      });
      for (var ee = this.hasAxisBrushed(), te = U; te < K; te++) {
        var re = void 0;
        if (!ee)
          re = "normal";
        else {
          re = "active";
          for (var ne = C.getValues(X, te), ae = 0, ie = Z.length; ae < ie; ae++) {
            var se = Q[ae].getActiveState(ne[ae]);
            if (se === "inactive") {
              re = "inactive";
              break;
            }
          }
        }
        G(re, te);
      }
    }, H.prototype.hasAxisBrushed = function() {
      for (var C = this.dimensions, G = this._axesMap, U = !1, K = 0, W = C.length; K < W; K++)
        G.get(C[K]).model.getActiveState() !== "normal" && (U = !0);
      return U;
    }, H.prototype.axisCoordToPoint = function(C, G) {
      var U = this._axesLayout[G];
      return applyTransform([C, 0], U.transform);
    }, H.prototype.getAxisLayout = function(C) {
      return clone$4(this._axesLayout[C]);
    }, H.prototype.getSlidedAxisExpandWindow = function(C) {
      var G = this._makeLayoutInfo(), U = G.pixelDimIndex, K = G.axisExpandWindow.slice(), W = K[1] - K[0], Z = [0, G.axisExpandWidth * (G.axisCount - 1)];
      if (!this.containPoint(C))
        return {
          behavior: "none",
          axisExpandWindow: K
        };
      var X = C[U] - G.layoutBase - G.axisExpandWindow0Pos, Q, ee = "slide", te = G.axisCollapseWidth, re = this._model.get("axisExpandSlideTriggerArea"), ne = re[0] != null;
      if (te)
        ne && te && X < W * re[0] ? (ee = "jump", Q = X - W * re[2]) : ne && te && X > W * (1 - re[0]) ? (ee = "jump", Q = X - W * (1 - re[2])) : (Q = X - W * re[1]) >= 0 && (Q = X - W * (1 - re[1])) <= 0 && (Q = 0), Q *= G.axisExpandWidth / te, Q ? sliderMove(Q, K, Z, "all") : ee = "none";
      else {
        var ae = K[1] - K[0], ie = Z[1] * X / ae;
        K = [mathMax$2(0, ie - ae / 2)], K[1] = mathMin$2(Z[1], K[0] + ae), K[0] = K[1] - ae;
      }
      return {
        axisExpandWindow: K,
        behavior: ee
      };
    }, H;
  }()
);
function restrict(H, C) {
  return mathMin$2(mathMax$2(H, C[0]), C[1]);
}
function layoutAxisWithoutExpand(H, C) {
  var G = C.layoutLength / (C.axisCount - 1);
  return {
    position: G * H,
    axisNameAvailableWidth: G,
    axisLabelShow: !0
  };
}
function layoutAxisWithExpand(H, C) {
  var G = C.layoutLength, U = C.axisExpandWidth, K = C.axisCount, W = C.axisCollapseWidth, Z = C.winInnerIndices, X, Q = W, ee = !1, te;
  return H < Z[0] ? (X = H * W, te = W) : H <= Z[1] ? (X = C.axisExpandWindow0Pos + H * U - C.axisExpandWindow[0], Q = U, ee = !0) : (X = G - (K - 1 - H) * W, te = W), {
    position: X,
    axisNameAvailableWidth: Q,
    axisLabelShow: ee,
    nameTruncateMaxWidth: te
  };
}
const Parallel$1 = Parallel;
function createParallelCoordSys(H, C) {
  var G = [];
  return H.eachComponent("parallel", function(U, K) {
    var W = new Parallel$1(U, H, C);
    W.name = "parallel_" + K, W.resize(U, C), U.coordinateSystem = W, W.model = U, G.push(W);
  }), H.eachSeries(function(U) {
    if (U.get("coordinateSystem") === "parallel") {
      var K = U.getReferringComponents("parallel", SINGLE_REFERRING).models[0];
      U.coordinateSystem = K.coordinateSystem;
    }
  }), G;
}
var parallelCoordSysCreator = {
  create: createParallelCoordSys
};
const parallelCoordSysCreator$1 = parallelCoordSysCreator;
var ParallelAxisModel = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G.activeIntervals = [], G;
    }
    return C.prototype.getAreaSelectStyle = function() {
      return makeStyleMapper([
        ["fill", "color"],
        ["lineWidth", "borderWidth"],
        ["stroke", "borderColor"],
        ["width", "width"],
        ["opacity", "opacity"]
        // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
        // So do not transfer decal directly.
      ])(this.getModel("areaSelectStyle"));
    }, C.prototype.setActiveIntervals = function(G) {
      var U = this.activeIntervals = clone$4(G);
      if (U)
        for (var K = U.length - 1; K >= 0; K--)
          asc$2(U[K]);
    }, C.prototype.getActiveState = function(G) {
      var U = this.activeIntervals;
      if (!U.length)
        return "normal";
      if (G == null || isNaN(+G))
        return "inactive";
      if (U.length === 1) {
        var K = U[0];
        if (K[0] <= G && G <= K[1])
          return "active";
      } else
        for (var W = 0, Z = U.length; W < Z; W++)
          if (U[W][0] <= G && G <= U[W][1])
            return "active";
      return "inactive";
    }, C;
  }(ComponentModel$1)
);
mixin(ParallelAxisModel, AxisModelCommonMixin);
const ParallelAxisModel$1 = ParallelAxisModel;
var BRUSH_PANEL_GLOBAL = !0, mathMin$1 = Math.min, mathMax$1 = Math.max, mathPow = Math.pow, COVER_Z = 1e4, UNSELECT_THRESHOLD = 6, MIN_RESIZE_LINE_WIDTH = 6, MUTEX_RESOURCE_KEY = "globalPan", DIRECTION_MAP = {
  w: [0, 0],
  e: [0, 1],
  n: [1, 0],
  s: [1, 1]
}, CURSOR_MAP = {
  w: "ew",
  e: "ew",
  n: "ns",
  s: "ns",
  ne: "nesw",
  sw: "nesw",
  nw: "nwse",
  se: "nwse"
}, DEFAULT_BRUSH_OPT = {
  brushStyle: {
    lineWidth: 2,
    stroke: "rgba(210,219,238,0.3)",
    fill: "#D2DBEE"
  },
  transformable: !0,
  brushMode: "single",
  removeOnClick: !1
}, baseUID = 0, BrushController = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C(G) {
      var U = H.call(this) || this;
      return U._track = [], U._covers = [], U._handlers = {}, process.env.NODE_ENV !== "production" && assert(G), U._zr = G, U.group = new Group$4(), U._uid = "brushController_" + baseUID++, each$f(pointerHandlers, function(K, W) {
        this._handlers[W] = bind$1(K, this);
      }, U), U;
    }
    return C.prototype.enableBrush = function(G) {
      return process.env.NODE_ENV !== "production" && assert(this._mounted), this._brushType && this._doDisableBrush(), G.brushType && this._doEnableBrush(G), this;
    }, C.prototype._doEnableBrush = function(G) {
      var U = this._zr;
      this._enableGlobalPan || take(U, MUTEX_RESOURCE_KEY, this._uid), each$f(this._handlers, function(K, W) {
        U.on(W, K);
      }), this._brushType = G.brushType, this._brushOption = merge(clone$4(DEFAULT_BRUSH_OPT), G, !0);
    }, C.prototype._doDisableBrush = function() {
      var G = this._zr;
      release(G, MUTEX_RESOURCE_KEY, this._uid), each$f(this._handlers, function(U, K) {
        G.off(K, U);
      }), this._brushType = this._brushOption = null;
    }, C.prototype.setPanels = function(G) {
      if (G && G.length) {
        var U = this._panels = {};
        each$f(G, function(K) {
          U[K.panelId] = clone$4(K);
        });
      } else
        this._panels = null;
      return this;
    }, C.prototype.mount = function(G) {
      G = G || {}, process.env.NODE_ENV !== "production" && (this._mounted = !0), this._enableGlobalPan = G.enableGlobalPan;
      var U = this.group;
      return this._zr.add(U), U.attr({
        x: G.x || 0,
        y: G.y || 0,
        rotation: G.rotation || 0,
        scaleX: G.scaleX || 1,
        scaleY: G.scaleY || 1
      }), this._transform = U.getLocalTransform(), this;
    }, C.prototype.updateCovers = function(G) {
      process.env.NODE_ENV !== "production" && assert(this._mounted), G = map$1(G, function(ne) {
        return merge(clone$4(DEFAULT_BRUSH_OPT), ne, !0);
      });
      var U = "\0-brush-index-", K = this._covers, W = this._covers = [], Z = this, X = this._creatingCover;
      return new DataDiffer$1(K, G, ee, Q).add(te).update(te).remove(re).execute(), this;
      function Q(ne, ae) {
        return (ne.id != null ? ne.id : U + ae) + "-" + ne.brushType;
      }
      function ee(ne, ae) {
        return Q(ne.__brushOption, ae);
      }
      function te(ne, ae) {
        var ie = G[ne];
        if (ae != null && K[ae] === X)
          W[ne] = K[ae];
        else {
          var se = W[ne] = ae != null ? (K[ae].__brushOption = ie, K[ae]) : endCreating(Z, createCover(Z, ie));
          updateCoverAfterCreation(Z, se);
        }
      }
      function re(ne) {
        K[ne] !== X && Z.group.remove(K[ne]);
      }
    }, C.prototype.unmount = function() {
      if (!(process.env.NODE_ENV !== "production" && !this._mounted))
        return this.enableBrush(!1), clearCovers(this), this._zr.remove(this.group), process.env.NODE_ENV !== "production" && (this._mounted = !1), this;
    }, C.prototype.dispose = function() {
      this.unmount(), this.off();
    }, C;
  }(Eventful$1)
);
function createCover(H, C) {
  var G = coverRenderers[C.brushType].createCover(H, C);
  return G.__brushOption = C, updateZ$1(G, C), H.group.add(G), G;
}
function endCreating(H, C) {
  var G = getCoverRenderer(C);
  return G.endCreating && (G.endCreating(H, C), updateZ$1(C, C.__brushOption)), C;
}
function updateCoverShape(H, C) {
  var G = C.__brushOption;
  getCoverRenderer(C).updateCoverShape(H, C, G.range, G);
}
function updateZ$1(H, C) {
  var G = C.z;
  G == null && (G = COVER_Z), H.traverse(function(U) {
    U.z = G, U.z2 = G;
  });
}
function updateCoverAfterCreation(H, C) {
  getCoverRenderer(C).updateCommon(H, C), updateCoverShape(H, C);
}
function getCoverRenderer(H) {
  return coverRenderers[H.__brushOption.brushType];
}
function getPanelByPoint(H, C, G) {
  var U = H._panels;
  if (!U)
    return BRUSH_PANEL_GLOBAL;
  var K, W = H._transform;
  return each$f(U, function(Z) {
    Z.isTargetByCursor(C, G, W) && (K = Z);
  }), K;
}
function getPanelByCover(H, C) {
  var G = H._panels;
  if (!G)
    return BRUSH_PANEL_GLOBAL;
  var U = C.__brushOption.panelId;
  return U != null ? G[U] : BRUSH_PANEL_GLOBAL;
}
function clearCovers(H) {
  var C = H._covers, G = C.length;
  return each$f(C, function(U) {
    H.group.remove(U);
  }, H), C.length = 0, !!G;
}
function trigger(H, C) {
  var G = map$1(H._covers, function(U) {
    var K = U.__brushOption, W = clone$4(K.range);
    return {
      brushType: K.brushType,
      panelId: K.panelId,
      range: W
    };
  });
  H.trigger("brush", {
    areas: G,
    isEnd: !!C.isEnd,
    removeOnClick: !!C.removeOnClick
  });
}
function shouldShowCover(H) {
  var C = H._track;
  if (!C.length)
    return !1;
  var G = C[C.length - 1], U = C[0], K = G[0] - U[0], W = G[1] - U[1], Z = mathPow(K * K + W * W, 0.5);
  return Z > UNSELECT_THRESHOLD;
}
function getTrackEnds(H) {
  var C = H.length - 1;
  return C < 0 && (C = 0), [H[0], H[C]];
}
function createBaseRectCover(H, C, G, U) {
  var K = new Group$4();
  return K.add(new Rect$3({
    name: "main",
    style: makeStyle(G),
    silent: !0,
    draggable: !0,
    cursor: "move",
    drift: curry$1(driftRect, H, C, K, ["n", "s", "w", "e"]),
    ondragend: curry$1(trigger, C, {
      isEnd: !0
    })
  })), each$f(U, function(W) {
    K.add(new Rect$3({
      name: W.join(""),
      style: {
        opacity: 0
      },
      draggable: !0,
      silent: !0,
      invisible: !0,
      drift: curry$1(driftRect, H, C, K, W),
      ondragend: curry$1(trigger, C, {
        isEnd: !0
      })
    }));
  }), K;
}
function updateBaseRect(H, C, G, U) {
  var K = U.brushStyle.lineWidth || 0, W = mathMax$1(K, MIN_RESIZE_LINE_WIDTH), Z = G[0][0], X = G[1][0], Q = Z - K / 2, ee = X - K / 2, te = G[0][1], re = G[1][1], ne = te - W + K / 2, ae = re - W + K / 2, ie = te - Z, se = re - X, oe = ie + K, le = se + K;
  updateRectShape(H, C, "main", Z, X, ie, se), U.transformable && (updateRectShape(H, C, "w", Q, ee, W, le), updateRectShape(H, C, "e", ne, ee, W, le), updateRectShape(H, C, "n", Q, ee, oe, W), updateRectShape(H, C, "s", Q, ae, oe, W), updateRectShape(H, C, "nw", Q, ee, W, W), updateRectShape(H, C, "ne", ne, ee, W, W), updateRectShape(H, C, "sw", Q, ae, W, W), updateRectShape(H, C, "se", ne, ae, W, W));
}
function updateCommon$1(H, C) {
  var G = C.__brushOption, U = G.transformable, K = C.childAt(0);
  K.useStyle(makeStyle(G)), K.attr({
    silent: !U,
    cursor: U ? "move" : "default"
  }), each$f([["w"], ["e"], ["n"], ["s"], ["s", "e"], ["s", "w"], ["n", "e"], ["n", "w"]], function(W) {
    var Z = C.childOfName(W.join("")), X = W.length === 1 ? getGlobalDirection1(H, W[0]) : getGlobalDirection2(H, W);
    Z && Z.attr({
      silent: !U,
      invisible: !U,
      cursor: U ? CURSOR_MAP[X] + "-resize" : null
    });
  });
}
function updateRectShape(H, C, G, U, K, W, Z) {
  var X = C.childOfName(G);
  X && X.setShape(pointsToRect(clipByPanel(H, C, [[U, K], [U + W, K + Z]])));
}
function makeStyle(H) {
  return defaults({
    strokeNoScale: !0
  }, H.brushStyle);
}
function formatRectRange(H, C, G, U) {
  var K = [mathMin$1(H, G), mathMin$1(C, U)], W = [mathMax$1(H, G), mathMax$1(C, U)];
  return [
    [K[0], W[0]],
    [K[1], W[1]]
    // y range
  ];
}
function getTransform(H) {
  return getTransform$1(H.group);
}
function getGlobalDirection1(H, C) {
  var G = {
    w: "left",
    e: "right",
    n: "top",
    s: "bottom"
  }, U = {
    left: "w",
    right: "e",
    top: "n",
    bottom: "s"
  }, K = transformDirection(G[C], getTransform(H));
  return U[K];
}
function getGlobalDirection2(H, C) {
  var G = [getGlobalDirection1(H, C[0]), getGlobalDirection1(H, C[1])];
  return (G[0] === "e" || G[0] === "w") && G.reverse(), G.join("");
}
function driftRect(H, C, G, U, K, W) {
  var Z = G.__brushOption, X = H.toRectRange(Z.range), Q = toLocalDelta(C, K, W);
  each$f(U, function(ee) {
    var te = DIRECTION_MAP[ee];
    X[te[0]][te[1]] += Q[te[0]];
  }), Z.range = H.fromRectRange(formatRectRange(X[0][0], X[1][0], X[0][1], X[1][1])), updateCoverAfterCreation(C, G), trigger(C, {
    isEnd: !1
  });
}
function driftPolygon(H, C, G, U) {
  var K = C.__brushOption.range, W = toLocalDelta(H, G, U);
  each$f(K, function(Z) {
    Z[0] += W[0], Z[1] += W[1];
  }), updateCoverAfterCreation(H, C), trigger(H, {
    isEnd: !1
  });
}
function toLocalDelta(H, C, G) {
  var U = H.group, K = U.transformCoordToLocal(C, G), W = U.transformCoordToLocal(0, 0);
  return [K[0] - W[0], K[1] - W[1]];
}
function clipByPanel(H, C, G) {
  var U = getPanelByCover(H, C);
  return U && U !== BRUSH_PANEL_GLOBAL ? U.clipPath(G, H._transform) : clone$4(G);
}
function pointsToRect(H) {
  var C = mathMin$1(H[0][0], H[1][0]), G = mathMin$1(H[0][1], H[1][1]), U = mathMax$1(H[0][0], H[1][0]), K = mathMax$1(H[0][1], H[1][1]);
  return {
    x: C,
    y: G,
    width: U - C,
    height: K - G
  };
}
function resetCursor(H, C, G) {
  if (// Check active
  !(!H._brushType || isOutsideZrArea(H, C.offsetX, C.offsetY))) {
    var U = H._zr, K = H._covers, W = getPanelByPoint(H, C, G);
    if (!H._dragging)
      for (var Z = 0; Z < K.length; Z++) {
        var X = K[Z].__brushOption;
        if (W && (W === BRUSH_PANEL_GLOBAL || X.panelId === W.panelId) && coverRenderers[X.brushType].contain(K[Z], G[0], G[1]))
          return;
      }
    W && U.setCursorStyle("crosshair");
  }
}
function preventDefault(H) {
  var C = H.event;
  C.preventDefault && C.preventDefault();
}
function mainShapeContain(H, C, G) {
  return H.childOfName("main").contain(C, G);
}
function updateCoverByMouse(H, C, G, U) {
  var K = H._creatingCover, W = H._creatingPanel, Z = H._brushOption, X;
  if (H._track.push(G.slice()), shouldShowCover(H) || K) {
    if (W && !K) {
      Z.brushMode === "single" && clearCovers(H);
      var Q = clone$4(Z);
      Q.brushType = determineBrushType(Q.brushType, W), Q.panelId = W === BRUSH_PANEL_GLOBAL ? null : W.panelId, K = H._creatingCover = createCover(H, Q), H._covers.push(K);
    }
    if (K) {
      var ee = coverRenderers[determineBrushType(H._brushType, W)], te = K.__brushOption;
      te.range = ee.getCreatingRange(clipByPanel(H, K, H._track)), U && (endCreating(H, K), ee.updateCommon(H, K)), updateCoverShape(H, K), X = {
        isEnd: U
      };
    }
  } else
    U && Z.brushMode === "single" && Z.removeOnClick && getPanelByPoint(H, C, G) && clearCovers(H) && (X = {
      isEnd: U,
      removeOnClick: !0
    });
  return X;
}
function determineBrushType(H, C) {
  return H === "auto" ? (process.env.NODE_ENV !== "production" && assert(C && C.defaultBrushType, 'MUST have defaultBrushType when brushType is "atuo"'), C.defaultBrushType) : H;
}
var pointerHandlers = {
  mousedown: function(H) {
    if (this._dragging)
      handleDragEnd(this, H);
    else if (!H.target || !H.target.draggable) {
      preventDefault(H);
      var C = this.group.transformCoordToLocal(H.offsetX, H.offsetY);
      this._creatingCover = null;
      var G = this._creatingPanel = getPanelByPoint(this, H, C);
      G && (this._dragging = !0, this._track = [C.slice()]);
    }
  },
  mousemove: function(H) {
    var C = H.offsetX, G = H.offsetY, U = this.group.transformCoordToLocal(C, G);
    if (resetCursor(this, H, U), this._dragging) {
      preventDefault(H);
      var K = updateCoverByMouse(this, H, U, !1);
      K && trigger(this, K);
    }
  },
  mouseup: function(H) {
    handleDragEnd(this, H);
  }
};
function handleDragEnd(H, C) {
  if (H._dragging) {
    preventDefault(C);
    var G = C.offsetX, U = C.offsetY, K = H.group.transformCoordToLocal(G, U), W = updateCoverByMouse(H, C, K, !0);
    H._dragging = !1, H._track = [], H._creatingCover = null, W && trigger(H, W);
  }
}
function isOutsideZrArea(H, C, G) {
  var U = H._zr;
  return C < 0 || C > U.getWidth() || G < 0 || G > U.getHeight();
}
var coverRenderers = {
  lineX: getLineRenderer(0),
  lineY: getLineRenderer(1),
  rect: {
    createCover: function(H, C) {
      function G(U) {
        return U;
      }
      return createBaseRectCover({
        toRectRange: G,
        fromRectRange: G
      }, H, C, [["w"], ["e"], ["n"], ["s"], ["s", "e"], ["s", "w"], ["n", "e"], ["n", "w"]]);
    },
    getCreatingRange: function(H) {
      var C = getTrackEnds(H);
      return formatRectRange(C[1][0], C[1][1], C[0][0], C[0][1]);
    },
    updateCoverShape: function(H, C, G, U) {
      updateBaseRect(H, C, G, U);
    },
    updateCommon: updateCommon$1,
    contain: mainShapeContain
  },
  polygon: {
    createCover: function(H, C) {
      var G = new Group$4();
      return G.add(new Polyline$3({
        name: "main",
        style: makeStyle(C),
        silent: !0
      })), G;
    },
    getCreatingRange: function(H) {
      return H;
    },
    endCreating: function(H, C) {
      C.remove(C.childAt(0)), C.add(new Polygon$1({
        name: "main",
        draggable: !0,
        drift: curry$1(driftPolygon, H, C),
        ondragend: curry$1(trigger, H, {
          isEnd: !0
        })
      }));
    },
    updateCoverShape: function(H, C, G, U) {
      C.childAt(0).setShape({
        points: clipByPanel(H, C, G)
      });
    },
    updateCommon: updateCommon$1,
    contain: mainShapeContain
  }
};
function getLineRenderer(H) {
  return {
    createCover: function(C, G) {
      return createBaseRectCover({
        toRectRange: function(U) {
          var K = [U, [0, 100]];
          return H && K.reverse(), K;
        },
        fromRectRange: function(U) {
          return U[H];
        }
      }, C, G, [[["w"], ["e"]], [["n"], ["s"]]][H]);
    },
    getCreatingRange: function(C) {
      var G = getTrackEnds(C), U = mathMin$1(G[0][H], G[1][H]), K = mathMax$1(G[0][H], G[1][H]);
      return [U, K];
    },
    updateCoverShape: function(C, G, U, K) {
      var W, Z = getPanelByCover(C, G);
      if (Z !== BRUSH_PANEL_GLOBAL && Z.getLinearBrushOtherExtent)
        W = Z.getLinearBrushOtherExtent(H);
      else {
        var X = C._zr;
        W = [0, [X.getWidth(), X.getHeight()][1 - H]];
      }
      var Q = [U, W];
      H && Q.reverse(), updateBaseRect(C, G, Q, K);
    },
    updateCommon: updateCommon$1,
    contain: mainShapeContain
  };
}
const BrushController$1 = BrushController;
function makeRectPanelClipPath(H) {
  return H = normalizeRect(H), function(C) {
    return clipPointsByRect(C, H);
  };
}
function makeLinearBrushOtherExtent(H, C) {
  return H = normalizeRect(H), function(G) {
    var U = C ?? G, K = U ? H.width : H.height, W = U ? H.x : H.y;
    return [W, W + (K || 0)];
  };
}
function makeRectIsTargetByCursor(H, C, G) {
  var U = normalizeRect(H);
  return function(K, W) {
    return U.contain(W[0], W[1]) && !onIrrelevantElement(K, C, G);
  };
}
function normalizeRect(H) {
  return BoundingRect$1.create(H);
}
var elementList$1 = ["axisLine", "axisTickLabel", "axisName"], ParallelAxisView = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G;
    }
    return C.prototype.init = function(G, U) {
      H.prototype.init.apply(this, arguments), (this._brushController = new BrushController$1(U.getZr())).on("brush", bind$1(this._onBrush, this));
    }, C.prototype.render = function(G, U, K, W) {
      if (!fromAxisAreaSelect(G, U, W)) {
        this.axisModel = G, this.api = K, this.group.removeAll();
        var Z = this._axisGroup;
        if (this._axisGroup = new Group$4(), this.group.add(this._axisGroup), !!G.get("show")) {
          var X = getCoordSysModel(G, U), Q = X.coordinateSystem, ee = G.getAreaSelectStyle(), te = ee.width, re = G.axis.dim, ne = Q.getAxisLayout(re), ae = extend({
            strokeContainThreshold: te
          }, ne), ie = new AxisBuilder$1(G, ae);
          each$f(elementList$1, ie.add, ie), this._axisGroup.add(ie.getGroup()), this._refreshBrushController(ae, ee, G, X, te, K), groupTransition(Z, this._axisGroup, G);
        }
      }
    }, C.prototype._refreshBrushController = function(G, U, K, W, Z, X) {
      var Q = K.axis.getExtent(), ee = Q[1] - Q[0], te = Math.min(30, Math.abs(ee) * 0.1), re = BoundingRect$1.create({
        x: Q[0],
        y: -Z / 2,
        width: ee,
        height: Z
      });
      re.x -= te, re.width += 2 * te, this._brushController.mount({
        enableGlobalPan: !0,
        rotation: G.rotation,
        x: G.position[0],
        y: G.position[1]
      }).setPanels([{
        panelId: "pl",
        clipPath: makeRectPanelClipPath(re),
        isTargetByCursor: makeRectIsTargetByCursor(re, X, W),
        getLinearBrushOtherExtent: makeLinearBrushOtherExtent(re, 0)
      }]).enableBrush({
        brushType: "lineX",
        brushStyle: U,
        removeOnClick: !0
      }).updateCovers(getCoverInfoList(K));
    }, C.prototype._onBrush = function(G) {
      var U = G.areas, K = this.axisModel, W = K.axis, Z = map$1(U, function(X) {
        return [W.coordToData(X.range[0], !0), W.coordToData(X.range[1], !0)];
      });
      (!K.option.realtime === G.isEnd || G.removeOnClick) && this.api.dispatchAction({
        type: "axisAreaSelect",
        parallelAxisId: K.id,
        intervals: Z
      });
    }, C.prototype.dispose = function() {
      this._brushController.dispose();
    }, C.type = "parallelAxis", C;
  }(ComponentView$1)
);
function fromAxisAreaSelect(H, C, G) {
  return G && G.type === "axisAreaSelect" && C.findComponents({
    mainType: "parallelAxis",
    query: G
  })[0] === H;
}
function getCoverInfoList(H) {
  var C = H.axis;
  return map$1(H.activeIntervals, function(G) {
    return {
      brushType: "lineX",
      panelId: "pl",
      range: [C.dataToCoord(G[0], !0), C.dataToCoord(G[1], !0)]
    };
  });
}
function getCoordSysModel(H, C) {
  return C.getComponent("parallel", H.get("parallelIndex"));
}
const ParallelAxisView$1 = ParallelAxisView;
var actionInfo = {
  type: "axisAreaSelect",
  event: "axisAreaSelected"
  // update: 'updateVisual'
};
function installParallelActions(H) {
  H.registerAction(actionInfo, function(C, G) {
    G.eachComponent({
      mainType: "parallelAxis",
      query: C
    }, function(U) {
      U.axis.model.setActiveIntervals(C.intervals);
    });
  }), H.registerAction("parallelAxisExpand", function(C, G) {
    G.eachComponent({
      mainType: "parallel",
      query: C
    }, function(U) {
      U.setAxisExpand(C);
    });
  });
}
var defaultAxisOption = {
  type: "value",
  areaSelectStyle: {
    width: 20,
    borderWidth: 1,
    borderColor: "rgba(160,197,232)",
    color: "rgba(160,197,232)",
    opacity: 0.3
  },
  realtime: !0,
  z: 10
};
function install$C(H) {
  H.registerComponentView(ParallelView$1), H.registerComponentModel(ParallelModel$1), H.registerCoordinateSystem("parallel", parallelCoordSysCreator$1), H.registerPreprocessor(parallelPreprocessor), H.registerComponentModel(ParallelAxisModel$1), H.registerComponentView(ParallelAxisView$1), axisModelCreator(H, "parallel", ParallelAxisModel$1, defaultAxisOption), installParallelActions(H);
}
function install$B(H) {
  use(install$C), H.registerChartView(ParallelView$3), H.registerSeriesModel(ParallelSeriesModel$1), H.registerVisual(H.PRIORITY.VISUAL.BRUSH, parallelVisual$1);
}
var SankeyPathShape = (
  /** @class */
  function() {
    function H() {
      this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.cpx1 = 0, this.cpy1 = 0, this.cpx2 = 0, this.cpy2 = 0, this.extent = 0;
    }
    return H;
  }()
), SankeyPath = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C(G) {
      return H.call(this, G) || this;
    }
    return C.prototype.getDefaultShape = function() {
      return new SankeyPathShape();
    }, C.prototype.buildPath = function(G, U) {
      var K = U.extent;
      G.moveTo(U.x1, U.y1), G.bezierCurveTo(U.cpx1, U.cpy1, U.cpx2, U.cpy2, U.x2, U.y2), U.orient === "vertical" ? (G.lineTo(U.x2 + K, U.y2), G.bezierCurveTo(U.cpx2 + K, U.cpy2, U.cpx1 + K, U.cpy1, U.x1 + K, U.y1)) : (G.lineTo(U.x2, U.y2 + K), G.bezierCurveTo(U.cpx2, U.cpy2 + K, U.cpx1, U.cpy1 + K, U.x1, U.y1 + K)), G.closePath();
    }, C.prototype.highlight = function() {
      enterEmphasis(this);
    }, C.prototype.downplay = function() {
      leaveEmphasis(this);
    }, C;
  }(Path$1)
), SankeyView = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G._focusAdjacencyDisabled = !1, G;
    }
    return C.prototype.render = function(G, U, K) {
      var W = this, Z = G.getGraph(), X = this.group, Q = G.layoutInfo, ee = Q.width, te = Q.height, re = G.getData(), ne = G.getData("edge"), ae = G.get("orient");
      this._model = G, X.removeAll(), X.x = Q.x, X.y = Q.y, Z.eachEdge(function(ie) {
        var se = new SankeyPath(), oe = getECData(se);
        oe.dataIndex = ie.dataIndex, oe.seriesIndex = G.seriesIndex, oe.dataType = "edge";
        var le = ie.getModel(), ue = le.getModel("lineStyle"), ce = ue.get("curveness"), de = ie.node1.getLayout(), ge = ie.node1.getModel(), fe = ge.get("localX"), ve = ge.get("localY"), pe = ie.node2.getLayout(), he = ie.node2.getModel(), me = he.get("localX"), ye = he.get("localY"), Ce = ie.getLayout(), Ie, be, Se, Ae, _e, xe, Te, Pe;
        switch (se.shape.extent = Math.max(1, Ce.dy), se.shape.orient = ae, ae === "vertical" ? (Ie = (fe != null ? fe * ee : de.x) + Ce.sy, be = (ve != null ? ve * te : de.y) + de.dy, Se = (me != null ? me * ee : pe.x) + Ce.ty, Ae = ye != null ? ye * te : pe.y, _e = Ie, xe = be * (1 - ce) + Ae * ce, Te = Se, Pe = be * ce + Ae * (1 - ce)) : (Ie = (fe != null ? fe * ee : de.x) + de.dx, be = (ve != null ? ve * te : de.y) + Ce.sy, Se = me != null ? me * ee : pe.x, Ae = (ye != null ? ye * te : pe.y) + Ce.ty, _e = Ie * (1 - ce) + Se * ce, xe = be, Te = Ie * ce + Se * (1 - ce), Pe = Ae), se.setShape({
          x1: Ie,
          y1: be,
          x2: Se,
          y2: Ae,
          cpx1: _e,
          cpy1: xe,
          cpx2: Te,
          cpy2: Pe
        }), se.useStyle(ue.getItemStyle()), se.style.fill) {
          case "source":
            se.style.fill = ie.node1.getVisual("color"), se.style.decal = ie.node1.getVisual("style").decal;
            break;
          case "target":
            se.style.fill = ie.node2.getVisual("color"), se.style.decal = ie.node2.getVisual("style").decal;
            break;
          case "gradient":
            var $e = ie.node1.getVisual("color"), Me = ie.node2.getVisual("color");
            isString($e) && isString(Me) && (se.style.fill = new LinearGradient$1(0, 0, +(ae === "horizontal"), +(ae === "vertical"), [{
              color: $e,
              offset: 0
            }, {
              color: Me,
              offset: 1
            }]));
        }
        setLabelStyle(se, getLabelStatesModels(le, "edgeLabel"), {
          labelFetcher: G,
          labelDataIndex: ie.dataIndex,
          defaultText: "" + le.get("value")
        }), se.setTextConfig({
          position: "inside"
        });
        var Ee = le.getModel("emphasis");
        setStatesStylesFromModel(se, le, "lineStyle", function(Oe) {
          return Oe.getItemStyle();
        }), X.add(se), ne.setItemGraphicEl(ie.dataIndex, se);
        var we = Ee.get("focus");
        toggleHoverEmphasis(se, we === "adjacency" ? ie.getAdjacentDataIndices() : we, Ee.get("blurScope"), Ee.get("disabled")), getECData(se).dataType = "edge";
      }), Z.eachNode(function(ie) {
        var se = ie.getLayout(), oe = ie.getModel(), le = oe.get("localX"), ue = oe.get("localY"), ce = oe.getModel("emphasis"), de = new Rect$3({
          shape: {
            x: le != null ? le * ee : se.x,
            y: ue != null ? ue * te : se.y,
            width: se.dx,
            height: se.dy
          },
          style: oe.getModel("itemStyle").getItemStyle(),
          z2: 10
        });
        setLabelStyle(de, getLabelStatesModels(oe), {
          labelFetcher: G,
          labelDataIndex: ie.dataIndex,
          defaultText: ie.id
        }), de.disableLabelAnimation = !0, de.setStyle("fill", ie.getVisual("color")), de.setStyle("decal", ie.getVisual("style").decal), setStatesStylesFromModel(de, oe), X.add(de), re.setItemGraphicEl(ie.dataIndex, de), getECData(de).dataType = "node";
        var ge = ce.get("focus");
        toggleHoverEmphasis(de, ge === "adjacency" ? ie.getAdjacentDataIndices() : ge, ce.get("blurScope"), ce.get("disabled"));
      }), re.eachItemGraphicEl(function(ie, se) {
        var oe = re.getItemModel(se);
        oe.get("draggable") && (ie.drift = function(le, ue) {
          W._focusAdjacencyDisabled = !0, this.shape.x += le, this.shape.y += ue, this.dirty(), K.dispatchAction({
            type: "dragNode",
            seriesId: G.id,
            dataIndex: re.getRawIndex(se),
            localX: this.shape.x / ee,
            localY: this.shape.y / te
          });
        }, ie.ondragend = function() {
          W._focusAdjacencyDisabled = !1;
        }, ie.draggable = !0, ie.cursor = "move");
      }), !this._data && G.isAnimationEnabled() && X.setClipPath(createGridClipShape$1(X.getBoundingRect(), G, function() {
        X.removeClipPath();
      })), this._data = G.getData();
    }, C.prototype.dispose = function() {
    }, C.type = "sankey", C;
  }(ChartView$1)
);
function createGridClipShape$1(H, C, G) {
  var U = new Rect$3({
    shape: {
      x: H.x - 10,
      y: H.y - 10,
      width: 0,
      height: H.height + 20
    }
  });
  return initProps(U, {
    shape: {
      width: H.width + 20
    }
  }, C, G), U;
}
const SankeyView$1 = SankeyView;
var SankeySeriesModel = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G;
    }
    return C.prototype.getInitialData = function(G, U) {
      var K = G.edges || G.links, W = G.data || G.nodes, Z = G.levels;
      this.levelModels = [];
      for (var X = this.levelModels, Q = 0; Q < Z.length; Q++)
        if (Z[Q].depth != null && Z[Q].depth >= 0)
          X[Z[Q].depth] = new Model$1(Z[Q], this, U);
        else if (process.env.NODE_ENV !== "production")
          throw new Error("levels[i].depth is mandatory and should be natural number");
      if (W && K) {
        var ee = createGraphFromNodeEdge(W, K, this, !0, te);
        return ee.data;
      }
      function te(re, ne) {
        re.wrapMethod("getItemModel", function(ae, ie) {
          var se = ae.parentModel, oe = se.getData().getItemLayout(ie);
          if (oe) {
            var le = oe.depth, ue = se.levelModels[le];
            ue && (ae.parentModel = ue);
          }
          return ae;
        }), ne.wrapMethod("getItemModel", function(ae, ie) {
          var se = ae.parentModel, oe = se.getGraph().getEdgeByIndex(ie), le = oe.node1.getLayout();
          if (le) {
            var ue = le.depth, ce = se.levelModels[ue];
            ce && (ae.parentModel = ce);
          }
          return ae;
        });
      }
    }, C.prototype.setNodePosition = function(G, U) {
      var K = this.option.data || this.option.nodes, W = K[G];
      W.localX = U[0], W.localY = U[1];
    }, C.prototype.getGraph = function() {
      return this.getData().graph;
    }, C.prototype.getEdgeData = function() {
      return this.getGraph().edgeData;
    }, C.prototype.formatTooltip = function(G, U, K) {
      function W(ae) {
        return isNaN(ae) || ae == null;
      }
      if (K === "edge") {
        var Z = this.getDataParams(G, K), X = Z.data, Q = Z.value, ee = X.source + " -- " + X.target;
        return createTooltipMarkup("nameValue", {
          name: ee,
          value: Q,
          noValue: W(Q)
        });
      } else {
        var te = this.getGraph().getNodeByIndex(G), re = te.getLayout().value, ne = this.getDataParams(G, K).data.name;
        return createTooltipMarkup("nameValue", {
          name: ne != null ? ne + "" : null,
          value: re,
          noValue: W(re)
        });
      }
    }, C.prototype.optionUpdated = function() {
    }, C.prototype.getDataParams = function(G, U) {
      var K = H.prototype.getDataParams.call(this, G, U);
      if (K.value == null && U === "node") {
        var W = this.getGraph().getNodeByIndex(G), Z = W.getLayout().value;
        K.value = Z;
      }
      return K;
    }, C.type = "series.sankey", C.defaultOption = {
      // zlevel: 0,
      z: 2,
      coordinateSystem: "view",
      left: "5%",
      top: "5%",
      right: "20%",
      bottom: "5%",
      orient: "horizontal",
      nodeWidth: 20,
      nodeGap: 8,
      draggable: !0,
      layoutIterations: 32,
      label: {
        show: !0,
        position: "right",
        fontSize: 12
      },
      edgeLabel: {
        show: !1,
        fontSize: 12
      },
      levels: [],
      nodeAlign: "justify",
      lineStyle: {
        color: "#314656",
        opacity: 0.2,
        curveness: 0.5
      },
      emphasis: {
        label: {
          show: !0
        },
        lineStyle: {
          opacity: 0.5
        }
      },
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      },
      animationEasing: "linear",
      animationDuration: 1e3
    }, C;
  }(SeriesModel$1)
);
const SankeySeriesModel$1 = SankeySeriesModel;
function sankeyLayout(H, C) {
  H.eachSeriesByType("sankey", function(G) {
    var U = G.get("nodeWidth"), K = G.get("nodeGap"), W = getViewRect$1(G, C);
    G.layoutInfo = W;
    var Z = W.width, X = W.height, Q = G.getGraph(), ee = Q.nodes, te = Q.edges;
    computeNodeValues(ee);
    var re = filter(ee, function(se) {
      return se.getLayout().value === 0;
    }), ne = re.length !== 0 ? 0 : G.get("layoutIterations"), ae = G.get("orient"), ie = G.get("nodeAlign");
    layoutSankey(ee, te, U, K, Z, X, ne, ae, ie);
  });
}
function getViewRect$1(H, C) {
  return getLayoutRect(H.getBoxLayoutParams(), {
    width: C.getWidth(),
    height: C.getHeight()
  });
}
function layoutSankey(H, C, G, U, K, W, Z, X, Q) {
  computeNodeBreadths(H, C, G, K, W, X, Q), computeNodeDepths(H, C, W, K, U, Z, X), computeEdgeDepths(H, X);
}
function computeNodeValues(H) {
  each$f(H, function(C) {
    var G = sum(C.outEdges, getEdgeValue), U = sum(C.inEdges, getEdgeValue), K = C.getValue() || 0, W = Math.max(G, U, K);
    C.setLayout({
      value: W
    }, !0);
  });
}
function computeNodeBreadths(H, C, G, U, K, W, Z) {
  for (var X = [], Q = [], ee = [], te = [], re = 0, ne = 0; ne < C.length; ne++)
    X[ne] = 1;
  for (var ne = 0; ne < H.length; ne++)
    Q[ne] = H[ne].inEdges.length, Q[ne] === 0 && ee.push(H[ne]);
  for (var ae = -1; ee.length; ) {
    for (var ie = 0; ie < ee.length; ie++) {
      var se = ee[ie], oe = se.hostGraph.data.getRawDataItem(se.dataIndex), le = oe.depth != null && oe.depth >= 0;
      le && oe.depth > ae && (ae = oe.depth), se.setLayout({
        depth: le ? oe.depth : re
      }, !0), W === "vertical" ? se.setLayout({
        dy: G
      }, !0) : se.setLayout({
        dx: G
      }, !0);
      for (var ue = 0; ue < se.outEdges.length; ue++) {
        var ce = se.outEdges[ue], de = C.indexOf(ce);
        X[de] = 0;
        var ge = ce.node2, fe = H.indexOf(ge);
        --Q[fe] === 0 && te.indexOf(ge) < 0 && te.push(ge);
      }
    }
    ++re, ee = te, te = [];
  }
  for (var ne = 0; ne < X.length; ne++)
    if (X[ne] === 1)
      throw new Error("Sankey is a DAG, the original data has cycle!");
  var ve = ae > re - 1 ? ae : re - 1;
  Z && Z !== "left" && adjustNodeWithNodeAlign(H, Z, W, ve);
  var pe = W === "vertical" ? (K - G) / ve : (U - G) / ve;
  scaleNodeBreadths(H, pe, W);
}
function isNodeDepth(H) {
  var C = H.hostGraph.data.getRawDataItem(H.dataIndex);
  return C.depth != null && C.depth >= 0;
}
function adjustNodeWithNodeAlign(H, C, G, U) {
  if (C === "right") {
    for (var K = [], W = H, Z = 0; W.length; ) {
      for (var X = 0; X < W.length; X++) {
        var Q = W[X];
        Q.setLayout({
          skNodeHeight: Z
        }, !0);
        for (var ee = 0; ee < Q.inEdges.length; ee++) {
          var te = Q.inEdges[ee];
          K.indexOf(te.node1) < 0 && K.push(te.node1);
        }
      }
      W = K, K = [], ++Z;
    }
    each$f(H, function(re) {
      isNodeDepth(re) || re.setLayout({
        depth: Math.max(0, U - re.getLayout().skNodeHeight)
      }, !0);
    });
  } else
    C === "justify" && moveSinksRight(H, U);
}
function moveSinksRight(H, C) {
  each$f(H, function(G) {
    !isNodeDepth(G) && !G.outEdges.length && G.setLayout({
      depth: C
    }, !0);
  });
}
function scaleNodeBreadths(H, C, G) {
  each$f(H, function(U) {
    var K = U.getLayout().depth * C;
    G === "vertical" ? U.setLayout({
      y: K
    }, !0) : U.setLayout({
      x: K
    }, !0);
  });
}
function computeNodeDepths(H, C, G, U, K, W, Z) {
  var X = prepareNodesByBreadth(H, Z);
  initializeNodeDepth(X, C, G, U, K, Z), resolveCollisions(X, K, G, U, Z);
  for (var Q = 1; W > 0; W--)
    Q *= 0.99, relaxRightToLeft(X, Q, Z), resolveCollisions(X, K, G, U, Z), relaxLeftToRight(X, Q, Z), resolveCollisions(X, K, G, U, Z);
}
function prepareNodesByBreadth(H, C) {
  var G = [], U = C === "vertical" ? "y" : "x", K = groupData(H, function(W) {
    return W.getLayout()[U];
  });
  return K.keys.sort(function(W, Z) {
    return W - Z;
  }), each$f(K.keys, function(W) {
    G.push(K.buckets.get(W));
  }), G;
}
function initializeNodeDepth(H, C, G, U, K, W) {
  var Z = 1 / 0;
  each$f(H, function(X) {
    var Q = X.length, ee = 0;
    each$f(X, function(re) {
      ee += re.getLayout().value;
    });
    var te = W === "vertical" ? (U - (Q - 1) * K) / ee : (G - (Q - 1) * K) / ee;
    te < Z && (Z = te);
  }), each$f(H, function(X) {
    each$f(X, function(Q, ee) {
      var te = Q.getLayout().value * Z;
      W === "vertical" ? (Q.setLayout({
        x: ee
      }, !0), Q.setLayout({
        dx: te
      }, !0)) : (Q.setLayout({
        y: ee
      }, !0), Q.setLayout({
        dy: te
      }, !0));
    });
  }), each$f(C, function(X) {
    var Q = +X.getValue() * Z;
    X.setLayout({
      dy: Q
    }, !0);
  });
}
function resolveCollisions(H, C, G, U, K) {
  var W = K === "vertical" ? "x" : "y";
  each$f(H, function(Z) {
    Z.sort(function(se, oe) {
      return se.getLayout()[W] - oe.getLayout()[W];
    });
    for (var X, Q, ee, te = 0, re = Z.length, ne = K === "vertical" ? "dx" : "dy", ae = 0; ae < re; ae++)
      Q = Z[ae], ee = te - Q.getLayout()[W], ee > 0 && (X = Q.getLayout()[W] + ee, K === "vertical" ? Q.setLayout({
        x: X
      }, !0) : Q.setLayout({
        y: X
      }, !0)), te = Q.getLayout()[W] + Q.getLayout()[ne] + C;
    var ie = K === "vertical" ? U : G;
    if (ee = te - C - ie, ee > 0) {
      X = Q.getLayout()[W] - ee, K === "vertical" ? Q.setLayout({
        x: X
      }, !0) : Q.setLayout({
        y: X
      }, !0), te = X;
      for (var ae = re - 2; ae >= 0; --ae)
        Q = Z[ae], ee = Q.getLayout()[W] + Q.getLayout()[ne] + C - te, ee > 0 && (X = Q.getLayout()[W] - ee, K === "vertical" ? Q.setLayout({
          x: X
        }, !0) : Q.setLayout({
          y: X
        }, !0)), te = Q.getLayout()[W];
    }
  });
}
function relaxRightToLeft(H, C, G) {
  each$f(H.slice().reverse(), function(U) {
    each$f(U, function(K) {
      if (K.outEdges.length) {
        var W = sum(K.outEdges, weightedTarget, G) / sum(K.outEdges, getEdgeValue);
        if (isNaN(W)) {
          var Z = K.outEdges.length;
          W = Z ? sum(K.outEdges, centerTarget, G) / Z : 0;
        }
        if (G === "vertical") {
          var X = K.getLayout().x + (W - center(K, G)) * C;
          K.setLayout({
            x: X
          }, !0);
        } else {
          var Q = K.getLayout().y + (W - center(K, G)) * C;
          K.setLayout({
            y: Q
          }, !0);
        }
      }
    });
  });
}
function weightedTarget(H, C) {
  return center(H.node2, C) * H.getValue();
}
function centerTarget(H, C) {
  return center(H.node2, C);
}
function weightedSource(H, C) {
  return center(H.node1, C) * H.getValue();
}
function centerSource(H, C) {
  return center(H.node1, C);
}
function center(H, C) {
  return C === "vertical" ? H.getLayout().x + H.getLayout().dx / 2 : H.getLayout().y + H.getLayout().dy / 2;
}
function getEdgeValue(H) {
  return H.getValue();
}
function sum(H, C, G) {
  for (var U = 0, K = H.length, W = -1; ++W < K; ) {
    var Z = +C(H[W], G);
    isNaN(Z) || (U += Z);
  }
  return U;
}
function relaxLeftToRight(H, C, G) {
  each$f(H, function(U) {
    each$f(U, function(K) {
      if (K.inEdges.length) {
        var W = sum(K.inEdges, weightedSource, G) / sum(K.inEdges, getEdgeValue);
        if (isNaN(W)) {
          var Z = K.inEdges.length;
          W = Z ? sum(K.inEdges, centerSource, G) / Z : 0;
        }
        if (G === "vertical") {
          var X = K.getLayout().x + (W - center(K, G)) * C;
          K.setLayout({
            x: X
          }, !0);
        } else {
          var Q = K.getLayout().y + (W - center(K, G)) * C;
          K.setLayout({
            y: Q
          }, !0);
        }
      }
    });
  });
}
function computeEdgeDepths(H, C) {
  var G = C === "vertical" ? "x" : "y";
  each$f(H, function(U) {
    U.outEdges.sort(function(K, W) {
      return K.node2.getLayout()[G] - W.node2.getLayout()[G];
    }), U.inEdges.sort(function(K, W) {
      return K.node1.getLayout()[G] - W.node1.getLayout()[G];
    });
  }), each$f(H, function(U) {
    var K = 0, W = 0;
    each$f(U.outEdges, function(Z) {
      Z.setLayout({
        sy: K
      }, !0), K += Z.getLayout().dy;
    }), each$f(U.inEdges, function(Z) {
      Z.setLayout({
        ty: W
      }, !0), W += Z.getLayout().dy;
    });
  });
}
function sankeyVisual(H) {
  H.eachSeriesByType("sankey", function(C) {
    var G = C.getGraph(), U = G.nodes, K = G.edges;
    if (U.length) {
      var W = 1 / 0, Z = -1 / 0;
      each$f(U, function(X) {
        var Q = X.getLayout().value;
        Q < W && (W = Q), Q > Z && (Z = Q);
      }), each$f(U, function(X) {
        var Q = new VisualMapping$1({
          type: "color",
          mappingMethod: "linear",
          dataExtent: [W, Z],
          visual: C.get("color")
        }), ee = Q.mapValueToVisual(X.getLayout().value), te = X.getModel().get(["itemStyle", "color"]);
        te != null ? (X.setVisual("color", te), X.setVisual("style", {
          fill: te
        })) : (X.setVisual("color", ee), X.setVisual("style", {
          fill: ee
        }));
      });
    }
    K.length && each$f(K, function(X) {
      var Q = X.getModel().get("lineStyle");
      X.setVisual("style", Q);
    });
  });
}
function install$A(H) {
  H.registerChartView(SankeyView$1), H.registerSeriesModel(SankeySeriesModel$1), H.registerLayout(sankeyLayout), H.registerVisual(sankeyVisual), H.registerAction({
    type: "dragNode",
    event: "dragnode",
    // here can only use 'update' now, other value is not support in echarts.
    update: "update"
  }, function(C, G) {
    G.eachComponent({
      mainType: "series",
      subType: "sankey",
      query: C
    }, function(U) {
      U.setNodePosition(C.dataIndex, [C.localX, C.localY]);
    });
  });
}
var WhiskerBoxCommonMixin = (
  /** @class */
  function() {
    function H() {
    }
    return H.prototype.getInitialData = function(C, G) {
      var U, K = G.getComponent("xAxis", this.get("xAxisIndex")), W = G.getComponent("yAxis", this.get("yAxisIndex")), Z = K.get("type"), X = W.get("type"), Q;
      Z === "category" ? (C.layout = "horizontal", U = K.getOrdinalMeta(), Q = !0) : X === "category" ? (C.layout = "vertical", U = W.getOrdinalMeta(), Q = !0) : C.layout = C.layout || "horizontal";
      var ee = ["x", "y"], te = C.layout === "horizontal" ? 0 : 1, re = this._baseAxisDim = ee[te], ne = ee[1 - te], ae = [K, W], ie = ae[te].get("type"), se = ae[1 - te].get("type"), oe = C.data;
      if (oe && Q) {
        var le = [];
        each$f(oe, function(de, ge) {
          var fe;
          isArray$1(de) ? (fe = de.slice(), de.unshift(ge)) : isArray$1(de.value) ? (fe = extend({}, de), fe.value = fe.value.slice(), de.value.unshift(ge)) : fe = de, le.push(fe);
        }), C.data = le;
      }
      var ue = this.defaultValueDimensions, ce = [{
        name: re,
        type: getDimensionTypeByAxis(ie),
        ordinalMeta: U,
        otherDims: {
          tooltip: !1,
          itemName: 0
        },
        dimsDef: ["base"]
      }, {
        name: ne,
        type: getDimensionTypeByAxis(se),
        dimsDef: ue.slice()
      }];
      return createSeriesDataSimply(this, {
        coordDimensions: ce,
        dimensionsCount: ue.length + 1,
        encodeDefaulter: curry$1(makeSeriesEncodeForAxisCoordSys, ce, this)
      });
    }, H.prototype.getBaseAxis = function() {
      var C = this._baseAxisDim;
      return this.ecModel.getComponent(C + "Axis", this.get(C + "AxisIndex")).axis;
    }, H;
  }()
), BoxplotSeriesModel = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G.defaultValueDimensions = [{
        name: "min",
        defaultTooltip: !0
      }, {
        name: "Q1",
        defaultTooltip: !0
      }, {
        name: "median",
        defaultTooltip: !0
      }, {
        name: "Q3",
        defaultTooltip: !0
      }, {
        name: "max",
        defaultTooltip: !0
      }], G.visualDrawType = "stroke", G;
    }
    return C.type = "series.boxplot", C.dependencies = ["xAxis", "yAxis", "grid"], C.defaultOption = {
      // zlevel: 0,
      z: 2,
      coordinateSystem: "cartesian2d",
      legendHoverLink: !0,
      layout: null,
      boxWidth: [7, 50],
      itemStyle: {
        color: "#fff",
        borderWidth: 1
      },
      emphasis: {
        scale: !0,
        itemStyle: {
          borderWidth: 2,
          shadowBlur: 5,
          shadowOffsetX: 1,
          shadowOffsetY: 1,
          shadowColor: "rgba(0,0,0,0.2)"
        }
      },
      animationDuration: 800
    }, C;
  }(SeriesModel$1)
);
mixin(BoxplotSeriesModel, WhiskerBoxCommonMixin, !0);
const BoxplotSeriesModel$1 = BoxplotSeriesModel;
var BoxplotView = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G;
    }
    return C.prototype.render = function(G, U, K) {
      var W = G.getData(), Z = this.group, X = this._data;
      this._data || Z.removeAll();
      var Q = G.get("layout") === "horizontal" ? 1 : 0;
      W.diff(X).add(function(ee) {
        if (W.hasValue(ee)) {
          var te = W.getItemLayout(ee), re = createNormalBox$1(te, W, ee, Q, !0);
          W.setItemGraphicEl(ee, re), Z.add(re);
        }
      }).update(function(ee, te) {
        var re = X.getItemGraphicEl(te);
        if (!W.hasValue(ee)) {
          Z.remove(re);
          return;
        }
        var ne = W.getItemLayout(ee);
        re ? (saveOldStyle(re), updateNormalBoxData(ne, re, W, ee)) : re = createNormalBox$1(ne, W, ee, Q), Z.add(re), W.setItemGraphicEl(ee, re);
      }).remove(function(ee) {
        var te = X.getItemGraphicEl(ee);
        te && Z.remove(te);
      }).execute(), this._data = W;
    }, C.prototype.remove = function(G) {
      var U = this.group, K = this._data;
      this._data = null, K && K.eachItemGraphicEl(function(W) {
        W && U.remove(W);
      });
    }, C.type = "boxplot", C;
  }(ChartView$1)
), BoxPathShape = (
  /** @class */
  function() {
    function H() {
    }
    return H;
  }()
), BoxPath = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C(G) {
      var U = H.call(this, G) || this;
      return U.type = "boxplotBoxPath", U;
    }
    return C.prototype.getDefaultShape = function() {
      return new BoxPathShape();
    }, C.prototype.buildPath = function(G, U) {
      var K = U.points, W = 0;
      for (G.moveTo(K[W][0], K[W][1]), W++; W < 4; W++)
        G.lineTo(K[W][0], K[W][1]);
      for (G.closePath(); W < K.length; W++)
        G.moveTo(K[W][0], K[W][1]), W++, G.lineTo(K[W][0], K[W][1]);
    }, C;
  }(Path$1)
);
function createNormalBox$1(H, C, G, U, K) {
  var W = H.ends, Z = new BoxPath({
    shape: {
      points: K ? transInit$1(W, U, H) : W
    }
  });
  return updateNormalBoxData(H, Z, C, G, K), Z;
}
function updateNormalBoxData(H, C, G, U, K) {
  var W = G.hostModel, Z = graphic[K ? "initProps" : "updateProps"];
  Z(C, {
    shape: {
      points: H.ends
    }
  }, W, U), C.useStyle(G.getItemVisual(U, "style")), C.style.strokeNoScale = !0, C.z2 = 100;
  var X = G.getItemModel(U), Q = X.getModel("emphasis");
  setStatesStylesFromModel(C, X), toggleHoverEmphasis(C, Q.get("focus"), Q.get("blurScope"), Q.get("disabled"));
}
function transInit$1(H, C, G) {
  return map$1(H, function(U) {
    return U = U.slice(), U[C] = G.initBaseline, U;
  });
}
const BoxplotView$1 = BoxplotView;
var each$9 = each$f;
function boxplotLayout(H) {
  var C = groupSeriesByAxis(H);
  each$9(C, function(G) {
    var U = G.seriesModels;
    U.length && (calculateBase(G), each$9(U, function(K, W) {
      layoutSingleSeries(K, G.boxOffsetList[W], G.boxWidthList[W]);
    }));
  });
}
function groupSeriesByAxis(H) {
  var C = [], G = [];
  return H.eachSeriesByType("boxplot", function(U) {
    var K = U.getBaseAxis(), W = indexOf(G, K);
    W < 0 && (W = G.length, G[W] = K, C[W] = {
      axis: K,
      seriesModels: []
    }), C[W].seriesModels.push(U);
  }), C;
}
function calculateBase(H) {
  var C = H.axis, G = H.seriesModels, U = G.length, K = H.boxWidthList = [], W = H.boxOffsetList = [], Z = [], X;
  if (C.type === "category")
    X = C.getBandWidth();
  else {
    var Q = 0;
    each$9(G, function(ie) {
      Q = Math.max(Q, ie.getData().count());
    });
    var ee = C.getExtent();
    X = Math.abs(ee[1] - ee[0]) / Q;
  }
  each$9(G, function(ie) {
    var se = ie.get("boxWidth");
    isArray$1(se) || (se = [se, se]), Z.push([parsePercent(se[0], X) || 0, parsePercent(se[1], X) || 0]);
  });
  var te = X * 0.8 - 2, re = te / U * 0.3, ne = (te - re * (U - 1)) / U, ae = ne / 2 - te / 2;
  each$9(G, function(ie, se) {
    W.push(ae), ae += re + ne, K.push(Math.min(Math.max(ne, Z[se][0]), Z[se][1]));
  });
}
function layoutSingleSeries(H, C, G) {
  var U = H.coordinateSystem, K = H.getData(), W = G / 2, Z = H.get("layout") === "horizontal" ? 0 : 1, X = 1 - Z, Q = ["x", "y"], ee = K.mapDimension(Q[Z]), te = K.mapDimensionsAll(Q[X]);
  if (ee == null || te.length < 5)
    return;
  for (var re = 0; re < K.count(); re++) {
    var ne = K.get(ee, re), ae = ce(ne, te[2], re), ie = ce(ne, te[0], re), se = ce(ne, te[1], re), oe = ce(ne, te[3], re), le = ce(ne, te[4], re), ue = [];
    de(ue, se, !1), de(ue, oe, !0), ue.push(ie, se, le, oe), ge(ue, ie), ge(ue, le), ge(ue, ae), K.setItemLayout(re, {
      initBaseline: ae[X],
      ends: ue
    });
  }
  function ce(fe, ve, pe) {
    var he = K.get(ve, pe), me = [];
    me[Z] = fe, me[X] = he;
    var ye;
    return isNaN(fe) || isNaN(he) ? ye = [NaN, NaN] : (ye = U.dataToPoint(me), ye[Z] += C), ye;
  }
  function de(fe, ve, pe) {
    var he = ve.slice(), me = ve.slice();
    he[Z] += W, me[Z] -= W, pe ? fe.push(he, me) : fe.push(me, he);
  }
  function ge(fe, ve) {
    var pe = ve.slice(), he = ve.slice();
    pe[Z] -= W, he[Z] += W, fe.push(pe, he);
  }
}
function prepareBoxplotData(H, C) {
  C = C || {};
  for (var G = [], U = [], K = C.boundIQR, W = K === "none" || K === 0, Z = 0; Z < H.length; Z++) {
    var X = asc$2(H[Z].slice()), Q = quantile(X, 0.25), ee = quantile(X, 0.5), te = quantile(X, 0.75), re = X[0], ne = X[X.length - 1], ae = (K ?? 1.5) * (te - Q), ie = W ? re : Math.max(re, Q - ae), se = W ? ne : Math.min(ne, te + ae), oe = C.itemNameFormatter, le = isFunction(oe) ? oe({
      value: Z
    }) : isString(oe) ? oe.replace("{value}", Z + "") : Z + "";
    G.push([le, ie, Q, ee, te, se]);
    for (var ue = 0; ue < X.length; ue++) {
      var ce = X[ue];
      if (ce < ie || ce > se) {
        var de = [le, ce];
        U.push(de);
      }
    }
  }
  return {
    boxData: G,
    outliers: U
  };
}
var boxplotTransform = {
  type: "echarts:boxplot",
  transform: function(C) {
    var G = C.upstream;
    if (G.sourceFormat !== SOURCE_FORMAT_ARRAY_ROWS) {
      var U = "";
      process.env.NODE_ENV !== "production" && (U = makePrintable("source data is not applicable for this boxplot transform. Expect number[][].")), throwError(U);
    }
    var K = prepareBoxplotData(G.getRawData(), C.config);
    return [{
      dimensions: ["ItemName", "Low", "Q1", "Q2", "Q3", "High"],
      data: K.boxData
    }, {
      data: K.outliers
    }];
  }
};
function install$z(H) {
  H.registerSeriesModel(BoxplotSeriesModel$1), H.registerChartView(BoxplotView$1), H.registerLayout(boxplotLayout), H.registerTransform(boxplotTransform);
}
var SKIP_PROPS = ["color", "borderColor"], CandlestickView = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G;
    }
    return C.prototype.render = function(G, U, K) {
      this.group.removeClipPath(), this._progressiveEls = null, this._updateDrawMode(G), this._isLargeDraw ? this._renderLarge(G) : this._renderNormal(G);
    }, C.prototype.incrementalPrepareRender = function(G, U, K) {
      this._clear(), this._updateDrawMode(G);
    }, C.prototype.incrementalRender = function(G, U, K, W) {
      this._progressiveEls = [], this._isLargeDraw ? this._incrementalRenderLarge(G, U) : this._incrementalRenderNormal(G, U);
    }, C.prototype.eachRendered = function(G) {
      traverseElements(this._progressiveEls || this.group, G);
    }, C.prototype._updateDrawMode = function(G) {
      var U = G.pipelineContext.large;
      (this._isLargeDraw == null || U !== this._isLargeDraw) && (this._isLargeDraw = U, this._clear());
    }, C.prototype._renderNormal = function(G) {
      var U = G.getData(), K = this._data, W = this.group, Z = U.getLayout("isSimpleBox"), X = G.get("clip", !0), Q = G.coordinateSystem, ee = Q.getArea && Q.getArea();
      this._data || W.removeAll(), U.diff(K).add(function(te) {
        if (U.hasValue(te)) {
          var re = U.getItemLayout(te);
          if (X && isNormalBoxClipped(ee, re))
            return;
          var ne = createNormalBox(re, te, !0);
          initProps(ne, {
            shape: {
              points: re.ends
            }
          }, G, te), setBoxCommon(ne, U, te, Z), W.add(ne), U.setItemGraphicEl(te, ne);
        }
      }).update(function(te, re) {
        var ne = K.getItemGraphicEl(re);
        if (!U.hasValue(te)) {
          W.remove(ne);
          return;
        }
        var ae = U.getItemLayout(te);
        if (X && isNormalBoxClipped(ee, ae)) {
          W.remove(ne);
          return;
        }
        ne ? (updateProps$1(ne, {
          shape: {
            points: ae.ends
          }
        }, G, te), saveOldStyle(ne)) : ne = createNormalBox(ae), setBoxCommon(ne, U, te, Z), W.add(ne), U.setItemGraphicEl(te, ne);
      }).remove(function(te) {
        var re = K.getItemGraphicEl(te);
        re && W.remove(re);
      }).execute(), this._data = U;
    }, C.prototype._renderLarge = function(G) {
      this._clear(), createLarge(G, this.group);
      var U = G.get("clip", !0) ? createClipPath(G.coordinateSystem, !1, G) : null;
      U ? this.group.setClipPath(U) : this.group.removeClipPath();
    }, C.prototype._incrementalRenderNormal = function(G, U) {
      for (var K = U.getData(), W = K.getLayout("isSimpleBox"), Z; (Z = G.next()) != null; ) {
        var X = K.getItemLayout(Z), Q = createNormalBox(X);
        setBoxCommon(Q, K, Z, W), Q.incremental = !0, this.group.add(Q), this._progressiveEls.push(Q);
      }
    }, C.prototype._incrementalRenderLarge = function(G, U) {
      createLarge(U, this.group, this._progressiveEls, !0);
    }, C.prototype.remove = function(G) {
      this._clear();
    }, C.prototype._clear = function() {
      this.group.removeAll(), this._data = null;
    }, C.type = "candlestick", C;
  }(ChartView$1)
), NormalBoxPathShape = (
  /** @class */
  function() {
    function H() {
    }
    return H;
  }()
), NormalBoxPath = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C(G) {
      var U = H.call(this, G) || this;
      return U.type = "normalCandlestickBox", U;
    }
    return C.prototype.getDefaultShape = function() {
      return new NormalBoxPathShape();
    }, C.prototype.buildPath = function(G, U) {
      var K = U.points;
      this.__simpleBox ? (G.moveTo(K[4][0], K[4][1]), G.lineTo(K[6][0], K[6][1])) : (G.moveTo(K[0][0], K[0][1]), G.lineTo(K[1][0], K[1][1]), G.lineTo(K[2][0], K[2][1]), G.lineTo(K[3][0], K[3][1]), G.closePath(), G.moveTo(K[4][0], K[4][1]), G.lineTo(K[5][0], K[5][1]), G.moveTo(K[6][0], K[6][1]), G.lineTo(K[7][0], K[7][1]));
    }, C;
  }(Path$1)
);
function createNormalBox(H, C, G) {
  var U = H.ends;
  return new NormalBoxPath({
    shape: {
      points: G ? transInit(U, H) : U
    },
    z2: 100
  });
}
function isNormalBoxClipped(H, C) {
  for (var G = !0, U = 0; U < C.ends.length; U++)
    if (H.contain(C.ends[U][0], C.ends[U][1])) {
      G = !1;
      break;
    }
  return G;
}
function setBoxCommon(H, C, G, U) {
  var K = C.getItemModel(G);
  H.useStyle(C.getItemVisual(G, "style")), H.style.strokeNoScale = !0, H.__simpleBox = U, setStatesStylesFromModel(H, K);
}
function transInit(H, C) {
  return map$1(H, function(G) {
    return G = G.slice(), G[1] = C.initBaseline, G;
  });
}
var LargeBoxPathShape = (
  /** @class */
  function() {
    function H() {
    }
    return H;
  }()
), LargeBoxPath = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C(G) {
      var U = H.call(this, G) || this;
      return U.type = "largeCandlestickBox", U;
    }
    return C.prototype.getDefaultShape = function() {
      return new LargeBoxPathShape();
    }, C.prototype.buildPath = function(G, U) {
      for (var K = U.points, W = 0; W < K.length; )
        if (this.__sign === K[W++]) {
          var Z = K[W++];
          G.moveTo(Z, K[W++]), G.lineTo(Z, K[W++]);
        } else
          W += 3;
    }, C;
  }(Path$1)
);
function createLarge(H, C, G, U) {
  var K = H.getData(), W = K.getLayout("largePoints"), Z = new LargeBoxPath({
    shape: {
      points: W
    },
    __sign: 1,
    ignoreCoarsePointer: !0
  });
  C.add(Z);
  var X = new LargeBoxPath({
    shape: {
      points: W
    },
    __sign: -1,
    ignoreCoarsePointer: !0
  });
  C.add(X);
  var Q = new LargeBoxPath({
    shape: {
      points: W
    },
    __sign: 0,
    ignoreCoarsePointer: !0
  });
  C.add(Q), setLargeStyle(1, Z, H), setLargeStyle(-1, X, H), setLargeStyle(0, Q, H), U && (Z.incremental = !0, X.incremental = !0), G && G.push(Z, X);
}
function setLargeStyle(H, C, G, U) {
  var K = G.get(["itemStyle", H > 0 ? "borderColor" : "borderColor0"]) || G.get(["itemStyle", H > 0 ? "color" : "color0"]);
  H === 0 && (K = G.get(["itemStyle", "borderColorDoji"]));
  var W = G.getModel("itemStyle").getItemStyle(SKIP_PROPS);
  C.useStyle(W), C.style.fill = null, C.style.stroke = K;
}
const CandlestickView$1 = CandlestickView;
var CandlestickSeriesModel = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G.defaultValueDimensions = [{
        name: "open",
        defaultTooltip: !0
      }, {
        name: "close",
        defaultTooltip: !0
      }, {
        name: "lowest",
        defaultTooltip: !0
      }, {
        name: "highest",
        defaultTooltip: !0
      }], G;
    }
    return C.prototype.getShadowDim = function() {
      return "open";
    }, C.prototype.brushSelector = function(G, U, K) {
      var W = U.getItemLayout(G);
      return W && K.rect(W.brushRect);
    }, C.type = "series.candlestick", C.dependencies = ["xAxis", "yAxis", "grid"], C.defaultOption = {
      // zlevel: 0,
      z: 2,
      coordinateSystem: "cartesian2d",
      legendHoverLink: !0,
      // xAxisIndex: 0,
      // yAxisIndex: 0,
      layout: null,
      clip: !0,
      itemStyle: {
        color: "#eb5454",
        color0: "#47b262",
        borderColor: "#eb5454",
        borderColor0: "#47b262",
        borderColorDoji: null,
        // borderColor: '#d24040',
        // borderColor0: '#398f4f',
        borderWidth: 1
      },
      emphasis: {
        scale: !0,
        itemStyle: {
          borderWidth: 2
        }
      },
      barMaxWidth: null,
      barMinWidth: null,
      barWidth: null,
      large: !0,
      largeThreshold: 600,
      progressive: 3e3,
      progressiveThreshold: 1e4,
      progressiveChunkMode: "mod",
      animationEasing: "linear",
      animationDuration: 300
    }, C;
  }(SeriesModel$1)
);
mixin(CandlestickSeriesModel, WhiskerBoxCommonMixin, !0);
const CandlestickSeriesModel$1 = CandlestickSeriesModel;
function candlestickPreprocessor(H) {
  !H || !isArray$1(H.series) || each$f(H.series, function(C) {
    isObject$3(C) && C.type === "k" && (C.type = "candlestick");
  });
}
var positiveBorderColorQuery = ["itemStyle", "borderColor"], negativeBorderColorQuery = ["itemStyle", "borderColor0"], dojiBorderColorQuery = ["itemStyle", "borderColorDoji"], positiveColorQuery = ["itemStyle", "color"], negativeColorQuery = ["itemStyle", "color0"], candlestickVisual = {
  seriesType: "candlestick",
  plan: createRenderPlanner(),
  // For legend.
  performRawSeries: !0,
  reset: function(H, C) {
    function G(W, Z) {
      return Z.get(W > 0 ? positiveColorQuery : negativeColorQuery);
    }
    function U(W, Z) {
      return Z.get(W === 0 ? dojiBorderColorQuery : W > 0 ? positiveBorderColorQuery : negativeBorderColorQuery);
    }
    if (!C.isSeriesFiltered(H)) {
      var K = H.pipelineContext.large;
      return !K && {
        progress: function(W, Z) {
          for (var X; (X = W.next()) != null; ) {
            var Q = Z.getItemModel(X), ee = Z.getItemLayout(X).sign, te = Q.getItemStyle();
            te.fill = G(ee, Q), te.stroke = U(ee, Q) || te.fill;
            var re = Z.ensureUniqueItemVisual(X, "style");
            extend(re, te);
          }
        }
      };
    }
  }
};
const candlestickVisual$1 = candlestickVisual;
var candlestickLayout = {
  seriesType: "candlestick",
  plan: createRenderPlanner(),
  reset: function(H) {
    var C = H.coordinateSystem, G = H.getData(), U = calculateCandleWidth(H, G), K = 0, W = 1, Z = ["x", "y"], X = G.getDimensionIndex(G.mapDimension(Z[K])), Q = map$1(G.mapDimensionsAll(Z[W]), G.getDimensionIndex, G), ee = Q[0], te = Q[1], re = Q[2], ne = Q[3];
    if (G.setLayout({
      candleWidth: U,
      // The value is experimented visually.
      isSimpleBox: U <= 1.3
    }), X < 0 || Q.length < 4)
      return;
    return {
      progress: H.pipelineContext.large ? ie : ae
    };
    function ae(se, oe) {
      for (var le, ue = oe.getStore(); (le = se.next()) != null; ) {
        var ce = ue.get(X, le), de = ue.get(ee, le), ge = ue.get(te, le), fe = ue.get(re, le), ve = ue.get(ne, le), pe = Math.min(de, ge), he = Math.max(de, ge), me = _e(pe, ce), ye = _e(he, ce), Ce = _e(fe, ce), Ie = _e(ve, ce), be = [];
        xe(be, ye, 0), xe(be, me, 1), be.push(Pe(Ie), Pe(ye), Pe(Ce), Pe(me));
        var Se = oe.getItemModel(le), Ae = !!Se.get(["itemStyle", "borderColorDoji"]);
        oe.setItemLayout(le, {
          sign: getSign(ue, le, de, ge, te, Ae),
          initBaseline: de > ge ? ye[W] : me[W],
          ends: be,
          brushRect: Te(fe, ve, ce)
        });
      }
      function _e($e, Me) {
        var Ee = [];
        return Ee[K] = Me, Ee[W] = $e, isNaN(Me) || isNaN($e) ? [NaN, NaN] : C.dataToPoint(Ee);
      }
      function xe($e, Me, Ee) {
        var we = Me.slice(), Oe = Me.slice();
        we[K] = subPixelOptimize(we[K] + U / 2, 1, !1), Oe[K] = subPixelOptimize(Oe[K] - U / 2, 1, !0), Ee ? $e.push(we, Oe) : $e.push(Oe, we);
      }
      function Te($e, Me, Ee) {
        var we = _e($e, Ee), Oe = _e(Me, Ee);
        return we[K] -= U / 2, Oe[K] -= U / 2, {
          x: we[0],
          y: we[1],
          width: U,
          height: Oe[1] - we[1]
        };
      }
      function Pe($e) {
        return $e[K] = subPixelOptimize($e[K], 1), $e;
      }
    }
    function ie(se, oe) {
      for (var le = createFloat32Array(se.count * 4), ue = 0, ce, de = [], ge = [], fe, ve = oe.getStore(), pe = !!H.get(["itemStyle", "borderColorDoji"]); (fe = se.next()) != null; ) {
        var he = ve.get(X, fe), me = ve.get(ee, fe), ye = ve.get(te, fe), Ce = ve.get(re, fe), Ie = ve.get(ne, fe);
        if (isNaN(he) || isNaN(Ce) || isNaN(Ie)) {
          le[ue++] = NaN, ue += 3;
          continue;
        }
        le[ue++] = getSign(ve, fe, me, ye, te, pe), de[K] = he, de[W] = Ce, ce = C.dataToPoint(de, null, ge), le[ue++] = ce ? ce[0] : NaN, le[ue++] = ce ? ce[1] : NaN, de[W] = Ie, ce = C.dataToPoint(de, null, ge), le[ue++] = ce ? ce[1] : NaN;
      }
      oe.setLayout("largePoints", le);
    }
  }
};
function getSign(H, C, G, U, K, W) {
  var Z;
  return G > U ? Z = -1 : G < U ? Z = 1 : Z = W ? 0 : C > 0 ? H.get(K, C - 1) <= U ? 1 : -1 : (
    // No record of previous, set to be positive
    1
  ), Z;
}
function calculateCandleWidth(H, C) {
  var G = H.getBaseAxis(), U, K = G.type === "category" ? G.getBandWidth() : (U = G.getExtent(), Math.abs(U[1] - U[0]) / C.count()), W = parsePercent(retrieve2(H.get("barMaxWidth"), K), K), Z = parsePercent(retrieve2(H.get("barMinWidth"), 1), K), X = H.get("barWidth");
  return X != null ? parsePercent(X, K) : Math.max(Math.min(K / 2, W), Z);
}
const candlestickLayout$1 = candlestickLayout;
function install$y(H) {
  H.registerChartView(CandlestickView$1), H.registerSeriesModel(CandlestickSeriesModel$1), H.registerPreprocessor(candlestickPreprocessor), H.registerVisual(candlestickVisual$1), H.registerLayout(candlestickLayout$1);
}
function updateRipplePath(H, C) {
  var G = C.rippleEffectColor || C.color;
  H.eachChild(function(U) {
    U.attr({
      z: C.z,
      zlevel: C.zlevel,
      style: {
        stroke: C.brushType === "stroke" ? G : null,
        fill: C.brushType === "fill" ? G : null
      }
    });
  });
}
var EffectSymbol = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C(G, U) {
      var K = H.call(this) || this, W = new SymbolClz(G, U), Z = new Group$4();
      return K.add(W), K.add(Z), K.updateData(G, U), K;
    }
    return C.prototype.stopEffectAnimation = function() {
      this.childAt(1).removeAll();
    }, C.prototype.startEffectAnimation = function(G) {
      for (var U = G.symbolType, K = G.color, W = G.rippleNumber, Z = this.childAt(1), X = 0; X < W; X++) {
        var Q = createSymbol$1(U, -1, -1, 2, 2, K);
        Q.attr({
          style: {
            strokeNoScale: !0
          },
          z2: 99,
          silent: !0,
          scaleX: 0.5,
          scaleY: 0.5
        });
        var ee = -X / W * G.period + G.effectOffset;
        Q.animate("", !0).when(G.period, {
          scaleX: G.rippleScale / 2,
          scaleY: G.rippleScale / 2
        }).delay(ee).start(), Q.animateStyle(!0).when(G.period, {
          opacity: 0
        }).delay(ee).start(), Z.add(Q);
      }
      updateRipplePath(Z, G);
    }, C.prototype.updateEffectAnimation = function(G) {
      for (var U = this._effectCfg, K = this.childAt(1), W = ["symbolType", "period", "rippleScale", "rippleNumber"], Z = 0; Z < W.length; Z++) {
        var X = W[Z];
        if (U[X] !== G[X]) {
          this.stopEffectAnimation(), this.startEffectAnimation(G);
          return;
        }
      }
      updateRipplePath(K, G);
    }, C.prototype.highlight = function() {
      enterEmphasis(this);
    }, C.prototype.downplay = function() {
      leaveEmphasis(this);
    }, C.prototype.getSymbolType = function() {
      var G = this.childAt(0);
      return G && G.getSymbolType();
    }, C.prototype.updateData = function(G, U) {
      var K = this, W = G.hostModel;
      this.childAt(0).updateData(G, U);
      var Z = this.childAt(1), X = G.getItemModel(U), Q = G.getItemVisual(U, "symbol"), ee = normalizeSymbolSize(G.getItemVisual(U, "symbolSize")), te = G.getItemVisual(U, "style"), re = te && te.fill, ne = X.getModel("emphasis");
      Z.setScale(ee), Z.traverse(function(oe) {
        oe.setStyle("fill", re);
      });
      var ae = normalizeSymbolOffset(G.getItemVisual(U, "symbolOffset"), ee);
      ae && (Z.x = ae[0], Z.y = ae[1]);
      var ie = G.getItemVisual(U, "symbolRotate");
      Z.rotation = (ie || 0) * Math.PI / 180 || 0;
      var se = {};
      se.showEffectOn = W.get("showEffectOn"), se.rippleScale = X.get(["rippleEffect", "scale"]), se.brushType = X.get(["rippleEffect", "brushType"]), se.period = X.get(["rippleEffect", "period"]) * 1e3, se.effectOffset = U / G.count(), se.z = W.getShallow("z") || 0, se.zlevel = W.getShallow("zlevel") || 0, se.symbolType = Q, se.color = re, se.rippleEffectColor = X.get(["rippleEffect", "color"]), se.rippleNumber = X.get(["rippleEffect", "number"]), se.showEffectOn === "render" ? (this._effectCfg ? this.updateEffectAnimation(se) : this.startEffectAnimation(se), this._effectCfg = se) : (this._effectCfg = null, this.stopEffectAnimation(), this.onHoverStateChange = function(oe) {
        oe === "emphasis" ? se.showEffectOn !== "render" && K.startEffectAnimation(se) : oe === "normal" && se.showEffectOn !== "render" && K.stopEffectAnimation();
      }), this._effectCfg = se, toggleHoverEmphasis(this, ne.get("focus"), ne.get("blurScope"), ne.get("disabled"));
    }, C.prototype.fadeOut = function(G) {
      G && G();
    }, C;
  }(Group$4)
);
const EffectSymbol$1 = EffectSymbol;
var EffectScatterView = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G;
    }
    return C.prototype.init = function() {
      this._symbolDraw = new SymbolDraw$1(EffectSymbol$1);
    }, C.prototype.render = function(G, U, K) {
      var W = G.getData(), Z = this._symbolDraw;
      Z.updateData(W, {
        clipShape: this._getClipShape(G)
      }), this.group.add(Z.group);
    }, C.prototype._getClipShape = function(G) {
      var U = G.coordinateSystem, K = U && U.getArea && U.getArea();
      return G.get("clip", !0) ? K : null;
    }, C.prototype.updateTransform = function(G, U, K) {
      var W = G.getData();
      this.group.dirty();
      var Z = pointsLayout("").reset(G, U, K);
      Z.progress && Z.progress({
        start: 0,
        end: W.count(),
        count: W.count()
      }, W), this._symbolDraw.updateLayout();
    }, C.prototype._updateGroupTransform = function(G) {
      var U = G.coordinateSystem;
      U && U.getRoamTransform && (this.group.transform = clone$2(U.getRoamTransform()), this.group.decomposeTransform());
    }, C.prototype.remove = function(G, U) {
      this._symbolDraw && this._symbolDraw.remove(!0);
    }, C.type = "effectScatter", C;
  }(ChartView$1)
);
const EffectScatterView$1 = EffectScatterView;
var EffectScatterSeriesModel = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G.hasSymbolVisual = !0, G;
    }
    return C.prototype.getInitialData = function(G, U) {
      return createSeriesData(null, this, {
        useEncodeDefaulter: !0
      });
    }, C.prototype.brushSelector = function(G, U, K) {
      return K.point(U.getItemLayout(G));
    }, C.type = "series.effectScatter", C.dependencies = ["grid", "polar"], C.defaultOption = {
      coordinateSystem: "cartesian2d",
      // zlevel: 0,
      z: 2,
      legendHoverLink: !0,
      effectType: "ripple",
      progressive: 0,
      // When to show the effect, option: 'render'|'emphasis'
      showEffectOn: "render",
      clip: !0,
      // Ripple effect config
      rippleEffect: {
        period: 4,
        // Scale of ripple
        scale: 2.5,
        // Brush type can be fill or stroke
        brushType: "fill",
        // Ripple number
        number: 3
      },
      universalTransition: {
        divideShape: "clone"
      },
      // Cartesian coordinate system
      // xAxisIndex: 0,
      // yAxisIndex: 0,
      // Polar coordinate system
      // polarIndex: 0,
      // Geo coordinate system
      // geoIndex: 0,
      // symbol: null,        // 图形类型
      symbolSize: 10
      // 图形大小，半宽（半径）参数，当图形为方向或菱形则总宽度为symbolSize * 2
      // symbolRotate: null,  // 图形旋转控制
      // itemStyle: {
      //     opacity: 1
      // }
    }, C;
  }(SeriesModel$1)
);
const EffectScatterSeriesModel$1 = EffectScatterSeriesModel;
function install$x(H) {
  H.registerChartView(EffectScatterView$1), H.registerSeriesModel(EffectScatterSeriesModel$1), H.registerLayout(pointsLayout("effectScatter"));
}
var EffectLine = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C(G, U, K) {
      var W = H.call(this) || this;
      return W.add(W.createLine(G, U, K)), W._updateEffectSymbol(G, U), W;
    }
    return C.prototype.createLine = function(G, U, K) {
      return new Line$1(G, U, K);
    }, C.prototype._updateEffectSymbol = function(G, U) {
      var K = G.getItemModel(U), W = K.getModel("effect"), Z = W.get("symbolSize"), X = W.get("symbol");
      isArray$1(Z) || (Z = [Z, Z]);
      var Q = G.getItemVisual(U, "style"), ee = W.get("color") || Q && Q.stroke, te = this.childAt(1);
      this._symbolType !== X && (this.remove(te), te = createSymbol$1(X, -0.5, -0.5, 1, 1, ee), te.z2 = 100, te.culling = !0, this.add(te)), te && (te.setStyle("shadowColor", ee), te.setStyle(W.getItemStyle(["color"])), te.scaleX = Z[0], te.scaleY = Z[1], te.setColor(ee), this._symbolType = X, this._symbolScale = Z, this._updateEffectAnimation(G, W, U));
    }, C.prototype._updateEffectAnimation = function(G, U, K) {
      var W = this.childAt(1);
      if (W) {
        var Z = G.getItemLayout(K), X = U.get("period") * 1e3, Q = U.get("loop"), ee = U.get("roundTrip"), te = U.get("constantSpeed"), re = retrieve(U.get("delay"), function(ae) {
          return ae / G.count() * X / 3;
        });
        if (W.ignore = !0, this._updateAnimationPoints(W, Z), te > 0 && (X = this._getLineLength(W) / te * 1e3), X !== this._period || Q !== this._loop || ee !== this._roundTrip) {
          W.stopAnimation();
          var ne = void 0;
          isFunction(re) ? ne = re(K) : ne = re, W.__t > 0 && (ne = -X * W.__t), this._animateSymbol(W, X, ne, Q, ee);
        }
        this._period = X, this._loop = Q, this._roundTrip = ee;
      }
    }, C.prototype._animateSymbol = function(G, U, K, W, Z) {
      if (U > 0) {
        G.__t = 0;
        var X = this, Q = G.animate("", W).when(Z ? U * 2 : U, {
          __t: Z ? 2 : 1
        }).delay(K).during(function() {
          X._updateSymbolPosition(G);
        });
        W || Q.done(function() {
          X.remove(G);
        }), Q.start();
      }
    }, C.prototype._getLineLength = function(G) {
      return dist$1(G.__p1, G.__cp1) + dist$1(G.__cp1, G.__p2);
    }, C.prototype._updateAnimationPoints = function(G, U) {
      G.__p1 = U[0], G.__p2 = U[1], G.__cp1 = U[2] || [(U[0][0] + U[1][0]) / 2, (U[0][1] + U[1][1]) / 2];
    }, C.prototype.updateData = function(G, U, K) {
      this.childAt(0).updateData(G, U, K), this._updateEffectSymbol(G, U);
    }, C.prototype._updateSymbolPosition = function(G) {
      var U = G.__p1, K = G.__p2, W = G.__cp1, Z = G.__t < 1 ? G.__t : 2 - G.__t, X = [G.x, G.y], Q = X.slice(), ee = quadraticAt$1, te = quadraticDerivativeAt;
      X[0] = ee(U[0], W[0], K[0], Z), X[1] = ee(U[1], W[1], K[1], Z);
      var re = G.__t < 1 ? te(U[0], W[0], K[0], Z) : te(K[0], W[0], U[0], 1 - Z), ne = G.__t < 1 ? te(U[1], W[1], K[1], Z) : te(K[1], W[1], U[1], 1 - Z);
      G.rotation = -Math.atan2(ne, re) - Math.PI / 2, (this._symbolType === "line" || this._symbolType === "rect" || this._symbolType === "roundRect") && (G.__lastT !== void 0 && G.__lastT < G.__t ? (G.scaleY = dist$1(Q, X) * 1.05, Z === 1 && (X[0] = Q[0] + (X[0] - Q[0]) / 2, X[1] = Q[1] + (X[1] - Q[1]) / 2)) : G.__lastT === 1 ? G.scaleY = 2 * dist$1(U, X) : G.scaleY = this._symbolScale[1]), G.__lastT = G.__t, G.ignore = !1, G.x = X[0], G.y = X[1];
    }, C.prototype.updateLayout = function(G, U) {
      this.childAt(0).updateLayout(G, U);
      var K = G.getItemModel(U).getModel("effect");
      this._updateEffectAnimation(G, K, U);
    }, C;
  }(Group$4)
);
const EffectLine$1 = EffectLine;
var Polyline = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C(G, U, K) {
      var W = H.call(this) || this;
      return W._createPolyline(G, U, K), W;
    }
    return C.prototype._createPolyline = function(G, U, K) {
      var W = G.getItemLayout(U), Z = new Polyline$3({
        shape: {
          points: W
        }
      });
      this.add(Z), this._updateCommonStl(G, U, K);
    }, C.prototype.updateData = function(G, U, K) {
      var W = G.hostModel, Z = this.childAt(0), X = {
        shape: {
          points: G.getItemLayout(U)
        }
      };
      updateProps$1(Z, X, W, U), this._updateCommonStl(G, U, K);
    }, C.prototype._updateCommonStl = function(G, U, K) {
      var W = this.childAt(0), Z = G.getItemModel(U), X = K && K.emphasisLineStyle, Q = K && K.focus, ee = K && K.blurScope, te = K && K.emphasisDisabled;
      if (!K || G.hasItemOption) {
        var re = Z.getModel("emphasis");
        X = re.getModel("lineStyle").getLineStyle(), te = re.get("disabled"), Q = re.get("focus"), ee = re.get("blurScope");
      }
      W.useStyle(G.getItemVisual(U, "style")), W.style.fill = null, W.style.strokeNoScale = !0;
      var ne = W.ensureState("emphasis");
      ne.style = X, toggleHoverEmphasis(this, Q, ee, te);
    }, C.prototype.updateLayout = function(G, U) {
      var K = this.childAt(0);
      K.setShape("points", G.getItemLayout(U));
    }, C;
  }(Group$4)
);
const Polyline$1 = Polyline;
var EffectPolyline = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G._lastFrame = 0, G._lastFramePercent = 0, G;
    }
    return C.prototype.createLine = function(G, U, K) {
      return new Polyline$1(G, U, K);
    }, C.prototype._updateAnimationPoints = function(G, U) {
      this._points = U;
      for (var K = [0], W = 0, Z = 1; Z < U.length; Z++) {
        var X = U[Z - 1], Q = U[Z];
        W += dist$1(X, Q), K.push(W);
      }
      if (W === 0) {
        this._length = 0;
        return;
      }
      for (var Z = 0; Z < K.length; Z++)
        K[Z] /= W;
      this._offsets = K, this._length = W;
    }, C.prototype._getLineLength = function() {
      return this._length;
    }, C.prototype._updateSymbolPosition = function(G) {
      var U = G.__t < 1 ? G.__t : 2 - G.__t, K = this._points, W = this._offsets, Z = K.length;
      if (W) {
        var X = this._lastFrame, Q;
        if (U < this._lastFramePercent) {
          var ee = Math.min(X + 1, Z - 1);
          for (Q = ee; Q >= 0 && !(W[Q] <= U); Q--)
            ;
          Q = Math.min(Q, Z - 2);
        } else {
          for (Q = X; Q < Z && !(W[Q] > U); Q++)
            ;
          Q = Math.min(Q - 1, Z - 2);
        }
        var te = (U - W[Q]) / (W[Q + 1] - W[Q]), re = K[Q], ne = K[Q + 1];
        G.x = re[0] * (1 - te) + te * ne[0], G.y = re[1] * (1 - te) + te * ne[1];
        var ae = G.__t < 1 ? ne[0] - re[0] : re[0] - ne[0], ie = G.__t < 1 ? ne[1] - re[1] : re[1] - ne[1];
        G.rotation = -Math.atan2(ie, ae) - Math.PI / 2, this._lastFrame = Q, this._lastFramePercent = U, G.ignore = !1;
      }
    }, C;
  }(EffectLine$1)
);
const EffectPolyline$1 = EffectPolyline;
var LargeLinesPathShape = (
  /** @class */
  function() {
    function H() {
      this.polyline = !1, this.curveness = 0, this.segs = [];
    }
    return H;
  }()
), LargeLinesPath = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C(G) {
      var U = H.call(this, G) || this;
      return U._off = 0, U.hoverDataIdx = -1, U;
    }
    return C.prototype.reset = function() {
      this.notClear = !1, this._off = 0;
    }, C.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    }, C.prototype.getDefaultShape = function() {
      return new LargeLinesPathShape();
    }, C.prototype.buildPath = function(G, U) {
      var K = U.segs, W = U.curveness, Z;
      if (U.polyline)
        for (Z = this._off; Z < K.length; ) {
          var X = K[Z++];
          if (X > 0) {
            G.moveTo(K[Z++], K[Z++]);
            for (var Q = 1; Q < X; Q++)
              G.lineTo(K[Z++], K[Z++]);
          }
        }
      else
        for (Z = this._off; Z < K.length; ) {
          var ee = K[Z++], te = K[Z++], re = K[Z++], ne = K[Z++];
          if (G.moveTo(ee, te), W > 0) {
            var ae = (ee + re) / 2 - (te - ne) * W, ie = (te + ne) / 2 - (re - ee) * W;
            G.quadraticCurveTo(ae, ie, re, ne);
          } else
            G.lineTo(re, ne);
        }
      this.incremental && (this._off = Z, this.notClear = !0);
    }, C.prototype.findDataIndex = function(G, U) {
      var K = this.shape, W = K.segs, Z = K.curveness, X = this.style.lineWidth;
      if (K.polyline)
        for (var Q = 0, ee = 0; ee < W.length; ) {
          var te = W[ee++];
          if (te > 0)
            for (var re = W[ee++], ne = W[ee++], ae = 1; ae < te; ae++) {
              var ie = W[ee++], se = W[ee++];
              if (containStroke$4(re, ne, ie, se, X, G, U))
                return Q;
            }
          Q++;
        }
      else
        for (var Q = 0, ee = 0; ee < W.length; ) {
          var re = W[ee++], ne = W[ee++], ie = W[ee++], se = W[ee++];
          if (Z > 0) {
            var oe = (re + ie) / 2 - (ne - se) * Z, le = (ne + se) / 2 - (ie - re) * Z;
            if (containStroke$2(re, ne, oe, le, ie, se, X, G, U))
              return Q;
          } else if (containStroke$4(re, ne, ie, se, X, G, U))
            return Q;
          Q++;
        }
      return -1;
    }, C.prototype.contain = function(G, U) {
      var K = this.transformCoordToLocal(G, U), W = this.getBoundingRect();
      if (G = K[0], U = K[1], W.contain(G, U)) {
        var Z = this.hoverDataIdx = this.findDataIndex(G, U);
        return Z >= 0;
      }
      return this.hoverDataIdx = -1, !1;
    }, C.prototype.getBoundingRect = function() {
      var G = this._rect;
      if (!G) {
        for (var U = this.shape, K = U.segs, W = 1 / 0, Z = 1 / 0, X = -1 / 0, Q = -1 / 0, ee = 0; ee < K.length; ) {
          var te = K[ee++], re = K[ee++];
          W = Math.min(te, W), X = Math.max(te, X), Z = Math.min(re, Z), Q = Math.max(re, Q);
        }
        G = this._rect = new BoundingRect$1(W, Z, X, Q);
      }
      return G;
    }, C;
  }(Path$1)
), LargeLineDraw = (
  /** @class */
  function() {
    function H() {
      this.group = new Group$4();
    }
    return H.prototype.updateData = function(C) {
      this._clear();
      var G = this._create();
      G.setShape({
        segs: C.getLayout("linesPoints")
      }), this._setCommon(G, C);
    }, H.prototype.incrementalPrepareUpdate = function(C) {
      this.group.removeAll(), this._clear();
    }, H.prototype.incrementalUpdate = function(C, G) {
      var U = this._newAdded[0], K = G.getLayout("linesPoints"), W = U && U.shape.segs;
      if (W && W.length < 2e4) {
        var Z = W.length, X = new Float32Array(Z + K.length);
        X.set(W), X.set(K, Z), U.setShape({
          segs: X
        });
      } else {
        this._newAdded = [];
        var Q = this._create();
        Q.incremental = !0, Q.setShape({
          segs: K
        }), this._setCommon(Q, G), Q.__startIndex = C.start;
      }
    }, H.prototype.remove = function() {
      this._clear();
    }, H.prototype.eachRendered = function(C) {
      this._newAdded[0] && C(this._newAdded[0]);
    }, H.prototype._create = function() {
      var C = new LargeLinesPath({
        cursor: "default",
        ignoreCoarsePointer: !0
      });
      return this._newAdded.push(C), this.group.add(C), C;
    }, H.prototype._setCommon = function(C, G, U) {
      var K = G.hostModel;
      C.setShape({
        polyline: K.get("polyline"),
        curveness: K.get(["lineStyle", "curveness"])
      }), C.useStyle(K.getModel("lineStyle").getLineStyle()), C.style.strokeNoScale = !0;
      var W = G.getVisual("style");
      W && W.stroke && C.setStyle("stroke", W.stroke), C.setStyle("fill", null);
      var Z = getECData(C);
      Z.seriesIndex = K.seriesIndex, C.on("mousemove", function(X) {
        Z.dataIndex = null;
        var Q = C.hoverDataIdx;
        Q > 0 && (Z.dataIndex = Q + C.__startIndex);
      });
    }, H.prototype._clear = function() {
      this._newAdded = [], this.group.removeAll();
    }, H;
  }()
);
const LargeLineDraw$1 = LargeLineDraw;
var linesLayout = {
  seriesType: "lines",
  plan: createRenderPlanner(),
  reset: function(H) {
    var C = H.coordinateSystem;
    if (!C) {
      process.env.NODE_ENV !== "production" && error("The lines series must have a coordinate system.");
      return;
    }
    var G = H.get("polyline"), U = H.pipelineContext.large;
    return {
      progress: function(K, W) {
        var Z = [];
        if (U) {
          var X = void 0, Q = K.end - K.start;
          if (G) {
            for (var ee = 0, te = K.start; te < K.end; te++)
              ee += H.getLineCoordsCount(te);
            X = new Float32Array(Q + ee * 2);
          } else
            X = new Float32Array(Q * 4);
          for (var re = 0, ne = [], te = K.start; te < K.end; te++) {
            var ae = H.getLineCoords(te, Z);
            G && (X[re++] = ae);
            for (var ie = 0; ie < ae; ie++)
              ne = C.dataToPoint(Z[ie], !1, ne), X[re++] = ne[0], X[re++] = ne[1];
          }
          W.setLayout("linesPoints", X);
        } else
          for (var te = K.start; te < K.end; te++) {
            var se = W.getItemModel(te), ae = H.getLineCoords(te, Z), oe = [];
            if (G)
              for (var le = 0; le < ae; le++)
                oe.push(C.dataToPoint(Z[le]));
            else {
              oe[0] = C.dataToPoint(Z[0]), oe[1] = C.dataToPoint(Z[1]);
              var ue = se.get(["lineStyle", "curveness"]);
              +ue && (oe[2] = [(oe[0][0] + oe[1][0]) / 2 - (oe[0][1] - oe[1][1]) * ue, (oe[0][1] + oe[1][1]) / 2 - (oe[1][0] - oe[0][0]) * ue]);
            }
            W.setItemLayout(te, oe);
          }
      }
    };
  }
};
const linesLayout$1 = linesLayout;
var LinesView = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G;
    }
    return C.prototype.render = function(G, U, K) {
      var W = G.getData(), Z = this._updateLineDraw(W, G), X = G.get("zlevel"), Q = G.get(["effect", "trailLength"]), ee = K.getZr(), te = ee.painter.getType() === "svg";
      te || ee.painter.getLayer(X).clear(!0), this._lastZlevel != null && !te && ee.configLayer(this._lastZlevel, {
        motionBlur: !1
      }), this._showEffect(G) && Q > 0 && (te ? process.env.NODE_ENV !== "production" && console.warn("SVG render mode doesn't support lines with trail effect") : ee.configLayer(X, {
        motionBlur: !0,
        lastFrameAlpha: Math.max(Math.min(Q / 10 + 0.9, 1), 0)
      })), Z.updateData(W);
      var re = G.get("clip", !0) && createClipPath(G.coordinateSystem, !1, G);
      re ? this.group.setClipPath(re) : this.group.removeClipPath(), this._lastZlevel = X, this._finished = !0;
    }, C.prototype.incrementalPrepareRender = function(G, U, K) {
      var W = G.getData(), Z = this._updateLineDraw(W, G);
      Z.incrementalPrepareUpdate(W), this._clearLayer(K), this._finished = !1;
    }, C.prototype.incrementalRender = function(G, U, K) {
      this._lineDraw.incrementalUpdate(G, U.getData()), this._finished = G.end === U.getData().count();
    }, C.prototype.eachRendered = function(G) {
      this._lineDraw && this._lineDraw.eachRendered(G);
    }, C.prototype.updateTransform = function(G, U, K) {
      var W = G.getData(), Z = G.pipelineContext;
      if (!this._finished || Z.large || Z.progressiveRender)
        return {
          update: !0
        };
      var X = linesLayout$1.reset(G, U, K);
      X.progress && X.progress({
        start: 0,
        end: W.count(),
        count: W.count()
      }, W), this._lineDraw.updateLayout(), this._clearLayer(K);
    }, C.prototype._updateLineDraw = function(G, U) {
      var K = this._lineDraw, W = this._showEffect(U), Z = !!U.get("polyline"), X = U.pipelineContext, Q = X.large;
      return process.env.NODE_ENV !== "production" && W && Q && console.warn("Large lines not support effect"), (!K || W !== this._hasEffet || Z !== this._isPolyline || Q !== this._isLargeDraw) && (K && K.remove(), K = this._lineDraw = Q ? new LargeLineDraw$1() : new LineDraw$1(Z ? W ? EffectPolyline$1 : Polyline$1 : W ? EffectLine$1 : Line$1), this._hasEffet = W, this._isPolyline = Z, this._isLargeDraw = Q), this.group.add(K.group), K;
    }, C.prototype._showEffect = function(G) {
      return !!G.get(["effect", "show"]);
    }, C.prototype._clearLayer = function(G) {
      var U = G.getZr(), K = U.painter.getType() === "svg";
      !K && this._lastZlevel != null && U.painter.getLayer(this._lastZlevel).clear(!0);
    }, C.prototype.remove = function(G, U) {
      this._lineDraw && this._lineDraw.remove(), this._lineDraw = null, this._clearLayer(U);
    }, C.prototype.dispose = function(G, U) {
      this.remove(G, U);
    }, C.type = "lines", C;
  }(ChartView$1)
);
const LinesView$1 = LinesView;
var Uint32Arr = typeof Uint32Array > "u" ? Array : Uint32Array, Float64Arr = typeof Float64Array > "u" ? Array : Float64Array;
function compatEc2(H) {
  var C = H.data;
  C && C[0] && C[0][0] && C[0][0].coord && (process.env.NODE_ENV !== "production" && console.warn("Lines data configuration has been changed to { coords:[[1,2],[2,3]] }"), H.data = map$1(C, function(G) {
    var U = [G[0].coord, G[1].coord], K = {
      coords: U
    };
    return G[0].name && (K.fromName = G[0].name), G[1].name && (K.toName = G[1].name), mergeAll([K, G[0], G[1]]);
  }));
}
var LinesSeriesModel = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G.visualStyleAccessPath = "lineStyle", G.visualDrawType = "stroke", G;
    }
    return C.prototype.init = function(G) {
      G.data = G.data || [], compatEc2(G);
      var U = this._processFlatCoordsArray(G.data);
      this._flatCoords = U.flatCoords, this._flatCoordsOffset = U.flatCoordsOffset, U.flatCoords && (G.data = new Float32Array(U.count)), H.prototype.init.apply(this, arguments);
    }, C.prototype.mergeOption = function(G) {
      if (compatEc2(G), G.data) {
        var U = this._processFlatCoordsArray(G.data);
        this._flatCoords = U.flatCoords, this._flatCoordsOffset = U.flatCoordsOffset, U.flatCoords && (G.data = new Float32Array(U.count));
      }
      H.prototype.mergeOption.apply(this, arguments);
    }, C.prototype.appendData = function(G) {
      var U = this._processFlatCoordsArray(G.data);
      U.flatCoords && (this._flatCoords ? (this._flatCoords = concatArray(this._flatCoords, U.flatCoords), this._flatCoordsOffset = concatArray(this._flatCoordsOffset, U.flatCoordsOffset)) : (this._flatCoords = U.flatCoords, this._flatCoordsOffset = U.flatCoordsOffset), G.data = new Float32Array(U.count)), this.getRawData().appendData(G.data);
    }, C.prototype._getCoordsFromItemModel = function(G) {
      var U = this.getData().getItemModel(G), K = U.option instanceof Array ? U.option : U.getShallow("coords");
      if (process.env.NODE_ENV !== "production" && !(K instanceof Array && K.length > 0 && K[0] instanceof Array))
        throw new Error("Invalid coords " + JSON.stringify(K) + ". Lines must have 2d coords array in data item.");
      return K;
    }, C.prototype.getLineCoordsCount = function(G) {
      return this._flatCoordsOffset ? this._flatCoordsOffset[G * 2 + 1] : this._getCoordsFromItemModel(G).length;
    }, C.prototype.getLineCoords = function(G, U) {
      if (this._flatCoordsOffset) {
        for (var K = this._flatCoordsOffset[G * 2], W = this._flatCoordsOffset[G * 2 + 1], Z = 0; Z < W; Z++)
          U[Z] = U[Z] || [], U[Z][0] = this._flatCoords[K + Z * 2], U[Z][1] = this._flatCoords[K + Z * 2 + 1];
        return W;
      } else {
        for (var X = this._getCoordsFromItemModel(G), Z = 0; Z < X.length; Z++)
          U[Z] = U[Z] || [], U[Z][0] = X[Z][0], U[Z][1] = X[Z][1];
        return X.length;
      }
    }, C.prototype._processFlatCoordsArray = function(G) {
      var U = 0;
      if (this._flatCoords && (U = this._flatCoords.length), isNumber(G[0])) {
        for (var K = G.length, W = new Uint32Arr(K), Z = new Float64Arr(K), X = 0, Q = 0, ee = 0, te = 0; te < K; ) {
          ee++;
          var re = G[te++];
          W[Q++] = X + U, W[Q++] = re;
          for (var ne = 0; ne < re; ne++) {
            var ae = G[te++], ie = G[te++];
            if (Z[X++] = ae, Z[X++] = ie, te > K && process.env.NODE_ENV !== "production")
              throw new Error("Invalid data format.");
          }
        }
        return {
          flatCoordsOffset: new Uint32Array(W.buffer, 0, Q),
          flatCoords: Z,
          count: ee
        };
      }
      return {
        flatCoordsOffset: null,
        flatCoords: null,
        count: G.length
      };
    }, C.prototype.getInitialData = function(G, U) {
      if (process.env.NODE_ENV !== "production") {
        var K = CoordinateSystem.get(G.coordinateSystem);
        if (!K)
          throw new Error("Unknown coordinate system " + G.coordinateSystem);
      }
      var W = new SeriesData$1(["value"], this);
      return W.hasItemOption = !1, W.initData(G.data, [], function(Z, X, Q, ee) {
        if (Z instanceof Array)
          return NaN;
        W.hasItemOption = !0;
        var te = Z.value;
        if (te != null)
          return te instanceof Array ? te[ee] : te;
      }), W;
    }, C.prototype.formatTooltip = function(G, U, K) {
      var W = this.getData(), Z = W.getItemModel(G), X = Z.get("name");
      if (X)
        return X;
      var Q = Z.get("fromName"), ee = Z.get("toName"), te = [];
      return Q != null && te.push(Q), ee != null && te.push(ee), createTooltipMarkup("nameValue", {
        name: te.join(" > ")
      });
    }, C.prototype.preventIncremental = function() {
      return !!this.get(["effect", "show"]);
    }, C.prototype.getProgressive = function() {
      var G = this.option.progressive;
      return G ?? (this.option.large ? 1e4 : this.get("progressive"));
    }, C.prototype.getProgressiveThreshold = function() {
      var G = this.option.progressiveThreshold;
      return G ?? (this.option.large ? 2e4 : this.get("progressiveThreshold"));
    }, C.prototype.getZLevelKey = function() {
      var G = this.getModel("effect"), U = G.get("trailLength");
      return this.getData().count() > this.getProgressiveThreshold() ? this.id : G.get("show") && U > 0 ? U + "" : "";
    }, C.type = "series.lines", C.dependencies = ["grid", "polar", "geo", "calendar"], C.defaultOption = {
      coordinateSystem: "geo",
      // zlevel: 0,
      z: 2,
      legendHoverLink: !0,
      // Cartesian coordinate system
      xAxisIndex: 0,
      yAxisIndex: 0,
      symbol: ["none", "none"],
      symbolSize: [10, 10],
      // Geo coordinate system
      geoIndex: 0,
      effect: {
        show: !1,
        period: 4,
        constantSpeed: 0,
        symbol: "circle",
        symbolSize: 3,
        loop: !0,
        trailLength: 0.2
      },
      large: !1,
      // Available when large is true
      largeThreshold: 2e3,
      polyline: !1,
      clip: !0,
      label: {
        show: !1,
        position: "end"
        // distance: 5,
        // formatter: 标签文本格式器，同Tooltip.formatter，不支持异步回调
      },
      lineStyle: {
        opacity: 0.5
      }
    }, C;
  }(SeriesModel$1)
);
const LinesSeriesModel$1 = LinesSeriesModel;
function normalize(H) {
  return H instanceof Array || (H = [H, H]), H;
}
var linesVisual = {
  seriesType: "lines",
  reset: function(H) {
    var C = normalize(H.get("symbol")), G = normalize(H.get("symbolSize")), U = H.getData();
    U.setVisual("fromSymbol", C && C[0]), U.setVisual("toSymbol", C && C[1]), U.setVisual("fromSymbolSize", G && G[0]), U.setVisual("toSymbolSize", G && G[1]);
    function K(W, Z) {
      var X = W.getItemModel(Z), Q = normalize(X.getShallow("symbol", !0)), ee = normalize(X.getShallow("symbolSize", !0));
      Q[0] && W.setItemVisual(Z, "fromSymbol", Q[0]), Q[1] && W.setItemVisual(Z, "toSymbol", Q[1]), ee[0] && W.setItemVisual(Z, "fromSymbolSize", ee[0]), ee[1] && W.setItemVisual(Z, "toSymbolSize", ee[1]);
    }
    return {
      dataEach: U.hasItemOption ? K : null
    };
  }
};
const linesVisual$1 = linesVisual;
function install$w(H) {
  H.registerChartView(LinesView$1), H.registerSeriesModel(LinesSeriesModel$1), H.registerLayout(linesLayout$1), H.registerVisual(linesVisual$1);
}
var GRADIENT_LEVELS = 256, HeatmapLayer = (
  /** @class */
  function() {
    function H() {
      this.blurSize = 30, this.pointSize = 20, this.maxOpacity = 1, this.minOpacity = 0, this._gradientPixels = {
        inRange: null,
        outOfRange: null
      };
      var C = platformApi.createCanvas();
      this.canvas = C;
    }
    return H.prototype.update = function(C, G, U, K, W, Z) {
      var X = this._getBrush(), Q = this._getGradient(W, "inRange"), ee = this._getGradient(W, "outOfRange"), te = this.pointSize + this.blurSize, re = this.canvas, ne = re.getContext("2d"), ae = C.length;
      re.width = G, re.height = U;
      for (var ie = 0; ie < ae; ++ie) {
        var se = C[ie], oe = se[0], le = se[1], ue = se[2], ce = K(ue);
        ne.globalAlpha = ce, ne.drawImage(X, oe - te, le - te);
      }
      if (!re.width || !re.height)
        return re;
      for (var de = ne.getImageData(0, 0, re.width, re.height), ge = de.data, fe = 0, ve = ge.length, pe = this.minOpacity, he = this.maxOpacity, me = he - pe; fe < ve; ) {
        var ce = ge[fe + 3] / 256, ye = Math.floor(ce * (GRADIENT_LEVELS - 1)) * 4;
        if (ce > 0) {
          var Ce = Z(ce) ? Q : ee;
          ce > 0 && (ce = ce * me + pe), ge[fe++] = Ce[ye], ge[fe++] = Ce[ye + 1], ge[fe++] = Ce[ye + 2], ge[fe++] = Ce[ye + 3] * ce * 256;
        } else
          fe += 4;
      }
      return ne.putImageData(de, 0, 0), re;
    }, H.prototype._getBrush = function() {
      var C = this._brushCanvas || (this._brushCanvas = platformApi.createCanvas()), G = this.pointSize + this.blurSize, U = G * 2;
      C.width = U, C.height = U;
      var K = C.getContext("2d");
      return K.clearRect(0, 0, U, U), K.shadowOffsetX = U, K.shadowBlur = this.blurSize, K.shadowColor = "#000", K.beginPath(), K.arc(-G, G, this.pointSize, 0, Math.PI * 2, !0), K.closePath(), K.fill(), C;
    }, H.prototype._getGradient = function(C, G) {
      for (var U = this._gradientPixels, K = U[G] || (U[G] = new Uint8ClampedArray(256 * 4)), W = [0, 0, 0, 0], Z = 0, X = 0; X < 256; X++)
        C[G](X / 255, !0, W), K[Z++] = W[0], K[Z++] = W[1], K[Z++] = W[2], K[Z++] = W[3];
      return K;
    }, H;
  }()
);
const HeatmapLayer$1 = HeatmapLayer;
function getIsInPiecewiseRange(H, C, G) {
  var U = H[1] - H[0];
  C = map$1(C, function(Z) {
    return {
      interval: [(Z.interval[0] - H[0]) / U, (Z.interval[1] - H[0]) / U]
    };
  });
  var K = C.length, W = 0;
  return function(Z) {
    var X;
    for (X = W; X < K; X++) {
      var Q = C[X].interval;
      if (Q[0] <= Z && Z <= Q[1]) {
        W = X;
        break;
      }
    }
    if (X === K)
      for (X = W - 1; X >= 0; X--) {
        var Q = C[X].interval;
        if (Q[0] <= Z && Z <= Q[1]) {
          W = X;
          break;
        }
      }
    return X >= 0 && X < K && G[X];
  };
}
function getIsInContinuousRange(H, C) {
  var G = H[1] - H[0];
  return C = [(C[0] - H[0]) / G, (C[1] - H[0]) / G], function(U) {
    return U >= C[0] && U <= C[1];
  };
}
function isGeoCoordSys(H) {
  var C = H.dimensions;
  return C[0] === "lng" && C[1] === "lat";
}
var HeatmapView = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G;
    }
    return C.prototype.render = function(G, U, K) {
      var W;
      if (U.eachComponent("visualMap", function(X) {
        X.eachTargetSeries(function(Q) {
          Q === G && (W = X);
        });
      }), process.env.NODE_ENV !== "production" && !W)
        throw new Error("Heatmap must use with visualMap");
      this._progressiveEls = null, this.group.removeAll();
      var Z = G.coordinateSystem;
      Z.type === "cartesian2d" || Z.type === "calendar" ? this._renderOnCartesianAndCalendar(G, K, 0, G.getData().count()) : isGeoCoordSys(Z) && this._renderOnGeo(Z, G, W, K);
    }, C.prototype.incrementalPrepareRender = function(G, U, K) {
      this.group.removeAll();
    }, C.prototype.incrementalRender = function(G, U, K, W) {
      var Z = U.coordinateSystem;
      Z && (isGeoCoordSys(Z) ? this.render(U, K, W) : (this._progressiveEls = [], this._renderOnCartesianAndCalendar(U, W, G.start, G.end, !0)));
    }, C.prototype.eachRendered = function(G) {
      traverseElements(this._progressiveEls || this.group, G);
    }, C.prototype._renderOnCartesianAndCalendar = function(G, U, K, W, Z) {
      var X = G.coordinateSystem, Q = isCoordinateSystemType(X, "cartesian2d"), ee, te, re, ne;
      if (Q) {
        var ae = X.getAxis("x"), ie = X.getAxis("y");
        if (process.env.NODE_ENV !== "production") {
          if (!(ae.type === "category" && ie.type === "category"))
            throw new Error("Heatmap on cartesian must have two category axes");
          if (!(ae.onBand && ie.onBand))
            throw new Error("Heatmap on cartesian must have two axes with boundaryGap true");
        }
        ee = ae.getBandWidth() + 0.5, te = ie.getBandWidth() + 0.5, re = ae.scale.getExtent(), ne = ie.scale.getExtent();
      }
      for (var se = this.group, oe = G.getData(), le = G.getModel(["emphasis", "itemStyle"]).getItemStyle(), ue = G.getModel(["blur", "itemStyle"]).getItemStyle(), ce = G.getModel(["select", "itemStyle"]).getItemStyle(), de = G.get(["itemStyle", "borderRadius"]), ge = getLabelStatesModels(G), fe = G.getModel("emphasis"), ve = fe.get("focus"), pe = fe.get("blurScope"), he = fe.get("disabled"), me = Q ? [oe.mapDimension("x"), oe.mapDimension("y"), oe.mapDimension("value")] : [oe.mapDimension("time"), oe.mapDimension("value")], ye = K; ye < W; ye++) {
        var Ce = void 0, Ie = oe.getItemVisual(ye, "style");
        if (Q) {
          var be = oe.get(me[0], ye), Se = oe.get(me[1], ye);
          if (isNaN(oe.get(me[2], ye)) || isNaN(be) || isNaN(Se) || be < re[0] || be > re[1] || Se < ne[0] || Se > ne[1])
            continue;
          var Ae = X.dataToPoint([be, Se]);
          Ce = new Rect$3({
            shape: {
              x: Ae[0] - ee / 2,
              y: Ae[1] - te / 2,
              width: ee,
              height: te
            },
            style: Ie
          });
        } else {
          if (isNaN(oe.get(me[1], ye)))
            continue;
          Ce = new Rect$3({
            z2: 1,
            shape: X.dataToRect([oe.get(me[0], ye)]).contentShape,
            style: Ie
          });
        }
        if (oe.hasItemOption) {
          var _e = oe.getItemModel(ye), xe = _e.getModel("emphasis");
          le = xe.getModel("itemStyle").getItemStyle(), ue = _e.getModel(["blur", "itemStyle"]).getItemStyle(), ce = _e.getModel(["select", "itemStyle"]).getItemStyle(), de = _e.get(["itemStyle", "borderRadius"]), ve = xe.get("focus"), pe = xe.get("blurScope"), he = xe.get("disabled"), ge = getLabelStatesModels(_e);
        }
        Ce.shape.r = de;
        var Te = G.getRawValue(ye), Pe = "-";
        Te && Te[2] != null && (Pe = Te[2] + ""), setLabelStyle(Ce, ge, {
          labelFetcher: G,
          labelDataIndex: ye,
          defaultOpacity: Ie.opacity,
          defaultText: Pe
        }), Ce.ensureState("emphasis").style = le, Ce.ensureState("blur").style = ue, Ce.ensureState("select").style = ce, toggleHoverEmphasis(Ce, ve, pe, he), Ce.incremental = Z, Z && (Ce.states.emphasis.hoverLayer = !0), se.add(Ce), oe.setItemGraphicEl(ye, Ce), this._progressiveEls && this._progressiveEls.push(Ce);
      }
    }, C.prototype._renderOnGeo = function(G, U, K, W) {
      var Z = K.targetVisuals.inRange, X = K.targetVisuals.outOfRange, Q = U.getData(), ee = this._hmLayer || this._hmLayer || new HeatmapLayer$1();
      ee.blurSize = U.get("blurSize"), ee.pointSize = U.get("pointSize"), ee.minOpacity = U.get("minOpacity"), ee.maxOpacity = U.get("maxOpacity");
      var te = G.getViewRect().clone(), re = G.getRoamTransform();
      te.applyTransform(re);
      var ne = Math.max(te.x, 0), ae = Math.max(te.y, 0), ie = Math.min(te.width + te.x, W.getWidth()), se = Math.min(te.height + te.y, W.getHeight()), oe = ie - ne, le = se - ae, ue = [Q.mapDimension("lng"), Q.mapDimension("lat"), Q.mapDimension("value")], ce = Q.mapArray(ue, function(ve, pe, he) {
        var me = G.dataToPoint([ve, pe]);
        return me[0] -= ne, me[1] -= ae, me.push(he), me;
      }), de = K.getExtent(), ge = K.type === "visualMap.continuous" ? getIsInContinuousRange(de, K.option.range) : getIsInPiecewiseRange(de, K.getPieceList(), K.option.selected);
      ee.update(ce, oe, le, Z.color.getNormalizer(), {
        inRange: Z.color.getColorMapper(),
        outOfRange: X.color.getColorMapper()
      }, ge);
      var fe = new ZRImage$1({
        style: {
          width: oe,
          height: le,
          x: ne,
          y: ae,
          image: ee.canvas
        },
        silent: !0
      });
      this.group.add(fe);
    }, C.type = "heatmap", C;
  }(ChartView$1)
);
const HeatmapView$1 = HeatmapView;
var HeatmapSeriesModel = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G;
    }
    return C.prototype.getInitialData = function(G, U) {
      return createSeriesData(null, this, {
        generateCoord: "value"
      });
    }, C.prototype.preventIncremental = function() {
      var G = CoordinateSystem.get(this.get("coordinateSystem"));
      if (G && G.dimensions)
        return G.dimensions[0] === "lng" && G.dimensions[1] === "lat";
    }, C.type = "series.heatmap", C.dependencies = ["grid", "geo", "calendar"], C.defaultOption = {
      coordinateSystem: "cartesian2d",
      // zlevel: 0,
      z: 2,
      // Cartesian coordinate system
      // xAxisIndex: 0,
      // yAxisIndex: 0,
      // Geo coordinate system
      geoIndex: 0,
      blurSize: 30,
      pointSize: 20,
      maxOpacity: 1,
      minOpacity: 0,
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      }
    }, C;
  }(SeriesModel$1)
);
const HeatmapSeriesModel$1 = HeatmapSeriesModel;
function install$v(H) {
  H.registerChartView(HeatmapView$1), H.registerSeriesModel(HeatmapSeriesModel$1);
}
var BAR_BORDER_WIDTH_QUERY = ["itemStyle", "borderWidth"], LAYOUT_ATTRS = [{
  xy: "x",
  wh: "width",
  index: 0,
  posDesc: ["left", "right"]
}, {
  xy: "y",
  wh: "height",
  index: 1,
  posDesc: ["top", "bottom"]
}], pathForLineWidth = new Circle$1(), PictorialBarView = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G;
    }
    return C.prototype.render = function(G, U, K) {
      var W = this.group, Z = G.getData(), X = this._data, Q = G.coordinateSystem, ee = Q.getBaseAxis(), te = ee.isHorizontal(), re = Q.master.getRect(), ne = {
        ecSize: {
          width: K.getWidth(),
          height: K.getHeight()
        },
        seriesModel: G,
        coordSys: Q,
        coordSysExtent: [[re.x, re.x + re.width], [re.y, re.y + re.height]],
        isHorizontal: te,
        valueDim: LAYOUT_ATTRS[+te],
        categoryDim: LAYOUT_ATTRS[1 - +te]
      };
      return Z.diff(X).add(function(ae) {
        if (Z.hasValue(ae)) {
          var ie = getItemModel(Z, ae), se = getSymbolMeta(Z, ae, ie, ne), oe = createBar(Z, ne, se);
          Z.setItemGraphicEl(ae, oe), W.add(oe), updateCommon(oe, ne, se);
        }
      }).update(function(ae, ie) {
        var se = X.getItemGraphicEl(ie);
        if (!Z.hasValue(ae)) {
          W.remove(se);
          return;
        }
        var oe = getItemModel(Z, ae), le = getSymbolMeta(Z, ae, oe, ne), ue = getShapeStr(Z, le);
        se && ue !== se.__pictorialShapeStr && (W.remove(se), Z.setItemGraphicEl(ae, null), se = null), se ? updateBar(se, ne, le) : se = createBar(Z, ne, le, !0), Z.setItemGraphicEl(ae, se), se.__pictorialSymbolMeta = le, W.add(se), updateCommon(se, ne, le);
      }).remove(function(ae) {
        var ie = X.getItemGraphicEl(ae);
        ie && removeBar(X, ae, ie.__pictorialSymbolMeta.animationModel, ie);
      }).execute(), this._data = Z, this.group;
    }, C.prototype.remove = function(G, U) {
      var K = this.group, W = this._data;
      G.get("animation") ? W && W.eachItemGraphicEl(function(Z) {
        removeBar(W, getECData(Z).dataIndex, G, Z);
      }) : K.removeAll();
    }, C.type = "pictorialBar", C;
  }(ChartView$1)
);
function getSymbolMeta(H, C, G, U) {
  var K = H.getItemLayout(C), W = G.get("symbolRepeat"), Z = G.get("symbolClip"), X = G.get("symbolPosition") || "start", Q = G.get("symbolRotate"), ee = (Q || 0) * Math.PI / 180 || 0, te = G.get("symbolPatternSize") || 2, re = G.isAnimationEnabled(), ne = {
    dataIndex: C,
    layout: K,
    itemModel: G,
    symbolType: H.getItemVisual(C, "symbol") || "circle",
    style: H.getItemVisual(C, "style"),
    symbolClip: Z,
    symbolRepeat: W,
    symbolRepeatDirection: G.get("symbolRepeatDirection"),
    symbolPatternSize: te,
    rotation: ee,
    animationModel: re ? G : null,
    hoverScale: re && G.get(["emphasis", "scale"]),
    z2: G.getShallow("z", !0) || 0
  };
  prepareBarLength(G, W, K, U, ne), prepareSymbolSize(H, C, K, W, Z, ne.boundingLength, ne.pxSign, te, U, ne), prepareLineWidth(G, ne.symbolScale, ee, U, ne);
  var ae = ne.symbolSize, ie = normalizeSymbolOffset(G.get("symbolOffset"), ae);
  return prepareLayoutInfo(G, ae, K, W, Z, ie, X, ne.valueLineWidth, ne.boundingLength, ne.repeatCutLength, U, ne), ne;
}
function prepareBarLength(H, C, G, U, K) {
  var W = U.valueDim, Z = H.get("symbolBoundingData"), X = U.coordSys.getOtherAxis(U.coordSys.getBaseAxis()), Q = X.toGlobalCoord(X.dataToCoord(0)), ee = 1 - +(G[W.wh] <= 0), te;
  if (isArray$1(Z)) {
    var re = [convertToCoordOnAxis(X, Z[0]) - Q, convertToCoordOnAxis(X, Z[1]) - Q];
    re[1] < re[0] && re.reverse(), te = re[ee];
  } else
    Z != null ? te = convertToCoordOnAxis(X, Z) - Q : C ? te = U.coordSysExtent[W.index][ee] - Q : te = G[W.wh];
  K.boundingLength = te, C && (K.repeatCutLength = G[W.wh]), K.pxSign = te > 0 ? 1 : -1;
}
function convertToCoordOnAxis(H, C) {
  return H.toGlobalCoord(H.dataToCoord(H.scale.parse(C)));
}
function prepareSymbolSize(H, C, G, U, K, W, Z, X, Q, ee) {
  var te = Q.valueDim, re = Q.categoryDim, ne = Math.abs(G[re.wh]), ae = H.getItemVisual(C, "symbolSize"), ie;
  isArray$1(ae) ? ie = ae.slice() : ae == null ? ie = ["100%", "100%"] : ie = [ae, ae], ie[re.index] = parsePercent(ie[re.index], ne), ie[te.index] = parsePercent(ie[te.index], U ? ne : Math.abs(W)), ee.symbolSize = ie;
  var se = ee.symbolScale = [ie[0] / X, ie[1] / X];
  se[te.index] *= (Q.isHorizontal ? -1 : 1) * Z;
}
function prepareLineWidth(H, C, G, U, K) {
  var W = H.get(BAR_BORDER_WIDTH_QUERY) || 0;
  W && (pathForLineWidth.attr({
    scaleX: C[0],
    scaleY: C[1],
    rotation: G
  }), pathForLineWidth.updateTransform(), W /= pathForLineWidth.getLineScale(), W *= C[U.valueDim.index]), K.valueLineWidth = W || 0;
}
function prepareLayoutInfo(H, C, G, U, K, W, Z, X, Q, ee, te, re) {
  var ne = te.categoryDim, ae = te.valueDim, ie = re.pxSign, se = Math.max(C[ae.index] + X, 0), oe = se;
  if (U) {
    var le = Math.abs(Q), ue = retrieve(H.get("symbolMargin"), "15%") + "", ce = !1;
    ue.lastIndexOf("!") === ue.length - 1 && (ce = !0, ue = ue.slice(0, ue.length - 1));
    var de = parsePercent(ue, C[ae.index]), ge = Math.max(se + de * 2, 0), fe = ce ? 0 : de * 2, ve = isNumeric(U), pe = ve ? U : toIntTimes((le + fe) / ge), he = le - pe * se;
    de = he / 2 / (ce ? pe : Math.max(pe - 1, 1)), ge = se + de * 2, fe = ce ? 0 : de * 2, !ve && U !== "fixed" && (pe = ee ? toIntTimes((Math.abs(ee) + fe) / ge) : 0), oe = pe * ge - fe, re.repeatTimes = pe, re.symbolMargin = de;
  }
  var me = ie * (oe / 2), ye = re.pathPosition = [];
  ye[ne.index] = G[ne.wh] / 2, ye[ae.index] = Z === "start" ? me : Z === "end" ? Q - me : Q / 2, W && (ye[0] += W[0], ye[1] += W[1]);
  var Ce = re.bundlePosition = [];
  Ce[ne.index] = G[ne.xy], Ce[ae.index] = G[ae.xy];
  var Ie = re.barRectShape = extend({}, G);
  Ie[ae.wh] = ie * Math.max(Math.abs(G[ae.wh]), Math.abs(ye[ae.index] + me)), Ie[ne.wh] = G[ne.wh];
  var be = re.clipShape = {};
  be[ne.xy] = -G[ne.xy], be[ne.wh] = te.ecSize[ne.wh], be[ae.xy] = 0, be[ae.wh] = G[ae.wh];
}
function createPath(H) {
  var C = H.symbolPatternSize, G = createSymbol$1(
    // Consider texture img, make a big size.
    H.symbolType,
    -C / 2,
    -C / 2,
    C,
    C
  );
  return G.attr({
    culling: !0
  }), G.type !== "image" && G.setStyle({
    strokeNoScale: !0
  }), G;
}
function createOrUpdateRepeatSymbols(H, C, G, U) {
  var K = H.__pictorialBundle, W = G.symbolSize, Z = G.valueLineWidth, X = G.pathPosition, Q = C.valueDim, ee = G.repeatTimes || 0, te = 0, re = W[C.valueDim.index] + Z + G.symbolMargin * 2;
  for (eachPath(H, function(se) {
    se.__pictorialAnimationIndex = te, se.__pictorialRepeatTimes = ee, te < ee ? updateAttr(se, null, ie(te), G, U) : updateAttr(se, null, {
      scaleX: 0,
      scaleY: 0
    }, G, U, function() {
      K.remove(se);
    }), te++;
  }); te < ee; te++) {
    var ne = createPath(G);
    ne.__pictorialAnimationIndex = te, ne.__pictorialRepeatTimes = ee, K.add(ne);
    var ae = ie(te);
    updateAttr(ne, {
      x: ae.x,
      y: ae.y,
      scaleX: 0,
      scaleY: 0
    }, {
      scaleX: ae.scaleX,
      scaleY: ae.scaleY,
      rotation: ae.rotation
    }, G, U);
  }
  function ie(se) {
    var oe = X.slice(), le = G.pxSign, ue = se;
    return (G.symbolRepeatDirection === "start" ? le > 0 : le < 0) && (ue = ee - 1 - se), oe[Q.index] = re * (ue - ee / 2 + 0.5) + X[Q.index], {
      x: oe[0],
      y: oe[1],
      scaleX: G.symbolScale[0],
      scaleY: G.symbolScale[1],
      rotation: G.rotation
    };
  }
}
function createOrUpdateSingleSymbol(H, C, G, U) {
  var K = H.__pictorialBundle, W = H.__pictorialMainPath;
  W ? updateAttr(W, null, {
    x: G.pathPosition[0],
    y: G.pathPosition[1],
    scaleX: G.symbolScale[0],
    scaleY: G.symbolScale[1],
    rotation: G.rotation
  }, G, U) : (W = H.__pictorialMainPath = createPath(G), K.add(W), updateAttr(W, {
    x: G.pathPosition[0],
    y: G.pathPosition[1],
    scaleX: 0,
    scaleY: 0,
    rotation: G.rotation
  }, {
    scaleX: G.symbolScale[0],
    scaleY: G.symbolScale[1]
  }, G, U));
}
function createOrUpdateBarRect(H, C, G) {
  var U = extend({}, C.barRectShape), K = H.__pictorialBarRect;
  K ? updateAttr(K, null, {
    shape: U
  }, C, G) : (K = H.__pictorialBarRect = new Rect$3({
    z2: 2,
    shape: U,
    silent: !0,
    style: {
      stroke: "transparent",
      fill: "transparent",
      lineWidth: 0
    }
  }), K.disableMorphing = !0, H.add(K));
}
function createOrUpdateClip(H, C, G, U) {
  if (G.symbolClip) {
    var K = H.__pictorialClipPath, W = extend({}, G.clipShape), Z = C.valueDim, X = G.animationModel, Q = G.dataIndex;
    if (K)
      updateProps$1(K, {
        shape: W
      }, X, Q);
    else {
      W[Z.wh] = 0, K = new Rect$3({
        shape: W
      }), H.__pictorialBundle.setClipPath(K), H.__pictorialClipPath = K;
      var ee = {};
      ee[Z.wh] = G.clipShape[Z.wh], graphic[U ? "updateProps" : "initProps"](K, {
        shape: ee
      }, X, Q);
    }
  }
}
function getItemModel(H, C) {
  var G = H.getItemModel(C);
  return G.getAnimationDelayParams = getAnimationDelayParams, G.isAnimationEnabled = isAnimationEnabled, G;
}
function getAnimationDelayParams(H) {
  return {
    index: H.__pictorialAnimationIndex,
    count: H.__pictorialRepeatTimes
  };
}
function isAnimationEnabled() {
  return this.parentModel.isAnimationEnabled() && !!this.getShallow("animation");
}
function createBar(H, C, G, U) {
  var K = new Group$4(), W = new Group$4();
  return K.add(W), K.__pictorialBundle = W, W.x = G.bundlePosition[0], W.y = G.bundlePosition[1], G.symbolRepeat ? createOrUpdateRepeatSymbols(K, C, G) : createOrUpdateSingleSymbol(K, C, G), createOrUpdateBarRect(K, G, U), createOrUpdateClip(K, C, G, U), K.__pictorialShapeStr = getShapeStr(H, G), K.__pictorialSymbolMeta = G, K;
}
function updateBar(H, C, G) {
  var U = G.animationModel, K = G.dataIndex, W = H.__pictorialBundle;
  updateProps$1(W, {
    x: G.bundlePosition[0],
    y: G.bundlePosition[1]
  }, U, K), G.symbolRepeat ? createOrUpdateRepeatSymbols(H, C, G, !0) : createOrUpdateSingleSymbol(H, C, G, !0), createOrUpdateBarRect(H, G, !0), createOrUpdateClip(H, C, G, !0);
}
function removeBar(H, C, G, U) {
  var K = U.__pictorialBarRect;
  K && K.removeTextContent();
  var W = [];
  eachPath(U, function(Z) {
    W.push(Z);
  }), U.__pictorialMainPath && W.push(U.__pictorialMainPath), U.__pictorialClipPath && (G = null), each$f(W, function(Z) {
    removeElement(Z, {
      scaleX: 0,
      scaleY: 0
    }, G, C, function() {
      U.parent && U.parent.remove(U);
    });
  }), H.setItemGraphicEl(C, null);
}
function getShapeStr(H, C) {
  return [H.getItemVisual(C.dataIndex, "symbol") || "none", !!C.symbolRepeat, !!C.symbolClip].join(":");
}
function eachPath(H, C, G) {
  each$f(H.__pictorialBundle.children(), function(U) {
    U !== H.__pictorialBarRect && C.call(G, U);
  });
}
function updateAttr(H, C, G, U, K, W) {
  C && H.attr(C), U.symbolClip && !K ? G && H.attr(G) : G && graphic[K ? "updateProps" : "initProps"](H, G, U.animationModel, U.dataIndex, W);
}
function updateCommon(H, C, G) {
  var U = G.dataIndex, K = G.itemModel, W = K.getModel("emphasis"), Z = W.getModel("itemStyle").getItemStyle(), X = K.getModel(["blur", "itemStyle"]).getItemStyle(), Q = K.getModel(["select", "itemStyle"]).getItemStyle(), ee = K.getShallow("cursor"), te = W.get("focus"), re = W.get("blurScope"), ne = W.get("scale");
  eachPath(H, function(se) {
    if (se instanceof ZRImage$1) {
      var oe = se.style;
      se.useStyle(extend({
        // TODO other properties like dx, dy ?
        image: oe.image,
        x: oe.x,
        y: oe.y,
        width: oe.width,
        height: oe.height
      }, G.style));
    } else
      se.useStyle(G.style);
    var le = se.ensureState("emphasis");
    le.style = Z, ne && (le.scaleX = se.scaleX * 1.1, le.scaleY = se.scaleY * 1.1), se.ensureState("blur").style = X, se.ensureState("select").style = Q, ee && (se.cursor = ee), se.z2 = G.z2;
  });
  var ae = C.valueDim.posDesc[+(G.boundingLength > 0)], ie = H.__pictorialBarRect;
  setLabelStyle(ie, getLabelStatesModels(K), {
    labelFetcher: C.seriesModel,
    labelDataIndex: U,
    defaultText: getDefaultLabel(C.seriesModel.getData(), U),
    inheritColor: G.style.fill,
    defaultOpacity: G.style.opacity,
    defaultOutsidePosition: ae
  }), toggleHoverEmphasis(H, te, re, W.get("disabled"));
}
function toIntTimes(H) {
  var C = Math.round(H);
  return Math.abs(H - C) < 1e-4 ? C : Math.ceil(H);
}
const PictorialBarView$1 = PictorialBarView;
var PictorialBarSeriesModel = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G.hasSymbolVisual = !0, G.defaultSymbol = "roundRect", G;
    }
    return C.prototype.getInitialData = function(G) {
      return G.stack = null, H.prototype.getInitialData.apply(this, arguments);
    }, C.type = "series.pictorialBar", C.dependencies = ["grid"], C.defaultOption = inheritDefaultOption(BaseBarSeriesModel$1.defaultOption, {
      symbol: "circle",
      symbolSize: null,
      symbolRotate: null,
      symbolPosition: null,
      symbolOffset: null,
      symbolMargin: null,
      symbolRepeat: !1,
      symbolRepeatDirection: "end",
      symbolClip: !1,
      symbolBoundingData: null,
      symbolPatternSize: 400,
      barGap: "-100%",
      // z can be set in data item, which is z2 actually.
      // Disable progressive
      progressive: 0,
      emphasis: {
        // By default pictorialBar do not hover scale. Hover scale is not suitable
        // for the case that both has foreground and background.
        scale: !1
      },
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      }
    }), C;
  }(BaseBarSeriesModel$1)
);
const PictorialBarSeriesModel$1 = PictorialBarSeriesModel;
function install$u(H) {
  H.registerChartView(PictorialBarView$1), H.registerSeriesModel(PictorialBarSeriesModel$1), H.registerLayout(H.PRIORITY.VISUAL.LAYOUT, curry$1(layout$3, "pictorialBar")), H.registerLayout(H.PRIORITY.VISUAL.PROGRESSIVE_LAYOUT, createProgressiveLayout("pictorialBar"));
}
var ThemeRiverView = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G._layers = [], G;
    }
    return C.prototype.render = function(G, U, K) {
      var W = G.getData(), Z = this, X = this.group, Q = G.getLayerSeries(), ee = W.getLayout("layoutInfo"), te = ee.rect, re = ee.boundaryGap;
      X.x = 0, X.y = te.y + re[0];
      function ne(oe) {
        return oe.name;
      }
      var ae = new DataDiffer$1(this._layersSeries || [], Q, ne, ne), ie = [];
      ae.add(bind$1(se, this, "add")).update(bind$1(se, this, "update")).remove(bind$1(se, this, "remove")).execute();
      function se(oe, le, ue) {
        var ce = Z._layers;
        if (oe === "remove") {
          X.remove(ce[le]);
          return;
        }
        for (var de = [], ge = [], fe, ve = Q[le].indices, pe = 0; pe < ve.length; pe++) {
          var he = W.getItemLayout(ve[pe]), me = he.x, ye = he.y0, Ce = he.y;
          de.push(me, ye), ge.push(me, ye + Ce), fe = W.getItemVisual(ve[pe], "style");
        }
        var Ie, be = W.getItemLayout(ve[0]), Se = G.getModel("label"), Ae = Se.get("margin"), _e = G.getModel("emphasis");
        if (oe === "add") {
          var xe = ie[le] = new Group$4();
          Ie = new ECPolygon({
            shape: {
              points: de,
              stackedOnPoints: ge,
              smooth: 0.4,
              stackedOnSmooth: 0.4,
              smoothConstraint: !1
            },
            z2: 0
          }), xe.add(Ie), X.add(xe), G.isAnimationEnabled() && Ie.setClipPath(createGridClipShape(Ie.getBoundingRect(), G, function() {
            Ie.removeClipPath();
          }));
        } else {
          var xe = ce[ue];
          Ie = xe.childAt(0), X.add(xe), ie[le] = xe, updateProps$1(Ie, {
            shape: {
              points: de,
              stackedOnPoints: ge
            }
          }, G), saveOldStyle(Ie);
        }
        setLabelStyle(Ie, getLabelStatesModels(G), {
          labelDataIndex: ve[pe - 1],
          defaultText: W.getName(ve[pe - 1]),
          inheritColor: fe.fill
        }, {
          normal: {
            verticalAlign: "middle"
            // align: 'right'
          }
        }), Ie.setTextConfig({
          position: null,
          local: !0
        });
        var Te = Ie.getTextContent();
        Te && (Te.x = be.x - Ae, Te.y = be.y0 + be.y / 2), Ie.useStyle(fe), W.setItemGraphicEl(le, Ie), setStatesStylesFromModel(Ie, G), toggleHoverEmphasis(Ie, _e.get("focus"), _e.get("blurScope"), _e.get("disabled"));
      }
      this._layersSeries = Q, this._layers = ie;
    }, C.type = "themeRiver", C;
  }(ChartView$1)
);
function createGridClipShape(H, C, G) {
  var U = new Rect$3({
    shape: {
      x: H.x - 10,
      y: H.y - 10,
      width: 0,
      height: H.height + 20
    }
  });
  return initProps(U, {
    shape: {
      x: H.x - 50,
      width: H.width + 100,
      height: H.height + 20
    }
  }, C, G), U;
}
const ThemeRiverView$1 = ThemeRiverView;
var DATA_NAME_INDEX = 2, ThemeRiverSeriesModel = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G;
    }
    return C.prototype.init = function(G) {
      H.prototype.init.apply(this, arguments), this.legendVisualProvider = new LegendVisualProvider$1(bind$1(this.getData, this), bind$1(this.getRawData, this));
    }, C.prototype.fixData = function(G) {
      var U = G.length, K = {}, W = groupData(G, function(ne) {
        return K.hasOwnProperty(ne[0] + "") || (K[ne[0] + ""] = -1), ne[2];
      }), Z = [];
      W.buckets.each(function(ne, ae) {
        Z.push({
          name: ae,
          dataList: ne
        });
      });
      for (var X = Z.length, Q = 0; Q < X; ++Q) {
        for (var ee = Z[Q].name, te = 0; te < Z[Q].dataList.length; ++te) {
          var re = Z[Q].dataList[te][0] + "";
          K[re] = Q;
        }
        for (var re in K)
          K.hasOwnProperty(re) && K[re] !== Q && (K[re] = Q, G[U] = [re, 0, ee], U++);
      }
      return G;
    }, C.prototype.getInitialData = function(G, U) {
      for (var K = this.getReferringComponents("singleAxis", SINGLE_REFERRING).models[0], W = K.get("type"), Z = filter(G.data, function(ie) {
        return ie[2] !== void 0;
      }), X = this.fixData(Z || []), Q = [], ee = this.nameMap = createHashMap(), te = 0, re = 0; re < X.length; ++re)
        Q.push(X[re][DATA_NAME_INDEX]), ee.get(X[re][DATA_NAME_INDEX]) || (ee.set(X[re][DATA_NAME_INDEX], te), te++);
      var ne = prepareSeriesDataSchema(X, {
        coordDimensions: ["single"],
        dimensionsDefine: [{
          name: "time",
          type: getDimensionTypeByAxis(W)
        }, {
          name: "value",
          type: "float"
        }, {
          name: "name",
          type: "ordinal"
        }],
        encodeDefine: {
          single: 0,
          value: 1,
          itemName: 2
        }
      }).dimensions, ae = new SeriesData$1(ne, this);
      return ae.initData(X), ae;
    }, C.prototype.getLayerSeries = function() {
      for (var G = this.getData(), U = G.count(), K = [], W = 0; W < U; ++W)
        K[W] = W;
      var Z = G.mapDimension("single"), X = groupData(K, function(ee) {
        return G.get("name", ee);
      }), Q = [];
      return X.buckets.each(function(ee, te) {
        ee.sort(function(re, ne) {
          return G.get(Z, re) - G.get(Z, ne);
        }), Q.push({
          name: te,
          indices: ee
        });
      }), Q;
    }, C.prototype.getAxisTooltipData = function(G, U, K) {
      isArray$1(G) || (G = G ? [G] : []);
      for (var W = this.getData(), Z = this.getLayerSeries(), X = [], Q = Z.length, ee, te = 0; te < Q; ++te) {
        for (var re = Number.MAX_VALUE, ne = -1, ae = Z[te].indices.length, ie = 0; ie < ae; ++ie) {
          var se = W.get(G[0], Z[te].indices[ie]), oe = Math.abs(se - U);
          oe <= re && (ee = se, re = oe, ne = Z[te].indices[ie]);
        }
        X.push(ne);
      }
      return {
        dataIndices: X,
        nestestValue: ee
      };
    }, C.prototype.formatTooltip = function(G, U, K) {
      var W = this.getData(), Z = W.getName(G), X = W.get(W.mapDimension("value"), G);
      return createTooltipMarkup("nameValue", {
        name: Z,
        value: X
      });
    }, C.type = "series.themeRiver", C.dependencies = ["singleAxis"], C.defaultOption = {
      // zlevel: 0,
      z: 2,
      colorBy: "data",
      coordinateSystem: "singleAxis",
      // gap in axis's orthogonal orientation
      boundaryGap: ["10%", "10%"],
      // legendHoverLink: true,
      singleAxisIndex: 0,
      animationEasing: "linear",
      label: {
        margin: 4,
        show: !0,
        position: "left",
        fontSize: 11
      },
      emphasis: {
        label: {
          show: !0
        }
      }
    }, C;
  }(SeriesModel$1)
);
const ThemeRiverSeriesModel$1 = ThemeRiverSeriesModel;
function themeRiverLayout(H, C) {
  H.eachSeriesByType("themeRiver", function(G) {
    var U = G.getData(), K = G.coordinateSystem, W = {}, Z = K.getRect();
    W.rect = Z;
    var X = G.get("boundaryGap"), Q = K.getAxis();
    if (W.boundaryGap = X, Q.orient === "horizontal") {
      X[0] = parsePercent(X[0], Z.height), X[1] = parsePercent(X[1], Z.height);
      var ee = Z.height - X[0] - X[1];
      doThemeRiverLayout(U, G, ee);
    } else {
      X[0] = parsePercent(X[0], Z.width), X[1] = parsePercent(X[1], Z.width);
      var te = Z.width - X[0] - X[1];
      doThemeRiverLayout(U, G, te);
    }
    U.setLayout("layoutInfo", W);
  });
}
function doThemeRiverLayout(H, C, G) {
  if (H.count())
    for (var U = C.coordinateSystem, K = C.getLayerSeries(), W = H.mapDimension("single"), Z = H.mapDimension("value"), X = map$1(K, function(oe) {
      return map$1(oe.indices, function(le) {
        var ue = U.dataToPoint(H.get(W, le));
        return ue[1] = H.get(Z, le), ue;
      });
    }), Q = computeBaseline(X), ee = Q.y0, te = G / Q.max, re = K.length, ne = K[0].indices.length, ae, ie = 0; ie < ne; ++ie) {
      ae = ee[ie] * te, H.setItemLayout(K[0].indices[ie], {
        layerIndex: 0,
        x: X[0][ie][0],
        y0: ae,
        y: X[0][ie][1] * te
      });
      for (var se = 1; se < re; ++se)
        ae += X[se - 1][ie][1] * te, H.setItemLayout(K[se].indices[ie], {
          layerIndex: se,
          x: X[se][ie][0],
          y0: ae,
          y: X[se][ie][1] * te
        });
    }
}
function computeBaseline(H) {
  for (var C = H.length, G = H[0].length, U = [], K = [], W = 0, Z = 0; Z < G; ++Z) {
    for (var X = 0, Q = 0; Q < C; ++Q)
      X += H[Q][Z][1];
    X > W && (W = X), U.push(X);
  }
  for (var ee = 0; ee < G; ++ee)
    K[ee] = (W - U[ee]) / 2;
  W = 0;
  for (var te = 0; te < G; ++te) {
    var re = U[te] + K[te];
    re > W && (W = re);
  }
  return {
    y0: K,
    max: W
  };
}
function install$t(H) {
  H.registerChartView(ThemeRiverView$1), H.registerSeriesModel(ThemeRiverSeriesModel$1), H.registerLayout(themeRiverLayout), H.registerProcessor(dataFilter$1("themeRiver"));
}
var DEFAULT_SECTOR_Z = 2, DEFAULT_TEXT_Z = 4, SunburstPiece = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C(G, U, K, W) {
      var Z = H.call(this) || this;
      Z.z2 = DEFAULT_SECTOR_Z, Z.textConfig = {
        inside: !0
      }, getECData(Z).seriesIndex = U.seriesIndex;
      var X = new ZRText$1({
        z2: DEFAULT_TEXT_Z,
        silent: G.getModel().get(["label", "silent"])
      });
      return Z.setTextContent(X), Z.updateData(!0, G, U, K, W), Z;
    }
    return C.prototype.updateData = function(G, U, K, W, Z) {
      this.node = U, U.piece = this, K = K || this._seriesModel, W = W || this._ecModel;
      var X = this;
      getECData(X).dataIndex = U.dataIndex;
      var Q = U.getModel(), ee = Q.getModel("emphasis"), te = U.getLayout(), re = extend({}, te);
      re.label = null;
      var ne = U.getVisual("style");
      ne.lineJoin = "bevel";
      var ae = U.getVisual("decal");
      ae && (ne.decal = createOrUpdatePatternFromDecal(ae, Z));
      var ie = getSectorCornerRadius(Q.getModel("itemStyle"), re, !0);
      extend(re, ie), each$f(SPECIAL_STATES, function(ue) {
        var ce = X.ensureState(ue), de = Q.getModel([ue, "itemStyle"]);
        ce.style = de.getItemStyle();
        var ge = getSectorCornerRadius(de, re);
        ge && (ce.shape = ge);
      }), G ? (X.setShape(re), X.shape.r = te.r0, updateProps$1(X, {
        shape: {
          r: te.r
        }
      }, K, U.dataIndex)) : (updateProps$1(X, {
        shape: re
      }, K), saveOldStyle(X)), X.useStyle(ne), this._updateLabel(K);
      var se = Q.getShallow("cursor");
      se && X.attr("cursor", se), this._seriesModel = K || this._seriesModel, this._ecModel = W || this._ecModel;
      var oe = ee.get("focus"), le = oe === "ancestor" ? U.getAncestorsIndices() : oe === "descendant" ? U.getDescendantIndices() : oe;
      toggleHoverEmphasis(this, le, ee.get("blurScope"), ee.get("disabled"));
    }, C.prototype._updateLabel = function(G) {
      var U = this, K = this.node.getModel(), W = K.getModel("label"), Z = this.node.getLayout(), X = Z.endAngle - Z.startAngle, Q = (Z.startAngle + Z.endAngle) / 2, ee = Math.cos(Q), te = Math.sin(Q), re = this, ne = re.getTextContent(), ae = this.node.dataIndex, ie = W.get("minAngle") / 180 * Math.PI, se = W.get("show") && !(ie != null && Math.abs(X) < ie);
      ne.ignore = !se, each$f(DISPLAY_STATES, function(le) {
        var ue = le === "normal" ? K.getModel("label") : K.getModel([le, "label"]), ce = le === "normal", de = ce ? ne : ne.ensureState(le), ge = G.getFormattedLabel(ae, le);
        ce && (ge = ge || U.node.name), de.style = createTextStyle(ue, {}, null, le !== "normal", !0), ge && (de.style.text = ge);
        var fe = ue.get("show");
        fe != null && !ce && (de.ignore = !fe);
        var ve = oe(ue, "position"), pe = ce ? re : re.states[le], he = pe.style.fill;
        pe.textConfig = {
          outsideFill: ue.get("color") === "inherit" ? he : null,
          inside: ve !== "outside"
        };
        var me, ye = oe(ue, "distance") || 0, Ce = oe(ue, "align");
        ve === "outside" ? (me = Z.r + ye, Ce = Q > Math.PI / 2 ? "right" : "left") : !Ce || Ce === "center" ? (X === 2 * Math.PI && Z.r0 === 0 ? me = 0 : me = (Z.r + Z.r0) / 2, Ce = "center") : Ce === "left" ? (me = Z.r0 + ye, Q > Math.PI / 2 && (Ce = "right")) : Ce === "right" && (me = Z.r - ye, Q > Math.PI / 2 && (Ce = "left")), de.style.align = Ce, de.style.verticalAlign = oe(ue, "verticalAlign") || "middle", de.x = me * ee + Z.cx, de.y = me * te + Z.cy;
        var Ie = oe(ue, "rotate"), be = 0;
        Ie === "radial" ? (be = -Q, be < -Math.PI / 2 && (be += Math.PI)) : Ie === "tangential" ? (be = Math.PI / 2 - Q, be > Math.PI / 2 ? be -= Math.PI : be < -Math.PI / 2 && (be += Math.PI)) : isNumber(Ie) && (be = Ie * Math.PI / 180), de.rotation = be;
      });
      function oe(le, ue) {
        var ce = le.get(ue);
        return ce ?? W.get(ue);
      }
      ne.dirtyStyle();
    }, C;
  }(Sector$1)
);
const SunburstPiece$1 = SunburstPiece;
var ROOT_TO_NODE_ACTION = "sunburstRootToNode", HIGHLIGHT_ACTION = "sunburstHighlight", UNHIGHLIGHT_ACTION = "sunburstUnhighlight";
function installSunburstAction(H) {
  H.registerAction({
    type: ROOT_TO_NODE_ACTION,
    update: "updateView"
  }, function(C, G) {
    G.eachComponent({
      mainType: "series",
      subType: "sunburst",
      query: C
    }, U);
    function U(K, W) {
      var Z = retrieveTargetInfo(C, [ROOT_TO_NODE_ACTION], K);
      if (Z) {
        var X = K.getViewRoot();
        X && (C.direction = aboveViewRoot(X, Z.node) ? "rollUp" : "drillDown"), K.resetViewRoot(Z.node);
      }
    }
  }), H.registerAction({
    type: HIGHLIGHT_ACTION,
    update: "none"
  }, function(C, G, U) {
    C = extend({}, C), G.eachComponent({
      mainType: "series",
      subType: "sunburst",
      query: C
    }, K);
    function K(W) {
      var Z = retrieveTargetInfo(C, [HIGHLIGHT_ACTION], W);
      Z && (C.dataIndex = Z.node.dataIndex);
    }
    process.env.NODE_ENV !== "production" && deprecateReplaceLog("sunburstHighlight", "highlight"), U.dispatchAction(extend(C, {
      type: "highlight"
    }));
  }), H.registerAction({
    type: UNHIGHLIGHT_ACTION,
    update: "updateView"
  }, function(C, G, U) {
    C = extend({}, C), process.env.NODE_ENV !== "production" && deprecateReplaceLog("sunburstUnhighlight", "downplay"), U.dispatchAction(extend(C, {
      type: "downplay"
    }));
  });
}
var SunburstView = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G;
    }
    return C.prototype.render = function(G, U, K, W) {
      var Z = this;
      this.seriesModel = G, this.api = K, this.ecModel = U;
      var X = G.getData(), Q = X.tree.root, ee = G.getViewRoot(), te = this.group, re = G.get("renderLabelForZeroData"), ne = [];
      ee.eachNode(function(ue) {
        ne.push(ue);
      });
      var ae = this._oldChildren || [];
      ie(ne, ae), le(Q, ee), this._initEvents(), this._oldChildren = ne;
      function ie(ue, ce) {
        if (ue.length === 0 && ce.length === 0)
          return;
        new DataDiffer$1(ce, ue, de, de).add(ge).update(ge).remove(curry$1(ge, null)).execute();
        function de(fe) {
          return fe.getId();
        }
        function ge(fe, ve) {
          var pe = fe == null ? null : ue[fe], he = ve == null ? null : ce[ve];
          se(pe, he);
        }
      }
      function se(ue, ce) {
        if (!re && ue && !ue.getValue() && (ue = null), ue !== Q && ce !== Q) {
          if (ce && ce.piece)
            ue ? (ce.piece.updateData(!1, ue, G, U, K), X.setItemGraphicEl(ue.dataIndex, ce.piece)) : oe(ce);
          else if (ue) {
            var de = new SunburstPiece$1(ue, G, U, K);
            te.add(de), X.setItemGraphicEl(ue.dataIndex, de);
          }
        }
      }
      function oe(ue) {
        ue && ue.piece && (te.remove(ue.piece), ue.piece = null);
      }
      function le(ue, ce) {
        ce.depth > 0 ? (Z.virtualPiece ? Z.virtualPiece.updateData(!1, ue, G, U, K) : (Z.virtualPiece = new SunburstPiece$1(ue, G, U, K), te.add(Z.virtualPiece)), ce.piece.off("click"), Z.virtualPiece.on("click", function(de) {
          Z._rootToNode(ce.parentNode);
        })) : Z.virtualPiece && (te.remove(Z.virtualPiece), Z.virtualPiece = null);
      }
    }, C.prototype._initEvents = function() {
      var G = this;
      this.group.off("click"), this.group.on("click", function(U) {
        var K = !1, W = G.seriesModel.getViewRoot();
        W.eachNode(function(Z) {
          if (!K && Z.piece && Z.piece === U.target) {
            var X = Z.getModel().get("nodeClick");
            if (X === "rootToNode")
              G._rootToNode(Z);
            else if (X === "link") {
              var Q = Z.getModel(), ee = Q.get("link");
              if (ee) {
                var te = Q.get("target", !0) || "_blank";
                windowOpen(ee, te);
              }
            }
            K = !0;
          }
        });
      });
    }, C.prototype._rootToNode = function(G) {
      G !== this.seriesModel.getViewRoot() && this.api.dispatchAction({
        type: ROOT_TO_NODE_ACTION,
        from: this.uid,
        seriesId: this.seriesModel.id,
        targetNode: G
      });
    }, C.prototype.containPoint = function(G, U) {
      var K = U.getData(), W = K.getItemLayout(0);
      if (W) {
        var Z = G[0] - W.cx, X = G[1] - W.cy, Q = Math.sqrt(Z * Z + X * X);
        return Q <= W.r && Q >= W.r0;
      }
    }, C.type = "sunburst", C;
  }(ChartView$1)
);
const SunburstView$1 = SunburstView;
var SunburstSeriesModel = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G.ignoreStyleOnData = !0, G;
    }
    return C.prototype.getInitialData = function(G, U) {
      var K = {
        name: G.name,
        children: G.data
      };
      completeTreeValue(K);
      var W = this._levelModels = map$1(G.levels || [], function(Q) {
        return new Model$1(Q, this, U);
      }, this), Z = Tree$1.createTree(K, this, X);
      function X(Q) {
        Q.wrapMethod("getItemModel", function(ee, te) {
          var re = Z.getNodeByDataIndex(te), ne = W[re.depth];
          return ne && (ee.parentModel = ne), ee;
        });
      }
      return Z.data;
    }, C.prototype.optionUpdated = function() {
      this.resetViewRoot();
    }, C.prototype.getDataParams = function(G) {
      var U = H.prototype.getDataParams.apply(this, arguments), K = this.getData().tree.getNodeByDataIndex(G);
      return U.treePathInfo = wrapTreePathInfo(K, this), U;
    }, C.prototype.getLevelModel = function(G) {
      return this._levelModels && this._levelModels[G.depth];
    }, C.prototype.getViewRoot = function() {
      return this._viewRoot;
    }, C.prototype.resetViewRoot = function(G) {
      G ? this._viewRoot = G : G = this._viewRoot;
      var U = this.getRawData().tree.root;
      (!G || G !== U && !U.contains(G)) && (this._viewRoot = U);
    }, C.prototype.enableAriaDecal = function() {
      enableAriaDecalForTree(this);
    }, C.type = "series.sunburst", C.defaultOption = {
      // zlevel: 0,
      z: 2,
      // 默认全局居中
      center: ["50%", "50%"],
      radius: [0, "75%"],
      // 默认顺时针
      clockwise: !0,
      startAngle: 90,
      // 最小角度改为0
      minAngle: 0,
      // If still show when all data zero.
      stillShowZeroSum: !0,
      // 'rootToNode', 'link', or false
      nodeClick: "rootToNode",
      renderLabelForZeroData: !1,
      label: {
        // could be: 'radial', 'tangential', or 'none'
        rotate: "radial",
        show: !0,
        opacity: 1,
        // 'left' is for inner side of inside, and 'right' is for outer
        // side for inside
        align: "center",
        position: "inside",
        distance: 5,
        silent: !0
      },
      itemStyle: {
        borderWidth: 1,
        borderColor: "white",
        borderType: "solid",
        shadowBlur: 0,
        shadowColor: "rgba(0, 0, 0, 0.2)",
        shadowOffsetX: 0,
        shadowOffsetY: 0,
        opacity: 1
      },
      emphasis: {
        focus: "descendant"
      },
      blur: {
        itemStyle: {
          opacity: 0.2
        },
        label: {
          opacity: 0.1
        }
      },
      // Animation type can be expansion, scale.
      animationType: "expansion",
      animationDuration: 1e3,
      animationDurationUpdate: 500,
      data: [],
      /**
       * Sort order.
       *
       * Valid values: 'desc', 'asc', null, or callback function.
       * 'desc' and 'asc' for descend and ascendant order;
       * null for not sorting;
       * example of callback function:
       * function(nodeA, nodeB) {
       *     return nodeA.getValue() - nodeB.getValue();
       * }
       */
      sort: "desc"
    }, C;
  }(SeriesModel$1)
);
function completeTreeValue(H) {
  var C = 0;
  each$f(H.children, function(U) {
    completeTreeValue(U);
    var K = U.value;
    isArray$1(K) && (K = K[0]), C += K;
  });
  var G = H.value;
  isArray$1(G) && (G = G[0]), (G == null || isNaN(G)) && (G = C), G < 0 && (G = 0), isArray$1(H.value) ? H.value[0] = G : H.value = G;
}
const SunburstSeriesModel$1 = SunburstSeriesModel;
var RADIAN = Math.PI / 180;
function sunburstLayout(H, C, G) {
  C.eachSeriesByType(H, function(U) {
    var K = U.get("center"), W = U.get("radius");
    isArray$1(W) || (W = [0, W]), isArray$1(K) || (K = [K, K]);
    var Z = G.getWidth(), X = G.getHeight(), Q = Math.min(Z, X), ee = parsePercent(K[0], Z), te = parsePercent(K[1], X), re = parsePercent(W[0], Q / 2), ne = parsePercent(W[1], Q / 2), ae = -U.get("startAngle") * RADIAN, ie = U.get("minAngle") * RADIAN, se = U.getData().tree.root, oe = U.getViewRoot(), le = oe.depth, ue = U.get("sort");
    ue != null && initChildren(oe, ue);
    var ce = 0;
    each$f(oe.children, function(Ae) {
      !isNaN(Ae.getValue()) && ce++;
    });
    var de = oe.getValue(), ge = Math.PI / (de || ce) * 2, fe = oe.depth > 0, ve = oe.height - (fe ? -1 : 1), pe = (ne - re) / (ve || 1), he = U.get("clockwise"), me = U.get("stillShowZeroSum"), ye = he ? 1 : -1, Ce = function(Ae, _e) {
      if (Ae) {
        var xe = _e;
        if (Ae !== se) {
          var Te = Ae.getValue(), Pe = de === 0 && me ? ge : Te * ge;
          Pe < ie && (Pe = ie), xe = _e + ye * Pe;
          var $e = Ae.depth - le - (fe ? -1 : 1), Me = re + pe * $e, Ee = re + pe * ($e + 1), we = U.getLevelModel(Ae);
          if (we) {
            var Oe = we.get("r0", !0), Ne = we.get("r", !0), ke = we.get("radius", !0);
            ke != null && (Oe = ke[0], Ne = ke[1]), Oe != null && (Me = parsePercent(Oe, Q / 2)), Ne != null && (Ee = parsePercent(Ne, Q / 2));
          }
          Ae.setLayout({
            angle: Pe,
            startAngle: _e,
            endAngle: xe,
            clockwise: he,
            cx: ee,
            cy: te,
            r0: Me,
            r: Ee
          });
        }
        if (Ae.children && Ae.children.length) {
          var ze = 0;
          each$f(Ae.children, function(He) {
            ze += Ce(He, _e + ze);
          });
        }
        return xe - _e;
      }
    };
    if (fe) {
      var Ie = re, be = re + pe, Se = Math.PI * 2;
      se.setLayout({
        angle: Se,
        startAngle: ae,
        endAngle: ae + Se,
        clockwise: he,
        cx: ee,
        cy: te,
        r0: Ie,
        r: be
      });
    }
    Ce(oe, ae);
  });
}
function initChildren(H, C) {
  var G = H.children || [];
  H.children = sort(G, C), G.length && each$f(H.children, function(U) {
    initChildren(U, C);
  });
}
function sort(H, C) {
  if (isFunction(C)) {
    var G = map$1(H, function(K, W) {
      var Z = K.getValue();
      return {
        params: {
          depth: K.depth,
          height: K.height,
          dataIndex: K.dataIndex,
          getValue: function() {
            return Z;
          }
        },
        index: W
      };
    });
    return G.sort(function(K, W) {
      return C(K.params, W.params);
    }), map$1(G, function(K) {
      return H[K.index];
    });
  } else {
    var U = C === "asc";
    return H.sort(function(K, W) {
      var Z = (K.getValue() - W.getValue()) * (U ? 1 : -1);
      return Z === 0 ? (K.dataIndex - W.dataIndex) * (U ? -1 : 1) : Z;
    });
  }
}
function sunburstVisual(H) {
  var C = {};
  function G(U, K, W) {
    for (var Z = U; Z && Z.depth > 1; )
      Z = Z.parentNode;
    var X = K.getColorFromPalette(Z.name || Z.dataIndex + "", C);
    return U.depth > 1 && isString(X) && (X = lift(X, (U.depth - 1) / (W - 1) * 0.5)), X;
  }
  H.eachSeriesByType("sunburst", function(U) {
    var K = U.getData(), W = K.tree;
    W.eachNode(function(Z) {
      var X = Z.getModel(), Q = X.getModel("itemStyle").getItemStyle();
      Q.fill || (Q.fill = G(Z, U, W.root.height));
      var ee = K.ensureUniqueItemVisual(Z.dataIndex, "style");
      extend(ee, Q);
    });
  });
}
function install$s(H) {
  H.registerChartView(SunburstView$1), H.registerSeriesModel(SunburstSeriesModel$1), H.registerLayout(curry$1(sunburstLayout, "sunburst")), H.registerProcessor(curry$1(dataFilter$1, "sunburst")), H.registerVisual(sunburstVisual), installSunburstAction(H);
}
var STYLE_VISUAL_TYPE = {
  color: "fill",
  borderColor: "stroke"
}, NON_STYLE_VISUAL_PROPS = {
  symbol: 1,
  symbolSize: 1,
  symbolKeepAspect: 1,
  legendIcon: 1,
  visualMeta: 1,
  liftZ: 1,
  decal: 1
}, customInnerStore = makeInner(), CustomSeriesModel = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G;
    }
    return C.prototype.optionUpdated = function() {
      this.currentZLevel = this.get("zlevel", !0), this.currentZ = this.get("z", !0);
    }, C.prototype.getInitialData = function(G, U) {
      return createSeriesData(null, this);
    }, C.prototype.getDataParams = function(G, U, K) {
      var W = H.prototype.getDataParams.call(this, G, U);
      return K && (W.info = customInnerStore(K).info), W;
    }, C.type = "series.custom", C.dependencies = ["grid", "polar", "geo", "singleAxis", "calendar"], C.defaultOption = {
      coordinateSystem: "cartesian2d",
      // zlevel: 0,
      z: 2,
      legendHoverLink: !0,
      // Custom series will not clip by default.
      // Some case will use custom series to draw label
      // For example https://echarts.apache.org/examples/en/editor.html?c=custom-gantt-flight
      clip: !1
      // Cartesian coordinate system
      // xAxisIndex: 0,
      // yAxisIndex: 0,
      // Polar coordinate system
      // polarIndex: 0,
      // Geo coordinate system
      // geoIndex: 0,
    }, C;
  }(SeriesModel$1)
);
const CustomSeriesModel$1 = CustomSeriesModel;
function dataToCoordSize$3(H, C) {
  return C = C || [0, 0], map$1(["x", "y"], function(G, U) {
    var K = this.getAxis(G), W = C[U], Z = H[U] / 2;
    return K.type === "category" ? K.getBandWidth() : Math.abs(K.dataToCoord(W - Z) - K.dataToCoord(W + Z));
  }, this);
}
function cartesianPrepareCustom(H) {
  var C = H.master.getRect();
  return {
    coordSys: {
      // The name exposed to user is always 'cartesian2d' but not 'grid'.
      type: "cartesian2d",
      x: C.x,
      y: C.y,
      width: C.width,
      height: C.height
    },
    api: {
      coord: function(G) {
        return H.dataToPoint(G);
      },
      size: bind$1(dataToCoordSize$3, H)
    }
  };
}
function dataToCoordSize$2(H, C) {
  return C = C || [0, 0], map$1([0, 1], function(G) {
    var U = C[G], K = H[G] / 2, W = [], Z = [];
    return W[G] = U - K, Z[G] = U + K, W[1 - G] = Z[1 - G] = C[1 - G], Math.abs(this.dataToPoint(W)[G] - this.dataToPoint(Z)[G]);
  }, this);
}
function geoPrepareCustom(H) {
  var C = H.getBoundingRect();
  return {
    coordSys: {
      type: "geo",
      x: C.x,
      y: C.y,
      width: C.width,
      height: C.height,
      zoom: H.getZoom()
    },
    api: {
      coord: function(G) {
        return H.dataToPoint(G);
      },
      size: bind$1(dataToCoordSize$2, H)
    }
  };
}
function dataToCoordSize$1(H, C) {
  var G = this.getAxis(), U = C instanceof Array ? C[0] : C, K = (H instanceof Array ? H[0] : H) / 2;
  return G.type === "category" ? G.getBandWidth() : Math.abs(G.dataToCoord(U - K) - G.dataToCoord(U + K));
}
function singlePrepareCustom(H) {
  var C = H.getRect();
  return {
    coordSys: {
      type: "singleAxis",
      x: C.x,
      y: C.y,
      width: C.width,
      height: C.height
    },
    api: {
      coord: function(G) {
        return H.dataToPoint(G);
      },
      size: bind$1(dataToCoordSize$1, H)
    }
  };
}
function dataToCoordSize(H, C) {
  return C = C || [0, 0], map$1(["Radius", "Angle"], function(G, U) {
    var K = "get" + G + "Axis", W = this[K](), Z = C[U], X = H[U] / 2, Q = W.type === "category" ? W.getBandWidth() : Math.abs(W.dataToCoord(Z - X) - W.dataToCoord(Z + X));
    return G === "Angle" && (Q = Q * Math.PI / 180), Q;
  }, this);
}
function polarPrepareCustom(H) {
  var C = H.getRadiusAxis(), G = H.getAngleAxis(), U = C.getExtent();
  return U[0] > U[1] && U.reverse(), {
    coordSys: {
      type: "polar",
      cx: H.cx,
      cy: H.cy,
      r: U[1],
      r0: U[0]
    },
    api: {
      coord: function(K) {
        var W = C.dataToRadius(K[0]), Z = G.dataToAngle(K[1]), X = H.coordToPoint([W, Z]);
        return X.push(W, Z * Math.PI / 180), X;
      },
      size: bind$1(dataToCoordSize, H)
    }
  };
}
function calendarPrepareCustom(H) {
  var C = H.getRect(), G = H.getRangeInfo();
  return {
    coordSys: {
      type: "calendar",
      x: C.x,
      y: C.y,
      width: C.width,
      height: C.height,
      cellWidth: H.getCellWidth(),
      cellHeight: H.getCellHeight(),
      rangeInfo: {
        start: G.start,
        end: G.end,
        weeks: G.weeks,
        dayCount: G.allDay
      }
    },
    api: {
      coord: function(U, K) {
        return H.dataToPoint(U, K);
      }
    }
  };
}
var deprecatedLogs = {};
function isEC4CompatibleStyle(H, C, G, U) {
  return H && (H.legacy || H.legacy !== !1 && !G && !U && C !== "tspan" && (C === "text" || hasOwn(H, "text")));
}
function convertFromEC4CompatibleStyle(H, C, G) {
  var U = H, K, W, Z;
  if (C === "text")
    Z = U;
  else {
    Z = {}, hasOwn(U, "text") && (Z.text = U.text), hasOwn(U, "rich") && (Z.rich = U.rich), hasOwn(U, "textFill") && (Z.fill = U.textFill), hasOwn(U, "textStroke") && (Z.stroke = U.textStroke), hasOwn(U, "fontFamily") && (Z.fontFamily = U.fontFamily), hasOwn(U, "fontSize") && (Z.fontSize = U.fontSize), hasOwn(U, "fontStyle") && (Z.fontStyle = U.fontStyle), hasOwn(U, "fontWeight") && (Z.fontWeight = U.fontWeight), W = {
      type: "text",
      style: Z,
      // ec4 does not support rectText trigger.
      // And when text position is different in normal and emphasis
      // => hover text trigger emphasis;
      // => text position changed, leave mouse pointer immediately;
      // That might cause incorrect state.
      silent: !0
    }, K = {};
    var X = hasOwn(U, "textPosition");
    G ? K.position = X ? U.textPosition : "inside" : X && (K.position = U.textPosition), hasOwn(U, "textPosition") && (K.position = U.textPosition), hasOwn(U, "textOffset") && (K.offset = U.textOffset), hasOwn(U, "textRotation") && (K.rotation = U.textRotation), hasOwn(U, "textDistance") && (K.distance = U.textDistance);
  }
  return convertEC4CompatibleRichItem(Z, H), each$f(Z.rich, function(Q) {
    convertEC4CompatibleRichItem(Q, Q);
  }), {
    textConfig: K,
    textContent: W
  };
}
function convertEC4CompatibleRichItem(H, C) {
  C && (C.font = C.textFont || C.font, hasOwn(C, "textStrokeWidth") && (H.lineWidth = C.textStrokeWidth), hasOwn(C, "textAlign") && (H.align = C.textAlign), hasOwn(C, "textVerticalAlign") && (H.verticalAlign = C.textVerticalAlign), hasOwn(C, "textLineHeight") && (H.lineHeight = C.textLineHeight), hasOwn(C, "textWidth") && (H.width = C.textWidth), hasOwn(C, "textHeight") && (H.height = C.textHeight), hasOwn(C, "textBackgroundColor") && (H.backgroundColor = C.textBackgroundColor), hasOwn(C, "textPadding") && (H.padding = C.textPadding), hasOwn(C, "textBorderColor") && (H.borderColor = C.textBorderColor), hasOwn(C, "textBorderWidth") && (H.borderWidth = C.textBorderWidth), hasOwn(C, "textBorderRadius") && (H.borderRadius = C.textBorderRadius), hasOwn(C, "textBoxShadowColor") && (H.shadowColor = C.textBoxShadowColor), hasOwn(C, "textBoxShadowBlur") && (H.shadowBlur = C.textBoxShadowBlur), hasOwn(C, "textBoxShadowOffsetX") && (H.shadowOffsetX = C.textBoxShadowOffsetX), hasOwn(C, "textBoxShadowOffsetY") && (H.shadowOffsetY = C.textBoxShadowOffsetY));
}
function convertToEC4StyleForCustomSerise(H, C, G) {
  var U = H;
  U.textPosition = U.textPosition || G.position || "inside", G.offset != null && (U.textOffset = G.offset), G.rotation != null && (U.textRotation = G.rotation), G.distance != null && (U.textDistance = G.distance);
  var K = U.textPosition.indexOf("inside") >= 0, W = H.fill || "#000";
  convertToEC4RichItem(U, C);
  var Z = U.textFill == null;
  return K ? Z && (U.textFill = G.insideFill || "#fff", !U.textStroke && G.insideStroke && (U.textStroke = G.insideStroke), !U.textStroke && (U.textStroke = W), U.textStrokeWidth == null && (U.textStrokeWidth = 2)) : (Z && (U.textFill = H.fill || G.outsideFill || "#000"), !U.textStroke && G.outsideStroke && (U.textStroke = G.outsideStroke)), U.text = C.text, U.rich = C.rich, each$f(C.rich, function(X) {
    convertToEC4RichItem(X, X);
  }), U;
}
function convertToEC4RichItem(H, C) {
  C && (hasOwn(C, "fill") && (H.textFill = C.fill), hasOwn(C, "stroke") && (H.textStroke = C.fill), hasOwn(C, "lineWidth") && (H.textStrokeWidth = C.lineWidth), hasOwn(C, "font") && (H.font = C.font), hasOwn(C, "fontStyle") && (H.fontStyle = C.fontStyle), hasOwn(C, "fontWeight") && (H.fontWeight = C.fontWeight), hasOwn(C, "fontSize") && (H.fontSize = C.fontSize), hasOwn(C, "fontFamily") && (H.fontFamily = C.fontFamily), hasOwn(C, "align") && (H.textAlign = C.align), hasOwn(C, "verticalAlign") && (H.textVerticalAlign = C.verticalAlign), hasOwn(C, "lineHeight") && (H.textLineHeight = C.lineHeight), hasOwn(C, "width") && (H.textWidth = C.width), hasOwn(C, "height") && (H.textHeight = C.height), hasOwn(C, "backgroundColor") && (H.textBackgroundColor = C.backgroundColor), hasOwn(C, "padding") && (H.textPadding = C.padding), hasOwn(C, "borderColor") && (H.textBorderColor = C.borderColor), hasOwn(C, "borderWidth") && (H.textBorderWidth = C.borderWidth), hasOwn(C, "borderRadius") && (H.textBorderRadius = C.borderRadius), hasOwn(C, "shadowColor") && (H.textBoxShadowColor = C.shadowColor), hasOwn(C, "shadowBlur") && (H.textBoxShadowBlur = C.shadowBlur), hasOwn(C, "shadowOffsetX") && (H.textBoxShadowOffsetX = C.shadowOffsetX), hasOwn(C, "shadowOffsetY") && (H.textBoxShadowOffsetY = C.shadowOffsetY), hasOwn(C, "textShadowColor") && (H.textShadowColor = C.textShadowColor), hasOwn(C, "textShadowBlur") && (H.textShadowBlur = C.textShadowBlur), hasOwn(C, "textShadowOffsetX") && (H.textShadowOffsetX = C.textShadowOffsetX), hasOwn(C, "textShadowOffsetY") && (H.textShadowOffsetY = C.textShadowOffsetY));
}
function warnDeprecated(H, C) {
  if (process.env.NODE_ENV !== "production") {
    var G = H + "^_^" + C;
    deprecatedLogs[G] || (console.warn('[ECharts] DEPRECATED: "' + H + '" has been deprecated. ' + C), deprecatedLogs[G] = !0);
  }
}
var LEGACY_TRANSFORM_PROPS_MAP = {
  position: ["x", "y"],
  scale: ["scaleX", "scaleY"],
  origin: ["originX", "originY"]
}, LEGACY_TRANSFORM_PROPS = keys(LEGACY_TRANSFORM_PROPS_MAP), TRANSFORM_PROPS_MAP = reduce(TRANSFORMABLE_PROPS, function(H, C) {
  return H[C] = 1, H;
}, {}), transformPropNamesStr = TRANSFORMABLE_PROPS.join(", "), ELEMENT_ANIMATABLE_PROPS = ["", "style", "shape", "extra"], transitionInnerStore = makeInner();
function getElementAnimationConfig(H, C, G, U, K) {
  var W = H + "Animation", Z = getAnimationConfig(H, U, K) || {}, X = transitionInnerStore(C).userDuring;
  return Z.duration > 0 && (Z.during = X ? bind$1(duringCall, {
    el: C,
    userDuring: X
  }) : null, Z.setToFinal = !0, Z.scope = H), extend(Z, G[W]), Z;
}
function applyUpdateTransition(H, C, G, U) {
  U = U || {};
  var K = U.dataIndex, W = U.isInit, Z = U.clearStyle, X = G.isAnimationEnabled(), Q = transitionInnerStore(H), ee = C.style;
  Q.userDuring = C.during;
  var te = {}, re = {};
  if (prepareTransformAllPropsFinal(H, C, re), prepareShapeOrExtraAllPropsFinal("shape", C, re), prepareShapeOrExtraAllPropsFinal("extra", C, re), !W && X && (prepareTransformTransitionFrom(H, C, te), prepareShapeOrExtraTransitionFrom("shape", H, C, te), prepareShapeOrExtraTransitionFrom("extra", H, C, te), prepareStyleTransitionFrom(H, C, ee, te)), re.style = ee, applyPropsDirectly(H, re, Z), applyMiscProps(H, C), X)
    if (W) {
      var ne = {};
      each$f(ELEMENT_ANIMATABLE_PROPS, function(ie) {
        var se = ie ? C[ie] : C;
        se && se.enterFrom && (ie && (ne[ie] = ne[ie] || {}), extend(ie ? ne[ie] : ne, se.enterFrom));
      });
      var ae = getElementAnimationConfig("enter", H, C, G, K);
      ae.duration > 0 && H.animateFrom(ne, ae);
    } else
      applyPropsTransition(H, C, K || 0, G, te);
  updateLeaveTo(H, C), ee ? H.dirty() : H.markRedraw();
}
function updateLeaveTo(H, C) {
  for (var G = transitionInnerStore(H).leaveToProps, U = 0; U < ELEMENT_ANIMATABLE_PROPS.length; U++) {
    var K = ELEMENT_ANIMATABLE_PROPS[U], W = K ? C[K] : C;
    W && W.leaveTo && (G || (G = transitionInnerStore(H).leaveToProps = {}), K && (G[K] = G[K] || {}), extend(K ? G[K] : G, W.leaveTo));
  }
}
function applyLeaveTransition(H, C, G, U) {
  if (H) {
    var K = H.parent, W = transitionInnerStore(H).leaveToProps;
    if (W) {
      var Z = getElementAnimationConfig("update", H, C, G, 0);
      Z.done = function() {
        K.remove(H), U && U();
      }, H.animateTo(W, Z);
    } else
      K.remove(H), U && U();
  }
}
function isTransitionAll(H) {
  return H === "all";
}
function applyPropsDirectly(H, C, G) {
  var U = C.style;
  if (!H.isGroup && U) {
    if (G) {
      H.useStyle({});
      for (var K = H.animators, W = 0; W < K.length; W++) {
        var Z = K[W];
        Z.targetName === "style" && Z.changeTarget(H.style);
      }
    }
    H.setStyle(U);
  }
  C && (C.style = null, C && H.attr(C), C.style = U);
}
function applyPropsTransition(H, C, G, U, K) {
  if (K) {
    var W = getElementAnimationConfig("update", H, C, U, G);
    W.duration > 0 && H.animateFrom(K, W);
  }
}
function applyMiscProps(H, C) {
  hasOwn(C, "silent") && (H.silent = C.silent), hasOwn(C, "ignore") && (H.ignore = C.ignore), H instanceof Displayable$1 && hasOwn(C, "invisible") && (H.invisible = C.invisible), H instanceof Path$1 && hasOwn(C, "autoBatch") && (H.autoBatch = C.autoBatch);
}
var tmpDuringScope = {}, transitionDuringAPI = {
  // Usually other props do not need to be changed in animation during.
  setTransform: function(H, C) {
    return process.env.NODE_ENV !== "production" && assert(hasOwn(TRANSFORM_PROPS_MAP, H), "Only " + transformPropNamesStr + " available in `setTransform`."), tmpDuringScope.el[H] = C, this;
  },
  getTransform: function(H) {
    return process.env.NODE_ENV !== "production" && assert(hasOwn(TRANSFORM_PROPS_MAP, H), "Only " + transformPropNamesStr + " available in `getTransform`."), tmpDuringScope.el[H];
  },
  setShape: function(H, C) {
    process.env.NODE_ENV !== "production" && assertNotReserved(H);
    var G = tmpDuringScope.el, U = G.shape || (G.shape = {});
    return U[H] = C, G.dirtyShape && G.dirtyShape(), this;
  },
  getShape: function(H) {
    process.env.NODE_ENV !== "production" && assertNotReserved(H);
    var C = tmpDuringScope.el.shape;
    if (C)
      return C[H];
  },
  setStyle: function(H, C) {
    process.env.NODE_ENV !== "production" && assertNotReserved(H);
    var G = tmpDuringScope.el, U = G.style;
    return U && (process.env.NODE_ENV !== "production" && eqNaN(C) && warn("style." + H + " must not be assigned with NaN."), U[H] = C, G.dirtyStyle && G.dirtyStyle()), this;
  },
  getStyle: function(H) {
    process.env.NODE_ENV !== "production" && assertNotReserved(H);
    var C = tmpDuringScope.el.style;
    if (C)
      return C[H];
  },
  setExtra: function(H, C) {
    process.env.NODE_ENV !== "production" && assertNotReserved(H);
    var G = tmpDuringScope.el.extra || (tmpDuringScope.el.extra = {});
    return G[H] = C, this;
  },
  getExtra: function(H) {
    process.env.NODE_ENV !== "production" && assertNotReserved(H);
    var C = tmpDuringScope.el.extra;
    if (C)
      return C[H];
  }
};
function assertNotReserved(H) {
  if (process.env.NODE_ENV !== "production" && (H === "transition" || H === "enterFrom" || H === "leaveTo"))
    throw new Error('key must not be "' + H + '"');
}
function duringCall() {
  var H = this, C = H.el;
  if (C) {
    var G = transitionInnerStore(C).userDuring, U = H.userDuring;
    if (G !== U) {
      H.el = H.userDuring = null;
      return;
    }
    tmpDuringScope.el = C, U(transitionDuringAPI);
  }
}
function prepareShapeOrExtraTransitionFrom(H, C, G, U) {
  var K = G[H];
  if (K) {
    var W = C[H], Z;
    if (W) {
      var X = G.transition, Q = K.transition;
      if (Q)
        if (!Z && (Z = U[H] = {}), isTransitionAll(Q))
          extend(Z, W);
        else
          for (var ee = normalizeToArray(Q), te = 0; te < ee.length; te++) {
            var re = ee[te], ne = W[re];
            Z[re] = ne;
          }
      else if (isTransitionAll(X) || indexOf(X, H) >= 0) {
        !Z && (Z = U[H] = {});
        for (var ae = keys(W), te = 0; te < ae.length; te++) {
          var re = ae[te], ne = W[re];
          isNonStyleTransitionEnabled(K[re], ne) && (Z[re] = ne);
        }
      }
    }
  }
}
function prepareShapeOrExtraAllPropsFinal(H, C, G) {
  var U = C[H];
  if (U)
    for (var K = G[H] = {}, W = keys(U), Z = 0; Z < W.length; Z++) {
      var X = W[Z];
      K[X] = cloneValue(U[X]);
    }
}
function prepareTransformTransitionFrom(H, C, G) {
  for (var U = C.transition, K = isTransitionAll(U) ? TRANSFORMABLE_PROPS : normalizeToArray(U || []), W = 0; W < K.length; W++) {
    var Z = K[W];
    if (!(Z === "style" || Z === "shape" || Z === "extra")) {
      var X = H[Z];
      process.env.NODE_ENV !== "production" && checkTransformPropRefer(Z, "el.transition"), G[Z] = X;
    }
  }
}
function prepareTransformAllPropsFinal(H, C, G) {
  for (var U = 0; U < LEGACY_TRANSFORM_PROPS.length; U++) {
    var K = LEGACY_TRANSFORM_PROPS[U], W = LEGACY_TRANSFORM_PROPS_MAP[K], Z = C[K];
    Z && (G[W[0]] = Z[0], G[W[1]] = Z[1]);
  }
  for (var U = 0; U < TRANSFORMABLE_PROPS.length; U++) {
    var X = TRANSFORMABLE_PROPS[U];
    C[X] != null && (G[X] = C[X]);
  }
}
function prepareStyleTransitionFrom(H, C, G, U) {
  if (G) {
    var K = H.style, W;
    if (K) {
      var Z = G.transition, X = C.transition;
      if (Z && !isTransitionAll(Z)) {
        var Q = normalizeToArray(Z);
        !W && (W = U.style = {});
        for (var ee = 0; ee < Q.length; ee++) {
          var te = Q[ee], re = K[te];
          W[te] = re;
        }
      } else if (H.getAnimationStyleProps && (isTransitionAll(X) || isTransitionAll(Z) || indexOf(X, "style") >= 0)) {
        var ne = H.getAnimationStyleProps(), ae = ne ? ne.style : null;
        if (ae) {
          !W && (W = U.style = {});
          for (var ie = keys(G), ee = 0; ee < ie.length; ee++) {
            var te = ie[ee];
            if (ae[te]) {
              var re = K[te];
              W[te] = re;
            }
          }
        }
      }
    }
  }
}
function isNonStyleTransitionEnabled(H, C) {
  return isArrayLike(H) ? H !== C : H != null && isFinite(H);
}
var checkTransformPropRefer;
process.env.NODE_ENV !== "production" && (checkTransformPropRefer = function(H, C) {
  hasOwn(TRANSFORM_PROPS_MAP, H) || warn("Prop `" + H + "` is not a permitted in `" + C + "`. Only `" + keys(TRANSFORM_PROPS_MAP).join("`, `") + "` are permitted.");
});
var getStateToRestore = makeInner(), KEYFRAME_EXCLUDE_KEYS = ["percent", "easing", "shape", "style", "extra"];
function stopPreviousKeyframeAnimationAndRestore(H) {
  H.stopAnimation("keyframe"), H.attr(getStateToRestore(H));
}
function applyKeyframeAnimation(H, C, G) {
  if (!(!G.isAnimationEnabled() || !C)) {
    if (isArray$1(C)) {
      each$f(C, function(X) {
        applyKeyframeAnimation(H, X, G);
      });
      return;
    }
    var U = C.keyframes, K = C.duration;
    if (G && K == null) {
      var W = getAnimationConfig("enter", G, 0);
      K = W && W.duration;
    }
    if (!(!U || !K)) {
      var Z = getStateToRestore(H);
      each$f(ELEMENT_ANIMATABLE_PROPS, function(X) {
        if (!(X && !H[X])) {
          var Q, ee = !1;
          U.sort(function(te, re) {
            return te.percent - re.percent;
          }), each$f(U, function(te) {
            var re = H.animators, ne = X ? te[X] : te;
            if (process.env.NODE_ENV !== "production" && te.percent >= 1 && (ee = !0), !!ne) {
              var ae = keys(ne);
              if (X || (ae = filter(ae, function(oe) {
                return indexOf(KEYFRAME_EXCLUDE_KEYS, oe) < 0;
              })), !!ae.length) {
                Q || (Q = H.animate(X, C.loop, !0), Q.scope = "keyframe");
                for (var ie = 0; ie < re.length; ie++)
                  re[ie] !== Q && re[ie].targetName === Q.targetName && re[ie].stopTracks(ae);
                X && (Z[X] = Z[X] || {});
                var se = X ? Z[X] : Z;
                each$f(ae, function(oe) {
                  se[oe] = ((X ? H[X] : H) || {})[oe];
                }), Q.whenWithKeys(K * te.percent, ne, ae, te.easing);
              }
            }
          }), Q && (process.env.NODE_ENV !== "production" && (ee || warn("End frame with percent: 1 is missing in the keyframeAnimation.", !0)), Q.delay(C.delay || 0).duration(K).start(C.easing));
        }
      });
    }
  }
}
var EMPHASIS = "emphasis", NORMAL = "normal", BLUR = "blur", SELECT = "select", STATES = [NORMAL, EMPHASIS, BLUR, SELECT], PATH_ITEM_STYLE = {
  normal: ["itemStyle"],
  emphasis: [EMPHASIS, "itemStyle"],
  blur: [BLUR, "itemStyle"],
  select: [SELECT, "itemStyle"]
}, PATH_LABEL = {
  normal: ["label"],
  emphasis: [EMPHASIS, "label"],
  blur: [BLUR, "label"],
  select: [SELECT, "label"]
}, DEFAULT_TRANSITION = ["x", "y"], GROUP_DIFF_PREFIX = "e\0\0", attachedTxInfoTmp = {
  normal: {},
  emphasis: {},
  blur: {},
  select: {}
}, prepareCustoms = {
  cartesian2d: cartesianPrepareCustom,
  geo: geoPrepareCustom,
  single: singlePrepareCustom,
  polar: polarPrepareCustom,
  calendar: calendarPrepareCustom
};
function isPath(H) {
  return H instanceof Path$1;
}
function isDisplayable(H) {
  return H instanceof Displayable$1;
}
function copyElement(H, C) {
  C.copyTransform(H), isDisplayable(C) && isDisplayable(H) && (C.setStyle(H.style), C.z = H.z, C.z2 = H.z2, C.zlevel = H.zlevel, C.invisible = H.invisible, C.ignore = H.ignore, isPath(C) && isPath(H) && C.setShape(H.shape));
}
var CustomChartView = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G;
    }
    return C.prototype.render = function(G, U, K, W) {
      this._progressiveEls = null;
      var Z = this._data, X = G.getData(), Q = this.group, ee = makeRenderItem(G, X, U, K);
      Z || Q.removeAll(), X.diff(Z).add(function(re) {
        createOrUpdateItem(K, null, re, ee(re, W), G, Q, X);
      }).remove(function(re) {
        var ne = Z.getItemGraphicEl(re);
        ne && applyLeaveTransition(ne, customInnerStore(ne).option, G);
      }).update(function(re, ne) {
        var ae = Z.getItemGraphicEl(ne);
        createOrUpdateItem(K, ae, re, ee(re, W), G, Q, X);
      }).execute();
      var te = G.get("clip", !0) ? createClipPath(G.coordinateSystem, !1, G) : null;
      te ? Q.setClipPath(te) : Q.removeClipPath(), this._data = X;
    }, C.prototype.incrementalPrepareRender = function(G, U, K) {
      this.group.removeAll(), this._data = null;
    }, C.prototype.incrementalRender = function(G, U, K, W, Z) {
      var X = U.getData(), Q = makeRenderItem(U, X, K, W), ee = this._progressiveEls = [];
      function te(ae) {
        ae.isGroup || (ae.incremental = !0, ae.ensureState("emphasis").hoverLayer = !0);
      }
      for (var re = G.start; re < G.end; re++) {
        var ne = createOrUpdateItem(null, null, re, Q(re, Z), U, this.group, X);
        ne && (ne.traverse(te), ee.push(ne));
      }
    }, C.prototype.eachRendered = function(G) {
      traverseElements(this._progressiveEls || this.group, G);
    }, C.prototype.filterForExposedEvent = function(G, U, K, W) {
      var Z = U.element;
      if (Z == null || K.name === Z)
        return !0;
      for (; (K = K.__hostTarget || K.parent) && K !== this.group; )
        if (K.name === Z)
          return !0;
      return !1;
    }, C.type = "custom", C;
  }(ChartView$1)
);
const CustomChartView$1 = CustomChartView;
function createEl$1(H) {
  var C = H.type, G;
  if (C === "path") {
    var U = H.shape, K = U.width != null && U.height != null ? {
      x: U.x || 0,
      y: U.y || 0,
      width: U.width,
      height: U.height
    } : null, W = getPathData(U);
    G = makePath(W, null, K, U.layout || "center"), customInnerStore(G).customPathData = W;
  } else if (C === "image")
    G = new ZRImage$1({}), customInnerStore(G).customImagePath = H.style.image;
  else if (C === "text")
    G = new ZRText$1({});
  else if (C === "group")
    G = new Group$4();
  else {
    if (C === "compoundPath")
      throw new Error('"compoundPath" is not supported yet.');
    var Z = getShapeClass(C);
    if (!Z) {
      var X = "";
      process.env.NODE_ENV !== "production" && (X = 'graphic type "' + C + '" can not be found.'), throwError(X);
    }
    G = new Z();
  }
  return customInnerStore(G).customGraphicType = C, G.name = H.name, G.z2EmphasisLift = 1, G.z2SelectLift = 1, G;
}
function updateElNormal(H, C, G, U, K, W, Z) {
  stopPreviousKeyframeAnimationAndRestore(C);
  var X = K && K.normal.cfg;
  X && C.setTextConfig(X), U && U.transition == null && (U.transition = DEFAULT_TRANSITION);
  var Q = U && U.style;
  if (Q) {
    if (C.type === "text") {
      var ee = Q;
      hasOwn(ee, "textFill") && (ee.fill = ee.textFill), hasOwn(ee, "textStroke") && (ee.stroke = ee.textStroke);
    }
    var te = void 0, re = isPath(C) ? Q.decal : null;
    H && re && (re.dirty = !0, te = createOrUpdatePatternFromDecal(re, H)), Q.__decalPattern = te;
  }
  if (isDisplayable(C) && Q) {
    var te = Q.__decalPattern;
    te && (Q.decal = te);
  }
  applyUpdateTransition(C, U, W, {
    dataIndex: G,
    isInit: Z,
    clearStyle: !0
  }), applyKeyframeAnimation(C, U.keyframeAnimation, W);
}
function updateElOnState(H, C, G, U, K) {
  var W = C.isGroup ? null : C, Z = K && K[H].cfg;
  if (W) {
    var X = W.ensureState(H);
    if (U === !1) {
      var Q = W.getState(H);
      Q && (Q.style = null);
    } else
      X.style = U || null;
    Z && (X.textConfig = Z), setDefaultStateProxy(W);
  }
}
function updateZ(H, C, G) {
  if (!H.isGroup) {
    var U = H, K = G.currentZ, W = G.currentZLevel;
    U.z = K, U.zlevel = W;
    var Z = C.z2;
    Z != null && (U.z2 = Z || 0);
    for (var X = 0; X < STATES.length; X++)
      updateZForEachState(U, C, STATES[X]);
  }
}
function updateZForEachState(H, C, G) {
  var U = G === NORMAL, K = U ? C : retrieveStateOption(C, G), W = K ? K.z2 : null, Z;
  W != null && (Z = U ? H : H.ensureState(G), Z.z2 = W || 0);
}
function makeRenderItem(H, C, G, U) {
  var K = H.get("renderItem"), W = H.coordinateSystem, Z = {};
  W && (process.env.NODE_ENV !== "production" && (assert(K, "series.render is required."), assert(W.prepareCustoms || prepareCustoms[W.type], "This coordSys does not support custom series.")), Z = W.prepareCustoms ? W.prepareCustoms(W) : prepareCustoms[W.type](W));
  for (var X = defaults({
    getWidth: U.getWidth,
    getHeight: U.getHeight,
    getZr: U.getZr,
    getDevicePixelRatio: U.getDevicePixelRatio,
    value: de,
    style: fe,
    ordinalRawValue: ge,
    styleEmphasis: ve,
    visual: me,
    barLayout: ye,
    currentSeriesIndices: Ce,
    font: Ie
  }, Z.api || {}), Q = {
    // The life cycle of context: current round of rendering.
    // The global life cycle is probably not necessary, because
    // user can store global status by themselves.
    context: {},
    seriesId: H.id,
    seriesName: H.name,
    seriesIndex: H.seriesIndex,
    coordSys: Z.coordSys,
    dataInsideLength: C.count(),
    encode: wrapEncodeDef(H.getData())
  }, ee, te, re = {}, ne = {}, ae = {}, ie = {}, se = 0; se < STATES.length; se++) {
    var oe = STATES[se];
    ae[oe] = H.getModel(PATH_ITEM_STYLE[oe]), ie[oe] = H.getModel(PATH_LABEL[oe]);
  }
  function le(be) {
    return be === ee ? te || (te = C.getItemModel(be)) : C.getItemModel(be);
  }
  function ue(be, Se) {
    return C.hasItemOption ? be === ee ? re[Se] || (re[Se] = le(be).getModel(PATH_ITEM_STYLE[Se])) : le(be).getModel(PATH_ITEM_STYLE[Se]) : ae[Se];
  }
  function ce(be, Se) {
    return C.hasItemOption ? be === ee ? ne[Se] || (ne[Se] = le(be).getModel(PATH_LABEL[Se])) : le(be).getModel(PATH_LABEL[Se]) : ie[Se];
  }
  return function(be, Se) {
    return ee = be, te = null, re = {}, ne = {}, K && K(defaults({
      dataIndexInside: be,
      dataIndex: C.getRawIndex(be),
      // Can be used for optimization when zoom or roam.
      actionType: Se ? Se.type : null
    }, Q), X);
  };
  function de(be, Se) {
    return Se == null && (Se = ee), C.getStore().get(C.getDimensionIndex(be || 0), Se);
  }
  function ge(be, Se) {
    Se == null && (Se = ee), be = be || 0;
    var Ae = C.getDimensionInfo(be);
    if (!Ae) {
      var _e = C.getDimensionIndex(be);
      return _e >= 0 ? C.getStore().get(_e, Se) : void 0;
    }
    var xe = C.get(Ae.name, Se), Te = Ae && Ae.ordinalMeta;
    return Te ? Te.categories[xe] : xe;
  }
  function fe(be, Se) {
    process.env.NODE_ENV !== "production" && warnDeprecated("api.style", "Please write literal style directly instead."), Se == null && (Se = ee);
    var Ae = C.getItemVisual(Se, "style"), _e = Ae && Ae.fill, xe = Ae && Ae.opacity, Te = ue(Se, NORMAL).getItemStyle();
    _e != null && (Te.fill = _e), xe != null && (Te.opacity = xe);
    var Pe = {
      inheritColor: isString(_e) ? _e : "#000"
    }, $e = ce(Se, NORMAL), Me = createTextStyle($e, null, Pe, !1, !0);
    Me.text = $e.getShallow("show") ? retrieve2(H.getFormattedLabel(Se, NORMAL), getDefaultLabel(C, Se)) : null;
    var Ee = createTextConfig($e, Pe, !1);
    return he(be, Te), Te = convertToEC4StyleForCustomSerise(Te, Me, Ee), be && pe(Te, be), Te.legacy = !0, Te;
  }
  function ve(be, Se) {
    process.env.NODE_ENV !== "production" && warnDeprecated("api.styleEmphasis", "Please write literal style directly instead."), Se == null && (Se = ee);
    var Ae = ue(Se, EMPHASIS).getItemStyle(), _e = ce(Se, EMPHASIS), xe = createTextStyle(_e, null, null, !0, !0);
    xe.text = _e.getShallow("show") ? retrieve3(H.getFormattedLabel(Se, EMPHASIS), H.getFormattedLabel(Se, NORMAL), getDefaultLabel(C, Se)) : null;
    var Te = createTextConfig(_e, null, !0);
    return he(be, Ae), Ae = convertToEC4StyleForCustomSerise(Ae, xe, Te), be && pe(Ae, be), Ae.legacy = !0, Ae;
  }
  function pe(be, Se) {
    for (var Ae in Se)
      hasOwn(Se, Ae) && (be[Ae] = Se[Ae]);
  }
  function he(be, Se) {
    be && (be.textFill && (Se.textFill = be.textFill), be.textPosition && (Se.textPosition = be.textPosition));
  }
  function me(be, Se) {
    if (Se == null && (Se = ee), hasOwn(STYLE_VISUAL_TYPE, be)) {
      var Ae = C.getItemVisual(Se, "style");
      return Ae ? Ae[STYLE_VISUAL_TYPE[be]] : null;
    }
    if (hasOwn(NON_STYLE_VISUAL_PROPS, be))
      return C.getItemVisual(Se, be);
  }
  function ye(be) {
    if (W.type === "cartesian2d") {
      var Se = W.getBaseAxis();
      return getLayoutOnAxis(defaults({
        axis: Se
      }, be));
    }
  }
  function Ce() {
    return G.getCurrentSeriesIndices();
  }
  function Ie(be) {
    return getFont(be, G);
  }
}
function wrapEncodeDef(H) {
  var C = {};
  return each$f(H.dimensions, function(G) {
    var U = H.getDimensionInfo(G);
    if (!U.isExtraCoord) {
      var K = U.coordDim, W = C[K] = C[K] || [];
      W[U.coordDimIndex] = H.getDimensionIndex(G);
    }
  }), C;
}
function createOrUpdateItem(H, C, G, U, K, W, Z) {
  if (!U) {
    W.remove(C);
    return;
  }
  var X = doCreateOrUpdateEl(H, C, G, U, K, W);
  return X && Z.setItemGraphicEl(G, X), X && toggleHoverEmphasis(X, U.focus, U.blurScope, U.emphasisDisabled), X;
}
function doCreateOrUpdateEl(H, C, G, U, K, W) {
  process.env.NODE_ENV !== "production" && assert(U, "should not have an null/undefined element setting");
  var Z = -1, X = C;
  C && doesElNeedRecreate(C, U, K) && (Z = indexOf(W.childrenRef(), C), C = null);
  var Q = !C, ee = C;
  ee ? ee.clearStates() : (ee = createEl$1(U), X && copyElement(X, ee)), U.morph === !1 ? ee.disableMorphing = !0 : ee.disableMorphing && (ee.disableMorphing = !1), attachedTxInfoTmp.normal.cfg = attachedTxInfoTmp.normal.conOpt = attachedTxInfoTmp.emphasis.cfg = attachedTxInfoTmp.emphasis.conOpt = attachedTxInfoTmp.blur.cfg = attachedTxInfoTmp.blur.conOpt = attachedTxInfoTmp.select.cfg = attachedTxInfoTmp.select.conOpt = null, attachedTxInfoTmp.isLegacy = !1, doCreateOrUpdateAttachedTx(ee, G, U, K, Q, attachedTxInfoTmp), doCreateOrUpdateClipPath(ee, G, U, K, Q), updateElNormal(H, ee, G, U, attachedTxInfoTmp, K, Q), hasOwn(U, "info") && (customInnerStore(ee).info = U.info);
  for (var te = 0; te < STATES.length; te++) {
    var re = STATES[te];
    if (re !== NORMAL) {
      var ne = retrieveStateOption(U, re), ae = retrieveStyleOptionOnState(U, ne, re);
      updateElOnState(re, ee, ne, ae, attachedTxInfoTmp);
    }
  }
  return updateZ(ee, U, K), U.type === "group" && mergeChildren(H, ee, G, U, K), Z >= 0 ? W.replaceAt(ee, Z) : W.add(ee), ee;
}
function doesElNeedRecreate(H, C, G) {
  var U = customInnerStore(H), K = C.type, W = C.shape, Z = C.style;
  return (
    // Always create new if universal transition is enabled.
    // Because we do transition after render. It needs to know what old element is. Replacement will loose it.
    G.isUniversalTransitionEnabled() || K != null && K !== U.customGraphicType || K === "path" && hasOwnPathData(W) && getPathData(W) !== U.customPathData || K === "image" && hasOwn(Z, "image") && Z.image !== U.customImagePath
  );
}
function doCreateOrUpdateClipPath(H, C, G, U, K) {
  var W = G.clipPath;
  if (W === !1)
    H && H.getClipPath() && H.removeClipPath();
  else if (W) {
    var Z = H.getClipPath();
    Z && doesElNeedRecreate(Z, W, U) && (Z = null), Z || (Z = createEl$1(W), process.env.NODE_ENV !== "production" && assert(isPath(Z), "Only any type of `path` can be used in `clipPath`, rather than " + Z.type + "."), H.setClipPath(Z)), updateElNormal(null, Z, C, W, null, U, K);
  }
}
function doCreateOrUpdateAttachedTx(H, C, G, U, K, W) {
  if (!H.isGroup) {
    processTxInfo(G, null, W), processTxInfo(G, EMPHASIS, W);
    var Z = W.normal.conOpt, X = W.emphasis.conOpt, Q = W.blur.conOpt, ee = W.select.conOpt;
    if (Z != null || X != null || ee != null || Q != null) {
      var te = H.getTextContent();
      if (Z === !1)
        te && H.removeTextContent();
      else {
        Z = W.normal.conOpt = Z || {
          type: "text"
        }, te ? te.clearStates() : (te = createEl$1(Z), H.setTextContent(te)), updateElNormal(null, te, C, Z, null, U, K);
        for (var re = Z && Z.style, ne = 0; ne < STATES.length; ne++) {
          var ae = STATES[ne];
          if (ae !== NORMAL) {
            var ie = W[ae].conOpt;
            updateElOnState(ae, te, ie, retrieveStyleOptionOnState(Z, ie, ae), null);
          }
        }
        re ? te.dirty() : te.markRedraw();
      }
    }
  }
}
function processTxInfo(H, C, G) {
  var U = C ? retrieveStateOption(H, C) : H, K = C ? retrieveStyleOptionOnState(H, U, EMPHASIS) : H.style, W = H.type, Z = U ? U.textConfig : null, X = H.textContent, Q = X ? C ? retrieveStateOption(X, C) : X : null;
  if (K && // Because emphasis style has little info to detect legacy,
  // if normal is legacy, emphasis is trade as legacy.
  (G.isLegacy || isEC4CompatibleStyle(K, W, !!Z, !!Q))) {
    G.isLegacy = !0;
    var ee = convertFromEC4CompatibleStyle(K, W, !C);
    !Z && ee.textConfig && (Z = ee.textConfig), !Q && ee.textContent && (Q = ee.textContent);
  }
  if (!C && Q) {
    var te = Q;
    !te.type && (te.type = "text"), process.env.NODE_ENV !== "production" && assert(te.type === "text", 'textContent.type must be "text"');
  }
  var re = C ? G[C] : G.normal;
  re.cfg = Z, re.conOpt = Q;
}
function retrieveStateOption(H, C) {
  return C ? H ? H[C] : null : H;
}
function retrieveStyleOptionOnState(H, C, G) {
  var U = C && C.style;
  return U == null && G === EMPHASIS && H && (U = H.styleEmphasis), U;
}
function mergeChildren(H, C, G, U, K) {
  var W = U.children, Z = W ? W.length : 0, X = U.$mergeChildren, Q = X === "byName" || U.diffChildrenByName, ee = X === !1;
  if (!(!Z && !Q && !ee)) {
    if (Q) {
      diffGroupChildren({
        api: H,
        oldChildren: C.children() || [],
        newChildren: W || [],
        dataIndex: G,
        seriesModel: K,
        group: C
      });
      return;
    }
    ee && C.removeAll();
    for (var te = 0; te < Z; te++) {
      var re = W[te], ne = C.childAt(te);
      re ? (re.ignore == null && (re.ignore = !1), doCreateOrUpdateEl(H, ne, G, re, K, C)) : (process.env.NODE_ENV !== "production" && assert(ne, "renderItem should not return a group containing elements as null/undefined/{} if they do not exist before."), ne.ignore = !0);
    }
    for (var ae = C.childCount() - 1; ae >= te; ae--) {
      var ie = C.childAt(ae);
      removeChildFromGroup(C, ie, K);
    }
  }
}
function removeChildFromGroup(H, C, G) {
  C && applyLeaveTransition(C, customInnerStore(H).option, G);
}
function diffGroupChildren(H) {
  new DataDiffer$1(H.oldChildren, H.newChildren, getKey, getKey, H).add(processAddUpdate).update(processAddUpdate).remove(processRemove).execute();
}
function getKey(H, C) {
  var G = H && H.name;
  return G ?? GROUP_DIFF_PREFIX + C;
}
function processAddUpdate(H, C) {
  var G = this.context, U = H != null ? G.newChildren[H] : null, K = C != null ? G.oldChildren[C] : null;
  doCreateOrUpdateEl(G.api, K, G.dataIndex, U, G.seriesModel, G.group);
}
function processRemove(H) {
  var C = this.context, G = C.oldChildren[H];
  G && applyLeaveTransition(G, customInnerStore(G).option, C.seriesModel);
}
function getPathData(H) {
  return H && (H.pathData || H.d);
}
function hasOwnPathData(H) {
  return H && (hasOwn(H, "pathData") || hasOwn(H, "d"));
}
function install$r(H) {
  H.registerChartView(CustomChartView$1), H.registerSeriesModel(CustomSeriesModel$1);
}
var inner$b = makeInner(), clone$1 = clone$4, bind = bind$1, BaseAxisPointer = (
  /** @class */
  function() {
    function H() {
      this._dragging = !1, this.animationThreshold = 15;
    }
    return H.prototype.render = function(C, G, U, K) {
      var W = G.get("value"), Z = G.get("status");
      if (this._axisModel = C, this._axisPointerModel = G, this._api = U, !(!K && this._lastValue === W && this._lastStatus === Z)) {
        this._lastValue = W, this._lastStatus = Z;
        var X = this._group, Q = this._handle;
        if (!Z || Z === "hide") {
          X && X.hide(), Q && Q.hide();
          return;
        }
        X && X.show(), Q && Q.show();
        var ee = {};
        this.makeElOption(ee, W, C, G, U);
        var te = ee.graphicKey;
        te !== this._lastGraphicKey && this.clear(U), this._lastGraphicKey = te;
        var re = this._moveAnimation = this.determineAnimation(C, G);
        if (!X)
          X = this._group = new Group$4(), this.createPointerEl(X, ee, C, G), this.createLabelEl(X, ee, C, G), U.getZr().add(X);
        else {
          var ne = curry$1(updateProps, G, re);
          this.updatePointerEl(X, ee, ne), this.updateLabelEl(X, ee, ne, G);
        }
        updateMandatoryProps(X, G, !0), this._renderHandle(W);
      }
    }, H.prototype.remove = function(C) {
      this.clear(C);
    }, H.prototype.dispose = function(C) {
      this.clear(C);
    }, H.prototype.determineAnimation = function(C, G) {
      var U = G.get("animation"), K = C.axis, W = K.type === "category", Z = G.get("snap");
      if (!Z && !W)
        return !1;
      if (U === "auto" || U == null) {
        var X = this.animationThreshold;
        if (W && K.getBandWidth() > X)
          return !0;
        if (Z) {
          var Q = getAxisInfo$1(C).seriesDataCount, ee = K.getExtent();
          return Math.abs(ee[0] - ee[1]) / Q > X;
        }
        return !1;
      }
      return U === !0;
    }, H.prototype.makeElOption = function(C, G, U, K, W) {
    }, H.prototype.createPointerEl = function(C, G, U, K) {
      var W = G.pointer;
      if (W) {
        var Z = inner$b(C).pointerEl = new graphic[W.type](clone$1(G.pointer));
        C.add(Z);
      }
    }, H.prototype.createLabelEl = function(C, G, U, K) {
      if (G.label) {
        var W = inner$b(C).labelEl = new ZRText$1(clone$1(G.label));
        C.add(W), updateLabelShowHide(W, K);
      }
    }, H.prototype.updatePointerEl = function(C, G, U) {
      var K = inner$b(C).pointerEl;
      K && G.pointer && (K.setStyle(G.pointer.style), U(K, {
        shape: G.pointer.shape
      }));
    }, H.prototype.updateLabelEl = function(C, G, U, K) {
      var W = inner$b(C).labelEl;
      W && (W.setStyle(G.label.style), U(W, {
        // Consider text length change in vertical axis, animation should
        // be used on shape, otherwise the effect will be weird.
        // TODOTODO
        // shape: elOption.label.shape,
        x: G.label.x,
        y: G.label.y
      }), updateLabelShowHide(W, K));
    }, H.prototype._renderHandle = function(C) {
      if (!(this._dragging || !this.updateHandleTransform)) {
        var G = this._axisPointerModel, U = this._api.getZr(), K = this._handle, W = G.getModel("handle"), Z = G.get("status");
        if (!W.get("show") || !Z || Z === "hide") {
          K && U.remove(K), this._handle = null;
          return;
        }
        var X;
        this._handle || (X = !0, K = this._handle = createIcon(W.get("icon"), {
          cursor: "move",
          draggable: !0,
          onmousemove: function(ee) {
            stop(ee.event);
          },
          onmousedown: bind(this._onHandleDragMove, this, 0, 0),
          drift: bind(this._onHandleDragMove, this),
          ondragend: bind(this._onHandleDragEnd, this)
        }), U.add(K)), updateMandatoryProps(K, G, !1), K.setStyle(W.getItemStyle(null, ["color", "borderColor", "borderWidth", "opacity", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"]));
        var Q = W.get("size");
        isArray$1(Q) || (Q = [Q, Q]), K.scaleX = Q[0] / 2, K.scaleY = Q[1] / 2, createOrUpdate(this, "_doDispatchAxisPointer", W.get("throttle") || 0, "fixRate"), this._moveHandleToValue(C, X);
      }
    }, H.prototype._moveHandleToValue = function(C, G) {
      updateProps(this._axisPointerModel, !G && this._moveAnimation, this._handle, getHandleTransProps(this.getHandleTransform(C, this._axisModel, this._axisPointerModel)));
    }, H.prototype._onHandleDragMove = function(C, G) {
      var U = this._handle;
      if (U) {
        this._dragging = !0;
        var K = this.updateHandleTransform(getHandleTransProps(U), [C, G], this._axisModel, this._axisPointerModel);
        this._payloadInfo = K, U.stopAnimation(), U.attr(getHandleTransProps(K)), inner$b(U).lastProp = null, this._doDispatchAxisPointer();
      }
    }, H.prototype._doDispatchAxisPointer = function() {
      var C = this._handle;
      if (C) {
        var G = this._payloadInfo, U = this._axisModel;
        this._api.dispatchAction({
          type: "updateAxisPointer",
          x: G.cursorPoint[0],
          y: G.cursorPoint[1],
          tooltipOption: G.tooltipOption,
          axesInfo: [{
            axisDim: U.axis.dim,
            axisIndex: U.componentIndex
          }]
        });
      }
    }, H.prototype._onHandleDragEnd = function() {
      this._dragging = !1;
      var C = this._handle;
      if (C) {
        var G = this._axisPointerModel.get("value");
        this._moveHandleToValue(G), this._api.dispatchAction({
          type: "hideTip"
        });
      }
    }, H.prototype.clear = function(C) {
      this._lastValue = null, this._lastStatus = null;
      var G = C.getZr(), U = this._group, K = this._handle;
      G && U && (this._lastGraphicKey = null, U && G.remove(U), K && G.remove(K), this._group = null, this._handle = null, this._payloadInfo = null), clear$1(this, "_doDispatchAxisPointer");
    }, H.prototype.doClear = function() {
    }, H.prototype.buildLabel = function(C, G, U) {
      return U = U || 0, {
        x: C[U],
        y: C[1 - U],
        width: G[U],
        height: G[1 - U]
      };
    }, H;
  }()
);
function updateProps(H, C, G, U) {
  propsEqual(inner$b(G).lastProp, U) || (inner$b(G).lastProp = U, C ? updateProps$1(G, U, H) : (G.stopAnimation(), G.attr(U)));
}
function propsEqual(H, C) {
  if (isObject$3(H) && isObject$3(C)) {
    var G = !0;
    return each$f(C, function(U, K) {
      G = G && propsEqual(H[K], U);
    }), !!G;
  } else
    return H === C;
}
function updateLabelShowHide(H, C) {
  H[C.get(["label", "show"]) ? "show" : "hide"]();
}
function getHandleTransProps(H) {
  return {
    x: H.x || 0,
    y: H.y || 0,
    rotation: H.rotation || 0
  };
}
function updateMandatoryProps(H, C, G) {
  var U = C.get("z"), K = C.get("zlevel");
  H && H.traverse(function(W) {
    W.type !== "group" && (U != null && (W.z = U), K != null && (W.zlevel = K), W.silent = G);
  });
}
const BaseAxisPointer$1 = BaseAxisPointer;
function buildElStyle(H) {
  var C = H.get("type"), G = H.getModel(C + "Style"), U;
  return C === "line" ? (U = G.getLineStyle(), U.fill = null) : C === "shadow" && (U = G.getAreaStyle(), U.stroke = null), U;
}
function buildLabelElOption(H, C, G, U, K) {
  var W = G.get("value"), Z = getValueLabel(W, C.axis, C.ecModel, G.get("seriesDataIndices"), {
    precision: G.get(["label", "precision"]),
    formatter: G.get(["label", "formatter"])
  }), X = G.getModel("label"), Q = normalizeCssArray(X.get("padding") || 0), ee = X.getFont(), te = getBoundingRect(Z, ee), re = K.position, ne = te.width + Q[1] + Q[3], ae = te.height + Q[0] + Q[2], ie = K.align;
  ie === "right" && (re[0] -= ne), ie === "center" && (re[0] -= ne / 2);
  var se = K.verticalAlign;
  se === "bottom" && (re[1] -= ae), se === "middle" && (re[1] -= ae / 2), confineInContainer(re, ne, ae, U);
  var oe = X.get("backgroundColor");
  (!oe || oe === "auto") && (oe = C.get(["axisLine", "lineStyle", "color"])), H.label = {
    // shape: {x: 0, y: 0, width: width, height: height, r: labelModel.get('borderRadius')},
    x: re[0],
    y: re[1],
    style: createTextStyle(X, {
      text: Z,
      font: ee,
      fill: X.getTextColor(),
      padding: Q,
      backgroundColor: oe
    }),
    // Lable should be over axisPointer.
    z2: 10
  };
}
function confineInContainer(H, C, G, U) {
  var K = U.getWidth(), W = U.getHeight();
  H[0] = Math.min(H[0] + C, K) - C, H[1] = Math.min(H[1] + G, W) - G, H[0] = Math.max(H[0], 0), H[1] = Math.max(H[1], 0);
}
function getValueLabel(H, C, G, U, K) {
  H = C.scale.parse(H);
  var W = C.scale.getLabel({
    value: H
  }, {
    // If `precision` is set, width can be fixed (like '12.00500'), which
    // helps to debounce when when moving label.
    precision: K.precision
  }), Z = K.formatter;
  if (Z) {
    var X = {
      value: getAxisRawValue(C, {
        value: H
      }),
      axisDimension: C.dim,
      axisIndex: C.index,
      seriesData: []
    };
    each$f(U, function(Q) {
      var ee = G.getSeriesByIndex(Q.seriesIndex), te = Q.dataIndexInside, re = ee && ee.getDataParams(te);
      re && X.seriesData.push(re);
    }), isString(Z) ? W = Z.replace("{value}", W) : isFunction(Z) && (W = Z(X));
  }
  return W;
}
function getTransformedPosition(H, C, G) {
  var U = create$1();
  return rotate(U, U, G.rotation), translate(U, U, G.position), applyTransform([H.dataToCoord(C), (G.labelOffset || 0) + (G.labelDirection || 1) * (G.labelMargin || 0)], U);
}
function buildCartesianSingleLabelElOption(H, C, G, U, K, W) {
  var Z = AxisBuilder$1.innerTextLayout(G.rotation, 0, G.labelDirection);
  G.labelMargin = K.get(["label", "margin"]), buildLabelElOption(C, U, K, W, {
    position: getTransformedPosition(U.axis, H, G),
    align: Z.textAlign,
    verticalAlign: Z.textVerticalAlign
  });
}
function makeLineShape(H, C, G) {
  return G = G || 0, {
    x1: H[G],
    y1: H[1 - G],
    x2: C[G],
    y2: C[1 - G]
  };
}
function makeRectShape(H, C, G) {
  return G = G || 0, {
    x: H[G],
    y: H[1 - G],
    width: C[G],
    height: C[1 - G]
  };
}
function makeSectorShape(H, C, G, U, K, W) {
  return {
    cx: H,
    cy: C,
    r0: G,
    r: U,
    startAngle: K,
    endAngle: W,
    clockwise: !0
  };
}
var CartesianAxisPointer = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      return H !== null && H.apply(this, arguments) || this;
    }
    return C.prototype.makeElOption = function(G, U, K, W, Z) {
      var X = K.axis, Q = X.grid, ee = W.get("type"), te = getCartesian(Q, X).getOtherAxis(X).getGlobalExtent(), re = X.toGlobalCoord(X.dataToCoord(U, !0));
      if (ee && ee !== "none") {
        var ne = buildElStyle(W), ae = pointerShapeBuilder$2[ee](X, re, te);
        ae.style = ne, G.graphicKey = ae.type, G.pointer = ae;
      }
      var ie = layout$2(Q.model, K);
      buildCartesianSingleLabelElOption(
        // @ts-ignore
        U,
        G,
        ie,
        K,
        W,
        Z
      );
    }, C.prototype.getHandleTransform = function(G, U, K) {
      var W = layout$2(U.axis.grid.model, U, {
        labelInside: !1
      });
      W.labelMargin = K.get(["handle", "margin"]);
      var Z = getTransformedPosition(U.axis, G, W);
      return {
        x: Z[0],
        y: Z[1],
        rotation: W.rotation + (W.labelDirection < 0 ? Math.PI : 0)
      };
    }, C.prototype.updateHandleTransform = function(G, U, K, W) {
      var Z = K.axis, X = Z.grid, Q = Z.getGlobalExtent(!0), ee = getCartesian(X, Z).getOtherAxis(Z).getGlobalExtent(), te = Z.dim === "x" ? 0 : 1, re = [G.x, G.y];
      re[te] += U[te], re[te] = Math.min(Q[1], re[te]), re[te] = Math.max(Q[0], re[te]);
      var ne = (ee[1] + ee[0]) / 2, ae = [ne, ne];
      ae[te] = re[te];
      var ie = [{
        verticalAlign: "middle"
      }, {
        align: "center"
      }];
      return {
        x: re[0],
        y: re[1],
        rotation: G.rotation,
        cursorPoint: ae,
        tooltipOption: ie[te]
      };
    }, C;
  }(BaseAxisPointer$1)
);
function getCartesian(H, C) {
  var G = {};
  return G[C.dim + "AxisIndex"] = C.index, H.getCartesian(G);
}
var pointerShapeBuilder$2 = {
  line: function(H, C, G) {
    var U = makeLineShape([C, G[0]], [C, G[1]], getAxisDimIndex(H));
    return {
      type: "Line",
      subPixelOptimize: !0,
      shape: U
    };
  },
  shadow: function(H, C, G) {
    var U = Math.max(1, H.getBandWidth()), K = G[1] - G[0];
    return {
      type: "Rect",
      shape: makeRectShape([C - U / 2, G[0]], [U, K], getAxisDimIndex(H))
    };
  }
};
function getAxisDimIndex(H) {
  return H.dim === "x" ? 0 : 1;
}
const CartesianAxisPointer$1 = CartesianAxisPointer;
var AxisPointerModel = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G;
    }
    return C.type = "axisPointer", C.defaultOption = {
      // 'auto' means that show when triggered by tooltip or handle.
      show: "auto",
      // zlevel: 0,
      z: 50,
      type: "line",
      // axispointer triggered by tootip determine snap automatically,
      // see `modelHelper`.
      snap: !1,
      triggerTooltip: !0,
      value: null,
      status: null,
      link: [],
      // Do not set 'auto' here, otherwise global animation: false
      // will not effect at this axispointer.
      animation: null,
      animationDurationUpdate: 200,
      lineStyle: {
        color: "#B9BEC9",
        width: 1,
        type: "dashed"
      },
      shadowStyle: {
        color: "rgba(210,219,238,0.2)"
      },
      label: {
        show: !0,
        formatter: null,
        precision: "auto",
        margin: 3,
        color: "#fff",
        padding: [5, 7, 5, 7],
        backgroundColor: "auto",
        borderColor: null,
        borderWidth: 0,
        borderRadius: 3
      },
      handle: {
        show: !1,
        // eslint-disable-next-line
        icon: "M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z",
        size: 45,
        // handle margin is from symbol center to axis, which is stable when circular move.
        margin: 50,
        // color: '#1b8bbd'
        // color: '#2f4554'
        color: "#333",
        shadowBlur: 3,
        shadowColor: "#aaa",
        shadowOffsetX: 0,
        shadowOffsetY: 2,
        // For mobile performance
        throttle: 40
      }
    }, C;
  }(ComponentModel$1)
);
const AxisPointerModel$1 = AxisPointerModel;
var inner$a = makeInner(), each$8 = each$f;
function register(H, C, G) {
  if (!env$1.node) {
    var U = C.getZr();
    inner$a(U).records || (inner$a(U).records = {}), initGlobalListeners(U, C);
    var K = inner$a(U).records[H] || (inner$a(U).records[H] = {});
    K.handler = G;
  }
}
function initGlobalListeners(H, C) {
  if (inner$a(H).initialized)
    return;
  inner$a(H).initialized = !0, G("click", curry$1(doEnter, "click")), G("mousemove", curry$1(doEnter, "mousemove")), G("globalout", onLeave);
  function G(U, K) {
    H.on(U, function(W) {
      var Z = makeDispatchAction$1(C);
      each$8(inner$a(H).records, function(X) {
        X && K(X, W, Z.dispatchAction);
      }), dispatchTooltipFinally(Z.pendings, C);
    });
  }
}
function dispatchTooltipFinally(H, C) {
  var G = H.showTip.length, U = H.hideTip.length, K;
  G ? K = H.showTip[G - 1] : U && (K = H.hideTip[U - 1]), K && (K.dispatchAction = null, C.dispatchAction(K));
}
function onLeave(H, C, G) {
  H.handler("leave", null, G);
}
function doEnter(H, C, G, U) {
  C.handler(H, G, U);
}
function makeDispatchAction$1(H) {
  var C = {
    showTip: [],
    hideTip: []
  }, G = function(U) {
    var K = C[U.type];
    K ? K.push(U) : (U.dispatchAction = G, H.dispatchAction(U));
  };
  return {
    dispatchAction: G,
    pendings: C
  };
}
function unregister(H, C) {
  if (!env$1.node) {
    var G = C.getZr(), U = (inner$a(G).records || {})[H];
    U && (inner$a(G).records[H] = null);
  }
}
var AxisPointerView = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G;
    }
    return C.prototype.render = function(G, U, K) {
      var W = U.getComponent("tooltip"), Z = G.get("triggerOn") || W && W.get("triggerOn") || "mousemove|click";
      register("axisPointer", K, function(X, Q, ee) {
        Z !== "none" && (X === "leave" || Z.indexOf(X) >= 0) && ee({
          type: "updateAxisPointer",
          currTrigger: X,
          x: Q && Q.offsetX,
          y: Q && Q.offsetY
        });
      });
    }, C.prototype.remove = function(G, U) {
      unregister("axisPointer", U);
    }, C.prototype.dispose = function(G, U) {
      unregister("axisPointer", U);
    }, C.type = "axisPointer", C;
  }(ComponentView$1)
);
const AxisPointerView$1 = AxisPointerView;
function findPointFromSeries(H, C) {
  var G = [], U = H.seriesIndex, K;
  if (U == null || !(K = C.getSeriesByIndex(U)))
    return {
      point: []
    };
  var W = K.getData(), Z = queryDataIndex(W, H);
  if (Z == null || Z < 0 || isArray$1(Z))
    return {
      point: []
    };
  var X = W.getItemGraphicEl(Z), Q = K.coordinateSystem;
  if (K.getTooltipPosition)
    G = K.getTooltipPosition(Z) || [];
  else if (Q && Q.dataToPoint)
    if (H.isStacked) {
      var ee = Q.getBaseAxis(), te = Q.getOtherAxis(ee), re = te.dim, ne = ee.dim, ae = re === "x" || re === "radius" ? 1 : 0, ie = W.mapDimension(ne), se = [];
      se[ae] = W.get(ie, Z), se[1 - ae] = W.get(W.getCalculationInfo("stackResultDimension"), Z), G = Q.dataToPoint(se) || [];
    } else
      G = Q.dataToPoint(W.getValues(map$1(Q.dimensions, function(le) {
        return W.mapDimension(le);
      }), Z)) || [];
  else if (X) {
    var oe = X.getBoundingRect().clone();
    oe.applyTransform(X.transform), G = [oe.x + oe.width / 2, oe.y + oe.height / 2];
  }
  return {
    point: G,
    el: X
  };
}
var inner$9 = makeInner();
function axisTrigger(H, C, G) {
  var U = H.currTrigger, K = [H.x, H.y], W = H, Z = H.dispatchAction || bind$1(G.dispatchAction, G), X = C.getComponent("axisPointer").coordSysAxesInfo;
  if (X) {
    illegalPoint(K) && (K = findPointFromSeries({
      seriesIndex: W.seriesIndex,
      // Do not use dataIndexInside from other ec instance.
      // FIXME: auto detect it?
      dataIndex: W.dataIndex
    }, C).point);
    var Q = illegalPoint(K), ee = W.axesInfo, te = X.axesInfo, re = U === "leave" || illegalPoint(K), ne = {}, ae = {}, ie = {
      list: [],
      map: {}
    }, se = {
      showPointer: curry$1(showPointer, ae),
      showTooltip: curry$1(showTooltip, ie)
    };
    each$f(X.coordSysMap, function(le, ue) {
      var ce = Q || le.containPoint(K);
      each$f(X.coordSysAxesInfo[ue], function(de, ge) {
        var fe = de.axis, ve = findInputAxisInfo(ee, de);
        if (!re && ce && (!ee || ve)) {
          var pe = ve && ve.value;
          pe == null && !Q && (pe = fe.pointToData(K)), pe != null && processOnAxis(de, pe, se, !1, ne);
        }
      });
    });
    var oe = {};
    return each$f(te, function(le, ue) {
      var ce = le.linkGroup;
      ce && !ae[ue] && each$f(ce.axesInfo, function(de, ge) {
        var fe = ae[ge];
        if (de !== le && fe) {
          var ve = fe.value;
          ce.mapper && (ve = le.axis.scale.parse(ce.mapper(ve, makeMapperParam(de), makeMapperParam(le)))), oe[le.key] = ve;
        }
      });
    }), each$f(oe, function(le, ue) {
      processOnAxis(te[ue], le, se, !0, ne);
    }), updateModelActually(ae, te, ne), dispatchTooltipActually(ie, K, H, Z), dispatchHighDownActually(te, Z, G), ne;
  }
}
function processOnAxis(H, C, G, U, K) {
  var W = H.axis;
  if (!(W.scale.isBlank() || !W.containData(C))) {
    if (!H.involveSeries) {
      G.showPointer(H, C);
      return;
    }
    var Z = buildPayloadsBySeries(C, H), X = Z.payloadBatch, Q = Z.snapToValue;
    X[0] && K.seriesIndex == null && extend(K, X[0]), !U && H.snap && W.containData(Q) && Q != null && (C = Q), G.showPointer(H, C, X), G.showTooltip(H, Z, Q);
  }
}
function buildPayloadsBySeries(H, C) {
  var G = C.axis, U = G.dim, K = H, W = [], Z = Number.MAX_VALUE, X = -1;
  return each$f(C.seriesModels, function(Q, ee) {
    var te = Q.getData().mapDimensionsAll(U), re, ne;
    if (Q.getAxisTooltipData) {
      var ae = Q.getAxisTooltipData(te, H, G);
      ne = ae.dataIndices, re = ae.nestestValue;
    } else {
      if (ne = Q.getData().indicesOfNearest(
        te[0],
        H,
        // Add a threshold to avoid find the wrong dataIndex
        // when data length is not same.
        // false,
        G.type === "category" ? 0.5 : null
      ), !ne.length)
        return;
      re = Q.getData().get(te[0], ne[0]);
    }
    if (!(re == null || !isFinite(re))) {
      var ie = H - re, se = Math.abs(ie);
      se <= Z && ((se < Z || ie >= 0 && X < 0) && (Z = se, X = ie, K = re, W.length = 0), each$f(ne, function(oe) {
        W.push({
          seriesIndex: Q.seriesIndex,
          dataIndexInside: oe,
          dataIndex: Q.getData().getRawIndex(oe)
        });
      }));
    }
  }), {
    payloadBatch: W,
    snapToValue: K
  };
}
function showPointer(H, C, G, U) {
  H[C.key] = {
    value: G,
    payloadBatch: U
  };
}
function showTooltip(H, C, G, U) {
  var K = G.payloadBatch, W = C.axis, Z = W.model, X = C.axisPointerModel;
  if (!(!C.triggerTooltip || !K.length)) {
    var Q = C.coordSys.model, ee = makeKey(Q), te = H.map[ee];
    te || (te = H.map[ee] = {
      coordSysId: Q.id,
      coordSysIndex: Q.componentIndex,
      coordSysType: Q.type,
      coordSysMainType: Q.mainType,
      dataByAxis: []
    }, H.list.push(te)), te.dataByAxis.push({
      axisDim: W.dim,
      axisIndex: Z.componentIndex,
      axisType: Z.type,
      axisId: Z.id,
      value: U,
      // Caustion: viewHelper.getValueLabel is actually on "view stage", which
      // depends that all models have been updated. So it should not be performed
      // here. Considering axisPointerModel used here is volatile, which is hard
      // to be retrieve in TooltipView, we prepare parameters here.
      valueLabelOpt: {
        precision: X.get(["label", "precision"]),
        formatter: X.get(["label", "formatter"])
      },
      seriesDataIndices: K.slice()
    });
  }
}
function updateModelActually(H, C, G) {
  var U = G.axesInfo = [];
  each$f(C, function(K, W) {
    var Z = K.axisPointerModel.option, X = H[W];
    X ? (!K.useHandle && (Z.status = "show"), Z.value = X.value, Z.seriesDataIndices = (X.payloadBatch || []).slice()) : !K.useHandle && (Z.status = "hide"), Z.status === "show" && U.push({
      axisDim: K.axis.dim,
      axisIndex: K.axis.model.componentIndex,
      value: Z.value
    });
  });
}
function dispatchTooltipActually(H, C, G, U) {
  if (illegalPoint(C) || !H.list.length) {
    U({
      type: "hideTip"
    });
    return;
  }
  var K = ((H.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {};
  U({
    type: "showTip",
    escapeConnect: !0,
    x: C[0],
    y: C[1],
    tooltipOption: G.tooltipOption,
    position: G.position,
    dataIndexInside: K.dataIndexInside,
    dataIndex: K.dataIndex,
    seriesIndex: K.seriesIndex,
    dataByCoordSys: H.list
  });
}
function dispatchHighDownActually(H, C, G) {
  var U = G.getZr(), K = "axisPointerLastHighlights", W = inner$9(U)[K] || {}, Z = inner$9(U)[K] = {};
  each$f(H, function(ee, te) {
    var re = ee.axisPointerModel.option;
    re.status === "show" && each$f(re.seriesDataIndices, function(ne) {
      var ae = ne.seriesIndex + " | " + ne.dataIndex;
      Z[ae] = ne;
    });
  });
  var X = [], Q = [];
  each$f(W, function(ee, te) {
    !Z[te] && Q.push(ee);
  }), each$f(Z, function(ee, te) {
    !W[te] && X.push(ee);
  }), Q.length && G.dispatchAction({
    type: "downplay",
    escapeConnect: !0,
    // Not blur others when highlight in axisPointer.
    notBlur: !0,
    batch: Q
  }), X.length && G.dispatchAction({
    type: "highlight",
    escapeConnect: !0,
    // Not blur others when highlight in axisPointer.
    notBlur: !0,
    batch: X
  });
}
function findInputAxisInfo(H, C) {
  for (var G = 0; G < (H || []).length; G++) {
    var U = H[G];
    if (C.axis.dim === U.axisDim && C.axis.model.componentIndex === U.axisIndex)
      return U;
  }
}
function makeMapperParam(H) {
  var C = H.axis.model, G = {}, U = G.axisDim = H.axis.dim;
  return G.axisIndex = G[U + "AxisIndex"] = C.componentIndex, G.axisName = G[U + "AxisName"] = C.name, G.axisId = G[U + "AxisId"] = C.id, G;
}
function illegalPoint(H) {
  return !H || H[0] == null || isNaN(H[0]) || H[1] == null || isNaN(H[1]);
}
function install$q(H) {
  AxisView$1.registerAxisPointerClass("CartesianAxisPointer", CartesianAxisPointer$1), H.registerComponentModel(AxisPointerModel$1), H.registerComponentView(AxisPointerView$1), H.registerPreprocessor(function(C) {
    if (C) {
      (!C.axisPointer || C.axisPointer.length === 0) && (C.axisPointer = {});
      var G = C.axisPointer.link;
      G && !isArray$1(G) && (C.axisPointer.link = [G]);
    }
  }), H.registerProcessor(H.PRIORITY.PROCESSOR.STATISTIC, function(C, G) {
    C.getComponent("axisPointer").coordSysAxesInfo = collect(C, G);
  }), H.registerAction({
    type: "updateAxisPointer",
    event: "updateAxisPointer",
    update: ":updateAxisPointer"
  }, axisTrigger);
}
function install$p(H) {
  use(install$N), use(install$q);
}
var PolarAxisPointer = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      return H !== null && H.apply(this, arguments) || this;
    }
    return C.prototype.makeElOption = function(G, U, K, W, Z) {
      var X = K.axis;
      X.dim === "angle" && (this.animationThreshold = Math.PI / 18);
      var Q = X.polar, ee = Q.getOtherAxis(X), te = ee.getExtent(), re = X.dataToCoord(U), ne = W.get("type");
      if (ne && ne !== "none") {
        var ae = buildElStyle(W), ie = pointerShapeBuilder$1[ne](X, Q, re, te);
        ie.style = ae, G.graphicKey = ie.type, G.pointer = ie;
      }
      var se = W.get(["label", "margin"]), oe = getLabelPosition(U, K, W, Q, se);
      buildLabelElOption(G, K, W, Z, oe);
    }, C;
  }(BaseAxisPointer$1)
);
function getLabelPosition(H, C, G, U, K) {
  var W = C.axis, Z = W.dataToCoord(H), X = U.getAngleAxis().getExtent()[0];
  X = X / 180 * Math.PI;
  var Q = U.getRadiusAxis().getExtent(), ee, te, re;
  if (W.dim === "radius") {
    var ne = create$1();
    rotate(ne, ne, X), translate(ne, ne, [U.cx, U.cy]), ee = applyTransform([Z, -K], ne);
    var ae = C.getModel("axisLabel").get("rotate") || 0, ie = AxisBuilder$1.innerTextLayout(X, ae * Math.PI / 180, -1);
    te = ie.textAlign, re = ie.textVerticalAlign;
  } else {
    var se = Q[1];
    ee = U.coordToPoint([se + K, Z]);
    var oe = U.cx, le = U.cy;
    te = Math.abs(ee[0] - oe) / se < 0.3 ? "center" : ee[0] > oe ? "left" : "right", re = Math.abs(ee[1] - le) / se < 0.3 ? "middle" : ee[1] > le ? "top" : "bottom";
  }
  return {
    position: ee,
    align: te,
    verticalAlign: re
  };
}
var pointerShapeBuilder$1 = {
  line: function(H, C, G, U) {
    return H.dim === "angle" ? {
      type: "Line",
      shape: makeLineShape(C.coordToPoint([U[0], G]), C.coordToPoint([U[1], G]))
    } : {
      type: "Circle",
      shape: {
        cx: C.cx,
        cy: C.cy,
        r: G
      }
    };
  },
  shadow: function(H, C, G, U) {
    var K = Math.max(1, H.getBandWidth()), W = Math.PI / 180;
    return H.dim === "angle" ? {
      type: "Sector",
      shape: makeSectorShape(
        C.cx,
        C.cy,
        U[0],
        U[1],
        (-G - K / 2) * W,
        (-G + K / 2) * W
      )
    } : {
      type: "Sector",
      shape: makeSectorShape(C.cx, C.cy, G - K / 2, G + K / 2, 0, Math.PI * 2)
    };
  }
};
const PolarAxisPointer$1 = PolarAxisPointer;
var PolarModel = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G;
    }
    return C.prototype.findAxisModel = function(G) {
      var U, K = this.ecModel;
      return K.eachComponent(G, function(W) {
        W.getCoordSysModel() === this && (U = W);
      }, this), U;
    }, C.type = "polar", C.dependencies = ["radiusAxis", "angleAxis"], C.defaultOption = {
      // zlevel: 0,
      z: 0,
      center: ["50%", "50%"],
      radius: "80%"
    }, C;
  }(ComponentModel$1)
);
const PolarModel$1 = PolarModel;
var PolarAxisModel = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      return H !== null && H.apply(this, arguments) || this;
    }
    return C.prototype.getCoordSysModel = function() {
      return this.getReferringComponents("polar", SINGLE_REFERRING).models[0];
    }, C.type = "polarAxis", C;
  }(ComponentModel$1)
);
mixin(PolarAxisModel, AxisModelCommonMixin);
var AngleAxisModel = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G;
    }
    return C.type = "angleAxis", C;
  }(PolarAxisModel)
), RadiusAxisModel = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G;
    }
    return C.type = "radiusAxis", C;
  }(PolarAxisModel)
), RadiusAxis = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C(G, U) {
      return H.call(this, "radius", G, U) || this;
    }
    return C.prototype.pointToData = function(G, U) {
      return this.polar.pointToData(G, U)[this.dim === "radius" ? 0 : 1];
    }, C;
  }(Axis$1)
);
RadiusAxis.prototype.dataToRadius = Axis$1.prototype.dataToCoord;
RadiusAxis.prototype.radiusToData = Axis$1.prototype.coordToData;
const RadiusAxis$1 = RadiusAxis;
var inner$8 = makeInner(), AngleAxis = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C(G, U) {
      return H.call(this, "angle", G, U || [0, 360]) || this;
    }
    return C.prototype.pointToData = function(G, U) {
      return this.polar.pointToData(G, U)[this.dim === "radius" ? 0 : 1];
    }, C.prototype.calculateCategoryInterval = function() {
      var G = this, U = G.getLabelModel(), K = G.scale, W = K.getExtent(), Z = K.count();
      if (W[1] - W[0] < 1)
        return 0;
      var X = W[0], Q = G.dataToCoord(X + 1) - G.dataToCoord(X), ee = Math.abs(Q), te = getBoundingRect(X == null ? "" : X + "", U.getFont(), "center", "top"), re = Math.max(te.height, 7), ne = re / ee;
      isNaN(ne) && (ne = 1 / 0);
      var ae = Math.max(0, Math.floor(ne)), ie = inner$8(G.model), se = ie.lastAutoInterval, oe = ie.lastTickCount;
      return se != null && oe != null && Math.abs(se - ae) <= 1 && Math.abs(oe - Z) <= 1 && se > ae ? ae = se : (ie.lastTickCount = Z, ie.lastAutoInterval = ae), ae;
    }, C;
  }(Axis$1)
);
AngleAxis.prototype.dataToAngle = Axis$1.prototype.dataToCoord;
AngleAxis.prototype.angleToData = Axis$1.prototype.coordToData;
const AngleAxis$1 = AngleAxis;
var polarDimensions = ["radius", "angle"], Polar = (
  /** @class */
  function() {
    function H(C) {
      this.dimensions = polarDimensions, this.type = "polar", this.cx = 0, this.cy = 0, this._radiusAxis = new RadiusAxis$1(), this._angleAxis = new AngleAxis$1(), this.axisPointerEnabled = !0, this.name = C || "", this._radiusAxis.polar = this._angleAxis.polar = this;
    }
    return H.prototype.containPoint = function(C) {
      var G = this.pointToCoord(C);
      return this._radiusAxis.contain(G[0]) && this._angleAxis.contain(G[1]);
    }, H.prototype.containData = function(C) {
      return this._radiusAxis.containData(C[0]) && this._angleAxis.containData(C[1]);
    }, H.prototype.getAxis = function(C) {
      var G = "_" + C + "Axis";
      return this[G];
    }, H.prototype.getAxes = function() {
      return [this._radiusAxis, this._angleAxis];
    }, H.prototype.getAxesByScale = function(C) {
      var G = [], U = this._angleAxis, K = this._radiusAxis;
      return U.scale.type === C && G.push(U), K.scale.type === C && G.push(K), G;
    }, H.prototype.getAngleAxis = function() {
      return this._angleAxis;
    }, H.prototype.getRadiusAxis = function() {
      return this._radiusAxis;
    }, H.prototype.getOtherAxis = function(C) {
      var G = this._angleAxis;
      return C === G ? this._radiusAxis : G;
    }, H.prototype.getBaseAxis = function() {
      return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAngleAxis();
    }, H.prototype.getTooltipAxes = function(C) {
      var G = C != null && C !== "auto" ? this.getAxis(C) : this.getBaseAxis();
      return {
        baseAxes: [G],
        otherAxes: [this.getOtherAxis(G)]
      };
    }, H.prototype.dataToPoint = function(C, G) {
      return this.coordToPoint([this._radiusAxis.dataToRadius(C[0], G), this._angleAxis.dataToAngle(C[1], G)]);
    }, H.prototype.pointToData = function(C, G) {
      var U = this.pointToCoord(C);
      return [this._radiusAxis.radiusToData(U[0], G), this._angleAxis.angleToData(U[1], G)];
    }, H.prototype.pointToCoord = function(C) {
      var G = C[0] - this.cx, U = C[1] - this.cy, K = this.getAngleAxis(), W = K.getExtent(), Z = Math.min(W[0], W[1]), X = Math.max(W[0], W[1]);
      K.inverse ? Z = X - 360 : X = Z + 360;
      var Q = Math.sqrt(G * G + U * U);
      G /= Q, U /= Q;
      for (var ee = Math.atan2(-U, G) / Math.PI * 180, te = ee < Z ? 1 : -1; ee < Z || ee > X; )
        ee += te * 360;
      return [Q, ee];
    }, H.prototype.coordToPoint = function(C) {
      var G = C[0], U = C[1] / 180 * Math.PI, K = Math.cos(U) * G + this.cx, W = -Math.sin(U) * G + this.cy;
      return [K, W];
    }, H.prototype.getArea = function() {
      var C = this.getAngleAxis(), G = this.getRadiusAxis(), U = G.getExtent().slice();
      U[0] > U[1] && U.reverse();
      var K = C.getExtent(), W = Math.PI / 180;
      return {
        cx: this.cx,
        cy: this.cy,
        r0: U[0],
        r: U[1],
        startAngle: -K[0] * W,
        endAngle: -K[1] * W,
        clockwise: C.inverse,
        contain: function(Z, X) {
          var Q = Z - this.cx, ee = X - this.cy, te = Q * Q + ee * ee - 1e-4, re = this.r, ne = this.r0;
          return te <= re * re && te >= ne * ne;
        }
      };
    }, H.prototype.convertToPixel = function(C, G, U) {
      var K = getCoordSys$2(G);
      return K === this ? this.dataToPoint(U) : null;
    }, H.prototype.convertFromPixel = function(C, G, U) {
      var K = getCoordSys$2(G);
      return K === this ? this.pointToData(U) : null;
    }, H;
  }()
);
function getCoordSys$2(H) {
  var C = H.seriesModel, G = H.polarModel;
  return G && G.coordinateSystem || C && C.coordinateSystem;
}
const Polar$1 = Polar;
function resizePolar(H, C, G) {
  var U = C.get("center"), K = G.getWidth(), W = G.getHeight();
  H.cx = parsePercent(U[0], K), H.cy = parsePercent(U[1], W);
  var Z = H.getRadiusAxis(), X = Math.min(K, W) / 2, Q = C.get("radius");
  Q == null ? Q = [0, "100%"] : isArray$1(Q) || (Q = [0, Q]);
  var ee = [parsePercent(Q[0], X), parsePercent(Q[1], X)];
  Z.inverse ? Z.setExtent(ee[1], ee[0]) : Z.setExtent(ee[0], ee[1]);
}
function updatePolarScale(H, C) {
  var G = this, U = G.getAngleAxis(), K = G.getRadiusAxis();
  if (U.scale.setExtent(1 / 0, -1 / 0), K.scale.setExtent(1 / 0, -1 / 0), H.eachSeries(function(X) {
    if (X.coordinateSystem === G) {
      var Q = X.getData();
      each$f(getDataDimensionsOnAxis(Q, "radius"), function(ee) {
        K.scale.unionExtentFromData(Q, ee);
      }), each$f(getDataDimensionsOnAxis(Q, "angle"), function(ee) {
        U.scale.unionExtentFromData(Q, ee);
      });
    }
  }), niceScaleExtent(U.scale, U.model), niceScaleExtent(K.scale, K.model), U.type === "category" && !U.onBand) {
    var W = U.getExtent(), Z = 360 / U.scale.count();
    U.inverse ? W[1] += Z : W[1] -= Z, U.setExtent(W[0], W[1]);
  }
}
function isAngleAxisModel(H) {
  return H.mainType === "angleAxis";
}
function setAxis(H, C) {
  if (H.type = C.get("type"), H.scale = createScaleByModel$1(C), H.onBand = C.get("boundaryGap") && H.type === "category", H.inverse = C.get("inverse"), isAngleAxisModel(C)) {
    H.inverse = H.inverse !== C.get("clockwise");
    var G = C.get("startAngle");
    H.setExtent(G, G + (H.inverse ? -360 : 360));
  }
  C.axis = H, H.model = C;
}
var polarCreator = {
  dimensions: polarDimensions,
  create: function(H, C) {
    var G = [];
    return H.eachComponent("polar", function(U, K) {
      var W = new Polar$1(K + "");
      W.update = updatePolarScale;
      var Z = W.getRadiusAxis(), X = W.getAngleAxis(), Q = U.findAxisModel("radiusAxis"), ee = U.findAxisModel("angleAxis");
      setAxis(Z, Q), setAxis(X, ee), resizePolar(W, U, C), G.push(W), U.coordinateSystem = W, W.model = U;
    }), H.eachSeries(function(U) {
      if (U.get("coordinateSystem") === "polar") {
        var K = U.getReferringComponents("polar", SINGLE_REFERRING).models[0];
        if (process.env.NODE_ENV !== "production" && !K)
          throw new Error('Polar "' + retrieve(U.get("polarIndex"), U.get("polarId"), 0) + '" not found');
        U.coordinateSystem = K.coordinateSystem;
      }
    }), G;
  }
};
const polarCreator$1 = polarCreator;
var elementList = ["axisLine", "axisLabel", "axisTick", "minorTick", "splitLine", "minorSplitLine", "splitArea"];
function getAxisLineShape(H, C, G) {
  C[1] > C[0] && (C = C.slice().reverse());
  var U = H.coordToPoint([C[0], G]), K = H.coordToPoint([C[1], G]);
  return {
    x1: U[0],
    y1: U[1],
    x2: K[0],
    y2: K[1]
  };
}
function getRadiusIdx(H) {
  var C = H.getRadiusAxis();
  return C.inverse ? 0 : 1;
}
function fixAngleOverlap(H) {
  var C = H[0], G = H[H.length - 1];
  C && G && Math.abs(Math.abs(C.coord - G.coord) - 360) < 1e-4 && H.pop();
}
var AngleAxisView = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G.axisPointerClass = "PolarAxisPointer", G;
    }
    return C.prototype.render = function(G, U) {
      if (this.group.removeAll(), !!G.get("show")) {
        var K = G.axis, W = K.polar, Z = W.getRadiusAxis().getExtent(), X = K.getTicksCoords(), Q = K.getMinorTicksCoords(), ee = map$1(K.getViewLabels(), function(te) {
          te = clone$4(te);
          var re = K.scale, ne = re.type === "ordinal" ? re.getRawOrdinalNumber(te.tickValue) : te.tickValue;
          return te.coord = K.dataToCoord(ne), te;
        });
        fixAngleOverlap(ee), fixAngleOverlap(X), each$f(elementList, function(te) {
          G.get([te, "show"]) && (!K.scale.isBlank() || te === "axisLine") && angelAxisElementsBuilders[te](this.group, G, W, X, Q, Z, ee);
        }, this);
      }
    }, C.type = "angleAxis", C;
  }(AxisView$1)
), angelAxisElementsBuilders = {
  axisLine: function(H, C, G, U, K, W) {
    var Z = C.getModel(["axisLine", "lineStyle"]), X = getRadiusIdx(G), Q = X ? 0 : 1, ee;
    W[Q] === 0 ? ee = new Circle$1({
      shape: {
        cx: G.cx,
        cy: G.cy,
        r: W[X]
      },
      style: Z.getLineStyle(),
      z2: 1,
      silent: !0
    }) : ee = new Ring$1({
      shape: {
        cx: G.cx,
        cy: G.cy,
        r: W[X],
        r0: W[Q]
      },
      style: Z.getLineStyle(),
      z2: 1,
      silent: !0
    }), ee.style.fill = null, H.add(ee);
  },
  axisTick: function(H, C, G, U, K, W) {
    var Z = C.getModel("axisTick"), X = (Z.get("inside") ? -1 : 1) * Z.get("length"), Q = W[getRadiusIdx(G)], ee = map$1(U, function(te) {
      return new Line$3({
        shape: getAxisLineShape(G, [Q, Q + X], te.coord)
      });
    });
    H.add(mergePath(ee, {
      style: defaults(Z.getModel("lineStyle").getLineStyle(), {
        stroke: C.get(["axisLine", "lineStyle", "color"])
      })
    }));
  },
  minorTick: function(H, C, G, U, K, W) {
    if (K.length) {
      for (var Z = C.getModel("axisTick"), X = C.getModel("minorTick"), Q = (Z.get("inside") ? -1 : 1) * X.get("length"), ee = W[getRadiusIdx(G)], te = [], re = 0; re < K.length; re++)
        for (var ne = 0; ne < K[re].length; ne++)
          te.push(new Line$3({
            shape: getAxisLineShape(G, [ee, ee + Q], K[re][ne].coord)
          }));
      H.add(mergePath(te, {
        style: defaults(X.getModel("lineStyle").getLineStyle(), defaults(Z.getLineStyle(), {
          stroke: C.get(["axisLine", "lineStyle", "color"])
        }))
      }));
    }
  },
  axisLabel: function(H, C, G, U, K, W, Z) {
    var X = C.getCategories(!0), Q = C.getModel("axisLabel"), ee = Q.get("margin"), te = C.get("triggerEvent");
    each$f(Z, function(re, ne) {
      var ae = Q, ie = re.tickValue, se = W[getRadiusIdx(G)], oe = G.coordToPoint([se + ee, re.coord]), le = G.cx, ue = G.cy, ce = Math.abs(oe[0] - le) / se < 0.3 ? "center" : oe[0] > le ? "left" : "right", de = Math.abs(oe[1] - ue) / se < 0.3 ? "middle" : oe[1] > ue ? "top" : "bottom";
      if (X && X[ie]) {
        var ge = X[ie];
        isObject$3(ge) && ge.textStyle && (ae = new Model$1(ge.textStyle, Q, Q.ecModel));
      }
      var fe = new ZRText$1({
        silent: AxisBuilder$1.isLabelSilent(C),
        style: createTextStyle(ae, {
          x: oe[0],
          y: oe[1],
          fill: ae.getTextColor() || C.get(["axisLine", "lineStyle", "color"]),
          text: re.formattedLabel,
          align: ce,
          verticalAlign: de
        })
      });
      if (H.add(fe), te) {
        var ve = AxisBuilder$1.makeAxisEventDataBase(C);
        ve.targetType = "axisLabel", ve.value = re.rawLabel, getECData(fe).eventData = ve;
      }
    }, this);
  },
  splitLine: function(H, C, G, U, K, W) {
    var Z = C.getModel("splitLine"), X = Z.getModel("lineStyle"), Q = X.get("color"), ee = 0;
    Q = Q instanceof Array ? Q : [Q];
    for (var te = [], re = 0; re < U.length; re++) {
      var ne = ee++ % Q.length;
      te[ne] = te[ne] || [], te[ne].push(new Line$3({
        shape: getAxisLineShape(G, W, U[re].coord)
      }));
    }
    for (var re = 0; re < te.length; re++)
      H.add(mergePath(te[re], {
        style: defaults({
          stroke: Q[re % Q.length]
        }, X.getLineStyle()),
        silent: !0,
        z: C.get("z")
      }));
  },
  minorSplitLine: function(H, C, G, U, K, W) {
    if (K.length) {
      for (var Z = C.getModel("minorSplitLine"), X = Z.getModel("lineStyle"), Q = [], ee = 0; ee < K.length; ee++)
        for (var te = 0; te < K[ee].length; te++)
          Q.push(new Line$3({
            shape: getAxisLineShape(G, W, K[ee][te].coord)
          }));
      H.add(mergePath(Q, {
        style: X.getLineStyle(),
        silent: !0,
        z: C.get("z")
      }));
    }
  },
  splitArea: function(H, C, G, U, K, W) {
    if (U.length) {
      var Z = C.getModel("splitArea"), X = Z.getModel("areaStyle"), Q = X.get("color"), ee = 0;
      Q = Q instanceof Array ? Q : [Q];
      for (var te = [], re = Math.PI / 180, ne = -U[0].coord * re, ae = Math.min(W[0], W[1]), ie = Math.max(W[0], W[1]), se = C.get("clockwise"), oe = 1, le = U.length; oe <= le; oe++) {
        var ue = oe === le ? U[0].coord : U[oe].coord, ce = ee++ % Q.length;
        te[ce] = te[ce] || [], te[ce].push(new Sector$1({
          shape: {
            cx: G.cx,
            cy: G.cy,
            r0: ae,
            r: ie,
            startAngle: ne,
            endAngle: -ue * re,
            clockwise: se
          },
          silent: !0
        })), ne = -ue * re;
      }
      for (var oe = 0; oe < te.length; oe++)
        H.add(mergePath(te[oe], {
          style: defaults({
            fill: Q[oe % Q.length]
          }, X.getAreaStyle()),
          silent: !0
        }));
    }
  }
};
const AngleAxisView$1 = AngleAxisView;
var axisBuilderAttrs$1 = ["axisLine", "axisTickLabel", "axisName"], selfBuilderAttrs$1 = ["splitLine", "splitArea", "minorSplitLine"], RadiusAxisView = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G.axisPointerClass = "PolarAxisPointer", G;
    }
    return C.prototype.render = function(G, U) {
      if (this.group.removeAll(), !!G.get("show")) {
        var K = this._axisGroup, W = this._axisGroup = new Group$4();
        this.group.add(W);
        var Z = G.axis, X = Z.polar, Q = X.getAngleAxis(), ee = Z.getTicksCoords(), te = Z.getMinorTicksCoords(), re = Q.getExtent()[0], ne = Z.getExtent(), ae = layoutAxis(X, G, re), ie = new AxisBuilder$1(G, ae);
        each$f(axisBuilderAttrs$1, ie.add, ie), W.add(ie.getGroup()), groupTransition(K, W, G), each$f(selfBuilderAttrs$1, function(se) {
          G.get([se, "show"]) && !Z.scale.isBlank() && axisElementBuilders$1[se](this.group, G, X, re, ne, ee, te);
        }, this);
      }
    }, C.type = "radiusAxis", C;
  }(AxisView$1)
), axisElementBuilders$1 = {
  splitLine: function(H, C, G, U, K, W) {
    var Z = C.getModel("splitLine"), X = Z.getModel("lineStyle"), Q = X.get("color"), ee = 0;
    Q = Q instanceof Array ? Q : [Q];
    for (var te = [], re = 0; re < W.length; re++) {
      var ne = ee++ % Q.length;
      te[ne] = te[ne] || [], te[ne].push(new Circle$1({
        shape: {
          cx: G.cx,
          cy: G.cy,
          // ensure circle radius >= 0
          r: Math.max(W[re].coord, 0)
        }
      }));
    }
    for (var re = 0; re < te.length; re++)
      H.add(mergePath(te[re], {
        style: defaults({
          stroke: Q[re % Q.length],
          fill: null
        }, X.getLineStyle()),
        silent: !0
      }));
  },
  minorSplitLine: function(H, C, G, U, K, W, Z) {
    if (Z.length) {
      for (var X = C.getModel("minorSplitLine"), Q = X.getModel("lineStyle"), ee = [], te = 0; te < Z.length; te++)
        for (var re = 0; re < Z[te].length; re++)
          ee.push(new Circle$1({
            shape: {
              cx: G.cx,
              cy: G.cy,
              r: Z[te][re].coord
            }
          }));
      H.add(mergePath(ee, {
        style: defaults({
          fill: null
        }, Q.getLineStyle()),
        silent: !0
      }));
    }
  },
  splitArea: function(H, C, G, U, K, W) {
    if (W.length) {
      var Z = C.getModel("splitArea"), X = Z.getModel("areaStyle"), Q = X.get("color"), ee = 0;
      Q = Q instanceof Array ? Q : [Q];
      for (var te = [], re = W[0].coord, ne = 1; ne < W.length; ne++) {
        var ae = ee++ % Q.length;
        te[ae] = te[ae] || [], te[ae].push(new Sector$1({
          shape: {
            cx: G.cx,
            cy: G.cy,
            r0: re,
            r: W[ne].coord,
            startAngle: 0,
            endAngle: Math.PI * 2
          },
          silent: !0
        })), re = W[ne].coord;
      }
      for (var ne = 0; ne < te.length; ne++)
        H.add(mergePath(te[ne], {
          style: defaults({
            fill: Q[ne % Q.length]
          }, X.getAreaStyle()),
          silent: !0
        }));
    }
  }
};
function layoutAxis(H, C, G) {
  return {
    position: [H.cx, H.cy],
    rotation: G / 180 * Math.PI,
    labelDirection: -1,
    tickDirection: -1,
    nameDirection: 1,
    labelRotate: C.getModel("axisLabel").get("rotate"),
    // Over splitLine and splitArea
    z2: 1
  };
}
const RadiusAxisView$1 = RadiusAxisView;
function getSeriesStackId(H) {
  return H.get("stack") || "__ec_stack_" + H.seriesIndex;
}
function getAxisKey(H, C) {
  return C.dim + H.model.componentIndex;
}
function barLayoutPolar(H, C, G) {
  var U = {}, K = calRadialBar(filter(C.getSeriesByType(H), function(W) {
    return !C.isSeriesFiltered(W) && W.coordinateSystem && W.coordinateSystem.type === "polar";
  }));
  C.eachSeriesByType(H, function(W) {
    if (W.coordinateSystem.type === "polar") {
      var Z = W.getData(), X = W.coordinateSystem, Q = X.getBaseAxis(), ee = getAxisKey(X, Q), te = getSeriesStackId(W), re = K[ee][te], ne = re.offset, ae = re.width, ie = X.getOtherAxis(Q), se = W.coordinateSystem.cx, oe = W.coordinateSystem.cy, le = W.get("barMinHeight") || 0, ue = W.get("barMinAngle") || 0;
      U[te] = U[te] || [];
      for (var ce = Z.mapDimension(ie.dim), de = Z.mapDimension(Q.dim), ge = isDimensionStacked(
        Z,
        ce
        /* , baseDim */
      ), fe = Q.dim !== "radius" || !W.get("roundCap", !0), ve = ie.dataToCoord(0), pe = 0, he = Z.count(); pe < he; pe++) {
        var me = Z.get(ce, pe), ye = Z.get(de, pe), Ce = me >= 0 ? "p" : "n", Ie = ve;
        ge && (U[te][ye] || (U[te][ye] = {
          p: ve,
          n: ve
          // Negative stack
        }), Ie = U[te][ye][Ce]);
        var be = void 0, Se = void 0, Ae = void 0, _e = void 0;
        if (ie.dim === "radius") {
          var xe = ie.dataToCoord(me) - ve, Te = Q.dataToCoord(ye);
          Math.abs(xe) < le && (xe = (xe < 0 ? -1 : 1) * le), be = Ie, Se = Ie + xe, Ae = Te - ne, _e = Ae - ae, ge && (U[te][ye][Ce] = Se);
        } else {
          var Pe = ie.dataToCoord(me, fe) - ve, $e = Q.dataToCoord(ye);
          Math.abs(Pe) < ue && (Pe = (Pe < 0 ? -1 : 1) * ue), be = $e + ne, Se = be + ae, Ae = Ie, _e = Ie + Pe, ge && (U[te][ye][Ce] = _e);
        }
        Z.setItemLayout(pe, {
          cx: se,
          cy: oe,
          r0: be,
          r: Se,
          // Consider that positive angle is anti-clockwise,
          // while positive radian of sector is clockwise
          startAngle: -Ae * Math.PI / 180,
          endAngle: -_e * Math.PI / 180,
          /**
           * Keep the same logic with bar in catesion: use end value to
           * control direction. Notice that if clockwise is true (by
           * default), the sector will always draw clockwisely, no matter
           * whether endAngle is greater or less than startAngle.
           */
          clockwise: Ae >= _e
        });
      }
    }
  });
}
function calRadialBar(H) {
  var C = {};
  each$f(H, function(U, K) {
    var W = U.getData(), Z = U.coordinateSystem, X = Z.getBaseAxis(), Q = getAxisKey(Z, X), ee = X.getExtent(), te = X.type === "category" ? X.getBandWidth() : Math.abs(ee[1] - ee[0]) / W.count(), re = C[Q] || {
      bandWidth: te,
      remainedWidth: te,
      autoWidthCount: 0,
      categoryGap: "20%",
      gap: "30%",
      stacks: {}
    }, ne = re.stacks;
    C[Q] = re;
    var ae = getSeriesStackId(U);
    ne[ae] || re.autoWidthCount++, ne[ae] = ne[ae] || {
      width: 0,
      maxWidth: 0
    };
    var ie = parsePercent(U.get("barWidth"), te), se = parsePercent(U.get("barMaxWidth"), te), oe = U.get("barGap"), le = U.get("barCategoryGap");
    ie && !ne[ae].width && (ie = Math.min(re.remainedWidth, ie), ne[ae].width = ie, re.remainedWidth -= ie), se && (ne[ae].maxWidth = se), oe != null && (re.gap = oe), le != null && (re.categoryGap = le);
  });
  var G = {};
  return each$f(C, function(U, K) {
    G[K] = {};
    var W = U.stacks, Z = U.bandWidth, X = parsePercent(U.categoryGap, Z), Q = parsePercent(U.gap, 1), ee = U.remainedWidth, te = U.autoWidthCount, re = (ee - X) / (te + (te - 1) * Q);
    re = Math.max(re, 0), each$f(W, function(se, oe) {
      var le = se.maxWidth;
      le && le < re && (le = Math.min(le, ee), se.width && (le = Math.min(le, se.width)), ee -= le, se.width = le, te--);
    }), re = (ee - X) / (te + (te - 1) * Q), re = Math.max(re, 0);
    var ne = 0, ae;
    each$f(W, function(se, oe) {
      se.width || (se.width = re), ae = se, ne += se.width * (1 + Q);
    }), ae && (ne -= ae.width * Q);
    var ie = -ne / 2;
    each$f(W, function(se, oe) {
      G[K][oe] = G[K][oe] || {
        offset: ie,
        width: se.width
      }, ie += se.width * (1 + Q);
    });
  }), G;
}
var angleAxisExtraOption = {
  startAngle: 90,
  clockwise: !0,
  splitNumber: 12,
  axisLabel: {
    rotate: 0
  }
}, radiusAxisExtraOption = {
  splitNumber: 5
}, PolarView = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G;
    }
    return C.type = "polar", C;
  }(ComponentView$1)
);
function install$o(H) {
  use(install$q), AxisView$1.registerAxisPointerClass("PolarAxisPointer", PolarAxisPointer$1), H.registerCoordinateSystem("polar", polarCreator$1), H.registerComponentModel(PolarModel$1), H.registerComponentView(PolarView), axisModelCreator(H, "angle", AngleAxisModel, angleAxisExtraOption), axisModelCreator(H, "radius", RadiusAxisModel, radiusAxisExtraOption), H.registerComponentView(AngleAxisView$1), H.registerComponentView(RadiusAxisView$1), H.registerLayout(curry$1(barLayoutPolar, "bar"));
}
function layout$1(H, C) {
  C = C || {};
  var G = H.coordinateSystem, U = H.axis, K = {}, W = U.position, Z = U.orient, X = G.getRect(), Q = [X.x, X.x + X.width, X.y, X.y + X.height], ee = {
    horizontal: {
      top: Q[2],
      bottom: Q[3]
    },
    vertical: {
      left: Q[0],
      right: Q[1]
    }
  };
  K.position = [Z === "vertical" ? ee.vertical[W] : Q[0], Z === "horizontal" ? ee.horizontal[W] : Q[3]];
  var te = {
    horizontal: 0,
    vertical: 1
  };
  K.rotation = Math.PI / 2 * te[Z];
  var re = {
    top: -1,
    bottom: 1,
    right: 1,
    left: -1
  };
  K.labelDirection = K.tickDirection = K.nameDirection = re[W], H.get(["axisTick", "inside"]) && (K.tickDirection = -K.tickDirection), retrieve(C.labelInside, H.get(["axisLabel", "inside"])) && (K.labelDirection = -K.labelDirection);
  var ne = C.rotate;
  return ne == null && (ne = H.get(["axisLabel", "rotate"])), K.labelRotation = W === "top" ? -ne : ne, K.z2 = 1, K;
}
var axisBuilderAttrs = ["axisLine", "axisTickLabel", "axisName"], selfBuilderAttrs = ["splitArea", "splitLine"], SingleAxisView = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G.axisPointerClass = "SingleAxisPointer", G;
    }
    return C.prototype.render = function(G, U, K, W) {
      var Z = this.group;
      Z.removeAll();
      var X = this._axisGroup;
      this._axisGroup = new Group$4();
      var Q = layout$1(G), ee = new AxisBuilder$1(G, Q);
      each$f(axisBuilderAttrs, ee.add, ee), Z.add(this._axisGroup), Z.add(ee.getGroup()), each$f(selfBuilderAttrs, function(te) {
        G.get([te, "show"]) && axisElementBuilders[te](this, this.group, this._axisGroup, G);
      }, this), groupTransition(X, this._axisGroup, G), H.prototype.render.call(this, G, U, K, W);
    }, C.prototype.remove = function() {
      rectCoordAxisHandleRemove(this);
    }, C.type = "singleAxis", C;
  }(AxisView$1)
), axisElementBuilders = {
  splitLine: function(H, C, G, U) {
    var K = U.axis;
    if (!K.scale.isBlank()) {
      var W = U.getModel("splitLine"), Z = W.getModel("lineStyle"), X = Z.get("color");
      X = X instanceof Array ? X : [X];
      for (var Q = Z.get("width"), ee = U.coordinateSystem.getRect(), te = K.isHorizontal(), re = [], ne = 0, ae = K.getTicksCoords({
        tickModel: W
      }), ie = [], se = [], oe = 0; oe < ae.length; ++oe) {
        var le = K.toGlobalCoord(ae[oe].coord);
        te ? (ie[0] = le, ie[1] = ee.y, se[0] = le, se[1] = ee.y + ee.height) : (ie[0] = ee.x, ie[1] = le, se[0] = ee.x + ee.width, se[1] = le);
        var ue = new Line$3({
          shape: {
            x1: ie[0],
            y1: ie[1],
            x2: se[0],
            y2: se[1]
          },
          silent: !0
        });
        subPixelOptimizeLine(ue.shape, Q);
        var ce = ne++ % X.length;
        re[ce] = re[ce] || [], re[ce].push(ue);
      }
      for (var de = Z.getLineStyle(["color"]), oe = 0; oe < re.length; ++oe)
        C.add(mergePath(re[oe], {
          style: defaults({
            stroke: X[oe % X.length]
          }, de),
          silent: !0
        }));
    }
  },
  splitArea: function(H, C, G, U) {
    rectCoordAxisBuildSplitArea(H, G, U, U);
  }
};
const SingleAxisView$1 = SingleAxisView;
var SingleAxisModel = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G;
    }
    return C.prototype.getCoordSysModel = function() {
      return this;
    }, C.type = "singleAxis", C.layoutMode = "box", C.defaultOption = {
      left: "5%",
      top: "5%",
      right: "5%",
      bottom: "5%",
      type: "value",
      position: "bottom",
      orient: "horizontal",
      axisLine: {
        show: !0,
        lineStyle: {
          width: 1,
          type: "solid"
        }
      },
      // Single coordinate system and single axis is the,
      // which is used as the parent tooltip model.
      // same model, so we set default tooltip show as true.
      tooltip: {
        show: !0
      },
      axisTick: {
        show: !0,
        length: 6,
        lineStyle: {
          width: 1
        }
      },
      axisLabel: {
        show: !0,
        interval: "auto"
      },
      splitLine: {
        show: !0,
        lineStyle: {
          type: "dashed",
          opacity: 0.2
        }
      }
    }, C;
  }(ComponentModel$1)
);
mixin(SingleAxisModel, AxisModelCommonMixin.prototype);
const SingleAxisModel$1 = SingleAxisModel;
var SingleAxis = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C(G, U, K, W, Z) {
      var X = H.call(this, G, U, K) || this;
      return X.type = W || "value", X.position = Z || "bottom", X;
    }
    return C.prototype.isHorizontal = function() {
      var G = this.position;
      return G === "top" || G === "bottom";
    }, C.prototype.pointToData = function(G, U) {
      return this.coordinateSystem.pointToData(G)[0];
    }, C;
  }(Axis$1)
);
const SingleAxis$1 = SingleAxis;
var singleDimensions = ["single"], Single = (
  /** @class */
  function() {
    function H(C, G, U) {
      this.type = "single", this.dimension = "single", this.dimensions = singleDimensions, this.axisPointerEnabled = !0, this.model = C, this._init(C, G, U);
    }
    return H.prototype._init = function(C, G, U) {
      var K = this.dimension, W = new SingleAxis$1(K, createScaleByModel$1(C), [0, 0], C.get("type"), C.get("position")), Z = W.type === "category";
      W.onBand = Z && C.get("boundaryGap"), W.inverse = C.get("inverse"), W.orient = C.get("orient"), C.axis = W, W.model = C, W.coordinateSystem = this, this._axis = W;
    }, H.prototype.update = function(C, G) {
      C.eachSeries(function(U) {
        if (U.coordinateSystem === this) {
          var K = U.getData();
          each$f(K.mapDimensionsAll(this.dimension), function(W) {
            this._axis.scale.unionExtentFromData(K, W);
          }, this), niceScaleExtent(this._axis.scale, this._axis.model);
        }
      }, this);
    }, H.prototype.resize = function(C, G) {
      this._rect = getLayoutRect({
        left: C.get("left"),
        top: C.get("top"),
        right: C.get("right"),
        bottom: C.get("bottom"),
        width: C.get("width"),
        height: C.get("height")
      }, {
        width: G.getWidth(),
        height: G.getHeight()
      }), this._adjustAxis();
    }, H.prototype.getRect = function() {
      return this._rect;
    }, H.prototype._adjustAxis = function() {
      var C = this._rect, G = this._axis, U = G.isHorizontal(), K = U ? [0, C.width] : [0, C.height], W = G.inverse ? 1 : 0;
      G.setExtent(K[W], K[1 - W]), this._updateAxisTransform(G, U ? C.x : C.y);
    }, H.prototype._updateAxisTransform = function(C, G) {
      var U = C.getExtent(), K = U[0] + U[1], W = C.isHorizontal();
      C.toGlobalCoord = W ? function(Z) {
        return Z + G;
      } : function(Z) {
        return K - Z + G;
      }, C.toLocalCoord = W ? function(Z) {
        return Z - G;
      } : function(Z) {
        return K - Z + G;
      };
    }, H.prototype.getAxis = function() {
      return this._axis;
    }, H.prototype.getBaseAxis = function() {
      return this._axis;
    }, H.prototype.getAxes = function() {
      return [this._axis];
    }, H.prototype.getTooltipAxes = function() {
      return {
        baseAxes: [this.getAxis()],
        // Empty otherAxes
        otherAxes: []
      };
    }, H.prototype.containPoint = function(C) {
      var G = this.getRect(), U = this.getAxis(), K = U.orient;
      return K === "horizontal" ? U.contain(U.toLocalCoord(C[0])) && C[1] >= G.y && C[1] <= G.y + G.height : U.contain(U.toLocalCoord(C[1])) && C[0] >= G.y && C[0] <= G.y + G.height;
    }, H.prototype.pointToData = function(C) {
      var G = this.getAxis();
      return [G.coordToData(G.toLocalCoord(C[G.orient === "horizontal" ? 0 : 1]))];
    }, H.prototype.dataToPoint = function(C) {
      var G = this.getAxis(), U = this.getRect(), K = [], W = G.orient === "horizontal" ? 0 : 1;
      return C instanceof Array && (C = C[0]), K[W] = G.toGlobalCoord(G.dataToCoord(+C)), K[1 - W] = W === 0 ? U.y + U.height / 2 : U.x + U.width / 2, K;
    }, H.prototype.convertToPixel = function(C, G, U) {
      var K = getCoordSys$1(G);
      return K === this ? this.dataToPoint(U) : null;
    }, H.prototype.convertFromPixel = function(C, G, U) {
      var K = getCoordSys$1(G);
      return K === this ? this.pointToData(U) : null;
    }, H;
  }()
);
function getCoordSys$1(H) {
  var C = H.seriesModel, G = H.singleAxisModel;
  return G && G.coordinateSystem || C && C.coordinateSystem;
}
function create(H, C) {
  var G = [];
  return H.eachComponent("singleAxis", function(U, K) {
    var W = new Single(U, H, C);
    W.name = "single_" + K, W.resize(U, C), U.coordinateSystem = W, G.push(W);
  }), H.eachSeries(function(U) {
    if (U.get("coordinateSystem") === "singleAxis") {
      var K = U.getReferringComponents("singleAxis", SINGLE_REFERRING).models[0];
      U.coordinateSystem = K && K.coordinateSystem;
    }
  }), G;
}
var singleCreator = {
  create,
  dimensions: singleDimensions
};
const singleCreator$1 = singleCreator;
var XY$1 = ["x", "y"], WH$1 = ["width", "height"], SingleAxisPointer = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      return H !== null && H.apply(this, arguments) || this;
    }
    return C.prototype.makeElOption = function(G, U, K, W, Z) {
      var X = K.axis, Q = X.coordinateSystem, ee = getGlobalExtent(Q, 1 - getPointDimIndex(X)), te = Q.dataToPoint(U)[0], re = W.get("type");
      if (re && re !== "none") {
        var ne = buildElStyle(W), ae = pointerShapeBuilder[re](X, te, ee);
        ae.style = ne, G.graphicKey = ae.type, G.pointer = ae;
      }
      var ie = layout$1(K);
      buildCartesianSingleLabelElOption(
        // @ts-ignore
        U,
        G,
        ie,
        K,
        W,
        Z
      );
    }, C.prototype.getHandleTransform = function(G, U, K) {
      var W = layout$1(U, {
        labelInside: !1
      });
      W.labelMargin = K.get(["handle", "margin"]);
      var Z = getTransformedPosition(U.axis, G, W);
      return {
        x: Z[0],
        y: Z[1],
        rotation: W.rotation + (W.labelDirection < 0 ? Math.PI : 0)
      };
    }, C.prototype.updateHandleTransform = function(G, U, K, W) {
      var Z = K.axis, X = Z.coordinateSystem, Q = getPointDimIndex(Z), ee = getGlobalExtent(X, Q), te = [G.x, G.y];
      te[Q] += U[Q], te[Q] = Math.min(ee[1], te[Q]), te[Q] = Math.max(ee[0], te[Q]);
      var re = getGlobalExtent(X, 1 - Q), ne = (re[1] + re[0]) / 2, ae = [ne, ne];
      return ae[Q] = te[Q], {
        x: te[0],
        y: te[1],
        rotation: G.rotation,
        cursorPoint: ae,
        tooltipOption: {
          verticalAlign: "middle"
        }
      };
    }, C;
  }(BaseAxisPointer$1)
), pointerShapeBuilder = {
  line: function(H, C, G) {
    var U = makeLineShape([C, G[0]], [C, G[1]], getPointDimIndex(H));
    return {
      type: "Line",
      subPixelOptimize: !0,
      shape: U
    };
  },
  shadow: function(H, C, G) {
    var U = H.getBandWidth(), K = G[1] - G[0];
    return {
      type: "Rect",
      shape: makeRectShape([C - U / 2, G[0]], [U, K], getPointDimIndex(H))
    };
  }
};
function getPointDimIndex(H) {
  return H.isHorizontal() ? 0 : 1;
}
function getGlobalExtent(H, C) {
  var G = H.getRect();
  return [G[XY$1[C]], G[XY$1[C]] + G[WH$1[C]]];
}
const SingleAxisPointer$1 = SingleAxisPointer;
var SingleView = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G;
    }
    return C.type = "single", C;
  }(ComponentView$1)
);
function install$n(H) {
  use(install$q), AxisView$1.registerAxisPointerClass("SingleAxisPointer", SingleAxisPointer$1), H.registerComponentView(SingleView), H.registerComponentView(SingleAxisView$1), H.registerComponentModel(SingleAxisModel$1), axisModelCreator(H, "single", SingleAxisModel$1, SingleAxisModel$1.defaultOption), H.registerCoordinateSystem("single", singleCreator$1);
}
var CalendarModel = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G;
    }
    return C.prototype.init = function(G, U, K) {
      var W = getLayoutParams(G);
      H.prototype.init.apply(this, arguments), mergeAndNormalizeLayoutParams$1(G, W);
    }, C.prototype.mergeOption = function(G) {
      H.prototype.mergeOption.apply(this, arguments), mergeAndNormalizeLayoutParams$1(this.option, G);
    }, C.prototype.getCellSize = function() {
      return this.option.cellSize;
    }, C.type = "calendar", C.defaultOption = {
      // zlevel: 0,
      z: 2,
      left: 80,
      top: 60,
      cellSize: 20,
      // horizontal vertical
      orient: "horizontal",
      // month separate line style
      splitLine: {
        show: !0,
        lineStyle: {
          color: "#000",
          width: 1,
          type: "solid"
        }
      },
      // rect style  temporarily unused emphasis
      itemStyle: {
        color: "#fff",
        borderWidth: 1,
        borderColor: "#ccc"
      },
      // week text style
      dayLabel: {
        show: !0,
        firstDay: 0,
        // start end
        position: "start",
        margin: "50%",
        color: "#000"
      },
      // month text style
      monthLabel: {
        show: !0,
        // start end
        position: "start",
        margin: 5,
        // center or left
        align: "center",
        formatter: null,
        color: "#000"
      },
      // year text style
      yearLabel: {
        show: !0,
        // top bottom left right
        position: null,
        margin: 30,
        formatter: null,
        color: "#ccc",
        fontFamily: "sans-serif",
        fontWeight: "bolder",
        fontSize: 20
      }
    }, C;
  }(ComponentModel$1)
);
function mergeAndNormalizeLayoutParams$1(H, C) {
  var G = H.cellSize, U;
  isArray$1(G) ? U = G : U = H.cellSize = [G, G], U.length === 1 && (U[1] = U[0]);
  var K = map$1([0, 1], function(W) {
    return sizeCalculable(C, W) && (U[W] = "auto"), U[W] != null && U[W] !== "auto";
  });
  mergeLayoutParam(H, C, {
    type: "box",
    ignoreSize: K
  });
}
const CalendarModel$1 = CalendarModel;
var CalendarView = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G;
    }
    return C.prototype.render = function(G, U, K) {
      var W = this.group;
      W.removeAll();
      var Z = G.coordinateSystem, X = Z.getRangeInfo(), Q = Z.getOrient(), ee = U.getLocaleModel();
      this._renderDayRect(G, X, W), this._renderLines(G, X, Q, W), this._renderYearText(G, X, Q, W), this._renderMonthText(G, ee, Q, W), this._renderWeekText(G, ee, X, Q, W);
    }, C.prototype._renderDayRect = function(G, U, K) {
      for (var W = G.coordinateSystem, Z = G.getModel("itemStyle").getItemStyle(), X = W.getCellWidth(), Q = W.getCellHeight(), ee = U.start.time; ee <= U.end.time; ee = W.getNextNDay(ee, 1).time) {
        var te = W.dataToRect([ee], !1).tl, re = new Rect$3({
          shape: {
            x: te[0],
            y: te[1],
            width: X,
            height: Q
          },
          cursor: "default",
          style: Z
        });
        K.add(re);
      }
    }, C.prototype._renderLines = function(G, U, K, W) {
      var Z = this, X = G.coordinateSystem, Q = G.getModel(["splitLine", "lineStyle"]).getLineStyle(), ee = G.get(["splitLine", "show"]), te = Q.lineWidth;
      this._tlpoints = [], this._blpoints = [], this._firstDayOfMonth = [], this._firstDayPoints = [];
      for (var re = U.start, ne = 0; re.time <= U.end.time; ne++) {
        ie(re.formatedDate), ne === 0 && (re = X.getDateInfo(U.start.y + "-" + U.start.m));
        var ae = re.date;
        ae.setMonth(ae.getMonth() + 1), re = X.getDateInfo(ae);
      }
      ie(X.getNextNDay(U.end.time, 1).formatedDate);
      function ie(se) {
        Z._firstDayOfMonth.push(X.getDateInfo(se)), Z._firstDayPoints.push(X.dataToRect([se], !1).tl);
        var oe = Z._getLinePointsOfOneWeek(G, se, K);
        Z._tlpoints.push(oe[0]), Z._blpoints.push(oe[oe.length - 1]), ee && Z._drawSplitline(oe, Q, W);
      }
      ee && this._drawSplitline(Z._getEdgesPoints(Z._tlpoints, te, K), Q, W), ee && this._drawSplitline(Z._getEdgesPoints(Z._blpoints, te, K), Q, W);
    }, C.prototype._getEdgesPoints = function(G, U, K) {
      var W = [G[0].slice(), G[G.length - 1].slice()], Z = K === "horizontal" ? 0 : 1;
      return W[0][Z] = W[0][Z] - U / 2, W[1][Z] = W[1][Z] + U / 2, W;
    }, C.prototype._drawSplitline = function(G, U, K) {
      var W = new Polyline$3({
        z2: 20,
        shape: {
          points: G
        },
        style: U
      });
      K.add(W);
    }, C.prototype._getLinePointsOfOneWeek = function(G, U, K) {
      for (var W = G.coordinateSystem, Z = W.getDateInfo(U), X = [], Q = 0; Q < 7; Q++) {
        var ee = W.getNextNDay(Z.time, Q), te = W.dataToRect([ee.time], !1);
        X[2 * ee.day] = te.tl, X[2 * ee.day + 1] = te[K === "horizontal" ? "bl" : "tr"];
      }
      return X;
    }, C.prototype._formatterLabel = function(G, U) {
      return isString(G) && G ? formatTplSimple(G, U) : isFunction(G) ? G(U) : U.nameMap;
    }, C.prototype._yearTextPositionControl = function(G, U, K, W, Z) {
      var X = U[0], Q = U[1], ee = ["center", "bottom"];
      W === "bottom" ? (Q += Z, ee = ["center", "top"]) : W === "left" ? X -= Z : W === "right" ? (X += Z, ee = ["center", "top"]) : Q -= Z;
      var te = 0;
      return (W === "left" || W === "right") && (te = Math.PI / 2), {
        rotation: te,
        x: X,
        y: Q,
        style: {
          align: ee[0],
          verticalAlign: ee[1]
        }
      };
    }, C.prototype._renderYearText = function(G, U, K, W) {
      var Z = G.getModel("yearLabel");
      if (Z.get("show")) {
        var X = Z.get("margin"), Q = Z.get("position");
        Q || (Q = K !== "horizontal" ? "top" : "left");
        var ee = [this._tlpoints[this._tlpoints.length - 1], this._blpoints[0]], te = (ee[0][0] + ee[1][0]) / 2, re = (ee[0][1] + ee[1][1]) / 2, ne = K === "horizontal" ? 0 : 1, ae = {
          top: [te, ee[ne][1]],
          bottom: [te, ee[1 - ne][1]],
          left: [ee[1 - ne][0], re],
          right: [ee[ne][0], re]
        }, ie = U.start.y;
        +U.end.y > +U.start.y && (ie = ie + "-" + U.end.y);
        var se = Z.get("formatter"), oe = {
          start: U.start.y,
          end: U.end.y,
          nameMap: ie
        }, le = this._formatterLabel(se, oe), ue = new ZRText$1({
          z2: 30,
          style: createTextStyle(Z, {
            text: le
          })
        });
        ue.attr(this._yearTextPositionControl(ue, ae[Q], K, Q, X)), W.add(ue);
      }
    }, C.prototype._monthTextPositionControl = function(G, U, K, W, Z) {
      var X = "left", Q = "top", ee = G[0], te = G[1];
      return K === "horizontal" ? (te = te + Z, U && (X = "center"), W === "start" && (Q = "bottom")) : (ee = ee + Z, U && (Q = "middle"), W === "start" && (X = "right")), {
        x: ee,
        y: te,
        align: X,
        verticalAlign: Q
      };
    }, C.prototype._renderMonthText = function(G, U, K, W) {
      var Z = G.getModel("monthLabel");
      if (Z.get("show")) {
        var X = Z.get("nameMap"), Q = Z.get("margin"), ee = Z.get("position"), te = Z.get("align"), re = [this._tlpoints, this._blpoints];
        (!X || isString(X)) && (X && (U = getLocaleModel(X) || U), X = U.get(["time", "monthAbbr"]) || []);
        var ne = ee === "start" ? 0 : 1, ae = K === "horizontal" ? 0 : 1;
        Q = ee === "start" ? -Q : Q;
        for (var ie = te === "center", se = 0; se < re[ne].length - 1; se++) {
          var oe = re[ne][se].slice(), le = this._firstDayOfMonth[se];
          if (ie) {
            var ue = this._firstDayPoints[se];
            oe[ae] = (ue[ae] + re[0][se + 1][ae]) / 2;
          }
          var ce = Z.get("formatter"), de = X[+le.m - 1], ge = {
            yyyy: le.y,
            yy: (le.y + "").slice(2),
            MM: le.m,
            M: +le.m,
            nameMap: de
          }, fe = this._formatterLabel(ce, ge), ve = new ZRText$1({
            z2: 30,
            style: extend(createTextStyle(Z, {
              text: fe
            }), this._monthTextPositionControl(oe, ie, K, ee, Q))
          });
          W.add(ve);
        }
      }
    }, C.prototype._weekTextPositionControl = function(G, U, K, W, Z) {
      var X = "center", Q = "middle", ee = G[0], te = G[1], re = K === "start";
      return U === "horizontal" ? (ee = ee + W + (re ? 1 : -1) * Z[0] / 2, X = re ? "right" : "left") : (te = te + W + (re ? 1 : -1) * Z[1] / 2, Q = re ? "bottom" : "top"), {
        x: ee,
        y: te,
        align: X,
        verticalAlign: Q
      };
    }, C.prototype._renderWeekText = function(G, U, K, W, Z) {
      var X = G.getModel("dayLabel");
      if (X.get("show")) {
        var Q = G.coordinateSystem, ee = X.get("position"), te = X.get("nameMap"), re = X.get("margin"), ne = Q.getFirstDayOfWeek();
        if (!te || isString(te)) {
          te && (U = getLocaleModel(te) || U);
          var ae = U.get(["time", "dayOfWeekShort"]);
          te = ae || map$1(U.get(["time", "dayOfWeekAbbr"]), function(ge) {
            return ge[0];
          });
        }
        var ie = Q.getNextNDay(K.end.time, 7 - K.lweek).time, se = [Q.getCellWidth(), Q.getCellHeight()];
        re = parsePercent(re, Math.min(se[1], se[0])), ee === "start" && (ie = Q.getNextNDay(K.start.time, -(7 + K.fweek)).time, re = -re);
        for (var oe = 0; oe < 7; oe++) {
          var le = Q.getNextNDay(ie, oe), ue = Q.dataToRect([le.time], !1).center, ce = oe;
          ce = Math.abs((oe + ne) % 7);
          var de = new ZRText$1({
            z2: 30,
            style: extend(createTextStyle(X, {
              text: te[ce]
            }), this._weekTextPositionControl(ue, W, ee, re, se))
          });
          Z.add(de);
        }
      }
    }, C.type = "calendar", C;
  }(ComponentView$1)
);
const CalendarView$1 = CalendarView;
var PROXIMATE_ONE_DAY = 864e5, Calendar = (
  /** @class */
  function() {
    function H(C, G, U) {
      this.type = "calendar", this.dimensions = H.dimensions, this.getDimensionsInfo = H.getDimensionsInfo, this._model = C;
    }
    return H.getDimensionsInfo = function() {
      return [{
        name: "time",
        type: "time"
      }, "value"];
    }, H.prototype.getRangeInfo = function() {
      return this._rangeInfo;
    }, H.prototype.getModel = function() {
      return this._model;
    }, H.prototype.getRect = function() {
      return this._rect;
    }, H.prototype.getCellWidth = function() {
      return this._sw;
    }, H.prototype.getCellHeight = function() {
      return this._sh;
    }, H.prototype.getOrient = function() {
      return this._orient;
    }, H.prototype.getFirstDayOfWeek = function() {
      return this._firstDayOfWeek;
    }, H.prototype.getDateInfo = function(C) {
      C = parseDate(C);
      var G = C.getFullYear(), U = C.getMonth() + 1, K = U < 10 ? "0" + U : "" + U, W = C.getDate(), Z = W < 10 ? "0" + W : "" + W, X = C.getDay();
      return X = Math.abs((X + 7 - this.getFirstDayOfWeek()) % 7), {
        y: G + "",
        m: K,
        d: Z,
        day: X,
        time: C.getTime(),
        formatedDate: G + "-" + K + "-" + Z,
        date: C
      };
    }, H.prototype.getNextNDay = function(C, G) {
      return G = G || 0, G === 0 ? this.getDateInfo(C) : (C = new Date(this.getDateInfo(C).time), C.setDate(C.getDate() + G), this.getDateInfo(C));
    }, H.prototype.update = function(C, G) {
      this._firstDayOfWeek = +this._model.getModel("dayLabel").get("firstDay"), this._orient = this._model.get("orient"), this._lineWidth = this._model.getModel("itemStyle").getItemStyle().lineWidth || 0, this._rangeInfo = this._getRangeInfo(this._initRangeOption());
      var U = this._rangeInfo.weeks || 1, K = ["width", "height"], W = this._model.getCellSize().slice(), Z = this._model.getBoxLayoutParams(), X = this._orient === "horizontal" ? [U, 7] : [7, U];
      each$f([0, 1], function(re) {
        te(W, re) && (Z[K[re]] = W[re] * X[re]);
      });
      var Q = {
        width: G.getWidth(),
        height: G.getHeight()
      }, ee = this._rect = getLayoutRect(Z, Q);
      each$f([0, 1], function(re) {
        te(W, re) || (W[re] = ee[K[re]] / X[re]);
      });
      function te(re, ne) {
        return re[ne] != null && re[ne] !== "auto";
      }
      this._sw = W[0], this._sh = W[1];
    }, H.prototype.dataToPoint = function(C, G) {
      isArray$1(C) && (C = C[0]), G == null && (G = !0);
      var U = this.getDateInfo(C), K = this._rangeInfo, W = U.formatedDate;
      if (G && !(U.time >= K.start.time && U.time < K.end.time + PROXIMATE_ONE_DAY))
        return [NaN, NaN];
      var Z = U.day, X = this._getRangeInfo([K.start.time, W]).nthWeek;
      return this._orient === "vertical" ? [this._rect.x + Z * this._sw + this._sw / 2, this._rect.y + X * this._sh + this._sh / 2] : [this._rect.x + X * this._sw + this._sw / 2, this._rect.y + Z * this._sh + this._sh / 2];
    }, H.prototype.pointToData = function(C) {
      var G = this.pointToDate(C);
      return G && G.time;
    }, H.prototype.dataToRect = function(C, G) {
      var U = this.dataToPoint(C, G);
      return {
        contentShape: {
          x: U[0] - (this._sw - this._lineWidth) / 2,
          y: U[1] - (this._sh - this._lineWidth) / 2,
          width: this._sw - this._lineWidth,
          height: this._sh - this._lineWidth
        },
        center: U,
        tl: [U[0] - this._sw / 2, U[1] - this._sh / 2],
        tr: [U[0] + this._sw / 2, U[1] - this._sh / 2],
        br: [U[0] + this._sw / 2, U[1] + this._sh / 2],
        bl: [U[0] - this._sw / 2, U[1] + this._sh / 2]
      };
    }, H.prototype.pointToDate = function(C) {
      var G = Math.floor((C[0] - this._rect.x) / this._sw) + 1, U = Math.floor((C[1] - this._rect.y) / this._sh) + 1, K = this._rangeInfo.range;
      return this._orient === "vertical" ? this._getDateByWeeksAndDay(U, G - 1, K) : this._getDateByWeeksAndDay(G, U - 1, K);
    }, H.prototype.convertToPixel = function(C, G, U) {
      var K = getCoordSys(G);
      return K === this ? K.dataToPoint(U) : null;
    }, H.prototype.convertFromPixel = function(C, G, U) {
      var K = getCoordSys(G);
      return K === this ? K.pointToData(U) : null;
    }, H.prototype.containPoint = function(C) {
      return console.warn("Not implemented."), !1;
    }, H.prototype._initRangeOption = function() {
      var C = this._model.get("range"), G;
      if (isArray$1(C) && C.length === 1 && (C = C[0]), isArray$1(C))
        G = C;
      else {
        var U = C.toString();
        if (/^\d{4}$/.test(U) && (G = [U + "-01-01", U + "-12-31"]), /^\d{4}[\/|-]\d{1,2}$/.test(U)) {
          var K = this.getDateInfo(U), W = K.date;
          W.setMonth(W.getMonth() + 1);
          var Z = this.getNextNDay(W, -1);
          G = [K.formatedDate, Z.formatedDate];
        }
        /^\d{4}[\/|-]\d{1,2}[\/|-]\d{1,2}$/.test(U) && (G = [U, U]);
      }
      if (!G)
        return process.env.NODE_ENV !== "production" && logError("Invalid date range."), C;
      var X = this._getRangeInfo(G);
      return X.start.time > X.end.time && G.reverse(), G;
    }, H.prototype._getRangeInfo = function(C) {
      var G = [this.getDateInfo(C[0]), this.getDateInfo(C[1])], U;
      G[0].time > G[1].time && (U = !0, G.reverse());
      var K = Math.floor(G[1].time / PROXIMATE_ONE_DAY) - Math.floor(G[0].time / PROXIMATE_ONE_DAY) + 1, W = new Date(G[0].time), Z = W.getDate(), X = G[1].date.getDate();
      W.setDate(Z + K - 1);
      var Q = W.getDate();
      if (Q !== X)
        for (var ee = W.getTime() - G[1].time > 0 ? 1 : -1; (Q = W.getDate()) !== X && (W.getTime() - G[1].time) * ee > 0; )
          K -= ee, W.setDate(Q - ee);
      var te = Math.floor((K + G[0].day + 6) / 7), re = U ? -te + 1 : te - 1;
      return U && G.reverse(), {
        range: [G[0].formatedDate, G[1].formatedDate],
        start: G[0],
        end: G[1],
        allDay: K,
        weeks: te,
        // From 0.
        nthWeek: re,
        fweek: G[0].day,
        lweek: G[1].day
      };
    }, H.prototype._getDateByWeeksAndDay = function(C, G, U) {
      var K = this._getRangeInfo(U);
      if (C > K.weeks || C === 0 && G < K.fweek || C === K.weeks && G > K.lweek)
        return null;
      var W = (C - 1) * 7 - K.fweek + G, Z = new Date(K.start.time);
      return Z.setDate(+K.start.d + W), this.getDateInfo(Z);
    }, H.create = function(C, G) {
      var U = [];
      return C.eachComponent("calendar", function(K) {
        var W = new H(K);
        U.push(W), K.coordinateSystem = W;
      }), C.eachSeries(function(K) {
        K.get("coordinateSystem") === "calendar" && (K.coordinateSystem = U[K.get("calendarIndex") || 0]);
      }), U;
    }, H.dimensions = ["time", "value"], H;
  }()
);
function getCoordSys(H) {
  var C = H.calendarModel, G = H.seriesModel, U = C ? C.coordinateSystem : G ? G.coordinateSystem : null;
  return U;
}
const Calendar$1 = Calendar;
function install$m(H) {
  H.registerComponentModel(CalendarModel$1), H.registerComponentView(CalendarView$1), H.registerCoordinateSystem("calendar", Calendar$1);
}
function setKeyInfoToNewElOption(H, C) {
  var G = H.existing;
  if (C.id = H.keyInfo.id, !C.type && G && (C.type = G.type), C.parentId == null) {
    var U = C.parentOption;
    U ? C.parentId = U.id : G && (C.parentId = G.parentId);
  }
  C.parentOption = null;
}
function isSetLoc(H, C) {
  var G;
  return each$f(C, function(U) {
    H[U] != null && H[U] !== "auto" && (G = !0);
  }), G;
}
function mergeNewElOptionToExist(H, C, G) {
  var U = extend({}, G), K = H[C], W = G.$action || "merge";
  if (W === "merge")
    if (K) {
      if (process.env.NODE_ENV !== "production") {
        var Z = G.type;
        assert(!Z || K.type === Z, 'Please set $action: "replace" to change `type`');
      }
      merge(K, U, !0), mergeLayoutParam(K, U, {
        ignoreSize: !0
      }), copyLayoutParams(G, K), copyTransitionInfo(G, K), copyTransitionInfo(G, K, "shape"), copyTransitionInfo(G, K, "style"), copyTransitionInfo(G, K, "extra"), G.clipPath = K.clipPath;
    } else
      H[C] = U;
  else
    W === "replace" ? H[C] = U : W === "remove" && K && (H[C] = null);
}
var TRANSITION_PROPS_TO_COPY = ["transition", "enterFrom", "leaveTo"], ROOT_TRANSITION_PROPS_TO_COPY = TRANSITION_PROPS_TO_COPY.concat(["enterAnimation", "updateAnimation", "leaveAnimation"]);
function copyTransitionInfo(H, C, G) {
  if (G && (!H[G] && C[G] && (H[G] = {}), H = H[G], C = C[G]), !(!H || !C))
    for (var U = G ? TRANSITION_PROPS_TO_COPY : ROOT_TRANSITION_PROPS_TO_COPY, K = 0; K < U.length; K++) {
      var W = U[K];
      H[W] == null && C[W] != null && (H[W] = C[W]);
    }
}
function setLayoutInfoToExist(H, C) {
  if (H && (H.hv = C.hv = [
    // Rigid body, don't care about `width`.
    isSetLoc(C, ["left", "right"]),
    // Rigid body, don't care about `height`.
    isSetLoc(C, ["top", "bottom"])
  ], H.type === "group")) {
    var G = H, U = C;
    G.width == null && (G.width = U.width = 0), G.height == null && (G.height = U.height = 0);
  }
}
var GraphicComponentModel = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G.preventAutoZ = !0, G;
    }
    return C.prototype.mergeOption = function(G, U) {
      var K = this.option.elements;
      this.option.elements = null, H.prototype.mergeOption.call(this, G, U), this.option.elements = K;
    }, C.prototype.optionUpdated = function(G, U) {
      var K = this.option, W = (U ? K : G).elements, Z = K.elements = U ? [] : K.elements, X = [];
      this._flatten(W, X, null);
      var Q = mappingToExists(Z, X, "normalMerge"), ee = this._elOptionsToUpdate = [];
      each$f(Q, function(te, re) {
        var ne = te.newOption;
        process.env.NODE_ENV !== "production" && assert(isObject$3(ne) || te.existing, "Empty graphic option definition"), ne && (ee.push(ne), setKeyInfoToNewElOption(te, ne), mergeNewElOptionToExist(Z, re, ne), setLayoutInfoToExist(Z[re], ne));
      }, this), K.elements = filter(Z, function(te) {
        return te && delete te.$action, te != null;
      });
    }, C.prototype._flatten = function(G, U, K) {
      each$f(G, function(W) {
        if (W) {
          K && (W.parentOption = K), U.push(W);
          var Z = W.children;
          Z && Z.length && this._flatten(Z, U, W), delete W.children;
        }
      }, this);
    }, C.prototype.useElOptionsToUpdate = function() {
      var G = this._elOptionsToUpdate;
      return this._elOptionsToUpdate = null, G;
    }, C.type = "graphic", C.defaultOption = {
      elements: []
      // parentId: null
    }, C;
  }(ComponentModel$1)
), nonShapeGraphicElements = {
  // Reserved but not supported in graphic component.
  path: null,
  compoundPath: null,
  // Supported in graphic component.
  group: Group$4,
  image: ZRImage$1,
  text: ZRText$1
}, inner$7 = makeInner(), GraphicComponentView = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G;
    }
    return C.prototype.init = function() {
      this._elMap = createHashMap();
    }, C.prototype.render = function(G, U, K) {
      G !== this._lastGraphicModel && this._clear(), this._lastGraphicModel = G, this._updateElements(G), this._relocate(G, K);
    }, C.prototype._updateElements = function(G) {
      var U = G.useElOptionsToUpdate();
      if (U) {
        var K = this._elMap, W = this.group, Z = G.get("z"), X = G.get("zlevel");
        each$f(U, function(Q) {
          var ee = convertOptionIdName(Q.id, null), te = ee != null ? K.get(ee) : null, re = convertOptionIdName(Q.parentId, null), ne = re != null ? K.get(re) : W, ae = Q.type, ie = Q.style;
          ae === "text" && ie && Q.hv && Q.hv[1] && (ie.textVerticalAlign = ie.textBaseline = ie.verticalAlign = ie.align = null);
          var se = Q.textContent, oe = Q.textConfig;
          if (ie && isEC4CompatibleStyle(ie, ae, !!oe, !!se)) {
            var le = convertFromEC4CompatibleStyle(ie, ae, !0);
            !oe && le.textConfig && (oe = Q.textConfig = le.textConfig), !se && le.textContent && (se = le.textContent);
          }
          var ue = getCleanedElOption(Q);
          process.env.NODE_ENV !== "production" && te && assert(ne === te.parent, "Changing parent is not supported.");
          var ce = Q.$action || "merge", de = ce === "merge", ge = ce === "replace";
          if (de) {
            var fe = !te, ve = te;
            fe ? ve = createEl(ee, ne, Q.type, K) : (ve && (inner$7(ve).isNew = !1), stopPreviousKeyframeAnimationAndRestore(ve)), ve && (applyUpdateTransition(ve, ue, G, {
              isInit: fe
            }), updateCommonAttrs(ve, Q, Z, X));
          } else if (ge) {
            removeEl$1(te, Q, K, G);
            var pe = createEl(ee, ne, Q.type, K);
            pe && (applyUpdateTransition(pe, ue, G, {
              isInit: !0
            }), updateCommonAttrs(pe, Q, Z, X));
          } else
            ce === "remove" && (updateLeaveTo(te, Q), removeEl$1(te, Q, K, G));
          var he = K.get(ee);
          if (he && se)
            if (de) {
              var me = he.getTextContent();
              me ? me.attr(se) : he.setTextContent(new ZRText$1(se));
            } else
              ge && he.setTextContent(new ZRText$1(se));
          if (he) {
            var ye = Q.clipPath;
            if (ye) {
              var Ce = ye.type, Ie = void 0, fe = !1;
              if (de) {
                var be = he.getClipPath();
                fe = !be || inner$7(be).type !== Ce, Ie = fe ? newEl(Ce) : be;
              } else
                ge && (fe = !0, Ie = newEl(Ce));
              he.setClipPath(Ie), applyUpdateTransition(Ie, ye, G, {
                isInit: fe
              }), applyKeyframeAnimation(Ie, ye.keyframeAnimation, G);
            }
            var Se = inner$7(he);
            he.setTextConfig(oe), Se.option = Q, setEventData(he, G, Q), setTooltipConfig({
              el: he,
              componentModel: G,
              itemName: he.name,
              itemTooltipOption: Q.tooltip
            }), applyKeyframeAnimation(he, Q.keyframeAnimation, G);
          }
        });
      }
    }, C.prototype._relocate = function(G, U) {
      for (var K = G.option.elements, W = this.group, Z = this._elMap, X = U.getWidth(), Q = U.getHeight(), ee = ["x", "y"], te = 0; te < K.length; te++) {
        var re = K[te], ne = convertOptionIdName(re.id, null), ae = ne != null ? Z.get(ne) : null;
        if (!(!ae || !ae.isGroup)) {
          var ie = ae.parent, se = ie === W, oe = inner$7(ae), le = inner$7(ie);
          oe.width = parsePercent(oe.option.width, se ? X : le.width) || 0, oe.height = parsePercent(oe.option.height, se ? Q : le.height) || 0;
        }
      }
      for (var te = K.length - 1; te >= 0; te--) {
        var re = K[te], ne = convertOptionIdName(re.id, null), ae = ne != null ? Z.get(ne) : null;
        if (ae) {
          var ie = ae.parent, le = inner$7(ie), ue = ie === W ? {
            width: X,
            height: Q
          } : {
            width: le.width,
            height: le.height
          }, ce = {}, de = positionElement(ae, re, ue, null, {
            hv: re.hv,
            boundingMode: re.bounding
          }, ce);
          if (!inner$7(ae).isNew && de) {
            for (var ge = re.transition, fe = {}, ve = 0; ve < ee.length; ve++) {
              var pe = ee[ve], he = ce[pe];
              ge && (isTransitionAll(ge) || indexOf(ge, pe) >= 0) ? fe[pe] = he : ae[pe] = he;
            }
            updateProps$1(ae, fe, G, 0);
          } else
            ae.attr(ce);
        }
      }
    }, C.prototype._clear = function() {
      var G = this, U = this._elMap;
      U.each(function(K) {
        removeEl$1(K, inner$7(K).option, U, G._lastGraphicModel);
      }), this._elMap = createHashMap();
    }, C.prototype.dispose = function() {
      this._clear();
    }, C.type = "graphic", C;
  }(ComponentView$1)
);
function newEl(H) {
  process.env.NODE_ENV !== "production" && assert(H, "graphic type MUST be set");
  var C = hasOwn(nonShapeGraphicElements, H) ? nonShapeGraphicElements[H] : getShapeClass(H);
  process.env.NODE_ENV !== "production" && assert(C, "graphic type " + H + " can not be found");
  var G = new C({});
  return inner$7(G).type = H, G;
}
function createEl(H, C, G, U) {
  var K = newEl(G);
  return C.add(K), U.set(H, K), inner$7(K).id = H, inner$7(K).isNew = !0, K;
}
function removeEl$1(H, C, G, U) {
  var K = H && H.parent;
  K && (H.type === "group" && H.traverse(function(W) {
    removeEl$1(W, C, G, U);
  }), applyLeaveTransition(H, C, U), G.removeKey(inner$7(H).id));
}
function updateCommonAttrs(H, C, G, U) {
  H.isGroup || each$f([
    ["cursor", Displayable$1.prototype.cursor],
    // We should not support configure z and zlevel in the element level.
    // But seems we didn't limit it previously. So here still use it to avoid breaking.
    ["zlevel", U || 0],
    ["z", G || 0],
    // z2 must not be null/undefined, otherwise sort error may occur.
    ["z2", 0]
  ], function(K) {
    var W = K[0];
    hasOwn(C, W) ? H[W] = retrieve2(C[W], K[1]) : H[W] == null && (H[W] = K[1]);
  }), each$f(keys(C), function(K) {
    if (K.indexOf("on") === 0) {
      var W = C[K];
      H[K] = isFunction(W) ? W : null;
    }
  }), hasOwn(C, "draggable") && (H.draggable = C.draggable), C.name != null && (H.name = C.name), C.id != null && (H.id = C.id);
}
function getCleanedElOption(H) {
  return H = extend({}, H), each$f(["id", "parentId", "$action", "hv", "bounding", "textContent", "clipPath"].concat(LOCATION_PARAMS), function(C) {
    delete H[C];
  }), H;
}
function setEventData(H, C, G) {
  var U = getECData(H).eventData;
  !H.silent && !H.ignore && !U && (U = getECData(H).eventData = {
    componentType: "graphic",
    componentIndex: C.componentIndex,
    name: H.name
  }), U && (U.info = G.info);
}
function install$l(H) {
  H.registerComponentModel(GraphicComponentModel), H.registerComponentView(GraphicComponentView), H.registerPreprocessor(function(C) {
    var G = C.graphic;
    isArray$1(G) ? !G[0] || !G[0].elements ? C.graphic = [{
      elements: G
    }] : C.graphic = [C.graphic[0]] : G && !G.elements && (C.graphic = [{
      elements: [G]
    }]);
  });
}
var DATA_ZOOM_AXIS_DIMENSIONS = ["x", "y", "radius", "angle", "single"], SERIES_COORDS = ["cartesian2d", "polar", "singleAxis"];
function isCoordSupported(H) {
  var C = H.get("coordinateSystem");
  return indexOf(SERIES_COORDS, C) >= 0;
}
function getAxisMainType(H) {
  return process.env.NODE_ENV !== "production" && assert(H), H + "Axis";
}
function findEffectedDataZooms(H, C) {
  var G = createHashMap(), U = [], K = createHashMap();
  H.eachComponent({
    mainType: "dataZoom",
    query: C
  }, function(te) {
    K.get(te.uid) || X(te);
  });
  var W;
  do
    W = !1, H.eachComponent("dataZoom", Z);
  while (W);
  function Z(te) {
    !K.get(te.uid) && Q(te) && (X(te), W = !0);
  }
  function X(te) {
    K.set(te.uid, !0), U.push(te), ee(te);
  }
  function Q(te) {
    var re = !1;
    return te.eachTargetAxis(function(ne, ae) {
      var ie = G.get(ne);
      ie && ie[ae] && (re = !0);
    }), re;
  }
  function ee(te) {
    te.eachTargetAxis(function(re, ne) {
      (G.get(re) || G.set(re, []))[ne] = !0;
    });
  }
  return U;
}
function collectReferCoordSysModelInfo(H) {
  var C = H.ecModel, G = {
    infoList: [],
    infoMap: createHashMap()
  };
  return H.eachTargetAxis(function(U, K) {
    var W = C.getComponent(getAxisMainType(U), K);
    if (W) {
      var Z = W.getCoordSysModel();
      if (Z) {
        var X = Z.uid, Q = G.infoMap.get(X);
        Q || (Q = {
          model: Z,
          axisModels: []
        }, G.infoList.push(Q), G.infoMap.set(X, Q)), Q.axisModels.push(W);
      }
    }
  }), G;
}
var DataZoomAxisInfo = (
  /** @class */
  function() {
    function H() {
      this.indexList = [], this.indexMap = [];
    }
    return H.prototype.add = function(C) {
      this.indexMap[C] || (this.indexList.push(C), this.indexMap[C] = !0);
    }, H;
  }()
), DataZoomModel = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G._autoThrottle = !0, G._noTarget = !0, G._rangePropMode = ["percent", "percent"], G;
    }
    return C.prototype.init = function(G, U, K) {
      var W = retrieveRawOption(G);
      this.settledOption = W, this.mergeDefaultAndTheme(G, K), this._doInit(W);
    }, C.prototype.mergeOption = function(G) {
      var U = retrieveRawOption(G);
      merge(this.option, G, !0), merge(this.settledOption, U, !0), this._doInit(U);
    }, C.prototype._doInit = function(G) {
      var U = this.option;
      this._setDefaultThrottle(G), this._updateRangeUse(G);
      var K = this.settledOption;
      each$f([["start", "startValue"], ["end", "endValue"]], function(W, Z) {
        this._rangePropMode[Z] === "value" && (U[W[0]] = K[W[0]] = null);
      }, this), this._resetTarget();
    }, C.prototype._resetTarget = function() {
      var G = this.get("orient", !0), U = this._targetAxisInfoMap = createHashMap(), K = this._fillSpecifiedTargetAxis(U);
      K ? this._orient = G || this._makeAutoOrientByTargetAxis() : (this._orient = G || "horizontal", this._fillAutoTargetAxisByOrient(U, this._orient)), this._noTarget = !0, U.each(function(W) {
        W.indexList.length && (this._noTarget = !1);
      }, this);
    }, C.prototype._fillSpecifiedTargetAxis = function(G) {
      var U = !1;
      return each$f(DATA_ZOOM_AXIS_DIMENSIONS, function(K) {
        var W = this.getReferringComponents(getAxisMainType(K), MULTIPLE_REFERRING);
        if (W.specified) {
          U = !0;
          var Z = new DataZoomAxisInfo();
          each$f(W.models, function(X) {
            Z.add(X.componentIndex);
          }), G.set(K, Z);
        }
      }, this), U;
    }, C.prototype._fillAutoTargetAxisByOrient = function(G, U) {
      var K = this.ecModel, W = !0;
      if (W) {
        var Z = U === "vertical" ? "y" : "x", X = K.findComponents({
          mainType: Z + "Axis"
        });
        Q(X, Z);
      }
      if (W) {
        var X = K.findComponents({
          mainType: "singleAxis",
          filter: function(te) {
            return te.get("orient", !0) === U;
          }
        });
        Q(X, "single");
      }
      function Q(ee, te) {
        var re = ee[0];
        if (re) {
          var ne = new DataZoomAxisInfo();
          if (ne.add(re.componentIndex), G.set(te, ne), W = !1, te === "x" || te === "y") {
            var ae = re.getReferringComponents("grid", SINGLE_REFERRING).models[0];
            ae && each$f(ee, function(ie) {
              re.componentIndex !== ie.componentIndex && ae === ie.getReferringComponents("grid", SINGLE_REFERRING).models[0] && ne.add(ie.componentIndex);
            });
          }
        }
      }
      W && each$f(DATA_ZOOM_AXIS_DIMENSIONS, function(ee) {
        if (W) {
          var te = K.findComponents({
            mainType: getAxisMainType(ee),
            filter: function(ne) {
              return ne.get("type", !0) === "category";
            }
          });
          if (te[0]) {
            var re = new DataZoomAxisInfo();
            re.add(te[0].componentIndex), G.set(ee, re), W = !1;
          }
        }
      }, this);
    }, C.prototype._makeAutoOrientByTargetAxis = function() {
      var G;
      return this.eachTargetAxis(function(U) {
        !G && (G = U);
      }, this), G === "y" ? "vertical" : "horizontal";
    }, C.prototype._setDefaultThrottle = function(G) {
      if (G.hasOwnProperty("throttle") && (this._autoThrottle = !1), this._autoThrottle) {
        var U = this.ecModel.option;
        this.option.throttle = U.animation && U.animationDurationUpdate > 0 ? 100 : 20;
      }
    }, C.prototype._updateRangeUse = function(G) {
      var U = this._rangePropMode, K = this.get("rangeMode");
      each$f([["start", "startValue"], ["end", "endValue"]], function(W, Z) {
        var X = G[W[0]] != null, Q = G[W[1]] != null;
        X && !Q ? U[Z] = "percent" : !X && Q ? U[Z] = "value" : K ? U[Z] = K[Z] : X && (U[Z] = "percent");
      });
    }, C.prototype.noTarget = function() {
      return this._noTarget;
    }, C.prototype.getFirstTargetAxisModel = function() {
      var G;
      return this.eachTargetAxis(function(U, K) {
        G == null && (G = this.ecModel.getComponent(getAxisMainType(U), K));
      }, this), G;
    }, C.prototype.eachTargetAxis = function(G, U) {
      this._targetAxisInfoMap.each(function(K, W) {
        each$f(K.indexList, function(Z) {
          G.call(U, W, Z);
        });
      });
    }, C.prototype.getAxisProxy = function(G, U) {
      var K = this.getAxisModel(G, U);
      if (K)
        return K.__dzAxisProxy;
    }, C.prototype.getAxisModel = function(G, U) {
      process.env.NODE_ENV !== "production" && assert(G && U != null);
      var K = this._targetAxisInfoMap.get(G);
      if (K && K.indexMap[U])
        return this.ecModel.getComponent(getAxisMainType(G), U);
    }, C.prototype.setRawRange = function(G) {
      var U = this.option, K = this.settledOption;
      each$f([["start", "startValue"], ["end", "endValue"]], function(W) {
        (G[W[0]] != null || G[W[1]] != null) && (U[W[0]] = K[W[0]] = G[W[0]], U[W[1]] = K[W[1]] = G[W[1]]);
      }, this), this._updateRangeUse(G);
    }, C.prototype.setCalculatedRange = function(G) {
      var U = this.option;
      each$f(["start", "startValue", "end", "endValue"], function(K) {
        U[K] = G[K];
      });
    }, C.prototype.getPercentRange = function() {
      var G = this.findRepresentativeAxisProxy();
      if (G)
        return G.getDataPercentWindow();
    }, C.prototype.getValueRange = function(G, U) {
      if (G == null && U == null) {
        var K = this.findRepresentativeAxisProxy();
        if (K)
          return K.getDataValueWindow();
      } else
        return this.getAxisProxy(G, U).getDataValueWindow();
    }, C.prototype.findRepresentativeAxisProxy = function(G) {
      if (G)
        return G.__dzAxisProxy;
      for (var U, K = this._targetAxisInfoMap.keys(), W = 0; W < K.length; W++)
        for (var Z = K[W], X = this._targetAxisInfoMap.get(Z), Q = 0; Q < X.indexList.length; Q++) {
          var ee = this.getAxisProxy(Z, X.indexList[Q]);
          if (ee.hostedBy(this))
            return ee;
          U || (U = ee);
        }
      return U;
    }, C.prototype.getRangePropMode = function() {
      return this._rangePropMode.slice();
    }, C.prototype.getOrient = function() {
      return process.env.NODE_ENV !== "production" && assert(this._orient), this._orient;
    }, C.type = "dataZoom", C.dependencies = ["xAxis", "yAxis", "radiusAxis", "angleAxis", "singleAxis", "series", "toolbox"], C.defaultOption = {
      // zlevel: 0,
      z: 4,
      filterMode: "filter",
      start: 0,
      end: 100
    }, C;
  }(ComponentModel$1)
);
function retrieveRawOption(H) {
  var C = {};
  return each$f(["start", "end", "startValue", "endValue", "throttle"], function(G) {
    H.hasOwnProperty(G) && (C[G] = H[G]);
  }), C;
}
const DataZoomModel$1 = DataZoomModel;
var SelectDataZoomModel = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G;
    }
    return C.type = "dataZoom.select", C;
  }(DataZoomModel$1)
);
const SelectZoomModel = SelectDataZoomModel;
var DataZoomView = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G;
    }
    return C.prototype.render = function(G, U, K, W) {
      this.dataZoomModel = G, this.ecModel = U, this.api = K;
    }, C.type = "dataZoom", C;
  }(ComponentView$1)
);
const DataZoomView$1 = DataZoomView;
var SelectDataZoomView = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G;
    }
    return C.type = "dataZoom.select", C;
  }(DataZoomView$1)
);
const SelectZoomView = SelectDataZoomView;
var each$7 = each$f, asc$1 = asc$2, AxisProxy = (
  /** @class */
  function() {
    function H(C, G, U, K) {
      this._dimName = C, this._axisIndex = G, this.ecModel = K, this._dataZoomModel = U;
    }
    return H.prototype.hostedBy = function(C) {
      return this._dataZoomModel === C;
    }, H.prototype.getDataValueWindow = function() {
      return this._valueWindow.slice();
    }, H.prototype.getDataPercentWindow = function() {
      return this._percentWindow.slice();
    }, H.prototype.getTargetSeriesModels = function() {
      var C = [];
      return this.ecModel.eachSeries(function(G) {
        if (isCoordSupported(G)) {
          var U = getAxisMainType(this._dimName), K = G.getReferringComponents(U, SINGLE_REFERRING).models[0];
          K && this._axisIndex === K.componentIndex && C.push(G);
        }
      }, this), C;
    }, H.prototype.getAxisModel = function() {
      return this.ecModel.getComponent(this._dimName + "Axis", this._axisIndex);
    }, H.prototype.getMinMaxSpan = function() {
      return clone$4(this._minMaxSpan);
    }, H.prototype.calculateDataWindow = function(C) {
      var G = this._dataExtent, U = this.getAxisModel(), K = U.axis.scale, W = this._dataZoomModel.getRangePropMode(), Z = [0, 100], X = [], Q = [], ee;
      each$7(["start", "end"], function(ne, ae) {
        var ie = C[ne], se = C[ne + "Value"];
        W[ae] === "percent" ? (ie == null && (ie = Z[ae]), se = K.parse(linearMap$2(ie, Z, G))) : (ee = !0, se = se == null ? G[ae] : K.parse(se), ie = linearMap$2(se, G, Z)), Q[ae] = se == null || isNaN(se) ? G[ae] : se, X[ae] = ie == null || isNaN(ie) ? Z[ae] : ie;
      }), asc$1(Q), asc$1(X);
      var te = this._minMaxSpan;
      ee ? re(Q, X, G, Z, !1) : re(X, Q, Z, G, !0);
      function re(ne, ae, ie, se, oe) {
        var le = oe ? "Span" : "ValueSpan";
        sliderMove(0, ne, ie, "all", te["min" + le], te["max" + le]);
        for (var ue = 0; ue < 2; ue++)
          ae[ue] = linearMap$2(ne[ue], ie, se, !0), oe && (ae[ue] = K.parse(ae[ue]));
      }
      return {
        valueWindow: Q,
        percentWindow: X
      };
    }, H.prototype.reset = function(C) {
      if (C === this._dataZoomModel) {
        var G = this.getTargetSeriesModels();
        this._dataExtent = calculateDataExtent(this, this._dimName, G), this._updateMinMaxSpan();
        var U = this.calculateDataWindow(C.settledOption);
        this._valueWindow = U.valueWindow, this._percentWindow = U.percentWindow, this._setAxisModel();
      }
    }, H.prototype.filterData = function(C, G) {
      if (C !== this._dataZoomModel)
        return;
      var U = this._dimName, K = this.getTargetSeriesModels(), W = C.get("filterMode"), Z = this._valueWindow;
      if (W === "none")
        return;
      each$7(K, function(Q) {
        var ee = Q.getData(), te = ee.mapDimensionsAll(U);
        if (te.length) {
          if (W === "weakFilter") {
            var re = ee.getStore(), ne = map$1(te, function(ae) {
              return ee.getDimensionIndex(ae);
            }, ee);
            ee.filterSelf(function(ae) {
              for (var ie, se, oe, le = 0; le < te.length; le++) {
                var ue = re.get(ne[le], ae), ce = !isNaN(ue), de = ue < Z[0], ge = ue > Z[1];
                if (ce && !de && !ge)
                  return !0;
                ce && (oe = !0), de && (ie = !0), ge && (se = !0);
              }
              return oe && ie && se;
            });
          } else
            each$7(te, function(ae) {
              if (W === "empty")
                Q.setData(ee = ee.map(ae, function(se) {
                  return X(se) ? se : NaN;
                }));
              else {
                var ie = {};
                ie[ae] = Z, ee.selectRange(ie);
              }
            });
          each$7(te, function(ae) {
            ee.setApproximateExtent(Z, ae);
          });
        }
      });
      function X(Q) {
        return Q >= Z[0] && Q <= Z[1];
      }
    }, H.prototype._updateMinMaxSpan = function() {
      var C = this._minMaxSpan = {}, G = this._dataZoomModel, U = this._dataExtent;
      each$7(["min", "max"], function(K) {
        var W = G.get(K + "Span"), Z = G.get(K + "ValueSpan");
        Z != null && (Z = this.getAxisModel().axis.scale.parse(Z)), Z != null ? W = linearMap$2(U[0] + Z, U, [0, 100], !0) : W != null && (Z = linearMap$2(W, [0, 100], U, !0) - U[0]), C[K + "Span"] = W, C[K + "ValueSpan"] = Z;
      }, this);
    }, H.prototype._setAxisModel = function() {
      var C = this.getAxisModel(), G = this._percentWindow, U = this._valueWindow;
      if (G) {
        var K = getPixelPrecision(U, [0, 500]);
        K = Math.min(K, 20);
        var W = C.axis.scale.rawExtentInfo;
        G[0] !== 0 && W.setDeterminedMinMax("min", +U[0].toFixed(K)), G[1] !== 100 && W.setDeterminedMinMax("max", +U[1].toFixed(K)), W.freeze();
      }
    }, H;
  }()
);
function calculateDataExtent(H, C, G) {
  var U = [1 / 0, -1 / 0];
  each$7(G, function(Z) {
    unionAxisExtentFromData(U, Z.getData(), C);
  });
  var K = H.getAxisModel(), W = ensureScaleRawExtentInfo(K.axis.scale, K, U).calculate();
  return [W.min, W.max];
}
const AxisProxy$1 = AxisProxy;
var dataZoomProcessor = {
  // `dataZoomProcessor` will only be performed in needed series. Consider if
  // there is a line series and a pie series, it is better not to update the
  // line series if only pie series is needed to be updated.
  getTargetSeries: function(H) {
    function C(K) {
      H.eachComponent("dataZoom", function(W) {
        W.eachTargetAxis(function(Z, X) {
          var Q = H.getComponent(getAxisMainType(Z), X);
          K(Z, X, Q, W);
        });
      });
    }
    C(function(K, W, Z, X) {
      Z.__dzAxisProxy = null;
    });
    var G = [];
    C(function(K, W, Z, X) {
      Z.__dzAxisProxy || (Z.__dzAxisProxy = new AxisProxy$1(K, W, X, H), G.push(Z.__dzAxisProxy));
    });
    var U = createHashMap();
    return each$f(G, function(K) {
      each$f(K.getTargetSeriesModels(), function(W) {
        U.set(W.uid, W);
      });
    }), U;
  },
  // Consider appendData, where filter should be performed. Because data process is
  // in block mode currently, it is not need to worry about that the overallProgress
  // execute every frame.
  overallReset: function(H, C) {
    H.eachComponent("dataZoom", function(G) {
      G.eachTargetAxis(function(U, K) {
        G.getAxisProxy(U, K).reset(G);
      }), G.eachTargetAxis(function(U, K) {
        G.getAxisProxy(U, K).filterData(G, C);
      });
    }), H.eachComponent("dataZoom", function(G) {
      var U = G.findRepresentativeAxisProxy();
      if (U) {
        var K = U.getDataPercentWindow(), W = U.getDataValueWindow();
        G.setCalculatedRange({
          start: K[0],
          end: K[1],
          startValue: W[0],
          endValue: W[1]
        });
      }
    });
  }
};
const dataZoomProcessor$1 = dataZoomProcessor;
function installDataZoomAction(H) {
  H.registerAction("dataZoom", function(C, G) {
    var U = findEffectedDataZooms(G, C);
    each$f(U, function(K) {
      K.setRawRange({
        start: C.start,
        end: C.end,
        startValue: C.startValue,
        endValue: C.endValue
      });
    });
  });
}
var installed$1 = !1;
function installCommon$1(H) {
  installed$1 || (installed$1 = !0, H.registerProcessor(H.PRIORITY.PROCESSOR.FILTER, dataZoomProcessor$1), installDataZoomAction(H), H.registerSubTypeDefaulter("dataZoom", function() {
    return "slider";
  }));
}
function install$k(H) {
  H.registerComponentModel(SelectZoomModel), H.registerComponentView(SelectZoomView), installCommon$1(H);
}
var ToolboxFeature = (
  /** @class */
  function() {
    function H() {
    }
    return H;
  }()
), features = {};
function registerFeature(H, C) {
  features[H] = C;
}
function getFeature(H) {
  return features[H];
}
var ToolboxModel = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G;
    }
    return C.prototype.optionUpdated = function() {
      H.prototype.optionUpdated.apply(this, arguments);
      var G = this.ecModel;
      each$f(this.option.feature, function(U, K) {
        var W = getFeature(K);
        W && (W.getDefaultOption && (W.defaultOption = W.getDefaultOption(G)), merge(U, W.defaultOption));
      });
    }, C.type = "toolbox", C.layoutMode = {
      type: "box",
      ignoreSize: !0
    }, C.defaultOption = {
      show: !0,
      z: 6,
      // zlevel: 0,
      orient: "horizontal",
      left: "right",
      top: "top",
      // right
      // bottom
      backgroundColor: "transparent",
      borderColor: "#ccc",
      borderRadius: 0,
      borderWidth: 0,
      padding: 5,
      itemSize: 15,
      itemGap: 8,
      showTitle: !0,
      iconStyle: {
        borderColor: "#666",
        color: "none"
      },
      emphasis: {
        iconStyle: {
          borderColor: "#3E98C5"
        }
      },
      // textStyle: {},
      // feature
      tooltip: {
        show: !1,
        position: "bottom"
      }
    }, C;
  }(ComponentModel$1)
);
const ToolboxModel$1 = ToolboxModel;
function layout(H, C, G) {
  var U = C.getBoxLayoutParams(), K = C.get("padding"), W = {
    width: G.getWidth(),
    height: G.getHeight()
  }, Z = getLayoutRect(U, W, K);
  box(C.get("orient"), H, C.get("itemGap"), Z.width, Z.height), positionElement(H, U, W, K);
}
function makeBackground(H, C) {
  var G = normalizeCssArray(C.get("padding")), U = C.getItemStyle(["color", "opacity"]);
  return U.fill = C.get("backgroundColor"), H = new Rect$3({
    shape: {
      x: H.x - G[3],
      y: H.y - G[0],
      width: H.width + G[1] + G[3],
      height: H.height + G[0] + G[2],
      r: C.get("borderRadius")
    },
    style: U,
    silent: !0,
    z2: -1
  }), H;
}
var ToolboxView = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      return H !== null && H.apply(this, arguments) || this;
    }
    return C.prototype.render = function(G, U, K, W) {
      var Z = this.group;
      if (Z.removeAll(), !G.get("show"))
        return;
      var X = +G.get("itemSize"), Q = G.get("orient") === "vertical", ee = G.get("feature") || {}, te = this._features || (this._features = {}), re = [];
      each$f(ee, function(ie, se) {
        re.push(se);
      }), new DataDiffer$1(this._featureNames || [], re).add(ne).update(ne).remove(curry$1(ne, null)).execute(), this._featureNames = re;
      function ne(ie, se) {
        var oe = re[ie], le = re[se], ue = ee[oe], ce = new Model$1(ue, G, G.ecModel), de;
        if (W && W.newTitle != null && W.featureName === oe && (ue.title = W.newTitle), oe && !le) {
          if (isUserFeatureName(oe))
            de = {
              onclick: ce.option.onclick,
              featureName: oe
            };
          else {
            var ge = getFeature(oe);
            if (!ge)
              return;
            de = new ge();
          }
          te[oe] = de;
        } else if (de = te[le], !de)
          return;
        de.uid = getUID("toolbox-feature"), de.model = ce, de.ecModel = U, de.api = K;
        var fe = de instanceof ToolboxFeature;
        if (!oe && le) {
          fe && de.dispose && de.dispose(U, K);
          return;
        }
        if (!ce.get("show") || fe && de.unusable) {
          fe && de.remove && de.remove(U, K);
          return;
        }
        ae(ce, de, oe), ce.setIconStatus = function(ve, pe) {
          var he = this.option, me = this.iconPaths;
          he.iconStatus = he.iconStatus || {}, he.iconStatus[ve] = pe, me[ve] && (pe === "emphasis" ? enterEmphasis : leaveEmphasis)(me[ve]);
        }, de instanceof ToolboxFeature && de.render && de.render(ce, U, K, W);
      }
      function ae(ie, se, oe) {
        var le = ie.getModel("iconStyle"), ue = ie.getModel(["emphasis", "iconStyle"]), ce = se instanceof ToolboxFeature && se.getIcons ? se.getIcons() : ie.get("icon"), de = ie.get("title") || {}, ge, fe;
        isString(ce) ? (ge = {}, ge[oe] = ce) : ge = ce, isString(de) ? (fe = {}, fe[oe] = de) : fe = de;
        var ve = ie.iconPaths = {};
        each$f(ge, function(pe, he) {
          var me = createIcon(pe, {}, {
            x: -X / 2,
            y: -X / 2,
            width: X,
            height: X
          });
          me.setStyle(le.getItemStyle());
          var ye = me.ensureState("emphasis");
          ye.style = ue.getItemStyle();
          var Ce = new ZRText$1({
            style: {
              text: fe[he],
              align: ue.get("textAlign"),
              borderRadius: ue.get("textBorderRadius"),
              padding: ue.get("textPadding"),
              fill: null
            },
            ignore: !0
          });
          me.setTextContent(Ce), setTooltipConfig({
            el: me,
            componentModel: G,
            itemName: he,
            formatterParamsExtra: {
              title: fe[he]
            }
          }), me.__title = fe[he], me.on("mouseover", function() {
            var Ie = ue.getItemStyle(), be = Q ? G.get("right") == null && G.get("left") !== "right" ? "right" : "left" : G.get("bottom") == null && G.get("top") !== "bottom" ? "bottom" : "top";
            Ce.setStyle({
              fill: ue.get("textFill") || Ie.fill || Ie.stroke || "#000",
              backgroundColor: ue.get("textBackgroundColor")
            }), me.setTextConfig({
              position: ue.get("textPosition") || be
            }), Ce.ignore = !G.get("showTitle"), K.enterEmphasis(this);
          }).on("mouseout", function() {
            ie.get(["iconStatus", he]) !== "emphasis" && K.leaveEmphasis(this), Ce.hide();
          }), (ie.get(["iconStatus", he]) === "emphasis" ? enterEmphasis : leaveEmphasis)(me), Z.add(me), me.on("click", bind$1(se.onclick, se, U, K, he)), ve[he] = me;
        });
      }
      layout(Z, G, K), Z.add(makeBackground(Z.getBoundingRect(), G)), Q || Z.eachChild(function(ie) {
        var se = ie.__title, oe = ie.ensureState("emphasis"), le = oe.textConfig || (oe.textConfig = {}), ue = ie.getTextContent(), ce = ue && ue.ensureState("emphasis");
        if (ce && !isFunction(ce) && se) {
          var de = ce.style || (ce.style = {}), ge = getBoundingRect(se, ZRText$1.makeFont(de)), fe = ie.x + Z.x, ve = ie.y + Z.y + X, pe = !1;
          ve + ge.height > K.getHeight() && (le.position = "top", pe = !0);
          var he = pe ? -5 - ge.height : X + 10;
          fe + ge.width / 2 > K.getWidth() ? (le.position = ["100%", he], de.align = "right") : fe - ge.width / 2 < 0 && (le.position = [0, he], de.align = "left");
        }
      });
    }, C.prototype.updateView = function(G, U, K, W) {
      each$f(this._features, function(Z) {
        Z instanceof ToolboxFeature && Z.updateView && Z.updateView(Z.model, U, K, W);
      });
    }, C.prototype.remove = function(G, U) {
      each$f(this._features, function(K) {
        K instanceof ToolboxFeature && K.remove && K.remove(G, U);
      }), this.group.removeAll();
    }, C.prototype.dispose = function(G, U) {
      each$f(this._features, function(K) {
        K instanceof ToolboxFeature && K.dispose && K.dispose(G, U);
      });
    }, C.type = "toolbox", C;
  }(ComponentView$1)
);
function isUserFeatureName(H) {
  return H.indexOf("my") === 0;
}
const ToolboxView$1 = ToolboxView;
var SaveAsImage = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      return H !== null && H.apply(this, arguments) || this;
    }
    return C.prototype.onclick = function(G, U) {
      var K = this.model, W = K.get("name") || G.get("title.0.text") || "echarts", Z = U.getZr().painter.getType() === "svg", X = Z ? "svg" : K.get("type", !0) || "png", Q = U.getConnectedDataURL({
        type: X,
        backgroundColor: K.get("backgroundColor", !0) || G.get("backgroundColor") || "#fff",
        connectedBackgroundColor: K.get("connectedBackgroundColor"),
        excludeComponents: K.get("excludeComponents"),
        pixelRatio: K.get("pixelRatio")
      }), ee = env$1.browser;
      if (isFunction(MouseEvent) && (ee.newEdge || !ee.ie && !ee.edge)) {
        var te = document.createElement("a");
        te.download = W + "." + X, te.target = "_blank", te.href = Q;
        var re = new MouseEvent("click", {
          // some micro front-end framework， window maybe is a Proxy
          view: document.defaultView,
          bubbles: !0,
          cancelable: !1
        });
        te.dispatchEvent(re);
      } else if (window.navigator.msSaveOrOpenBlob || Z) {
        var ne = Q.split(","), ae = ne[0].indexOf("base64") > -1, ie = Z ? decodeURIComponent(ne[1]) : ne[1];
        ae && (ie = window.atob(ie));
        var se = W + "." + X;
        if (window.navigator.msSaveOrOpenBlob) {
          for (var oe = ie.length, le = new Uint8Array(oe); oe--; )
            le[oe] = ie.charCodeAt(oe);
          var ue = new Blob([le]);
          window.navigator.msSaveOrOpenBlob(ue, se);
        } else {
          var ce = document.createElement("iframe");
          document.body.appendChild(ce);
          var de = ce.contentWindow, ge = de.document;
          ge.open("image/svg+xml", "replace"), ge.write(ie), ge.close(), de.focus(), ge.execCommand("SaveAs", !0, se), document.body.removeChild(ce);
        }
      } else {
        var fe = K.get("lang"), ve = '<body style="margin:0;"><img src="' + Q + '" style="max-width:100%;" title="' + (fe && fe[0] || "") + '" /></body>', pe = window.open();
        pe.document.write(ve), pe.document.title = W;
      }
    }, C.getDefaultOption = function(G) {
      var U = {
        show: !0,
        icon: "M4.7,22.9L29.3,45.5L54.7,23.4M4.6,43.6L4.6,58L53.8,58L53.8,43.6M29.2,45.1L29.2,0",
        title: G.getLocaleModel().get(["toolbox", "saveAsImage", "title"]),
        type: "png",
        // Default use option.backgroundColor
        // backgroundColor: '#fff',
        connectedBackgroundColor: "#fff",
        name: "",
        excludeComponents: ["toolbox"],
        // use current pixel ratio of device by default
        // pixelRatio: 1,
        lang: G.getLocaleModel().get(["toolbox", "saveAsImage", "lang"])
      };
      return U;
    }, C;
  }(ToolboxFeature)
);
const SaveAsImage$1 = SaveAsImage;
var INNER_STACK_KEYWORD = "__ec_magicType_stack__", radioTypes = [["line", "bar"], ["stack"]], MagicType = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      return H !== null && H.apply(this, arguments) || this;
    }
    return C.prototype.getIcons = function() {
      var G = this.model, U = G.get("icon"), K = {};
      return each$f(G.get("type"), function(W) {
        U[W] && (K[W] = U[W]);
      }), K;
    }, C.getDefaultOption = function(G) {
      var U = {
        show: !0,
        type: [],
        // Icon group
        icon: {
          line: "M4.1,28.9h7.1l9.3-22l7.4,38l9.7-19.7l3,12.8h14.9M4.1,58h51.4",
          bar: "M6.7,22.9h10V48h-10V22.9zM24.9,13h10v35h-10V13zM43.2,2h10v46h-10V2zM3.1,58h53.7",
          // eslint-disable-next-line
          stack: "M8.2,38.4l-8.4,4.1l30.6,15.3L60,42.5l-8.1-4.1l-21.5,11L8.2,38.4z M51.9,30l-8.1,4.2l-13.4,6.9l-13.9-6.9L8.2,30l-8.4,4.2l8.4,4.2l22.2,11l21.5-11l8.1-4.2L51.9,30z M51.9,21.7l-8.1,4.2L35.7,30l-5.3,2.8L24.9,30l-8.4-4.1l-8.3-4.2l-8.4,4.2L8.2,30l8.3,4.2l13.9,6.9l13.4-6.9l8.1-4.2l8.1-4.1L51.9,21.7zM30.4,2.2L-0.2,17.5l8.4,4.1l8.3,4.2l8.4,4.2l5.5,2.7l5.3-2.7l8.1-4.2l8.1-4.2l8.1-4.1L30.4,2.2z"
          // jshint ignore:line
        },
        // `line`, `bar`, `stack`, `tiled`
        title: G.getLocaleModel().get(["toolbox", "magicType", "title"]),
        option: {},
        seriesIndex: {}
      };
      return U;
    }, C.prototype.onclick = function(G, U, K) {
      var W = this.model, Z = W.get(["seriesIndex", K]);
      if (seriesOptGenreator[K]) {
        var X = {
          series: []
        }, Q = function(re) {
          var ne = re.subType, ae = re.id, ie = seriesOptGenreator[K](ne, ae, re, W);
          ie && (defaults(ie, re.option), X.series.push(ie));
          var se = re.coordinateSystem;
          if (se && se.type === "cartesian2d" && (K === "line" || K === "bar")) {
            var oe = se.getAxesByScale("ordinal")[0];
            if (oe) {
              var le = oe.dim, ue = le + "Axis", ce = re.getReferringComponents(ue, SINGLE_REFERRING).models[0], de = ce.componentIndex;
              X[ue] = X[ue] || [];
              for (var ge = 0; ge <= de; ge++)
                X[ue][de] = X[ue][de] || {};
              X[ue][de].boundaryGap = K === "bar";
            }
          }
        };
        each$f(radioTypes, function(re) {
          indexOf(re, K) >= 0 && each$f(re, function(ne) {
            W.setIconStatus(ne, "normal");
          });
        }), W.setIconStatus(K, "emphasis"), G.eachComponent({
          mainType: "series",
          query: Z == null ? null : {
            seriesIndex: Z
          }
        }, Q);
        var ee, te = K;
        K === "stack" && (ee = merge({
          stack: W.option.title.tiled,
          tiled: W.option.title.stack
        }, W.option.title), W.get(["iconStatus", K]) !== "emphasis" && (te = "tiled")), U.dispatchAction({
          type: "changeMagicType",
          currentType: te,
          newOption: X,
          newTitle: ee,
          featureName: "magicType"
        });
      }
    }, C;
  }(ToolboxFeature)
), seriesOptGenreator = {
  line: function(H, C, G, U) {
    if (H === "bar")
      return merge({
        id: C,
        type: "line",
        // Preserve data related option
        data: G.get("data"),
        stack: G.get("stack"),
        markPoint: G.get("markPoint"),
        markLine: G.get("markLine")
      }, U.get(["option", "line"]) || {}, !0);
  },
  bar: function(H, C, G, U) {
    if (H === "line")
      return merge({
        id: C,
        type: "bar",
        // Preserve data related option
        data: G.get("data"),
        stack: G.get("stack"),
        markPoint: G.get("markPoint"),
        markLine: G.get("markLine")
      }, U.get(["option", "bar"]) || {}, !0);
  },
  stack: function(H, C, G, U) {
    var K = G.get("stack") === INNER_STACK_KEYWORD;
    if (H === "line" || H === "bar")
      return U.setIconStatus("stack", K ? "normal" : "emphasis"), merge({
        id: C,
        stack: K ? "" : INNER_STACK_KEYWORD
      }, U.get(["option", "stack"]) || {}, !0);
  }
};
registerAction({
  type: "changeMagicType",
  event: "magicTypeChanged",
  update: "prepareAndUpdate"
}, function(H, C) {
  C.mergeOption(H.newOption);
});
const MagicType$1 = MagicType;
var BLOCK_SPLITER = new Array(60).join("-"), ITEM_SPLITER = "	";
function groupSeries(H) {
  var C = {}, G = [], U = [];
  return H.eachRawSeries(function(K) {
    var W = K.coordinateSystem;
    if (W && (W.type === "cartesian2d" || W.type === "polar")) {
      var Z = W.getBaseAxis();
      if (Z.type === "category") {
        var X = Z.dim + "_" + Z.index;
        C[X] || (C[X] = {
          categoryAxis: Z,
          valueAxis: W.getOtherAxis(Z),
          series: []
        }, U.push({
          axisDim: Z.dim,
          axisIndex: Z.index
        })), C[X].series.push(K);
      } else
        G.push(K);
    } else
      G.push(K);
  }), {
    seriesGroupByCategoryAxis: C,
    other: G,
    meta: U
  };
}
function assembleSeriesWithCategoryAxis(H) {
  var C = [];
  return each$f(H, function(G, U) {
    var K = G.categoryAxis, W = G.valueAxis, Z = W.dim, X = [" "].concat(map$1(G.series, function(ae) {
      return ae.name;
    })), Q = [K.model.getCategories()];
    each$f(G.series, function(ae) {
      var ie = ae.getRawData();
      Q.push(ae.getRawData().mapArray(ie.mapDimension(Z), function(se) {
        return se;
      }));
    });
    for (var ee = [X.join(ITEM_SPLITER)], te = 0; te < Q[0].length; te++) {
      for (var re = [], ne = 0; ne < Q.length; ne++)
        re.push(Q[ne][te]);
      ee.push(re.join(ITEM_SPLITER));
    }
    C.push(ee.join(`
`));
  }), C.join(`

` + BLOCK_SPLITER + `

`);
}
function assembleOtherSeries(H) {
  return map$1(H, function(C) {
    var G = C.getRawData(), U = [C.name], K = [];
    return G.each(G.dimensions, function() {
      for (var W = arguments.length, Z = arguments[W - 1], X = G.getName(Z), Q = 0; Q < W - 1; Q++)
        K[Q] = arguments[Q];
      U.push((X ? X + ITEM_SPLITER : "") + K.join(ITEM_SPLITER));
    }), U.join(`
`);
  }).join(`

` + BLOCK_SPLITER + `

`);
}
function getContentFromModel(H) {
  var C = groupSeries(H);
  return {
    value: filter([assembleSeriesWithCategoryAxis(C.seriesGroupByCategoryAxis), assembleOtherSeries(C.other)], function(G) {
      return !!G.replace(/[\n\t\s]/g, "");
    }).join(`

` + BLOCK_SPLITER + `

`),
    meta: C.meta
  };
}
function trim(H) {
  return H.replace(/^\s\s*/, "").replace(/\s\s*$/, "");
}
function isTSVFormat(H) {
  var C = H.slice(0, H.indexOf(`
`));
  if (C.indexOf(ITEM_SPLITER) >= 0)
    return !0;
}
var itemSplitRegex = new RegExp("[" + ITEM_SPLITER + "]+", "g");
function parseTSVContents(H) {
  for (var C = H.split(/\n+/g), G = trim(C.shift()).split(itemSplitRegex), U = [], K = map$1(G, function(Q) {
    return {
      name: Q,
      data: []
    };
  }), W = 0; W < C.length; W++) {
    var Z = trim(C[W]).split(itemSplitRegex);
    U.push(Z.shift());
    for (var X = 0; X < Z.length; X++)
      K[X] && (K[X].data[W] = Z[X]);
  }
  return {
    series: K,
    categories: U
  };
}
function parseListContents(H) {
  for (var C = H.split(/\n+/g), G = trim(C.shift()), U = [], K = 0; K < C.length; K++) {
    var W = trim(C[K]);
    if (W) {
      var Z = W.split(itemSplitRegex), X = "", Q = void 0, ee = !1;
      isNaN(Z[0]) ? (ee = !0, X = Z[0], Z = Z.slice(1), U[K] = {
        name: X,
        value: []
      }, Q = U[K].value) : Q = U[K] = [];
      for (var te = 0; te < Z.length; te++)
        Q.push(+Z[te]);
      Q.length === 1 && (ee ? U[K].value = Q[0] : U[K] = Q[0]);
    }
  }
  return {
    name: G,
    data: U
  };
}
function parseContents(H, C) {
  var G = H.split(new RegExp(`
*` + BLOCK_SPLITER + `
*`, "g")), U = {
    series: []
  };
  return each$f(G, function(K, W) {
    if (isTSVFormat(K)) {
      var Z = parseTSVContents(K), X = C[W], Q = X.axisDim + "Axis";
      X && (U[Q] = U[Q] || [], U[Q][X.axisIndex] = {
        data: Z.categories
      }, U.series = U.series.concat(Z.series));
    } else {
      var Z = parseListContents(K);
      U.series.push(Z);
    }
  }), U;
}
var DataView = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      return H !== null && H.apply(this, arguments) || this;
    }
    return C.prototype.onclick = function(G, U) {
      setTimeout(function() {
        U.dispatchAction({
          type: "hideTip"
        });
      });
      var K = U.getDom(), W = this.model;
      this._dom && K.removeChild(this._dom);
      var Z = document.createElement("div");
      Z.style.cssText = "position:absolute;top:0;bottom:0;left:0;right:0;padding:5px", Z.style.backgroundColor = W.get("backgroundColor") || "#fff";
      var X = document.createElement("h4"), Q = W.get("lang") || [];
      X.innerHTML = Q[0] || W.get("title"), X.style.cssText = "margin:10px 20px", X.style.color = W.get("textColor");
      var ee = document.createElement("div"), te = document.createElement("textarea");
      ee.style.cssText = "overflow:auto";
      var re = W.get("optionToContent"), ne = W.get("contentToOption"), ae = getContentFromModel(G);
      if (isFunction(re)) {
        var ie = re(U.getOption());
        isString(ie) ? ee.innerHTML = ie : isDom(ie) && ee.appendChild(ie);
      } else {
        te.readOnly = W.get("readOnly");
        var se = te.style;
        se.cssText = "display:block;width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;resize:none;box-sizing:border-box;outline:none", se.color = W.get("textColor"), se.borderColor = W.get("textareaBorderColor"), se.backgroundColor = W.get("textareaColor"), te.value = ae.value, ee.appendChild(te);
      }
      var oe = ae.meta, le = document.createElement("div");
      le.style.cssText = "position:absolute;bottom:5px;left:0;right:0";
      var ue = "float:right;margin-right:20px;border:none;cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px", ce = document.createElement("div"), de = document.createElement("div");
      ue += ";background-color:" + W.get("buttonColor"), ue += ";color:" + W.get("buttonTextColor");
      var ge = this;
      function fe() {
        K.removeChild(Z), ge._dom = null;
      }
      addEventListener(ce, "click", fe), addEventListener(de, "click", function() {
        if (ne == null && re != null || ne != null && re == null) {
          process.env.NODE_ENV !== "production" && warn("It seems you have just provided one of `contentToOption` and `optionToContent` functions but missed the other one. Data change is ignored."), fe();
          return;
        }
        var ve;
        try {
          isFunction(ne) ? ve = ne(ee, U.getOption()) : ve = parseContents(te.value, oe);
        } catch (pe) {
          throw fe(), new Error("Data view format error " + pe);
        }
        ve && U.dispatchAction({
          type: "changeDataView",
          newOption: ve
        }), fe();
      }), ce.innerHTML = Q[1], de.innerHTML = Q[2], de.style.cssText = ce.style.cssText = ue, !W.get("readOnly") && le.appendChild(de), le.appendChild(ce), Z.appendChild(X), Z.appendChild(ee), Z.appendChild(le), ee.style.height = K.clientHeight - 80 + "px", K.appendChild(Z), this._dom = Z;
    }, C.prototype.remove = function(G, U) {
      this._dom && U.getDom().removeChild(this._dom);
    }, C.prototype.dispose = function(G, U) {
      this.remove(G, U);
    }, C.getDefaultOption = function(G) {
      var U = {
        show: !0,
        readOnly: !1,
        optionToContent: null,
        contentToOption: null,
        // eslint-disable-next-line
        icon: "M17.5,17.3H33 M17.5,17.3H33 M45.4,29.5h-28 M11.5,2v56H51V14.8L38.4,2H11.5z M38.4,2.2v12.7H51 M45.4,41.7h-28",
        title: G.getLocaleModel().get(["toolbox", "dataView", "title"]),
        lang: G.getLocaleModel().get(["toolbox", "dataView", "lang"]),
        backgroundColor: "#fff",
        textColor: "#000",
        textareaColor: "#fff",
        textareaBorderColor: "#333",
        buttonColor: "#c23531",
        buttonTextColor: "#fff"
      };
      return U;
    }, C;
  }(ToolboxFeature)
);
function tryMergeDataOption(H, C) {
  return map$1(H, function(G, U) {
    var K = C && C[U];
    if (isObject$3(K) && !isArray$1(K)) {
      var W = isObject$3(G) && !isArray$1(G);
      W || (G = {
        value: G
      });
      var Z = K.name != null && G.name == null;
      return G = defaults(G, K), Z && delete G.name, G;
    } else
      return G;
  });
}
registerAction({
  type: "changeDataView",
  event: "dataViewChanged",
  update: "prepareAndUpdate"
}, function(H, C) {
  var G = [];
  each$f(H.newOption.series, function(U) {
    var K = C.getSeriesByName(U.name)[0];
    if (!K)
      G.push(extend({
        // Default is scatter
        type: "scatter"
      }, U));
    else {
      var W = K.get("data");
      G.push({
        name: U.name,
        data: tryMergeDataOption(U.data, W)
      });
    }
  }), C.mergeOption(defaults({
    series: G
  }, H.newOption));
});
const DataView$1 = DataView;
var each$6 = each$f, inner$6 = makeInner();
function push(H, C) {
  var G = getStoreSnapshots(H);
  each$6(C, function(U, K) {
    for (var W = G.length - 1; W >= 0; W--) {
      var Z = G[W];
      if (Z[K])
        break;
    }
    if (W < 0) {
      var X = H.queryComponents({
        mainType: "dataZoom",
        subType: "select",
        id: K
      })[0];
      if (X) {
        var Q = X.getPercentRange();
        G[0][K] = {
          dataZoomId: K,
          start: Q[0],
          end: Q[1]
        };
      }
    }
  }), G.push(C);
}
function pop(H) {
  var C = getStoreSnapshots(H), G = C[C.length - 1];
  C.length > 1 && C.pop();
  var U = {};
  return each$6(G, function(K, W) {
    for (var Z = C.length - 1; Z >= 0; Z--)
      if (K = C[Z][W], K) {
        U[W] = K;
        break;
      }
  }), U;
}
function clear(H) {
  inner$6(H).snapshots = null;
}
function count(H) {
  return getStoreSnapshots(H).length;
}
function getStoreSnapshots(H) {
  var C = inner$6(H);
  return C.snapshots || (C.snapshots = [{}]), C.snapshots;
}
var RestoreOption = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      return H !== null && H.apply(this, arguments) || this;
    }
    return C.prototype.onclick = function(G, U) {
      clear(G), U.dispatchAction({
        type: "restore",
        from: this.uid
      });
    }, C.getDefaultOption = function(G) {
      var U = {
        show: !0,
        // eslint-disable-next-line
        icon: "M3.8,33.4 M47,18.9h9.8V8.7 M56.3,20.1 C52.1,9,40.5,0.6,26.8,2.1C12.6,3.7,1.6,16.2,2.1,30.6 M13,41.1H3.1v10.2 M3.7,39.9c4.2,11.1,15.8,19.5,29.5,18 c14.2-1.6,25.2-14.1,24.7-28.5",
        title: G.getLocaleModel().get(["toolbox", "restore", "title"])
      };
      return U;
    }, C;
  }(ToolboxFeature)
);
registerAction({
  type: "restore",
  event: "restore",
  update: "prepareAndUpdate"
}, function(H, C) {
  C.resetOption("recreate");
});
const Restore = RestoreOption;
var INCLUDE_FINDER_MAIN_TYPES = ["grid", "xAxis", "yAxis", "geo", "graph", "polar", "radiusAxis", "angleAxis", "bmap"], BrushTargetManager = (
  /** @class */
  function() {
    function H(C, G, U) {
      var K = this;
      this._targetInfoList = [];
      var W = parseFinder(G, C);
      each$f(targetInfoBuilders, function(Z, X) {
        (!U || !U.include || indexOf(U.include, X) >= 0) && Z(W, K._targetInfoList);
      });
    }
    return H.prototype.setOutputRanges = function(C, G) {
      return this.matchOutputRanges(C, G, function(U, K, W) {
        if ((U.coordRanges || (U.coordRanges = [])).push(K), !U.coordRange) {
          U.coordRange = K;
          var Z = coordConvert[U.brushType](0, W, K);
          U.__rangeOffset = {
            offset: diffProcessor[U.brushType](Z.values, U.range, [1, 1]),
            xyMinMax: Z.xyMinMax
          };
        }
      }), C;
    }, H.prototype.matchOutputRanges = function(C, G, U) {
      each$f(C, function(K) {
        var W = this.findTargetInfo(K, G);
        W && W !== !0 && each$f(W.coordSyses, function(Z) {
          var X = coordConvert[K.brushType](1, Z, K.range, !0);
          U(K, X.values, Z, G);
        });
      }, this);
    }, H.prototype.setInputRanges = function(C, G) {
      each$f(C, function(U) {
        var K = this.findTargetInfo(U, G);
        if (process.env.NODE_ENV !== "production" && (assert(!K || K === !0 || U.coordRange, "coordRange must be specified when coord index specified."), assert(!K || K !== !0 || U.range, "range must be specified in global brush.")), U.range = U.range || [], K && K !== !0) {
          U.panelId = K.panelId;
          var W = coordConvert[U.brushType](0, K.coordSys, U.coordRange), Z = U.__rangeOffset;
          U.range = Z ? diffProcessor[U.brushType](W.values, Z.offset, getScales(W.xyMinMax, Z.xyMinMax)) : W.values;
        }
      }, this);
    }, H.prototype.makePanelOpts = function(C, G) {
      return map$1(this._targetInfoList, function(U) {
        var K = U.getPanelRect();
        return {
          panelId: U.panelId,
          defaultBrushType: G ? G(U) : null,
          clipPath: makeRectPanelClipPath(K),
          isTargetByCursor: makeRectIsTargetByCursor(K, C, U.coordSysModel),
          getLinearBrushOtherExtent: makeLinearBrushOtherExtent(K)
        };
      });
    }, H.prototype.controlSeries = function(C, G, U) {
      var K = this.findTargetInfo(C, U);
      return K === !0 || K && indexOf(K.coordSyses, G.coordinateSystem) >= 0;
    }, H.prototype.findTargetInfo = function(C, G) {
      for (var U = this._targetInfoList, K = parseFinder(G, C), W = 0; W < U.length; W++) {
        var Z = U[W], X = C.panelId;
        if (X) {
          if (Z.panelId === X)
            return Z;
        } else
          for (var Q = 0; Q < targetInfoMatchers.length; Q++)
            if (targetInfoMatchers[Q](K, Z))
              return Z;
      }
      return !0;
    }, H;
  }()
);
function formatMinMax(H) {
  return H[0] > H[1] && H.reverse(), H;
}
function parseFinder(H, C) {
  return parseFinder$1(H, C, {
    includeMainTypes: INCLUDE_FINDER_MAIN_TYPES
  });
}
var targetInfoBuilders = {
  grid: function(H, C) {
    var G = H.xAxisModels, U = H.yAxisModels, K = H.gridModels, W = createHashMap(), Z = {}, X = {};
    !G && !U && !K || (each$f(G, function(Q) {
      var ee = Q.axis.grid.model;
      W.set(ee.id, ee), Z[ee.id] = !0;
    }), each$f(U, function(Q) {
      var ee = Q.axis.grid.model;
      W.set(ee.id, ee), X[ee.id] = !0;
    }), each$f(K, function(Q) {
      W.set(Q.id, Q), Z[Q.id] = !0, X[Q.id] = !0;
    }), W.each(function(Q) {
      var ee = Q.coordinateSystem, te = [];
      each$f(ee.getCartesians(), function(re, ne) {
        (indexOf(G, re.getAxis("x").model) >= 0 || indexOf(U, re.getAxis("y").model) >= 0) && te.push(re);
      }), C.push({
        panelId: "grid--" + Q.id,
        gridModel: Q,
        coordSysModel: Q,
        // Use the first one as the representitive coordSys.
        coordSys: te[0],
        coordSyses: te,
        getPanelRect: panelRectBuilders.grid,
        xAxisDeclared: Z[Q.id],
        yAxisDeclared: X[Q.id]
      });
    }));
  },
  geo: function(H, C) {
    each$f(H.geoModels, function(G) {
      var U = G.coordinateSystem;
      C.push({
        panelId: "geo--" + G.id,
        geoModel: G,
        coordSysModel: G,
        coordSys: U,
        coordSyses: [U],
        getPanelRect: panelRectBuilders.geo
      });
    });
  }
}, targetInfoMatchers = [
  // grid
  function(H, C) {
    var G = H.xAxisModel, U = H.yAxisModel, K = H.gridModel;
    return !K && G && (K = G.axis.grid.model), !K && U && (K = U.axis.grid.model), K && K === C.gridModel;
  },
  // geo
  function(H, C) {
    var G = H.geoModel;
    return G && G === C.geoModel;
  }
], panelRectBuilders = {
  grid: function() {
    return this.coordSys.master.getRect().clone();
  },
  geo: function() {
    var H = this.coordSys, C = H.getBoundingRect().clone();
    return C.applyTransform(getTransform$1(H)), C;
  }
}, coordConvert = {
  lineX: curry$1(axisConvert, 0),
  lineY: curry$1(axisConvert, 1),
  rect: function(H, C, G, U) {
    var K = H ? C.pointToData([G[0][0], G[1][0]], U) : C.dataToPoint([G[0][0], G[1][0]], U), W = H ? C.pointToData([G[0][1], G[1][1]], U) : C.dataToPoint([G[0][1], G[1][1]], U), Z = [formatMinMax([K[0], W[0]]), formatMinMax([K[1], W[1]])];
    return {
      values: Z,
      xyMinMax: Z
    };
  },
  polygon: function(H, C, G, U) {
    var K = [[1 / 0, -1 / 0], [1 / 0, -1 / 0]], W = map$1(G, function(Z) {
      var X = H ? C.pointToData(Z, U) : C.dataToPoint(Z, U);
      return K[0][0] = Math.min(K[0][0], X[0]), K[1][0] = Math.min(K[1][0], X[1]), K[0][1] = Math.max(K[0][1], X[0]), K[1][1] = Math.max(K[1][1], X[1]), X;
    });
    return {
      values: W,
      xyMinMax: K
    };
  }
};
function axisConvert(H, C, G, U) {
  process.env.NODE_ENV !== "production" && assert(G.type === "cartesian2d", "lineX/lineY brush is available only in cartesian2d.");
  var K = G.getAxis(["x", "y"][H]), W = formatMinMax(map$1([0, 1], function(X) {
    return C ? K.coordToData(K.toLocalCoord(U[X]), !0) : K.toGlobalCoord(K.dataToCoord(U[X]));
  })), Z = [];
  return Z[H] = W, Z[1 - H] = [NaN, NaN], {
    values: W,
    xyMinMax: Z
  };
}
var diffProcessor = {
  lineX: curry$1(axisDiffProcessor, 0),
  lineY: curry$1(axisDiffProcessor, 1),
  rect: function(H, C, G) {
    return [[H[0][0] - G[0] * C[0][0], H[0][1] - G[0] * C[0][1]], [H[1][0] - G[1] * C[1][0], H[1][1] - G[1] * C[1][1]]];
  },
  polygon: function(H, C, G) {
    return map$1(H, function(U, K) {
      return [U[0] - G[0] * C[K][0], U[1] - G[1] * C[K][1]];
    });
  }
};
function axisDiffProcessor(H, C, G, U) {
  return [C[0] - U[H] * G[0], C[1] - U[H] * G[1]];
}
function getScales(H, C) {
  var G = getSize(H), U = getSize(C), K = [G[0] / U[0], G[1] / U[1]];
  return isNaN(K[0]) && (K[0] = 1), isNaN(K[1]) && (K[1] = 1), K;
}
function getSize(H) {
  return H ? [H[0][1] - H[0][0], H[1][1] - H[1][0]] : [NaN, NaN];
}
const BrushTargetManager$1 = BrushTargetManager;
var each$5 = each$f, DATA_ZOOM_ID_BASE = makeInternalComponentId("toolbox-dataZoom_"), DataZoomFeature = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      return H !== null && H.apply(this, arguments) || this;
    }
    return C.prototype.render = function(G, U, K, W) {
      this._brushController || (this._brushController = new BrushController$1(K.getZr()), this._brushController.on("brush", bind$1(this._onBrush, this)).mount()), updateZoomBtnStatus(G, U, this, W, K), updateBackBtnStatus(G, U);
    }, C.prototype.onclick = function(G, U, K) {
      handlers[K].call(this);
    }, C.prototype.remove = function(G, U) {
      this._brushController && this._brushController.unmount();
    }, C.prototype.dispose = function(G, U) {
      this._brushController && this._brushController.dispose();
    }, C.prototype._onBrush = function(G) {
      var U = G.areas;
      if (!G.isEnd || !U.length)
        return;
      var K = {}, W = this.ecModel;
      this._brushController.updateCovers([]);
      var Z = new BrushTargetManager$1(makeAxisFinder(this.model), W, {
        include: ["grid"]
      });
      Z.matchOutputRanges(U, W, function(ee, te, re) {
        if (re.type === "cartesian2d") {
          var ne = ee.brushType;
          ne === "rect" ? (X("x", re, te[0]), X("y", re, te[1])) : X({
            lineX: "x",
            lineY: "y"
          }[ne], re, te);
        }
      }), push(W, K), this._dispatchZoomAction(K);
      function X(ee, te, re) {
        var ne = te.getAxis(ee), ae = ne.model, ie = Q(ee, ae, W), se = ie.findRepresentativeAxisProxy(ae).getMinMaxSpan();
        (se.minValueSpan != null || se.maxValueSpan != null) && (re = sliderMove(0, re.slice(), ne.scale.getExtent(), 0, se.minValueSpan, se.maxValueSpan)), ie && (K[ie.id] = {
          dataZoomId: ie.id,
          startValue: re[0],
          endValue: re[1]
        });
      }
      function Q(ee, te, re) {
        var ne;
        return re.eachComponent({
          mainType: "dataZoom",
          subType: "select"
        }, function(ae) {
          var ie = ae.getAxisModel(ee, te.componentIndex);
          ie && (ne = ae);
        }), ne;
      }
    }, C.prototype._dispatchZoomAction = function(G) {
      var U = [];
      each$5(G, function(K, W) {
        U.push(clone$4(K));
      }), U.length && this.api.dispatchAction({
        type: "dataZoom",
        from: this.uid,
        batch: U
      });
    }, C.getDefaultOption = function(G) {
      var U = {
        show: !0,
        filterMode: "filter",
        // Icon group
        icon: {
          zoom: "M0,13.5h26.9 M13.5,26.9V0 M32.1,13.5H58V58H13.5 V32.1",
          back: "M22,1.4L9.9,13.5l12.3,12.3 M10.3,13.5H54.9v44.6 H10.3v-26"
        },
        // `zoom`, `back`
        title: G.getLocaleModel().get(["toolbox", "dataZoom", "title"]),
        brushStyle: {
          borderWidth: 0,
          color: "rgba(210,219,238,0.2)"
        }
      };
      return U;
    }, C;
  }(ToolboxFeature)
), handlers = {
  zoom: function() {
    var H = !this._isZoomActive;
    this.api.dispatchAction({
      type: "takeGlobalCursor",
      key: "dataZoomSelect",
      dataZoomSelectActive: H
    });
  },
  back: function() {
    this._dispatchZoomAction(pop(this.ecModel));
  }
};
function makeAxisFinder(H) {
  var C = {
    xAxisIndex: H.get("xAxisIndex", !0),
    yAxisIndex: H.get("yAxisIndex", !0),
    xAxisId: H.get("xAxisId", !0),
    yAxisId: H.get("yAxisId", !0)
  };
  return C.xAxisIndex == null && C.xAxisId == null && (C.xAxisIndex = "all"), C.yAxisIndex == null && C.yAxisId == null && (C.yAxisIndex = "all"), C;
}
function updateBackBtnStatus(H, C) {
  H.setIconStatus("back", count(C) > 1 ? "emphasis" : "normal");
}
function updateZoomBtnStatus(H, C, G, U, K) {
  var W = G._isZoomActive;
  U && U.type === "takeGlobalCursor" && (W = U.key === "dataZoomSelect" ? U.dataZoomSelectActive : !1), G._isZoomActive = W, H.setIconStatus("zoom", W ? "emphasis" : "normal");
  var Z = new BrushTargetManager$1(makeAxisFinder(H), C, {
    include: ["grid"]
  }), X = Z.makePanelOpts(K, function(Q) {
    return Q.xAxisDeclared && !Q.yAxisDeclared ? "lineX" : !Q.xAxisDeclared && Q.yAxisDeclared ? "lineY" : "rect";
  });
  G._brushController.setPanels(X).enableBrush(W && X.length ? {
    brushType: "auto",
    brushStyle: H.getModel("brushStyle").getItemStyle()
  } : !1);
}
registerInternalOptionCreator("dataZoom", function(H) {
  var C = H.getComponent("toolbox", 0), G = ["feature", "dataZoom"];
  if (!C || C.get(G) == null)
    return;
  var U = C.getModel(G), K = [], W = makeAxisFinder(U), Z = parseFinder$1(H, W);
  each$5(Z.xAxisModels, function(Q) {
    return X(Q, "xAxis", "xAxisIndex");
  }), each$5(Z.yAxisModels, function(Q) {
    return X(Q, "yAxis", "yAxisIndex");
  });
  function X(Q, ee, te) {
    var re = Q.componentIndex, ne = {
      type: "select",
      $fromToolbox: !0,
      // Default to be filter
      filterMode: U.get("filterMode", !0) || "filter",
      // Id for merge mapping.
      id: DATA_ZOOM_ID_BASE + ee + re
    };
    ne[te] = re, K.push(ne);
  }
  return K;
});
const DataZoom = DataZoomFeature;
function install$j(H) {
  H.registerComponentModel(ToolboxModel$1), H.registerComponentView(ToolboxView$1), registerFeature("saveAsImage", SaveAsImage$1), registerFeature("magicType", MagicType$1), registerFeature("dataView", DataView$1), registerFeature("dataZoom", DataZoom), registerFeature("restore", Restore), use(install$k);
}
var TooltipModel = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G;
    }
    return C.type = "tooltip", C.dependencies = ["axisPointer"], C.defaultOption = {
      // zlevel: 0,
      z: 60,
      show: !0,
      // tooltip main content
      showContent: !0,
      // 'trigger' only works on coordinate system.
      // 'item' | 'axis' | 'none'
      trigger: "item",
      // 'click' | 'mousemove' | 'none'
      triggerOn: "mousemove|click",
      alwaysShowContent: !1,
      displayMode: "single",
      renderMode: "auto",
      // whether restraint content inside viewRect.
      // If renderMode: 'richText', default true.
      // If renderMode: 'html', defaut false (for backward compat).
      confine: null,
      showDelay: 0,
      hideDelay: 100,
      // Animation transition time, unit is second
      transitionDuration: 0.4,
      enterable: !1,
      backgroundColor: "#fff",
      // box shadow
      shadowBlur: 10,
      shadowColor: "rgba(0, 0, 0, .2)",
      shadowOffsetX: 1,
      shadowOffsetY: 2,
      // tooltip border radius, unit is px, default is 4
      borderRadius: 4,
      // tooltip border width, unit is px, default is 0 (no border)
      borderWidth: 1,
      // Tooltip inside padding, default is 5 for all direction
      // Array is allowed to set up, right, bottom, left, same with css
      // The default value: See `tooltip/tooltipMarkup.ts#getPaddingFromTooltipModel`.
      padding: null,
      // Extra css text
      extraCssText: "",
      // axis indicator, trigger by axis
      axisPointer: {
        // default is line
        // legal values: 'line' | 'shadow' | 'cross'
        type: "line",
        // Valid when type is line, appoint tooltip line locate on which line. Optional
        // legal values: 'x' | 'y' | 'angle' | 'radius' | 'auto'
        // default is 'auto', chose the axis which type is category.
        // for multiply y axis, cartesian coord chose x axis, polar chose angle axis
        axis: "auto",
        animation: "auto",
        animationDurationUpdate: 200,
        animationEasingUpdate: "exponentialOut",
        crossStyle: {
          color: "#999",
          width: 1,
          type: "dashed",
          // TODO formatter
          textStyle: {}
        }
        // lineStyle and shadowStyle should not be specified here,
        // otherwise it will always override those styles on option.axisPointer.
      },
      textStyle: {
        color: "#666",
        fontSize: 14
      }
    }, C;
  }(ComponentModel$1)
);
const TooltipModel$1 = TooltipModel;
function shouldTooltipConfine(H) {
  var C = H.get("confine");
  return C != null ? !!C : H.get("renderMode") === "richText";
}
function testStyle(H) {
  if (env$1.domSupported) {
    for (var C = document.documentElement.style, G = 0, U = H.length; G < U; G++)
      if (H[G] in C)
        return H[G];
  }
}
var TRANSFORM_VENDOR = testStyle(["transform", "webkitTransform", "OTransform", "MozTransform", "msTransform"]), TRANSITION_VENDOR = testStyle(["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]);
function toCSSVendorPrefix(H, C) {
  if (!H)
    return C;
  C = toCamelCase(C, !0);
  var G = H.indexOf(C);
  return H = G === -1 ? C : "-" + H.slice(0, G) + "-" + C, H.toLowerCase();
}
function getComputedStyle$1(H, C) {
  var G = H.currentStyle || document.defaultView && document.defaultView.getComputedStyle(H);
  return G ? C ? G[C] : G : null;
}
var CSS_TRANSITION_VENDOR = toCSSVendorPrefix(TRANSITION_VENDOR, "transition"), CSS_TRANSFORM_VENDOR = toCSSVendorPrefix(TRANSFORM_VENDOR, "transform"), gCssText = "position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;" + (env$1.transform3dSupported ? "will-change:transform;" : "");
function mirrorPos(H) {
  return H = H === "left" ? "right" : H === "right" ? "left" : H === "top" ? "bottom" : "top", H;
}
function assembleArrow(H, C, G) {
  if (!isString(G) || G === "inside")
    return "";
  var U = H.get("backgroundColor"), K = H.get("borderWidth");
  C = convertToColorString(C);
  var W = mirrorPos(G), Z = Math.max(Math.round(K) * 1.5, 6), X = "", Q = CSS_TRANSFORM_VENDOR + ":", ee;
  indexOf(["left", "right"], W) > -1 ? (X += "top:50%", Q += "translateY(-50%) rotate(" + (ee = W === "left" ? -225 : -45) + "deg)") : (X += "left:50%", Q += "translateX(-50%) rotate(" + (ee = W === "top" ? 225 : 45) + "deg)");
  var te = ee * Math.PI / 180, re = Z + K, ne = re * Math.abs(Math.cos(te)) + re * Math.abs(Math.sin(te)), ae = Math.round(((ne - Math.SQRT2 * K) / 2 + Math.SQRT2 * K - (ne - re) / 2) * 100) / 100;
  X += ";" + W + ":-" + ae + "px";
  var ie = C + " solid " + K + "px;", se = ["position:absolute;width:" + Z + "px;height:" + Z + "px;z-index:-1;", X + ";" + Q + ";", "border-bottom:" + ie, "border-right:" + ie, "background-color:" + U + ";"];
  return '<div style="' + se.join("") + '"></div>';
}
function assembleTransition(H, C) {
  var G = "cubic-bezier(0.23,1,0.32,1)", U = " " + H / 2 + "s " + G, K = "opacity" + U + ",visibility" + U;
  return C || (U = " " + H + "s " + G, K += env$1.transformSupported ? "," + CSS_TRANSFORM_VENDOR + U : ",left" + U + ",top" + U), CSS_TRANSITION_VENDOR + ":" + K;
}
function assembleTransform(H, C, G) {
  var U = H.toFixed(0) + "px", K = C.toFixed(0) + "px";
  if (!env$1.transformSupported)
    return G ? "top:" + K + ";left:" + U + ";" : [["top", K], ["left", U]];
  var W = env$1.transform3dSupported, Z = "translate" + (W ? "3d" : "") + "(" + U + "," + K + (W ? ",0" : "") + ")";
  return G ? "top:0;left:0;" + CSS_TRANSFORM_VENDOR + ":" + Z + ";" : [["top", 0], ["left", 0], [TRANSFORM_VENDOR, Z]];
}
function assembleFont(H) {
  var C = [], G = H.get("fontSize"), U = H.getTextColor();
  U && C.push("color:" + U), C.push("font:" + H.getFont()), G && C.push("line-height:" + Math.round(G * 3 / 2) + "px");
  var K = H.get("textShadowColor"), W = H.get("textShadowBlur") || 0, Z = H.get("textShadowOffsetX") || 0, X = H.get("textShadowOffsetY") || 0;
  return K && W && C.push("text-shadow:" + Z + "px " + X + "px " + W + "px " + K), each$f(["decoration", "align"], function(Q) {
    var ee = H.get(Q);
    ee && C.push("text-" + Q + ":" + ee);
  }), C.join(";");
}
function assembleCssText(H, C, G) {
  var U = [], K = H.get("transitionDuration"), W = H.get("backgroundColor"), Z = H.get("shadowBlur"), X = H.get("shadowColor"), Q = H.get("shadowOffsetX"), ee = H.get("shadowOffsetY"), te = H.getModel("textStyle"), re = getPaddingFromTooltipModel(H, "html"), ne = Q + "px " + ee + "px " + Z + "px " + X;
  return U.push("box-shadow:" + ne), C && K && U.push(assembleTransition(K, G)), W && U.push("background-color:" + W), each$f(["width", "color", "radius"], function(ae) {
    var ie = "border-" + ae, se = toCamelCase(ie), oe = H.get(se);
    oe != null && U.push(ie + ":" + oe + (ae === "color" ? "" : "px"));
  }), U.push(assembleFont(te)), re != null && U.push("padding:" + normalizeCssArray(re).join("px ") + "px"), U.join(";") + ";";
}
function makeStyleCoord$1(H, C, G, U, K) {
  var W = C && C.painter;
  if (G) {
    var Z = W && W.getViewportRoot();
    Z && transformLocalCoord(H, Z, document.body, U, K);
  } else {
    H[0] = U, H[1] = K;
    var X = W && W.getViewportRootOffset();
    X && (H[0] += X.offsetLeft, H[1] += X.offsetTop);
  }
  H[2] = H[0] / C.getWidth(), H[3] = H[1] / C.getHeight();
}
var TooltipHTMLContent = (
  /** @class */
  function() {
    function H(C, G, U) {
      if (this._show = !1, this._styleCoord = [0, 0, 0, 0], this._enterable = !0, this._firstShow = !0, this._longHide = !0, env$1.wxa)
        return null;
      var K = document.createElement("div");
      K.domBelongToZr = !0, this.el = K;
      var W = this._zr = G.getZr(), Z = this._appendToBody = U && U.appendToBody;
      makeStyleCoord$1(this._styleCoord, W, Z, G.getWidth() / 2, G.getHeight() / 2), Z ? document.body.appendChild(K) : C.appendChild(K), this._container = C;
      var X = this;
      K.onmouseenter = function() {
        X._enterable && (clearTimeout(X._hideTimeout), X._show = !0), X._inContent = !0;
      }, K.onmousemove = function(Q) {
        if (Q = Q || window.event, !X._enterable) {
          var ee = W.handler, te = W.painter.getViewportRoot();
          normalizeEvent(te, Q, !0), ee.dispatch("mousemove", Q);
        }
      }, K.onmouseleave = function() {
        X._inContent = !1, X._enterable && X._show && X.hideLater(X._hideDelay);
      };
    }
    return H.prototype.update = function(C) {
      var G = this._container, U = getComputedStyle$1(G, "position"), K = G.style;
      K.position !== "absolute" && U !== "absolute" && (K.position = "relative");
      var W = C.get("alwaysShowContent");
      W && this._moveIfResized(), this.el.className = C.get("className") || "";
    }, H.prototype.show = function(C, G) {
      clearTimeout(this._hideTimeout), clearTimeout(this._longHideTimeout);
      var U = this.el, K = U.style, W = this._styleCoord;
      U.innerHTML ? K.cssText = gCssText + assembleCssText(C, !this._firstShow, this._longHide) + assembleTransform(W[0], W[1], !0) + ("border-color:" + convertToColorString(G) + ";") + (C.get("extraCssText") || "") + (";pointer-events:" + (this._enterable ? "auto" : "none")) : K.display = "none", this._show = !0, this._firstShow = !1, this._longHide = !1;
    }, H.prototype.setContent = function(C, G, U, K, W) {
      var Z = this.el;
      if (C == null) {
        Z.innerHTML = "";
        return;
      }
      var X = "";
      if (isString(W) && U.get("trigger") === "item" && !shouldTooltipConfine(U) && (X = assembleArrow(U, K, W)), isString(C))
        Z.innerHTML = C + X;
      else if (C) {
        Z.innerHTML = "", isArray$1(C) || (C = [C]);
        for (var Q = 0; Q < C.length; Q++)
          isDom(C[Q]) && C[Q].parentNode !== Z && Z.appendChild(C[Q]);
        if (X && Z.childNodes.length) {
          var ee = document.createElement("div");
          ee.innerHTML = X, Z.appendChild(ee);
        }
      }
    }, H.prototype.setEnterable = function(C) {
      this._enterable = C;
    }, H.prototype.getSize = function() {
      var C = this.el;
      return [C.offsetWidth, C.offsetHeight];
    }, H.prototype.moveTo = function(C, G) {
      var U = this._styleCoord;
      if (makeStyleCoord$1(U, this._zr, this._appendToBody, C, G), U[0] != null && U[1] != null) {
        var K = this.el.style, W = assembleTransform(U[0], U[1]);
        each$f(W, function(Z) {
          K[Z[0]] = Z[1];
        });
      }
    }, H.prototype._moveIfResized = function() {
      var C = this._styleCoord[2], G = this._styleCoord[3];
      this.moveTo(C * this._zr.getWidth(), G * this._zr.getHeight());
    }, H.prototype.hide = function() {
      var C = this, G = this.el.style;
      G.visibility = "hidden", G.opacity = "0", env$1.transform3dSupported && (G.willChange = ""), this._show = !1, this._longHideTimeout = setTimeout(function() {
        return C._longHide = !0;
      }, 500);
    }, H.prototype.hideLater = function(C) {
      this._show && !(this._inContent && this._enterable) && (C ? (this._hideDelay = C, this._show = !1, this._hideTimeout = setTimeout(bind$1(this.hide, this), C)) : this.hide());
    }, H.prototype.isShow = function() {
      return this._show;
    }, H.prototype.dispose = function() {
      this.el.parentNode.removeChild(this.el);
    }, H;
  }()
);
const TooltipHTMLContent$1 = TooltipHTMLContent;
var TooltipRichContent = (
  /** @class */
  function() {
    function H(C) {
      this._show = !1, this._styleCoord = [0, 0, 0, 0], this._enterable = !0, this._zr = C.getZr(), makeStyleCoord(this._styleCoord, this._zr, C.getWidth() / 2, C.getHeight() / 2);
    }
    return H.prototype.update = function(C) {
      var G = C.get("alwaysShowContent");
      G && this._moveIfResized();
    }, H.prototype.show = function() {
      this._hideTimeout && clearTimeout(this._hideTimeout), this.el.show(), this._show = !0;
    }, H.prototype.setContent = function(C, G, U, K, W) {
      var Z = this;
      isObject$3(C) && throwError(process.env.NODE_ENV !== "production" ? "Passing DOM nodes as content is not supported in richText tooltip!" : ""), this.el && this._zr.remove(this.el);
      var X = U.getModel("textStyle");
      this.el = new ZRText$1({
        style: {
          rich: G.richTextStyles,
          text: C,
          lineHeight: 22,
          borderWidth: 1,
          borderColor: K,
          textShadowColor: X.get("textShadowColor"),
          fill: U.get(["textStyle", "color"]),
          padding: getPaddingFromTooltipModel(U, "richText"),
          verticalAlign: "top",
          align: "left"
        },
        z: U.get("z")
      }), each$f(["backgroundColor", "borderRadius", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"], function(ee) {
        Z.el.style[ee] = U.get(ee);
      }), each$f(["textShadowBlur", "textShadowOffsetX", "textShadowOffsetY"], function(ee) {
        Z.el.style[ee] = X.get(ee) || 0;
      }), this._zr.add(this.el);
      var Q = this;
      this.el.on("mouseover", function() {
        Q._enterable && (clearTimeout(Q._hideTimeout), Q._show = !0), Q._inContent = !0;
      }), this.el.on("mouseout", function() {
        Q._enterable && Q._show && Q.hideLater(Q._hideDelay), Q._inContent = !1;
      });
    }, H.prototype.setEnterable = function(C) {
      this._enterable = C;
    }, H.prototype.getSize = function() {
      var C = this.el, G = this.el.getBoundingRect(), U = calcShadowOuterSize(C.style);
      return [G.width + U.left + U.right, G.height + U.top + U.bottom];
    }, H.prototype.moveTo = function(C, G) {
      var U = this.el;
      if (U) {
        var K = this._styleCoord;
        makeStyleCoord(K, this._zr, C, G), C = K[0], G = K[1];
        var W = U.style, Z = mathMaxWith0(W.borderWidth || 0), X = calcShadowOuterSize(W);
        U.x = C + Z + X.left, U.y = G + Z + X.top, U.markRedraw();
      }
    }, H.prototype._moveIfResized = function() {
      var C = this._styleCoord[2], G = this._styleCoord[3];
      this.moveTo(C * this._zr.getWidth(), G * this._zr.getHeight());
    }, H.prototype.hide = function() {
      this.el && this.el.hide(), this._show = !1;
    }, H.prototype.hideLater = function(C) {
      this._show && !(this._inContent && this._enterable) && (C ? (this._hideDelay = C, this._show = !1, this._hideTimeout = setTimeout(bind$1(this.hide, this), C)) : this.hide());
    }, H.prototype.isShow = function() {
      return this._show;
    }, H.prototype.dispose = function() {
      this._zr.remove(this.el);
    }, H;
  }()
);
function mathMaxWith0(H) {
  return Math.max(0, H);
}
function calcShadowOuterSize(H) {
  var C = mathMaxWith0(H.shadowBlur || 0), G = mathMaxWith0(H.shadowOffsetX || 0), U = mathMaxWith0(H.shadowOffsetY || 0);
  return {
    left: mathMaxWith0(C - G),
    right: mathMaxWith0(C + G),
    top: mathMaxWith0(C - U),
    bottom: mathMaxWith0(C + U)
  };
}
function makeStyleCoord(H, C, G, U) {
  H[0] = G, H[1] = U, H[2] = H[0] / C.getWidth(), H[3] = H[1] / C.getHeight();
}
const TooltipRichContent$1 = TooltipRichContent;
var proxyRect = new Rect$3({
  shape: {
    x: -1,
    y: -1,
    width: 2,
    height: 2
  }
}), TooltipView = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G;
    }
    return C.prototype.init = function(G, U) {
      if (!(env$1.node || !U.getDom())) {
        var K = G.getComponent("tooltip"), W = this._renderMode = getTooltipRenderMode(K.get("renderMode"));
        this._tooltipContent = W === "richText" ? new TooltipRichContent$1(U) : new TooltipHTMLContent$1(U.getDom(), U, {
          appendToBody: K.get("appendToBody", !0)
        });
      }
    }, C.prototype.render = function(G, U, K) {
      if (!(env$1.node || !K.getDom())) {
        this.group.removeAll(), this._tooltipModel = G, this._ecModel = U, this._api = K, this._alwaysShowContent = G.get("alwaysShowContent");
        var W = this._tooltipContent;
        W.update(G), W.setEnterable(G.get("enterable")), this._initGlobalListener(), this._keepShow(), this._renderMode !== "richText" && G.get("transitionDuration") ? createOrUpdate(this, "_updatePosition", 50, "fixRate") : clear$1(this, "_updatePosition");
      }
    }, C.prototype._initGlobalListener = function() {
      var G = this._tooltipModel, U = G.get("triggerOn");
      register("itemTooltip", this._api, bind$1(function(K, W, Z) {
        U !== "none" && (U.indexOf(K) >= 0 ? this._tryShow(W, Z) : K === "leave" && this._hide(Z));
      }, this));
    }, C.prototype._keepShow = function() {
      var G = this._tooltipModel, U = this._ecModel, K = this._api, W = G.get("triggerOn");
      if (this._lastX != null && this._lastY != null && W !== "none" && W !== "click") {
        var Z = this;
        clearTimeout(this._refreshUpdateTimeout), this._refreshUpdateTimeout = setTimeout(function() {
          !K.isDisposed() && Z.manuallyShowTip(G, U, K, {
            x: Z._lastX,
            y: Z._lastY,
            dataByCoordSys: Z._lastDataByCoordSys
          });
        });
      }
    }, C.prototype.manuallyShowTip = function(G, U, K, W) {
      if (!(W.from === this.uid || env$1.node || !K.getDom())) {
        var Z = makeDispatchAction(W, K);
        this._ticket = "";
        var X = W.dataByCoordSys, Q = findComponentReference(W, U, K);
        if (Q) {
          var ee = Q.el.getBoundingRect().clone();
          ee.applyTransform(Q.el.transform), this._tryShow({
            offsetX: ee.x + ee.width / 2,
            offsetY: ee.y + ee.height / 2,
            target: Q.el,
            position: W.position,
            // When manully trigger, the mouse is not on the el, so we'd better to
            // position tooltip on the bottom of the el and display arrow is possible.
            positionDefault: "bottom"
          }, Z);
        } else if (W.tooltip && W.x != null && W.y != null) {
          var te = proxyRect;
          te.x = W.x, te.y = W.y, te.update(), getECData(te).tooltipConfig = {
            name: null,
            option: W.tooltip
          }, this._tryShow({
            offsetX: W.x,
            offsetY: W.y,
            target: te
          }, Z);
        } else if (X)
          this._tryShow({
            offsetX: W.x,
            offsetY: W.y,
            position: W.position,
            dataByCoordSys: X,
            tooltipOption: W.tooltipOption
          }, Z);
        else if (W.seriesIndex != null) {
          if (this._manuallyAxisShowTip(G, U, K, W))
            return;
          var re = findPointFromSeries(W, U), ne = re.point[0], ae = re.point[1];
          ne != null && ae != null && this._tryShow({
            offsetX: ne,
            offsetY: ae,
            target: re.el,
            position: W.position,
            // When manully trigger, the mouse is not on the el, so we'd better to
            // position tooltip on the bottom of the el and display arrow is possible.
            positionDefault: "bottom"
          }, Z);
        } else
          W.x != null && W.y != null && (K.dispatchAction({
            type: "updateAxisPointer",
            x: W.x,
            y: W.y
          }), this._tryShow({
            offsetX: W.x,
            offsetY: W.y,
            position: W.position,
            target: K.getZr().findHover(W.x, W.y).target
          }, Z));
      }
    }, C.prototype.manuallyHideTip = function(G, U, K, W) {
      var Z = this._tooltipContent;
      !this._alwaysShowContent && this._tooltipModel && Z.hideLater(this._tooltipModel.get("hideDelay")), this._lastX = this._lastY = this._lastDataByCoordSys = null, W.from !== this.uid && this._hide(makeDispatchAction(W, K));
    }, C.prototype._manuallyAxisShowTip = function(G, U, K, W) {
      var Z = W.seriesIndex, X = W.dataIndex, Q = U.getComponent("axisPointer").coordSysAxesInfo;
      if (!(Z == null || X == null || Q == null)) {
        var ee = U.getSeriesByIndex(Z);
        if (ee) {
          var te = ee.getData(), re = buildTooltipModel([te.getItemModel(X), ee, (ee.coordinateSystem || {}).model], this._tooltipModel);
          if (re.get("trigger") === "axis")
            return K.dispatchAction({
              type: "updateAxisPointer",
              seriesIndex: Z,
              dataIndex: X,
              position: W.position
            }), !0;
        }
      }
    }, C.prototype._tryShow = function(G, U) {
      var K = G.target, W = this._tooltipModel;
      if (W) {
        this._lastX = G.offsetX, this._lastY = G.offsetY;
        var Z = G.dataByCoordSys;
        if (Z && Z.length)
          this._showAxisTooltip(Z, G);
        else if (K) {
          this._lastDataByCoordSys = null;
          var X, Q;
          findEventDispatcher(K, function(ee) {
            if (getECData(ee).dataIndex != null)
              return X = ee, !0;
            if (getECData(ee).tooltipConfig != null)
              return Q = ee, !0;
          }, !0), X ? this._showSeriesItemTooltip(G, X, U) : Q ? this._showComponentItemTooltip(G, Q, U) : this._hide(U);
        } else
          this._lastDataByCoordSys = null, this._hide(U);
      }
    }, C.prototype._showOrMove = function(G, U) {
      var K = G.get("showDelay");
      U = bind$1(U, this), clearTimeout(this._showTimout), K > 0 ? this._showTimout = setTimeout(U, K) : U();
    }, C.prototype._showAxisTooltip = function(G, U) {
      var K = this._ecModel, W = this._tooltipModel, Z = [U.offsetX, U.offsetY], X = buildTooltipModel([U.tooltipOption], W), Q = this._renderMode, ee = [], te = createTooltipMarkup("section", {
        blocks: [],
        noHeader: !0
      }), re = [], ne = new TooltipMarkupStyleCreator();
      each$f(G, function(ue) {
        each$f(ue.dataByAxis, function(ce) {
          var de = K.getComponent(ce.axisDim + "Axis", ce.axisIndex), ge = ce.value;
          if (!(!de || ge == null)) {
            var fe = getValueLabel(ge, de.axis, K, ce.seriesDataIndices, ce.valueLabelOpt), ve = createTooltipMarkup("section", {
              header: fe,
              noHeader: !trim$1(fe),
              sortBlocks: !0,
              blocks: []
            });
            te.blocks.push(ve), each$f(ce.seriesDataIndices, function(pe) {
              var he = K.getSeriesByIndex(pe.seriesIndex), me = pe.dataIndexInside, ye = he.getDataParams(me);
              if (!(ye.dataIndex < 0)) {
                ye.axisDim = ce.axisDim, ye.axisIndex = ce.axisIndex, ye.axisType = ce.axisType, ye.axisId = ce.axisId, ye.axisValue = getAxisRawValue(de.axis, {
                  value: ge
                }), ye.axisValueLabel = fe, ye.marker = ne.makeTooltipMarker("item", convertToColorString(ye.color), Q);
                var Ce = normalizeTooltipFormatResult(he.formatTooltip(me, !0, null)), Ie = Ce.frag;
                if (Ie) {
                  var be = buildTooltipModel([he], W).get("valueFormatter");
                  ve.blocks.push(be ? extend({
                    valueFormatter: be
                  }, Ie) : Ie);
                }
                Ce.text && re.push(Ce.text), ee.push(ye);
              }
            });
          }
        });
      }), te.blocks.reverse(), re.reverse();
      var ae = U.position, ie = X.get("order"), se = buildTooltipMarkup(te, ne, Q, ie, K.get("useUTC"), X.get("textStyle"));
      se && re.unshift(se);
      var oe = Q === "richText" ? `

` : "<br/>", le = re.join(oe);
      this._showOrMove(X, function() {
        this._updateContentNotChangedOnAxis(G, ee) ? this._updatePosition(X, ae, Z[0], Z[1], this._tooltipContent, ee) : this._showTooltipContent(X, le, ee, Math.random() + "", Z[0], Z[1], ae, null, ne);
      });
    }, C.prototype._showSeriesItemTooltip = function(G, U, K) {
      var W = this._ecModel, Z = getECData(U), X = Z.seriesIndex, Q = W.getSeriesByIndex(X), ee = Z.dataModel || Q, te = Z.dataIndex, re = Z.dataType, ne = ee.getData(re), ae = this._renderMode, ie = G.positionDefault, se = buildTooltipModel([ne.getItemModel(te), ee, Q && (Q.coordinateSystem || {}).model], this._tooltipModel, ie ? {
        position: ie
      } : null), oe = se.get("trigger");
      if (!(oe != null && oe !== "item")) {
        var le = ee.getDataParams(te, re), ue = new TooltipMarkupStyleCreator();
        le.marker = ue.makeTooltipMarker("item", convertToColorString(le.color), ae);
        var ce = normalizeTooltipFormatResult(ee.formatTooltip(te, !1, re)), de = se.get("order"), ge = se.get("valueFormatter"), fe = ce.frag, ve = fe ? buildTooltipMarkup(ge ? extend({
          valueFormatter: ge
        }, fe) : fe, ue, ae, de, W.get("useUTC"), se.get("textStyle")) : ce.text, pe = "item_" + ee.name + "_" + te;
        this._showOrMove(se, function() {
          this._showTooltipContent(se, ve, le, pe, G.offsetX, G.offsetY, G.position, G.target, ue);
        }), K({
          type: "showTip",
          dataIndexInside: te,
          dataIndex: ne.getRawIndex(te),
          seriesIndex: X,
          from: this.uid
        });
      }
    }, C.prototype._showComponentItemTooltip = function(G, U, K) {
      var W = getECData(U), Z = W.tooltipConfig, X = Z.option || {};
      if (isString(X)) {
        var Q = X;
        X = {
          content: Q,
          // Fixed formatter
          formatter: Q
        };
      }
      var ee = [X], te = this._ecModel.getComponent(W.componentMainType, W.componentIndex);
      te && ee.push(te), ee.push({
        formatter: X.content
      });
      var re = G.positionDefault, ne = buildTooltipModel(ee, this._tooltipModel, re ? {
        position: re
      } : null), ae = ne.get("content"), ie = Math.random() + "", se = new TooltipMarkupStyleCreator();
      this._showOrMove(ne, function() {
        var oe = clone$4(ne.get("formatterParams") || {});
        this._showTooltipContent(ne, ae, oe, ie, G.offsetX, G.offsetY, G.position, U, se);
      }), K({
        type: "showTip",
        from: this.uid
      });
    }, C.prototype._showTooltipContent = function(G, U, K, W, Z, X, Q, ee, te) {
      if (this._ticket = "", !(!G.get("showContent") || !G.get("show"))) {
        var re = this._tooltipContent;
        re.setEnterable(G.get("enterable"));
        var ne = G.get("formatter");
        Q = Q || G.get("position");
        var ae = U, ie = this._getNearestPoint([Z, X], K, G.get("trigger"), G.get("borderColor")), se = ie.color;
        if (ne)
          if (isString(ne)) {
            var oe = G.ecModel.get("useUTC"), le = isArray$1(K) ? K[0] : K, ue = le && le.axisType && le.axisType.indexOf("time") >= 0;
            ae = ne, ue && (ae = format(le.axisValue, ae, oe)), ae = formatTpl(ae, K, !0);
          } else if (isFunction(ne)) {
            var ce = bind$1(function(de, ge) {
              de === this._ticket && (re.setContent(ge, te, G, se, Q), this._updatePosition(G, Q, Z, X, re, K, ee));
            }, this);
            this._ticket = W, ae = ne(K, W, ce);
          } else
            ae = ne;
        re.setContent(ae, te, G, se, Q), re.show(G, se), this._updatePosition(G, Q, Z, X, re, K, ee);
      }
    }, C.prototype._getNearestPoint = function(G, U, K, W) {
      if (K === "axis" || isArray$1(U))
        return {
          color: W || (this._renderMode === "html" ? "#fff" : "none")
        };
      if (!isArray$1(U))
        return {
          color: W || U.color || U.borderColor
        };
    }, C.prototype._updatePosition = function(G, U, K, W, Z, X, Q) {
      var ee = this._api.getWidth(), te = this._api.getHeight();
      U = U || G.get("position");
      var re = Z.getSize(), ne = G.get("align"), ae = G.get("verticalAlign"), ie = Q && Q.getBoundingRect().clone();
      if (Q && ie.applyTransform(Q.transform), isFunction(U) && (U = U([K, W], X, Z.el, ie, {
        viewSize: [ee, te],
        contentSize: re.slice()
      })), isArray$1(U))
        K = parsePercent(U[0], ee), W = parsePercent(U[1], te);
      else if (isObject$3(U)) {
        var se = U;
        se.width = re[0], se.height = re[1];
        var oe = getLayoutRect(se, {
          width: ee,
          height: te
        });
        K = oe.x, W = oe.y, ne = null, ae = null;
      } else if (isString(U) && Q) {
        var le = calcTooltipPosition(U, ie, re, G.get("borderWidth"));
        K = le[0], W = le[1];
      } else {
        var le = refixTooltipPosition(K, W, Z, ee, te, ne ? null : 20, ae ? null : 20);
        K = le[0], W = le[1];
      }
      if (ne && (K -= isCenterAlign(ne) ? re[0] / 2 : ne === "right" ? re[0] : 0), ae && (W -= isCenterAlign(ae) ? re[1] / 2 : ae === "bottom" ? re[1] : 0), shouldTooltipConfine(G)) {
        var le = confineTooltipPosition(K, W, Z, ee, te);
        K = le[0], W = le[1];
      }
      Z.moveTo(K, W);
    }, C.prototype._updateContentNotChangedOnAxis = function(G, U) {
      var K = this._lastDataByCoordSys, W = this._cbParamsList, Z = !!K && K.length === G.length;
      return Z && each$f(K, function(X, Q) {
        var ee = X.dataByAxis || [], te = G[Q] || {}, re = te.dataByAxis || [];
        Z = Z && ee.length === re.length, Z && each$f(ee, function(ne, ae) {
          var ie = re[ae] || {}, se = ne.seriesDataIndices || [], oe = ie.seriesDataIndices || [];
          Z = Z && ne.value === ie.value && ne.axisType === ie.axisType && ne.axisId === ie.axisId && se.length === oe.length, Z && each$f(se, function(le, ue) {
            var ce = oe[ue];
            Z = Z && le.seriesIndex === ce.seriesIndex && le.dataIndex === ce.dataIndex;
          }), W && each$f(ne.seriesDataIndices, function(le) {
            var ue = le.seriesIndex, ce = U[ue], de = W[ue];
            ce && de && de.data !== ce.data && (Z = !1);
          });
        });
      }), this._lastDataByCoordSys = G, this._cbParamsList = U, !!Z;
    }, C.prototype._hide = function(G) {
      this._lastDataByCoordSys = null, G({
        type: "hideTip",
        from: this.uid
      });
    }, C.prototype.dispose = function(G, U) {
      env$1.node || !U.getDom() || (clear$1(this, "_updatePosition"), this._tooltipContent.dispose(), unregister("itemTooltip", U));
    }, C.type = "tooltip", C;
  }(ComponentView$1)
);
function buildTooltipModel(H, C, G) {
  var U = C.ecModel, K;
  G ? (K = new Model$1(G, U, U), K = new Model$1(C.option, K, U)) : K = C;
  for (var W = H.length - 1; W >= 0; W--) {
    var Z = H[W];
    Z && (Z instanceof Model$1 && (Z = Z.get("tooltip", !0)), isString(Z) && (Z = {
      formatter: Z
    }), Z && (K = new Model$1(Z, K, U)));
  }
  return K;
}
function makeDispatchAction(H, C) {
  return H.dispatchAction || bind$1(C.dispatchAction, C);
}
function refixTooltipPosition(H, C, G, U, K, W, Z) {
  var X = G.getSize(), Q = X[0], ee = X[1];
  return W != null && (H + Q + W + 2 > U ? H -= Q + W : H += W), Z != null && (C + ee + Z > K ? C -= ee + Z : C += Z), [H, C];
}
function confineTooltipPosition(H, C, G, U, K) {
  var W = G.getSize(), Z = W[0], X = W[1];
  return H = Math.min(H + Z, U) - Z, C = Math.min(C + X, K) - X, H = Math.max(H, 0), C = Math.max(C, 0), [H, C];
}
function calcTooltipPosition(H, C, G, U) {
  var K = G[0], W = G[1], Z = Math.ceil(Math.SQRT2 * U) + 8, X = 0, Q = 0, ee = C.width, te = C.height;
  switch (H) {
    case "inside":
      X = C.x + ee / 2 - K / 2, Q = C.y + te / 2 - W / 2;
      break;
    case "top":
      X = C.x + ee / 2 - K / 2, Q = C.y - W - Z;
      break;
    case "bottom":
      X = C.x + ee / 2 - K / 2, Q = C.y + te + Z;
      break;
    case "left":
      X = C.x - K - Z, Q = C.y + te / 2 - W / 2;
      break;
    case "right":
      X = C.x + ee + Z, Q = C.y + te / 2 - W / 2;
  }
  return [X, Q];
}
function isCenterAlign(H) {
  return H === "center" || H === "middle";
}
function findComponentReference(H, C, G) {
  var U = preParseFinder(H).queryOptionMap, K = U.keys()[0];
  if (!(!K || K === "series")) {
    var W = queryReferringComponents(C, K, U.get(K), {
      useDefault: !1,
      enableAll: !1,
      enableNone: !1
    }), Z = W.models[0];
    if (Z) {
      var X = G.getViewOfComponentModel(Z), Q;
      if (X.group.traverse(function(ee) {
        var te = getECData(ee).tooltipConfig;
        if (te && te.name === H.name)
          return Q = ee, !0;
      }), Q)
        return {
          componentMainType: K,
          componentIndex: Z.componentIndex,
          el: Q
        };
    }
  }
}
const TooltipView$1 = TooltipView;
function install$i(H) {
  use(install$q), H.registerComponentModel(TooltipModel$1), H.registerComponentView(TooltipView$1), H.registerAction({
    type: "showTip",
    event: "showTip",
    update: "tooltip:manuallyShowTip"
  }, noop), H.registerAction({
    type: "hideTip",
    event: "hideTip",
    update: "tooltip:manuallyHideTip"
  }, noop);
}
var DEFAULT_TOOLBOX_BTNS = ["rect", "polygon", "keep", "clear"];
function brushPreprocessor(H, C) {
  var G = normalizeToArray(H ? H.brush : []);
  if (G.length) {
    var U = [];
    each$f(G, function(Q) {
      var ee = Q.hasOwnProperty("toolbox") ? Q.toolbox : [];
      ee instanceof Array && (U = U.concat(ee));
    });
    var K = H && H.toolbox;
    isArray$1(K) && (K = K[0]), K || (K = {
      feature: {}
    }, H.toolbox = [K]);
    var W = K.feature || (K.feature = {}), Z = W.brush || (W.brush = {}), X = Z.type || (Z.type = []);
    X.push.apply(X, U), removeDuplicate(X), C && !X.length && X.push.apply(X, DEFAULT_TOOLBOX_BTNS);
  }
}
function removeDuplicate(H) {
  var C = {};
  each$f(H, function(G) {
    C[G] = 1;
  }), H.length = 0, each$f(C, function(G, U) {
    H.push(U);
  });
}
var each$4 = each$f;
function hasKeys(H) {
  if (H) {
    for (var C in H)
      if (H.hasOwnProperty(C))
        return !0;
  }
}
function createVisualMappings(H, C, G) {
  var U = {};
  return each$4(C, function(W) {
    var Z = U[W] = K();
    each$4(H[W], function(X, Q) {
      if (VisualMapping$1.isValidType(Q)) {
        var ee = {
          type: Q,
          visual: X
        };
        G && G(ee, W), Z[Q] = new VisualMapping$1(ee), Q === "opacity" && (ee = clone$4(ee), ee.type = "colorAlpha", Z.__hidden.__alphaForOpacity = new VisualMapping$1(ee));
      }
    });
  }), U;
  function K() {
    var W = function() {
    };
    W.prototype.__hidden = W.prototype;
    var Z = new W();
    return Z;
  }
}
function replaceVisualOption(H, C, G) {
  var U;
  each$f(G, function(K) {
    C.hasOwnProperty(K) && hasKeys(C[K]) && (U = !0);
  }), U && each$f(G, function(K) {
    C.hasOwnProperty(K) && hasKeys(C[K]) ? H[K] = clone$4(C[K]) : delete H[K];
  });
}
function applyVisual(H, C, G, U, K, W) {
  var Z = {};
  each$f(H, function(re) {
    var ne = VisualMapping$1.prepareVisualTypes(C[re]);
    Z[re] = ne;
  });
  var X;
  function Q(re) {
    return getItemVisualFromData(G, X, re);
  }
  function ee(re, ne) {
    setItemVisualFromData(G, X, re, ne);
  }
  W == null ? G.each(te) : G.each([W], te);
  function te(re, ne) {
    X = W == null ? re : ne;
    var ae = G.getRawDataItem(X);
    if (!(ae && ae.visualMap === !1))
      for (var ie = U.call(K, re), se = C[ie], oe = Z[ie], le = 0, ue = oe.length; le < ue; le++) {
        var ce = oe[le];
        se[ce] && se[ce].applyVisual(re, Q, ee);
      }
  }
}
function incrementalApplyVisual(H, C, G, U) {
  var K = {};
  return each$f(H, function(W) {
    var Z = VisualMapping$1.prepareVisualTypes(C[W]);
    K[W] = Z;
  }), {
    progress: function(Z, X) {
      var Q;
      U != null && (Q = X.getDimensionIndex(U));
      function ee(ge) {
        return getItemVisualFromData(X, re, ge);
      }
      function te(ge, fe) {
        setItemVisualFromData(X, re, ge, fe);
      }
      for (var re, ne = X.getStore(); (re = Z.next()) != null; ) {
        var ae = X.getRawDataItem(re);
        if (!(ae && ae.visualMap === !1))
          for (var ie = U != null ? ne.get(Q, re) : re, se = G(ie), oe = C[se], le = K[se], ue = 0, ce = le.length; ue < ce; ue++) {
            var de = le[ue];
            oe[de] && oe[de].applyVisual(ie, ee, te);
          }
      }
    }
  };
}
function makeBrushCommonSelectorForSeries(H) {
  var C = H.brushType, G = {
    point: function(U) {
      return selector[C].point(U, G, H);
    },
    rect: function(U) {
      return selector[C].rect(U, G, H);
    }
  };
  return G;
}
var selector = {
  lineX: getLineSelectors(0),
  lineY: getLineSelectors(1),
  rect: {
    point: function(H, C, G) {
      return H && G.boundingRect.contain(H[0], H[1]);
    },
    rect: function(H, C, G) {
      return H && G.boundingRect.intersect(H);
    }
  },
  polygon: {
    point: function(H, C, G) {
      return H && G.boundingRect.contain(H[0], H[1]) && contain(G.range, H[0], H[1]);
    },
    rect: function(H, C, G) {
      var U = G.range;
      if (!H || U.length <= 1)
        return !1;
      var K = H.x, W = H.y, Z = H.width, X = H.height, Q = U[0];
      if (contain(U, K, W) || contain(U, K + Z, W) || contain(U, K, W + X) || contain(U, K + Z, W + X) || BoundingRect$1.create(H).contain(Q[0], Q[1]) || linePolygonIntersect(K, W, K + Z, W, U) || linePolygonIntersect(K, W, K, W + X, U) || linePolygonIntersect(K + Z, W, K + Z, W + X, U) || linePolygonIntersect(K, W + X, K + Z, W + X, U))
        return !0;
    }
  }
};
function getLineSelectors(H) {
  var C = ["x", "y"], G = ["width", "height"];
  return {
    point: function(U, K, W) {
      if (U) {
        var Z = W.range, X = U[H];
        return inLineRange(X, Z);
      }
    },
    rect: function(U, K, W) {
      if (U) {
        var Z = W.range, X = [U[C[H]], U[C[H]] + U[G[H]]];
        return X[1] < X[0] && X.reverse(), inLineRange(X[0], Z) || inLineRange(X[1], Z) || inLineRange(Z[0], X) || inLineRange(Z[1], X);
      }
    }
  };
}
function inLineRange(H, C) {
  return C[0] <= H && H <= C[1];
}
var STATE_LIST = ["inBrush", "outOfBrush"], DISPATCH_METHOD = "__ecBrushSelect", DISPATCH_FLAG = "__ecInBrushSelectEvent";
function layoutCovers(H) {
  H.eachComponent({
    mainType: "brush"
  }, function(C) {
    var G = C.brushTargetManager = new BrushTargetManager$1(C.option, H);
    G.setInputRanges(C.areas, H);
  });
}
function brushVisual(H, C, G) {
  var U = [], K, W;
  H.eachComponent({
    mainType: "brush"
  }, function(Z) {
    G && G.type === "takeGlobalCursor" && Z.setBrushOption(G.key === "brush" ? G.brushOption : {
      brushType: !1
    });
  }), layoutCovers(H), H.eachComponent({
    mainType: "brush"
  }, function(Z, X) {
    var Q = {
      brushId: Z.id,
      brushIndex: X,
      brushName: Z.name,
      areas: clone$4(Z.areas),
      selected: []
    };
    U.push(Q);
    var ee = Z.option, te = ee.brushLink, re = [], ne = [], ae = [], ie = !1;
    X || (K = ee.throttleType, W = ee.throttleDelay);
    var se = map$1(Z.areas, function(ge) {
      var fe = boundingRectBuilders[ge.brushType], ve = defaults({
        boundingRect: fe ? fe(ge) : void 0
      }, ge);
      return ve.selectors = makeBrushCommonSelectorForSeries(ve), ve;
    }), oe = createVisualMappings(Z.option, STATE_LIST, function(ge) {
      ge.mappingMethod = "fixed";
    });
    isArray$1(te) && each$f(te, function(ge) {
      re[ge] = 1;
    });
    function le(ge) {
      return te === "all" || !!re[ge];
    }
    function ue(ge) {
      return !!ge.length;
    }
    H.eachSeries(function(ge, fe) {
      var ve = ae[fe] = [];
      ge.subType === "parallel" ? ce(ge, fe) : de(ge, fe, ve);
    });
    function ce(ge, fe) {
      var ve = ge.coordinateSystem;
      ie = ie || ve.hasAxisBrushed(), le(fe) && ve.eachActiveState(ge.getData(), function(pe, he) {
        pe === "active" && (ne[he] = 1);
      });
    }
    function de(ge, fe, ve) {
      if (!(!ge.brushSelector || brushModelNotControll(Z, fe)) && (each$f(se, function(he) {
        Z.brushTargetManager.controlSeries(he, ge, H) && ve.push(he), ie = ie || ue(ve);
      }), le(fe) && ue(ve))) {
        var pe = ge.getData();
        pe.each(function(he) {
          checkInRange(ge, ve, pe, he) && (ne[he] = 1);
        });
      }
    }
    H.eachSeries(function(ge, fe) {
      var ve = {
        seriesId: ge.id,
        seriesIndex: fe,
        seriesName: ge.name,
        dataIndex: []
      };
      Q.selected.push(ve);
      var pe = ae[fe], he = ge.getData(), me = le(fe) ? function(ye) {
        return ne[ye] ? (ve.dataIndex.push(he.getRawIndex(ye)), "inBrush") : "outOfBrush";
      } : function(ye) {
        return checkInRange(ge, pe, he, ye) ? (ve.dataIndex.push(he.getRawIndex(ye)), "inBrush") : "outOfBrush";
      };
      (le(fe) ? ie : ue(pe)) && applyVisual(STATE_LIST, oe, he, me);
    });
  }), dispatchAction$1(C, K, W, U, G);
}
function dispatchAction$1(H, C, G, U, K) {
  if (K) {
    var W = H.getZr();
    if (!W[DISPATCH_FLAG]) {
      W[DISPATCH_METHOD] || (W[DISPATCH_METHOD] = doDispatch);
      var Z = createOrUpdate(W, DISPATCH_METHOD, G, C);
      Z(H, U);
    }
  }
}
function doDispatch(H, C) {
  if (!H.isDisposed()) {
    var G = H.getZr();
    G[DISPATCH_FLAG] = !0, H.dispatchAction({
      type: "brushSelect",
      batch: C
    }), G[DISPATCH_FLAG] = !1;
  }
}
function checkInRange(H, C, G, U) {
  for (var K = 0, W = C.length; K < W; K++) {
    var Z = C[K];
    if (H.brushSelector(U, G, Z.selectors, Z))
      return !0;
  }
}
function brushModelNotControll(H, C) {
  var G = H.option.seriesIndex;
  return G != null && G !== "all" && (isArray$1(G) ? indexOf(G, C) < 0 : C !== G);
}
var boundingRectBuilders = {
  rect: function(H) {
    return getBoundingRectFromMinMax(H.range);
  },
  polygon: function(H) {
    for (var C, G = H.range, U = 0, K = G.length; U < K; U++) {
      C = C || [[1 / 0, -1 / 0], [1 / 0, -1 / 0]];
      var W = G[U];
      W[0] < C[0][0] && (C[0][0] = W[0]), W[0] > C[0][1] && (C[0][1] = W[0]), W[1] < C[1][0] && (C[1][0] = W[1]), W[1] > C[1][1] && (C[1][1] = W[1]);
    }
    return C && getBoundingRectFromMinMax(C);
  }
};
function getBoundingRectFromMinMax(H) {
  return new BoundingRect$1(H[0][0], H[1][0], H[0][1] - H[0][0], H[1][1] - H[1][0]);
}
var BrushView = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G;
    }
    return C.prototype.init = function(G, U) {
      this.ecModel = G, this.api = U, this.model, (this._brushController = new BrushController$1(U.getZr())).on("brush", bind$1(this._onBrush, this)).mount();
    }, C.prototype.render = function(G, U, K, W) {
      this.model = G, this._updateController(G, U, K, W);
    }, C.prototype.updateTransform = function(G, U, K, W) {
      layoutCovers(U), this._updateController(G, U, K, W);
    }, C.prototype.updateVisual = function(G, U, K, W) {
      this.updateTransform(G, U, K, W);
    }, C.prototype.updateView = function(G, U, K, W) {
      this._updateController(G, U, K, W);
    }, C.prototype._updateController = function(G, U, K, W) {
      (!W || W.$from !== G.id) && this._brushController.setPanels(G.brushTargetManager.makePanelOpts(K)).enableBrush(G.brushOption).updateCovers(G.areas.slice());
    }, C.prototype.dispose = function() {
      this._brushController.dispose();
    }, C.prototype._onBrush = function(G) {
      var U = this.model.id, K = this.model.brushTargetManager.setOutputRanges(G.areas, this.ecModel);
      (!G.isEnd || G.removeOnClick) && this.api.dispatchAction({
        type: "brush",
        brushId: U,
        areas: clone$4(K),
        $from: U
      }), G.isEnd && this.api.dispatchAction({
        type: "brushEnd",
        brushId: U,
        areas: clone$4(K),
        $from: U
      });
    }, C.type = "brush", C;
  }(ComponentView$1)
);
const BrushView$1 = BrushView;
var DEFAULT_OUT_OF_BRUSH_COLOR = "#ddd", BrushModel = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G.areas = [], G.brushOption = {}, G;
    }
    return C.prototype.optionUpdated = function(G, U) {
      var K = this.option;
      !U && replaceVisualOption(K, G, ["inBrush", "outOfBrush"]);
      var W = K.inBrush = K.inBrush || {};
      K.outOfBrush = K.outOfBrush || {
        color: DEFAULT_OUT_OF_BRUSH_COLOR
      }, W.hasOwnProperty("liftZ") || (W.liftZ = 5);
    }, C.prototype.setAreas = function(G) {
      process.env.NODE_ENV !== "production" && (assert(isArray$1(G)), each$f(G, function(U) {
        assert(U.brushType, "Illegal areas");
      })), G && (this.areas = map$1(G, function(U) {
        return generateBrushOption(this.option, U);
      }, this));
    }, C.prototype.setBrushOption = function(G) {
      this.brushOption = generateBrushOption(this.option, G), this.brushType = this.brushOption.brushType;
    }, C.type = "brush", C.dependencies = ["geo", "grid", "xAxis", "yAxis", "parallel", "series"], C.defaultOption = {
      seriesIndex: "all",
      brushType: "rect",
      brushMode: "single",
      transformable: !0,
      brushStyle: {
        borderWidth: 1,
        color: "rgba(210,219,238,0.3)",
        borderColor: "#D2DBEE"
      },
      throttleType: "fixRate",
      throttleDelay: 0,
      removeOnClick: !0,
      z: 1e4
    }, C;
  }(ComponentModel$1)
);
function generateBrushOption(H, C) {
  return merge({
    brushType: H.brushType,
    brushMode: H.brushMode,
    transformable: H.transformable,
    brushStyle: new Model$1(H.brushStyle).getItemStyle(),
    removeOnClick: H.removeOnClick,
    z: H.z
  }, C, !0);
}
const BrushModel$1 = BrushModel;
var ICON_TYPES = ["rect", "polygon", "lineX", "lineY", "keep", "clear"], BrushFeature = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      return H !== null && H.apply(this, arguments) || this;
    }
    return C.prototype.render = function(G, U, K) {
      var W, Z, X;
      U.eachComponent({
        mainType: "brush"
      }, function(Q) {
        W = Q.brushType, Z = Q.brushOption.brushMode || "single", X = X || !!Q.areas.length;
      }), this._brushType = W, this._brushMode = Z, each$f(G.get("type", !0), function(Q) {
        G.setIconStatus(Q, (Q === "keep" ? Z === "multiple" : Q === "clear" ? X : Q === W) ? "emphasis" : "normal");
      });
    }, C.prototype.updateView = function(G, U, K) {
      this.render(G, U, K);
    }, C.prototype.getIcons = function() {
      var G = this.model, U = G.get("icon", !0), K = {};
      return each$f(G.get("type", !0), function(W) {
        U[W] && (K[W] = U[W]);
      }), K;
    }, C.prototype.onclick = function(G, U, K) {
      var W = this._brushType, Z = this._brushMode;
      K === "clear" ? (U.dispatchAction({
        type: "axisAreaSelect",
        intervals: []
      }), U.dispatchAction({
        type: "brush",
        command: "clear",
        // Clear all areas of all brush components.
        areas: []
      })) : U.dispatchAction({
        type: "takeGlobalCursor",
        key: "brush",
        brushOption: {
          brushType: K === "keep" ? W : W === K ? !1 : K,
          brushMode: K === "keep" ? Z === "multiple" ? "single" : "multiple" : Z
        }
      });
    }, C.getDefaultOption = function(G) {
      var U = {
        show: !0,
        type: ICON_TYPES.slice(),
        icon: {
          /* eslint-disable */
          rect: "M7.3,34.7 M0.4,10V-0.2h9.8 M89.6,10V-0.2h-9.8 M0.4,60v10.2h9.8 M89.6,60v10.2h-9.8 M12.3,22.4V10.5h13.1 M33.6,10.5h7.8 M49.1,10.5h7.8 M77.5,22.4V10.5h-13 M12.3,31.1v8.2 M77.7,31.1v8.2 M12.3,47.6v11.9h13.1 M33.6,59.5h7.6 M49.1,59.5 h7.7 M77.5,47.6v11.9h-13",
          polygon: "M55.2,34.9c1.7,0,3.1,1.4,3.1,3.1s-1.4,3.1-3.1,3.1 s-3.1-1.4-3.1-3.1S53.5,34.9,55.2,34.9z M50.4,51c1.7,0,3.1,1.4,3.1,3.1c0,1.7-1.4,3.1-3.1,3.1c-1.7,0-3.1-1.4-3.1-3.1 C47.3,52.4,48.7,51,50.4,51z M55.6,37.1l1.5-7.8 M60.1,13.5l1.6-8.7l-7.8,4 M59,19l-1,5.3 M24,16.1l6.4,4.9l6.4-3.3 M48.5,11.6 l-5.9,3.1 M19.1,12.8L9.7,5.1l1.1,7.7 M13.4,29.8l1,7.3l6.6,1.6 M11.6,18.4l1,6.1 M32.8,41.9 M26.6,40.4 M27.3,40.2l6.1,1.6 M49.9,52.1l-5.6-7.6l-4.9-1.2",
          lineX: "M15.2,30 M19.7,15.6V1.9H29 M34.8,1.9H40.4 M55.3,15.6V1.9H45.9 M19.7,44.4V58.1H29 M34.8,58.1H40.4 M55.3,44.4 V58.1H45.9 M12.5,20.3l-9.4,9.6l9.6,9.8 M3.1,29.9h16.5 M62.5,20.3l9.4,9.6L62.3,39.7 M71.9,29.9H55.4",
          lineY: "M38.8,7.7 M52.7,12h13.2v9 M65.9,26.6V32 M52.7,46.3h13.2v-9 M24.9,12H11.8v9 M11.8,26.6V32 M24.9,46.3H11.8v-9 M48.2,5.1l-9.3-9l-9.4,9.2 M38.9-3.9V12 M48.2,53.3l-9.3,9l-9.4-9.2 M38.9,62.3V46.4",
          keep: "M4,10.5V1h10.3 M20.7,1h6.1 M33,1h6.1 M55.4,10.5V1H45.2 M4,17.3v6.6 M55.6,17.3v6.6 M4,30.5V40h10.3 M20.7,40 h6.1 M33,40h6.1 M55.4,30.5V40H45.2 M21,18.9h62.9v48.6H21V18.9z",
          clear: "M22,14.7l30.9,31 M52.9,14.7L22,45.7 M4.7,16.8V4.2h13.1 M26,4.2h7.8 M41.6,4.2h7.8 M70.3,16.8V4.2H57.2 M4.7,25.9v8.6 M70.3,25.9v8.6 M4.7,43.2v12.6h13.1 M26,55.8h7.8 M41.6,55.8h7.8 M70.3,43.2v12.6H57.2"
          // jshint ignore:line
          /* eslint-enable */
        },
        // `rect`, `polygon`, `lineX`, `lineY`, `keep`, `clear`
        title: G.getLocaleModel().get(["toolbox", "brush", "title"])
      };
      return U;
    }, C;
  }(ToolboxFeature)
);
const BrushFeature$1 = BrushFeature;
function install$h(H) {
  H.registerComponentView(BrushView$1), H.registerComponentModel(BrushModel$1), H.registerPreprocessor(brushPreprocessor), H.registerVisual(H.PRIORITY.VISUAL.BRUSH, brushVisual), H.registerAction({
    type: "brush",
    event: "brush",
    update: "updateVisual"
  }, function(C, G) {
    G.eachComponent({
      mainType: "brush",
      query: C
    }, function(U) {
      U.setAreas(C.areas);
    });
  }), H.registerAction({
    type: "brushSelect",
    event: "brushSelected",
    update: "none"
  }, noop), H.registerAction({
    type: "brushEnd",
    event: "brushEnd",
    update: "none"
  }, noop), registerFeature("brush", BrushFeature$1);
}
var TitleModel = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G.layoutMode = {
        type: "box",
        ignoreSize: !0
      }, G;
    }
    return C.type = "title", C.defaultOption = {
      // zlevel: 0,
      z: 6,
      show: !0,
      text: "",
      target: "blank",
      subtext: "",
      subtarget: "blank",
      left: 0,
      top: 0,
      backgroundColor: "rgba(0,0,0,0)",
      borderColor: "#ccc",
      borderWidth: 0,
      padding: 5,
      itemGap: 10,
      textStyle: {
        fontSize: 18,
        fontWeight: "bold",
        color: "#464646"
      },
      subtextStyle: {
        fontSize: 12,
        color: "#6E7079"
      }
    }, C;
  }(ComponentModel$1)
), TitleView = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G;
    }
    return C.prototype.render = function(G, U, K) {
      if (this.group.removeAll(), !!G.get("show")) {
        var W = this.group, Z = G.getModel("textStyle"), X = G.getModel("subtextStyle"), Q = G.get("textAlign"), ee = retrieve2(G.get("textBaseline"), G.get("textVerticalAlign")), te = new ZRText$1({
          style: createTextStyle(Z, {
            text: G.get("text"),
            fill: Z.getTextColor()
          }, {
            disableBox: !0
          }),
          z2: 10
        }), re = te.getBoundingRect(), ne = G.get("subtext"), ae = new ZRText$1({
          style: createTextStyle(X, {
            text: ne,
            fill: X.getTextColor(),
            y: re.height + G.get("itemGap"),
            verticalAlign: "top"
          }, {
            disableBox: !0
          }),
          z2: 10
        }), ie = G.get("link"), se = G.get("sublink"), oe = G.get("triggerEvent", !0);
        te.silent = !ie && !oe, ae.silent = !se && !oe, ie && te.on("click", function() {
          windowOpen(ie, "_" + G.get("target"));
        }), se && ae.on("click", function() {
          windowOpen(se, "_" + G.get("subtarget"));
        }), getECData(te).eventData = getECData(ae).eventData = oe ? {
          componentType: "title",
          componentIndex: G.componentIndex
        } : null, W.add(te), ne && W.add(ae);
        var le = W.getBoundingRect(), ue = G.getBoxLayoutParams();
        ue.width = le.width, ue.height = le.height;
        var ce = getLayoutRect(ue, {
          width: K.getWidth(),
          height: K.getHeight()
        }, G.get("padding"));
        Q || (Q = G.get("left") || G.get("right"), Q === "middle" && (Q = "center"), Q === "right" ? ce.x += ce.width : Q === "center" && (ce.x += ce.width / 2)), ee || (ee = G.get("top") || G.get("bottom"), ee === "center" && (ee = "middle"), ee === "bottom" ? ce.y += ce.height : ee === "middle" && (ce.y += ce.height / 2), ee = ee || "top"), W.x = ce.x, W.y = ce.y, W.markRedraw();
        var de = {
          align: Q,
          verticalAlign: ee
        };
        te.setStyle(de), ae.setStyle(de), le = W.getBoundingRect();
        var ge = ce.margin, fe = G.getItemStyle(["color", "opacity"]);
        fe.fill = G.get("backgroundColor");
        var ve = new Rect$3({
          shape: {
            x: le.x - ge[3],
            y: le.y - ge[0],
            width: le.width + ge[1] + ge[3],
            height: le.height + ge[0] + ge[2],
            r: G.get("borderRadius")
          },
          style: fe,
          subPixelOptimize: !0,
          silent: !0
        });
        W.add(ve);
      }
    }, C.type = "title", C;
  }(ComponentView$1)
);
function install$g(H) {
  H.registerComponentModel(TitleModel), H.registerComponentView(TitleView);
}
var TimelineModel = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G.layoutMode = "box", G;
    }
    return C.prototype.init = function(G, U, K) {
      this.mergeDefaultAndTheme(G, K), this._initData();
    }, C.prototype.mergeOption = function(G) {
      H.prototype.mergeOption.apply(this, arguments), this._initData();
    }, C.prototype.setCurrentIndex = function(G) {
      G == null && (G = this.option.currentIndex);
      var U = this._data.count();
      this.option.loop ? G = (G % U + U) % U : (G >= U && (G = U - 1), G < 0 && (G = 0)), this.option.currentIndex = G;
    }, C.prototype.getCurrentIndex = function() {
      return this.option.currentIndex;
    }, C.prototype.isIndexMax = function() {
      return this.getCurrentIndex() >= this._data.count() - 1;
    }, C.prototype.setPlayState = function(G) {
      this.option.autoPlay = !!G;
    }, C.prototype.getPlayState = function() {
      return !!this.option.autoPlay;
    }, C.prototype._initData = function() {
      var G = this.option, U = G.data || [], K = G.axisType, W = this._names = [], Z;
      K === "category" ? (Z = [], each$f(U, function(ee, te) {
        var re = convertOptionIdName(getDataItemValue(ee), ""), ne;
        isObject$3(ee) ? (ne = clone$4(ee), ne.value = te) : ne = te, Z.push(ne), W.push(re);
      })) : Z = U;
      var X = {
        category: "ordinal",
        time: "time",
        value: "number"
      }[K] || "number", Q = this._data = new SeriesData$1([{
        name: "value",
        type: X
      }], this);
      Q.initData(Z, W);
    }, C.prototype.getData = function() {
      return this._data;
    }, C.prototype.getCategories = function() {
      if (this.get("axisType") === "category")
        return this._names.slice();
    }, C.type = "timeline", C.defaultOption = {
      // zlevel: 0,                  // 一级层叠
      z: 4,
      show: !0,
      axisType: "time",
      realtime: !0,
      left: "20%",
      top: null,
      right: "20%",
      bottom: 0,
      width: null,
      height: 40,
      padding: 5,
      controlPosition: "left",
      autoPlay: !1,
      rewind: !1,
      loop: !0,
      playInterval: 2e3,
      currentIndex: 0,
      itemStyle: {},
      label: {
        color: "#000"
      },
      data: []
    }, C;
  }(ComponentModel$1)
);
const TimelineModel$1 = TimelineModel;
var SliderTimelineModel = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G;
    }
    return C.type = "timeline.slider", C.defaultOption = inheritDefaultOption(TimelineModel$1.defaultOption, {
      backgroundColor: "rgba(0,0,0,0)",
      borderColor: "#ccc",
      borderWidth: 0,
      orient: "horizontal",
      inverse: !1,
      tooltip: {
        trigger: "item"
        // data item may also have tootip attr.
      },
      symbol: "circle",
      symbolSize: 12,
      lineStyle: {
        show: !0,
        width: 2,
        color: "#DAE1F5"
      },
      label: {
        position: "auto",
        // When using number, label position is not
        // restricted by viewRect.
        // positive: right/bottom, negative: left/top
        show: !0,
        interval: "auto",
        rotate: 0,
        // formatter: null,
        // 其余属性默认使用全局文本样式，详见TEXTSTYLE
        color: "#A4B1D7"
      },
      itemStyle: {
        color: "#A4B1D7",
        borderWidth: 1
      },
      checkpointStyle: {
        symbol: "circle",
        symbolSize: 15,
        color: "#316bf3",
        borderColor: "#fff",
        borderWidth: 2,
        shadowBlur: 2,
        shadowOffsetX: 1,
        shadowOffsetY: 1,
        shadowColor: "rgba(0, 0, 0, 0.3)",
        // borderColor: 'rgba(194,53,49, 0.5)',
        animation: !0,
        animationDuration: 300,
        animationEasing: "quinticInOut"
      },
      controlStyle: {
        show: !0,
        showPlayBtn: !0,
        showPrevBtn: !0,
        showNextBtn: !0,
        itemSize: 24,
        itemGap: 12,
        position: "left",
        playIcon: "path://M31.6,53C17.5,53,6,41.5,6,27.4S17.5,1.8,31.6,1.8C45.7,1.8,57.2,13.3,57.2,27.4S45.7,53,31.6,53z M31.6,3.3 C18.4,3.3,7.5,14.1,7.5,27.4c0,13.3,10.8,24.1,24.1,24.1C44.9,51.5,55.7,40.7,55.7,27.4C55.7,14.1,44.9,3.3,31.6,3.3z M24.9,21.3 c0-2.2,1.6-3.1,3.5-2l10.5,6.1c1.899,1.1,1.899,2.9,0,4l-10.5,6.1c-1.9,1.1-3.5,0.2-3.5-2V21.3z",
        stopIcon: "path://M30.9,53.2C16.8,53.2,5.3,41.7,5.3,27.6S16.8,2,30.9,2C45,2,56.4,13.5,56.4,27.6S45,53.2,30.9,53.2z M30.9,3.5C17.6,3.5,6.8,14.4,6.8,27.6c0,13.3,10.8,24.1,24.101,24.1C44.2,51.7,55,40.9,55,27.6C54.9,14.4,44.1,3.5,30.9,3.5z M36.9,35.8c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H36c0.5,0,0.9,0.4,0.9,1V35.8z M27.8,35.8 c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H27c0.5,0,0.9,0.4,0.9,1L27.8,35.8L27.8,35.8z",
        // eslint-disable-next-line max-len
        nextIcon: "M2,18.5A1.52,1.52,0,0,1,.92,18a1.49,1.49,0,0,1,0-2.12L7.81,9.36,1,3.11A1.5,1.5,0,1,1,3,.89l8,7.34a1.48,1.48,0,0,1,.49,1.09,1.51,1.51,0,0,1-.46,1.1L3,18.08A1.5,1.5,0,0,1,2,18.5Z",
        // eslint-disable-next-line max-len
        prevIcon: "M10,.5A1.52,1.52,0,0,1,11.08,1a1.49,1.49,0,0,1,0,2.12L4.19,9.64,11,15.89a1.5,1.5,0,1,1-2,2.22L1,10.77A1.48,1.48,0,0,1,.5,9.68,1.51,1.51,0,0,1,1,8.58L9,.92A1.5,1.5,0,0,1,10,.5Z",
        prevBtnSize: 18,
        nextBtnSize: 18,
        color: "#A4B1D7",
        borderColor: "#A4B1D7",
        borderWidth: 1
      },
      emphasis: {
        label: {
          show: !0,
          // 其余属性默认使用全局文本样式，详见TEXTSTYLE
          color: "#6f778d"
        },
        itemStyle: {
          color: "#316BF3"
        },
        controlStyle: {
          color: "#316BF3",
          borderColor: "#316BF3",
          borderWidth: 2
        }
      },
      progress: {
        lineStyle: {
          color: "#316BF3"
        },
        itemStyle: {
          color: "#316BF3"
        },
        label: {
          color: "#6f778d"
        }
      },
      data: []
    }), C;
  }(TimelineModel$1)
);
mixin(SliderTimelineModel, DataFormatMixin.prototype);
const SliderTimelineModel$1 = SliderTimelineModel;
var TimelineView = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G;
    }
    return C.type = "timeline", C;
  }(ComponentView$1)
);
const TimelineView$1 = TimelineView;
var TimelineAxis = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C(G, U, K, W) {
      var Z = H.call(this, G, U, K) || this;
      return Z.type = W || "value", Z;
    }
    return C.prototype.getLabelModel = function() {
      return this.model.getModel("label");
    }, C.prototype.isHorizontal = function() {
      return this.model.get("orient") === "horizontal";
    }, C;
  }(Axis$1)
);
const TimelineAxis$1 = TimelineAxis;
var PI = Math.PI, labelDataIndexStore = makeInner(), SliderTimelineView = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G;
    }
    return C.prototype.init = function(G, U) {
      this.api = U;
    }, C.prototype.render = function(G, U, K) {
      if (this.model = G, this.api = K, this.ecModel = U, this.group.removeAll(), G.get("show", !0)) {
        var W = this._layout(G, K), Z = this._createGroup("_mainGroup"), X = this._createGroup("_labelGroup"), Q = this._axis = this._createAxis(W, G);
        G.formatTooltip = function(ee) {
          var te = Q.scale.getLabel({
            value: ee
          });
          return createTooltipMarkup("nameValue", {
            noName: !0,
            value: te
          });
        }, each$f(["AxisLine", "AxisTick", "Control", "CurrentPointer"], function(ee) {
          this["_render" + ee](W, Z, Q, G);
        }, this), this._renderAxisLabel(W, X, Q, G), this._position(W, G);
      }
      this._doPlayStop(), this._updateTicksStatus();
    }, C.prototype.remove = function() {
      this._clearTimer(), this.group.removeAll();
    }, C.prototype.dispose = function() {
      this._clearTimer();
    }, C.prototype._layout = function(G, U) {
      var K = G.get(["label", "position"]), W = G.get("orient"), Z = getViewRect(G, U), X;
      K == null || K === "auto" ? X = W === "horizontal" ? Z.y + Z.height / 2 < U.getHeight() / 2 ? "-" : "+" : Z.x + Z.width / 2 < U.getWidth() / 2 ? "+" : "-" : isString(K) ? X = {
        horizontal: {
          top: "-",
          bottom: "+"
        },
        vertical: {
          left: "-",
          right: "+"
        }
      }[W][K] : X = K;
      var Q = {
        horizontal: "center",
        vertical: X >= 0 || X === "+" ? "left" : "right"
      }, ee = {
        horizontal: X >= 0 || X === "+" ? "top" : "bottom",
        vertical: "middle"
      }, te = {
        horizontal: 0,
        vertical: PI / 2
      }, re = W === "vertical" ? Z.height : Z.width, ne = G.getModel("controlStyle"), ae = ne.get("show", !0), ie = ae ? ne.get("itemSize") : 0, se = ae ? ne.get("itemGap") : 0, oe = ie + se, le = G.get(["label", "rotate"]) || 0;
      le = le * PI / 180;
      var ue, ce, de, ge = ne.get("position", !0), fe = ae && ne.get("showPlayBtn", !0), ve = ae && ne.get("showPrevBtn", !0), pe = ae && ne.get("showNextBtn", !0), he = 0, me = re;
      ge === "left" || ge === "bottom" ? (fe && (ue = [0, 0], he += oe), ve && (ce = [he, 0], he += oe), pe && (de = [me - ie, 0], me -= oe)) : (fe && (ue = [me - ie, 0], me -= oe), ve && (ce = [0, 0], he += oe), pe && (de = [me - ie, 0], me -= oe));
      var ye = [he, me];
      return G.get("inverse") && ye.reverse(), {
        viewRect: Z,
        mainLength: re,
        orient: W,
        rotation: te[W],
        labelRotation: le,
        labelPosOpt: X,
        labelAlign: G.get(["label", "align"]) || Q[W],
        labelBaseline: G.get(["label", "verticalAlign"]) || G.get(["label", "baseline"]) || ee[W],
        // Based on mainGroup.
        playPosition: ue,
        prevBtnPosition: ce,
        nextBtnPosition: de,
        axisExtent: ye,
        controlSize: ie,
        controlGap: se
      };
    }, C.prototype._position = function(G, U) {
      var K = this._mainGroup, W = this._labelGroup, Z = G.viewRect;
      if (G.orient === "vertical") {
        var X = create$1(), Q = Z.x, ee = Z.y + Z.height;
        translate(X, X, [-Q, -ee]), rotate(X, X, -PI / 2), translate(X, X, [Q, ee]), Z = Z.clone(), Z.applyTransform(X);
      }
      var te = ue(Z), re = ue(K.getBoundingRect()), ne = ue(W.getBoundingRect()), ae = [K.x, K.y], ie = [W.x, W.y];
      ie[0] = ae[0] = te[0][0];
      var se = G.labelPosOpt;
      if (se == null || isString(se)) {
        var oe = se === "+" ? 0 : 1;
        ce(ae, re, te, 1, oe), ce(ie, ne, te, 1, 1 - oe);
      } else {
        var oe = se >= 0 ? 0 : 1;
        ce(ae, re, te, 1, oe), ie[1] = ae[1] + se;
      }
      K.setPosition(ae), W.setPosition(ie), K.rotation = W.rotation = G.rotation, le(K), le(W);
      function le(de) {
        de.originX = te[0][0] - de.x, de.originY = te[1][0] - de.y;
      }
      function ue(de) {
        return [[de.x, de.x + de.width], [de.y, de.y + de.height]];
      }
      function ce(de, ge, fe, ve, pe) {
        de[ve] += fe[ve][pe] - ge[ve][pe];
      }
    }, C.prototype._createAxis = function(G, U) {
      var K = U.getData(), W = U.get("axisType"), Z = createScaleByModel(U, W);
      Z.getTicks = function() {
        return K.mapArray(["value"], function(ee) {
          return {
            value: ee
          };
        });
      };
      var X = K.getDataExtent("value");
      Z.setExtent(X[0], X[1]), Z.calcNiceTicks();
      var Q = new TimelineAxis$1("value", Z, G.axisExtent, W);
      return Q.model = U, Q;
    }, C.prototype._createGroup = function(G) {
      var U = this[G] = new Group$4();
      return this.group.add(U), U;
    }, C.prototype._renderAxisLine = function(G, U, K, W) {
      var Z = K.getExtent();
      if (W.get(["lineStyle", "show"])) {
        var X = new Line$3({
          shape: {
            x1: Z[0],
            y1: 0,
            x2: Z[1],
            y2: 0
          },
          style: extend({
            lineCap: "round"
          }, W.getModel("lineStyle").getLineStyle()),
          silent: !0,
          z2: 1
        });
        U.add(X);
        var Q = this._progressLine = new Line$3({
          shape: {
            x1: Z[0],
            x2: this._currentPointer ? this._currentPointer.x : Z[0],
            y1: 0,
            y2: 0
          },
          style: defaults({
            lineCap: "round",
            lineWidth: X.style.lineWidth
          }, W.getModel(["progress", "lineStyle"]).getLineStyle()),
          silent: !0,
          z2: 1
        });
        U.add(Q);
      }
    }, C.prototype._renderAxisTick = function(G, U, K, W) {
      var Z = this, X = W.getData(), Q = K.scale.getTicks();
      this._tickSymbols = [], each$f(Q, function(ee) {
        var te = K.dataToCoord(ee.value), re = X.getItemModel(ee.value), ne = re.getModel("itemStyle"), ae = re.getModel(["emphasis", "itemStyle"]), ie = re.getModel(["progress", "itemStyle"]), se = {
          x: te,
          y: 0,
          onclick: bind$1(Z._changeTimeline, Z, ee.value)
        }, oe = giveSymbol(re, ne, U, se);
        oe.ensureState("emphasis").style = ae.getItemStyle(), oe.ensureState("progress").style = ie.getItemStyle(), enableHoverEmphasis(oe);
        var le = getECData(oe);
        re.get("tooltip") ? (le.dataIndex = ee.value, le.dataModel = W) : le.dataIndex = le.dataModel = null, Z._tickSymbols.push(oe);
      });
    }, C.prototype._renderAxisLabel = function(G, U, K, W) {
      var Z = this, X = K.getLabelModel();
      if (X.get("show")) {
        var Q = W.getData(), ee = K.getViewLabels();
        this._tickLabels = [], each$f(ee, function(te) {
          var re = te.tickValue, ne = Q.getItemModel(re), ae = ne.getModel("label"), ie = ne.getModel(["emphasis", "label"]), se = ne.getModel(["progress", "label"]), oe = K.dataToCoord(te.tickValue), le = new ZRText$1({
            x: oe,
            y: 0,
            rotation: G.labelRotation - G.rotation,
            onclick: bind$1(Z._changeTimeline, Z, re),
            silent: !1,
            style: createTextStyle(ae, {
              text: te.formattedLabel,
              align: G.labelAlign,
              verticalAlign: G.labelBaseline
            })
          });
          le.ensureState("emphasis").style = createTextStyle(ie), le.ensureState("progress").style = createTextStyle(se), U.add(le), enableHoverEmphasis(le), labelDataIndexStore(le).dataIndex = re, Z._tickLabels.push(le);
        });
      }
    }, C.prototype._renderControl = function(G, U, K, W) {
      var Z = G.controlSize, X = G.rotation, Q = W.getModel("controlStyle").getItemStyle(), ee = W.getModel(["emphasis", "controlStyle"]).getItemStyle(), te = W.getPlayState(), re = W.get("inverse", !0);
      ne(G.nextBtnPosition, "next", bind$1(this._changeTimeline, this, re ? "-" : "+")), ne(G.prevBtnPosition, "prev", bind$1(this._changeTimeline, this, re ? "+" : "-")), ne(G.playPosition, te ? "stop" : "play", bind$1(this._handlePlayClick, this, !te), !0);
      function ne(ae, ie, se, oe) {
        if (ae) {
          var le = parsePercent$1(retrieve2(W.get(["controlStyle", ie + "BtnSize"]), Z), Z), ue = [0, -le / 2, le, le], ce = makeControlIcon(W, ie + "Icon", ue, {
            x: ae[0],
            y: ae[1],
            originX: Z / 2,
            originY: 0,
            rotation: oe ? -X : 0,
            rectHover: !0,
            style: Q,
            onclick: se
          });
          ce.ensureState("emphasis").style = ee, U.add(ce), enableHoverEmphasis(ce);
        }
      }
    }, C.prototype._renderCurrentPointer = function(G, U, K, W) {
      var Z = W.getData(), X = W.getCurrentIndex(), Q = Z.getItemModel(X).getModel("checkpointStyle"), ee = this, te = {
        onCreate: function(re) {
          re.draggable = !0, re.drift = bind$1(ee._handlePointerDrag, ee), re.ondragend = bind$1(ee._handlePointerDragend, ee), pointerMoveTo(re, ee._progressLine, X, K, W, !0);
        },
        onUpdate: function(re) {
          pointerMoveTo(re, ee._progressLine, X, K, W);
        }
      };
      this._currentPointer = giveSymbol(Q, Q, this._mainGroup, {}, this._currentPointer, te);
    }, C.prototype._handlePlayClick = function(G) {
      this._clearTimer(), this.api.dispatchAction({
        type: "timelinePlayChange",
        playState: G,
        from: this.uid
      });
    }, C.prototype._handlePointerDrag = function(G, U, K) {
      this._clearTimer(), this._pointerChangeTimeline([K.offsetX, K.offsetY]);
    }, C.prototype._handlePointerDragend = function(G) {
      this._pointerChangeTimeline([G.offsetX, G.offsetY], !0);
    }, C.prototype._pointerChangeTimeline = function(G, U) {
      var K = this._toAxisCoord(G)[0], W = this._axis, Z = asc$2(W.getExtent().slice());
      K > Z[1] && (K = Z[1]), K < Z[0] && (K = Z[0]), this._currentPointer.x = K, this._currentPointer.markRedraw();
      var X = this._progressLine;
      X && (X.shape.x2 = K, X.dirty());
      var Q = this._findNearestTick(K), ee = this.model;
      (U || Q !== ee.getCurrentIndex() && ee.get("realtime")) && this._changeTimeline(Q);
    }, C.prototype._doPlayStop = function() {
      var G = this;
      this._clearTimer(), this.model.getPlayState() && (this._timer = setTimeout(function() {
        var U = G.model;
        G._changeTimeline(U.getCurrentIndex() + (U.get("rewind", !0) ? -1 : 1));
      }, this.model.get("playInterval")));
    }, C.prototype._toAxisCoord = function(G) {
      var U = this._mainGroup.getLocalTransform();
      return applyTransform(G, U, !0);
    }, C.prototype._findNearestTick = function(G) {
      var U = this.model.getData(), K = 1 / 0, W, Z = this._axis;
      return U.each(["value"], function(X, Q) {
        var ee = Z.dataToCoord(X), te = Math.abs(ee - G);
        te < K && (K = te, W = Q);
      }), W;
    }, C.prototype._clearTimer = function() {
      this._timer && (clearTimeout(this._timer), this._timer = null);
    }, C.prototype._changeTimeline = function(G) {
      var U = this.model.getCurrentIndex();
      G === "+" ? G = U + 1 : G === "-" && (G = U - 1), this.api.dispatchAction({
        type: "timelineChange",
        currentIndex: G,
        from: this.uid
      });
    }, C.prototype._updateTicksStatus = function() {
      var G = this.model.getCurrentIndex(), U = this._tickSymbols, K = this._tickLabels;
      if (U)
        for (var W = 0; W < U.length; W++)
          U && U[W] && U[W].toggleState("progress", W < G);
      if (K)
        for (var W = 0; W < K.length; W++)
          K && K[W] && K[W].toggleState("progress", labelDataIndexStore(K[W]).dataIndex <= G);
    }, C.type = "timeline.slider", C;
  }(TimelineView$1)
);
function createScaleByModel(H, C) {
  if (C = C || H.get("type"), C)
    switch (C) {
      case "category":
        return new OrdinalScale$1({
          ordinalMeta: H.getCategories(),
          extent: [1 / 0, -1 / 0]
        });
      case "time":
        return new TimeScale$1({
          locale: H.ecModel.getLocaleModel(),
          useUTC: H.ecModel.get("useUTC")
        });
      default:
        return new IntervalScale$1();
    }
}
function getViewRect(H, C) {
  return getLayoutRect(H.getBoxLayoutParams(), {
    width: C.getWidth(),
    height: C.getHeight()
  }, H.get("padding"));
}
function makeControlIcon(H, C, G, U) {
  var K = U.style, W = createIcon(H.get(["controlStyle", C]), U || {}, new BoundingRect$1(G[0], G[1], G[2], G[3]));
  return K && W.setStyle(K), W;
}
function giveSymbol(H, C, G, U, K, W) {
  var Z = C.get("color");
  if (K)
    K.setColor(Z), G.add(K), W && W.onUpdate(K);
  else {
    var X = H.get("symbol");
    K = createSymbol$1(X, -1, -1, 2, 2, Z), K.setStyle("strokeNoScale", !0), G.add(K), W && W.onCreate(K);
  }
  var Q = C.getItemStyle(["color"]);
  K.setStyle(Q), U = merge({
    rectHover: !0,
    z2: 100
  }, U, !0);
  var ee = normalizeSymbolSize(H.get("symbolSize"));
  U.scaleX = ee[0] / 2, U.scaleY = ee[1] / 2;
  var te = normalizeSymbolOffset(H.get("symbolOffset"), ee);
  te && (U.x = (U.x || 0) + te[0], U.y = (U.y || 0) + te[1]);
  var re = H.get("symbolRotate");
  return U.rotation = (re || 0) * Math.PI / 180 || 0, K.attr(U), K.updateTransform(), K;
}
function pointerMoveTo(H, C, G, U, K, W) {
  if (!H.dragging) {
    var Z = K.getModel("checkpointStyle"), X = U.dataToCoord(K.getData().get("value", G));
    if (W || !Z.get("animation", !0))
      H.attr({
        x: X,
        y: 0
      }), C && C.attr({
        shape: {
          x2: X
        }
      });
    else {
      var Q = {
        duration: Z.get("animationDuration", !0),
        easing: Z.get("animationEasing", !0)
      };
      H.stopAnimation(null, !0), H.animateTo({
        x: X,
        y: 0
      }, Q), C && C.animateTo({
        shape: {
          x2: X
        }
      }, Q);
    }
  }
}
const SliderTimelineView$1 = SliderTimelineView;
function installTimelineAction(H) {
  H.registerAction({
    type: "timelineChange",
    event: "timelineChanged",
    update: "prepareAndUpdate"
  }, function(C, G, U) {
    var K = G.getComponent("timeline");
    return K && C.currentIndex != null && (K.setCurrentIndex(C.currentIndex), !K.get("loop", !0) && K.isIndexMax() && K.getPlayState() && (K.setPlayState(!1), U.dispatchAction({
      type: "timelinePlayChange",
      playState: !1,
      from: C.from
    }))), G.resetOption("timeline", {
      replaceMerge: K.get("replaceMerge", !0)
    }), defaults({
      currentIndex: K.option.currentIndex
    }, C);
  }), H.registerAction({
    type: "timelinePlayChange",
    event: "timelinePlayChanged",
    update: "update"
  }, function(C, G) {
    var U = G.getComponent("timeline");
    U && C.playState != null && U.setPlayState(C.playState);
  });
}
function timelinePreprocessor(H) {
  var C = H && H.timeline;
  isArray$1(C) || (C = C ? [C] : []), each$f(C, function(G) {
    G && compatibleEC2(G);
  });
}
function compatibleEC2(H) {
  var C = H.type, G = {
    number: "value",
    time: "time"
  };
  if (G[C] && (H.axisType = G[C], delete H.type), transferItem(H), has$1(H, "controlPosition")) {
    var U = H.controlStyle || (H.controlStyle = {});
    has$1(U, "position") || (U.position = H.controlPosition), U.position === "none" && !has$1(U, "show") && (U.show = !1, delete U.position), delete H.controlPosition;
  }
  each$f(H.data || [], function(K) {
    isObject$3(K) && !isArray$1(K) && (!has$1(K, "value") && has$1(K, "name") && (K.value = K.name), transferItem(K));
  });
}
function transferItem(H) {
  var C = H.itemStyle || (H.itemStyle = {}), G = C.emphasis || (C.emphasis = {}), U = H.label || H.label || {}, K = U.normal || (U.normal = {}), W = {
    normal: 1,
    emphasis: 1
  };
  each$f(U, function(Z, X) {
    !W[X] && !has$1(K, X) && (K[X] = Z);
  }), G.label && !has$1(U, "emphasis") && (U.emphasis = G.label, delete G.label);
}
function has$1(H, C) {
  return H.hasOwnProperty(C);
}
function install$f(H) {
  H.registerComponentModel(SliderTimelineModel$1), H.registerComponentView(SliderTimelineView$1), H.registerSubTypeDefaulter("timeline", function() {
    return "slider";
  }), installTimelineAction(H), H.registerPreprocessor(timelinePreprocessor);
}
function checkMarkerInSeries(H, C) {
  if (!H)
    return !1;
  for (var G = isArray$1(H) ? H : [H], U = 0; U < G.length; U++)
    if (G[U] && G[U][C])
      return !0;
  return !1;
}
function fillLabel(H) {
  defaultEmphasis(H, "label", ["show"]);
}
var inner$5 = makeInner(), MarkerModel = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G.createdBySelf = !1, G;
    }
    return C.prototype.init = function(G, U, K) {
      if (process.env.NODE_ENV !== "production" && this.type === "marker")
        throw new Error("Marker component is abstract component. Use markLine, markPoint, markArea instead.");
      this.mergeDefaultAndTheme(G, K), this._mergeOption(G, K, !1, !0);
    }, C.prototype.isAnimationEnabled = function() {
      if (env$1.node)
        return !1;
      var G = this.__hostSeries;
      return this.getShallow("animation") && G && G.isAnimationEnabled();
    }, C.prototype.mergeOption = function(G, U) {
      this._mergeOption(G, U, !1, !1);
    }, C.prototype._mergeOption = function(G, U, K, W) {
      var Z = this.mainType;
      K || U.eachSeries(function(X) {
        var Q = X.get(this.mainType, !0), ee = inner$5(X)[Z];
        if (!Q || !Q.data) {
          inner$5(X)[Z] = null;
          return;
        }
        ee ? ee._mergeOption(Q, U, !0) : (W && fillLabel(Q), each$f(Q.data, function(te) {
          te instanceof Array ? (fillLabel(te[0]), fillLabel(te[1])) : fillLabel(te);
        }), ee = this.createMarkerModelFromSeries(Q, this, U), extend(ee, {
          mainType: this.mainType,
          // Use the same series index and name
          seriesIndex: X.seriesIndex,
          name: X.name,
          createdBySelf: !0
        }), ee.__hostSeries = X), inner$5(X)[Z] = ee;
      }, this);
    }, C.prototype.formatTooltip = function(G, U, K) {
      var W = this.getData(), Z = this.getRawValue(G), X = W.getName(G);
      return createTooltipMarkup("section", {
        header: this.name,
        blocks: [createTooltipMarkup("nameValue", {
          name: X,
          value: Z,
          noName: !X,
          noValue: Z == null
        })]
      });
    }, C.prototype.getData = function() {
      return this._data;
    }, C.prototype.setData = function(G) {
      this._data = G;
    }, C.getMarkerModelFromSeries = function(G, U) {
      return inner$5(G)[U];
    }, C.type = "marker", C.dependencies = ["series", "grid", "polar", "geo"], C;
  }(ComponentModel$1)
);
mixin(MarkerModel, DataFormatMixin.prototype);
const MarkerModel$1 = MarkerModel;
var MarkPointModel = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G;
    }
    return C.prototype.createMarkerModelFromSeries = function(G, U, K) {
      return new C(G, U, K);
    }, C.type = "markPoint", C.defaultOption = {
      // zlevel: 0,
      z: 5,
      symbol: "pin",
      symbolSize: 50,
      // symbolRotate: 0,
      // symbolOffset: [0, 0]
      tooltip: {
        trigger: "item"
      },
      label: {
        show: !0,
        position: "inside"
      },
      itemStyle: {
        borderWidth: 2
      },
      emphasis: {
        label: {
          show: !0
        }
      }
    }, C;
  }(MarkerModel$1)
);
const MarkPointModel$1 = MarkPointModel;
function hasXOrY(H) {
  return !(isNaN(parseFloat(H.x)) && isNaN(parseFloat(H.y)));
}
function hasXAndY(H) {
  return !isNaN(parseFloat(H.x)) && !isNaN(parseFloat(H.y));
}
function markerTypeCalculatorWithExtent(H, C, G, U, K, W) {
  var Z = [], X = isDimensionStacked(
    C,
    U
    /* , otherDataDim */
  ), Q = X ? C.getCalculationInfo("stackResultDimension") : U, ee = numCalculate(C, Q, H), te = C.indicesOfNearest(Q, ee)[0];
  Z[K] = C.get(G, te), Z[W] = C.get(Q, te);
  var re = C.get(U, te), ne = getPrecision(C.get(U, te));
  return ne = Math.min(ne, 20), ne >= 0 && (Z[W] = +Z[W].toFixed(ne)), [Z, re];
}
var markerTypeCalculator = {
  min: curry$1(markerTypeCalculatorWithExtent, "min"),
  max: curry$1(markerTypeCalculatorWithExtent, "max"),
  average: curry$1(markerTypeCalculatorWithExtent, "average"),
  median: curry$1(markerTypeCalculatorWithExtent, "median")
};
function dataTransform(H, C) {
  if (C) {
    var G = H.getData(), U = H.coordinateSystem, K = U.dimensions;
    if (!hasXAndY(C) && !isArray$1(C.coord) && U) {
      var W = getAxisInfo(C, G, U, H);
      if (C = clone$4(C), C.type && markerTypeCalculator[C.type] && W.baseAxis && W.valueAxis) {
        var Z = indexOf(K, W.baseAxis.dim), X = indexOf(K, W.valueAxis.dim), Q = markerTypeCalculator[C.type](G, W.baseDataDim, W.valueDataDim, Z, X);
        C.coord = Q[0], C.value = Q[1];
      } else
        C.coord = [C.xAxis != null ? C.xAxis : C.radiusAxis, C.yAxis != null ? C.yAxis : C.angleAxis];
    }
    if (C.coord == null)
      C.coord = [];
    else
      for (var ee = C.coord, te = 0; te < 2; te++)
        markerTypeCalculator[ee[te]] && (ee[te] = numCalculate(G, G.mapDimension(K[te]), ee[te]));
    return C;
  }
}
function getAxisInfo(H, C, G, U) {
  var K = {};
  return H.valueIndex != null || H.valueDim != null ? (K.valueDataDim = H.valueIndex != null ? C.getDimension(H.valueIndex) : H.valueDim, K.valueAxis = G.getAxis(dataDimToCoordDim(U, K.valueDataDim)), K.baseAxis = G.getOtherAxis(K.valueAxis), K.baseDataDim = C.mapDimension(K.baseAxis.dim)) : (K.baseAxis = U.getBaseAxis(), K.valueAxis = G.getOtherAxis(K.baseAxis), K.baseDataDim = C.mapDimension(K.baseAxis.dim), K.valueDataDim = C.mapDimension(K.valueAxis.dim)), K;
}
function dataDimToCoordDim(H, C) {
  var G = H.getData().getDimensionInfo(C);
  return G && G.coordDim;
}
function dataFilter(H, C) {
  return H && H.containData && C.coord && !hasXOrY(C) ? H.containData(C.coord) : !0;
}
function zoneFilter(H, C, G) {
  return H && H.containZone && C.coord && G.coord && !hasXOrY(C) && !hasXOrY(G) ? H.containZone(C.coord, G.coord) : !0;
}
function createMarkerDimValueGetter(H, C) {
  return H ? function(G, U, K, W) {
    var Z = W < 2 ? G.coord && G.coord[W] : G.value;
    return parseDataValue(Z, C[W]);
  } : function(G, U, K, W) {
    return parseDataValue(G.value, C[W]);
  };
}
function numCalculate(H, C, G) {
  if (G === "average") {
    var U = 0, K = 0;
    return H.each(C, function(W, Z) {
      isNaN(W) || (U += W, K++);
    }), U / K;
  } else
    return G === "median" ? H.getMedian(C) : H.getDataExtent(C)[G === "max" ? 1 : 0];
}
var inner$4 = makeInner(), MarkerView = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G;
    }
    return C.prototype.init = function() {
      this.markerGroupMap = createHashMap();
    }, C.prototype.render = function(G, U, K) {
      var W = this, Z = this.markerGroupMap;
      Z.each(function(X) {
        inner$4(X).keep = !1;
      }), U.eachSeries(function(X) {
        var Q = MarkerModel$1.getMarkerModelFromSeries(X, W.type);
        Q && W.renderSeries(X, Q, U, K);
      }), Z.each(function(X) {
        !inner$4(X).keep && W.group.remove(X.group);
      });
    }, C.prototype.markKeep = function(G) {
      inner$4(G).keep = !0;
    }, C.prototype.toggleBlurSeries = function(G, U) {
      var K = this;
      each$f(G, function(W) {
        var Z = MarkerModel$1.getMarkerModelFromSeries(W, K.type);
        if (Z) {
          var X = Z.getData();
          X.eachItemGraphicEl(function(Q) {
            Q && (U ? enterBlur(Q) : leaveBlur(Q));
          });
        }
      });
    }, C.type = "marker", C;
  }(ComponentView$1)
);
const MarkerView$1 = MarkerView;
function updateMarkerLayout(H, C, G) {
  var U = C.coordinateSystem;
  H.each(function(K) {
    var W = H.getItemModel(K), Z, X = parsePercent(W.get("x"), G.getWidth()), Q = parsePercent(W.get("y"), G.getHeight());
    if (!isNaN(X) && !isNaN(Q))
      Z = [X, Q];
    else if (C.getMarkerPosition)
      Z = C.getMarkerPosition(H.getValues(H.dimensions, K));
    else if (U) {
      var ee = H.get(U.dimensions[0], K), te = H.get(U.dimensions[1], K);
      Z = U.dataToPoint([ee, te]);
    }
    isNaN(X) || (Z[0] = X), isNaN(Q) || (Z[1] = Q), H.setItemLayout(K, Z);
  });
}
var MarkPointView = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G;
    }
    return C.prototype.updateTransform = function(G, U, K) {
      U.eachSeries(function(W) {
        var Z = MarkerModel$1.getMarkerModelFromSeries(W, "markPoint");
        Z && (updateMarkerLayout(Z.getData(), W, K), this.markerGroupMap.get(W.id).updateLayout());
      }, this);
    }, C.prototype.renderSeries = function(G, U, K, W) {
      var Z = G.coordinateSystem, X = G.id, Q = G.getData(), ee = this.markerGroupMap, te = ee.get(X) || ee.set(X, new SymbolDraw$1()), re = createData(Z, G, U);
      U.setData(re), updateMarkerLayout(U.getData(), G, W), re.each(function(ne) {
        var ae = re.getItemModel(ne), ie = ae.getShallow("symbol"), se = ae.getShallow("symbolSize"), oe = ae.getShallow("symbolRotate"), le = ae.getShallow("symbolOffset"), ue = ae.getShallow("symbolKeepAspect");
        if (isFunction(ie) || isFunction(se) || isFunction(oe) || isFunction(le)) {
          var ce = U.getRawValue(ne), de = U.getDataParams(ne);
          isFunction(ie) && (ie = ie(ce, de)), isFunction(se) && (se = se(ce, de)), isFunction(oe) && (oe = oe(ce, de)), isFunction(le) && (le = le(ce, de));
        }
        var ge = ae.getModel("itemStyle").getItemStyle(), fe = getVisualFromData(Q, "color");
        ge.fill || (ge.fill = fe), re.setItemVisual(ne, {
          symbol: ie,
          symbolSize: se,
          symbolRotate: oe,
          symbolOffset: le,
          symbolKeepAspect: ue,
          style: ge
        });
      }), te.updateData(re), this.group.add(te.group), re.eachItemGraphicEl(function(ne) {
        ne.traverse(function(ae) {
          getECData(ae).dataModel = U;
        });
      }), this.markKeep(te), te.group.silent = U.get("silent") || G.get("silent");
    }, C.type = "markPoint", C;
  }(MarkerView$1)
);
function createData(H, C, G) {
  var U;
  H ? U = map$1(H && H.dimensions, function(X) {
    var Q = C.getData().getDimensionInfo(C.getData().mapDimension(X)) || {};
    return extend(extend({}, Q), {
      name: X,
      // DON'T use ordinalMeta to parse and collect ordinal.
      ordinalMeta: null
    });
  }) : U = [{
    name: "value",
    type: "float"
  }];
  var K = new SeriesData$1(U, G), W = map$1(G.get("data"), curry$1(dataTransform, C));
  H && (W = filter(W, curry$1(dataFilter, H)));
  var Z = createMarkerDimValueGetter(!!H, U);
  return K.initData(W, null, Z), K;
}
const MarkPointView$1 = MarkPointView;
function install$e(H) {
  H.registerComponentModel(MarkPointModel$1), H.registerComponentView(MarkPointView$1), H.registerPreprocessor(function(C) {
    checkMarkerInSeries(C.series, "markPoint") && (C.markPoint = C.markPoint || {});
  });
}
var MarkLineModel = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G;
    }
    return C.prototype.createMarkerModelFromSeries = function(G, U, K) {
      return new C(G, U, K);
    }, C.type = "markLine", C.defaultOption = {
      // zlevel: 0,
      z: 5,
      symbol: ["circle", "arrow"],
      symbolSize: [8, 16],
      // symbolRotate: 0,
      symbolOffset: 0,
      precision: 2,
      tooltip: {
        trigger: "item"
      },
      label: {
        show: !0,
        position: "end",
        distance: 5
      },
      lineStyle: {
        type: "dashed"
      },
      emphasis: {
        label: {
          show: !0
        },
        lineStyle: {
          width: 3
        }
      },
      animationEasing: "linear"
    }, C;
  }(MarkerModel$1)
);
const MarkLineModel$1 = MarkLineModel;
var inner$3 = makeInner(), markLineTransform = function(H, C, G, U) {
  var K = H.getData(), W;
  if (isArray$1(U))
    W = U;
  else {
    var Z = U.type;
    if (Z === "min" || Z === "max" || Z === "average" || Z === "median" || U.xAxis != null || U.yAxis != null) {
      var X = void 0, Q = void 0;
      if (U.yAxis != null || U.xAxis != null)
        X = C.getAxis(U.yAxis != null ? "y" : "x"), Q = retrieve(U.yAxis, U.xAxis);
      else {
        var ee = getAxisInfo(U, K, C, H);
        X = ee.valueAxis;
        var te = getStackedDimension(K, ee.valueDataDim);
        Q = numCalculate(K, te, Z);
      }
      var re = X.dim === "x" ? 0 : 1, ne = 1 - re, ae = clone$4(U), ie = {
        coord: []
      };
      ae.type = null, ae.coord = [], ae.coord[ne] = -1 / 0, ie.coord[ne] = 1 / 0;
      var se = G.get("precision");
      se >= 0 && isNumber(Q) && (Q = +Q.toFixed(Math.min(se, 20))), ae.coord[re] = ie.coord[re] = Q, W = [ae, ie, {
        type: Z,
        valueIndex: U.valueIndex,
        // Force to use the value of calculated value.
        value: Q
      }];
    } else
      process.env.NODE_ENV !== "production" && logError("Invalid markLine data."), W = [];
  }
  var oe = [dataTransform(H, W[0]), dataTransform(H, W[1]), extend({}, W[2])];
  return oe[2].type = oe[2].type || null, merge(oe[2], oe[0]), merge(oe[2], oe[1]), oe;
};
function isInfinity$1(H) {
  return !isNaN(H) && !isFinite(H);
}
function ifMarkLineHasOnlyDim(H, C, G, U) {
  var K = 1 - H, W = U.dimensions[H];
  return isInfinity$1(C[K]) && isInfinity$1(G[K]) && C[H] === G[H] && U.getAxis(W).containData(C[H]);
}
function markLineFilter(H, C) {
  if (H.type === "cartesian2d") {
    var G = C[0].coord, U = C[1].coord;
    if (G && U && (ifMarkLineHasOnlyDim(1, G, U, H) || ifMarkLineHasOnlyDim(0, G, U, H)))
      return !0;
  }
  return dataFilter(H, C[0]) && dataFilter(H, C[1]);
}
function updateSingleMarkerEndLayout(H, C, G, U, K) {
  var W = U.coordinateSystem, Z = H.getItemModel(C), X, Q = parsePercent(Z.get("x"), K.getWidth()), ee = parsePercent(Z.get("y"), K.getHeight());
  if (!isNaN(Q) && !isNaN(ee))
    X = [Q, ee];
  else {
    if (U.getMarkerPosition)
      X = U.getMarkerPosition(H.getValues(H.dimensions, C));
    else {
      var te = W.dimensions, re = H.get(te[0], C), ne = H.get(te[1], C);
      X = W.dataToPoint([re, ne]);
    }
    if (isCoordinateSystemType(W, "cartesian2d")) {
      var ae = W.getAxis("x"), ie = W.getAxis("y"), te = W.dimensions;
      isInfinity$1(H.get(te[0], C)) ? X[0] = ae.toGlobalCoord(ae.getExtent()[G ? 0 : 1]) : isInfinity$1(H.get(te[1], C)) && (X[1] = ie.toGlobalCoord(ie.getExtent()[G ? 0 : 1]));
    }
    isNaN(Q) || (X[0] = Q), isNaN(ee) || (X[1] = ee);
  }
  H.setItemLayout(C, X);
}
var MarkLineView = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G;
    }
    return C.prototype.updateTransform = function(G, U, K) {
      U.eachSeries(function(W) {
        var Z = MarkerModel$1.getMarkerModelFromSeries(W, "markLine");
        if (Z) {
          var X = Z.getData(), Q = inner$3(Z).from, ee = inner$3(Z).to;
          Q.each(function(te) {
            updateSingleMarkerEndLayout(Q, te, !0, W, K), updateSingleMarkerEndLayout(ee, te, !1, W, K);
          }), X.each(function(te) {
            X.setItemLayout(te, [Q.getItemLayout(te), ee.getItemLayout(te)]);
          }), this.markerGroupMap.get(W.id).updateLayout();
        }
      }, this);
    }, C.prototype.renderSeries = function(G, U, K, W) {
      var Z = G.coordinateSystem, X = G.id, Q = G.getData(), ee = this.markerGroupMap, te = ee.get(X) || ee.set(X, new LineDraw$1());
      this.group.add(te.group);
      var re = createList$1(Z, G, U), ne = re.from, ae = re.to, ie = re.line;
      inner$3(U).from = ne, inner$3(U).to = ae, U.setData(ie);
      var se = U.get("symbol"), oe = U.get("symbolSize"), le = U.get("symbolRotate"), ue = U.get("symbolOffset");
      isArray$1(se) || (se = [se, se]), isArray$1(oe) || (oe = [oe, oe]), isArray$1(le) || (le = [le, le]), isArray$1(ue) || (ue = [ue, ue]), re.from.each(function(de) {
        ce(ne, de, !0), ce(ae, de, !1);
      }), ie.each(function(de) {
        var ge = ie.getItemModel(de).getModel("lineStyle").getLineStyle();
        ie.setItemLayout(de, [ne.getItemLayout(de), ae.getItemLayout(de)]), ge.stroke == null && (ge.stroke = ne.getItemVisual(de, "style").fill), ie.setItemVisual(de, {
          fromSymbolKeepAspect: ne.getItemVisual(de, "symbolKeepAspect"),
          fromSymbolOffset: ne.getItemVisual(de, "symbolOffset"),
          fromSymbolRotate: ne.getItemVisual(de, "symbolRotate"),
          fromSymbolSize: ne.getItemVisual(de, "symbolSize"),
          fromSymbol: ne.getItemVisual(de, "symbol"),
          toSymbolKeepAspect: ae.getItemVisual(de, "symbolKeepAspect"),
          toSymbolOffset: ae.getItemVisual(de, "symbolOffset"),
          toSymbolRotate: ae.getItemVisual(de, "symbolRotate"),
          toSymbolSize: ae.getItemVisual(de, "symbolSize"),
          toSymbol: ae.getItemVisual(de, "symbol"),
          style: ge
        });
      }), te.updateData(ie), re.line.eachItemGraphicEl(function(de) {
        getECData(de).dataModel = U, de.traverse(function(ge) {
          getECData(ge).dataModel = U;
        });
      });
      function ce(de, ge, fe) {
        var ve = de.getItemModel(ge);
        updateSingleMarkerEndLayout(de, ge, fe, G, W);
        var pe = ve.getModel("itemStyle").getItemStyle();
        pe.fill == null && (pe.fill = getVisualFromData(Q, "color")), de.setItemVisual(ge, {
          symbolKeepAspect: ve.get("symbolKeepAspect"),
          // `0` should be considered as a valid value, so use `retrieve2` instead of `||`
          symbolOffset: retrieve2(ve.get("symbolOffset", !0), ue[fe ? 0 : 1]),
          symbolRotate: retrieve2(ve.get("symbolRotate", !0), le[fe ? 0 : 1]),
          // TODO: when 2d array is supported, it should ignore parent
          symbolSize: retrieve2(ve.get("symbolSize"), oe[fe ? 0 : 1]),
          symbol: retrieve2(ve.get("symbol", !0), se[fe ? 0 : 1]),
          style: pe
        });
      }
      this.markKeep(te), te.group.silent = U.get("silent") || G.get("silent");
    }, C.type = "markLine", C;
  }(MarkerView$1)
);
function createList$1(H, C, G) {
  var U;
  H ? U = map$1(H && H.dimensions, function(ee) {
    var te = C.getData().getDimensionInfo(C.getData().mapDimension(ee)) || {};
    return extend(extend({}, te), {
      name: ee,
      // DON'T use ordinalMeta to parse and collect ordinal.
      ordinalMeta: null
    });
  }) : U = [{
    name: "value",
    type: "float"
  }];
  var K = new SeriesData$1(U, G), W = new SeriesData$1(U, G), Z = new SeriesData$1([], G), X = map$1(G.get("data"), curry$1(markLineTransform, C, H, G));
  H && (X = filter(X, curry$1(markLineFilter, H)));
  var Q = createMarkerDimValueGetter(!!H, U);
  return K.initData(map$1(X, function(ee) {
    return ee[0];
  }), null, Q), W.initData(map$1(X, function(ee) {
    return ee[1];
  }), null, Q), Z.initData(map$1(X, function(ee) {
    return ee[2];
  })), Z.hasItemOption = !0, {
    from: K,
    to: W,
    line: Z
  };
}
const MarkLineView$1 = MarkLineView;
function install$d(H) {
  H.registerComponentModel(MarkLineModel$1), H.registerComponentView(MarkLineView$1), H.registerPreprocessor(function(C) {
    checkMarkerInSeries(C.series, "markLine") && (C.markLine = C.markLine || {});
  });
}
var MarkAreaModel = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G;
    }
    return C.prototype.createMarkerModelFromSeries = function(G, U, K) {
      return new C(G, U, K);
    }, C.type = "markArea", C.defaultOption = {
      // zlevel: 0,
      // PENDING
      z: 1,
      tooltip: {
        trigger: "item"
      },
      // markArea should fixed on the coordinate system
      animation: !1,
      label: {
        show: !0,
        position: "top"
      },
      itemStyle: {
        // color and borderColor default to use color from series
        // color: 'auto'
        // borderColor: 'auto'
        borderWidth: 0
      },
      emphasis: {
        label: {
          show: !0,
          position: "top"
        }
      }
    }, C;
  }(MarkerModel$1)
);
const MarkAreaModel$1 = MarkAreaModel;
var inner$2 = makeInner(), markAreaTransform = function(H, C, G, U) {
  var K = U[0], W = U[1];
  if (!(!K || !W)) {
    var Z = dataTransform(H, K), X = dataTransform(H, W), Q = Z.coord, ee = X.coord;
    Q[0] = retrieve(Q[0], -1 / 0), Q[1] = retrieve(Q[1], -1 / 0), ee[0] = retrieve(ee[0], 1 / 0), ee[1] = retrieve(ee[1], 1 / 0);
    var te = mergeAll([{}, Z, X]);
    return te.coord = [Z.coord, X.coord], te.x0 = Z.x, te.y0 = Z.y, te.x1 = X.x, te.y1 = X.y, te;
  }
};
function isInfinity(H) {
  return !isNaN(H) && !isFinite(H);
}
function ifMarkAreaHasOnlyDim(H, C, G, U) {
  var K = 1 - H;
  return isInfinity(C[K]) && isInfinity(G[K]);
}
function markAreaFilter(H, C) {
  var G = C.coord[0], U = C.coord[1], K = {
    coord: G,
    x: C.x0,
    y: C.y0
  }, W = {
    coord: U,
    x: C.x1,
    y: C.y1
  };
  return isCoordinateSystemType(H, "cartesian2d") ? G && U && (ifMarkAreaHasOnlyDim(1, G, U) || ifMarkAreaHasOnlyDim(0, G, U)) ? !0 : zoneFilter(H, K, W) : dataFilter(H, K) || dataFilter(H, W);
}
function getSingleMarkerEndPoint(H, C, G, U, K) {
  var W = U.coordinateSystem, Z = H.getItemModel(C), X, Q = parsePercent(Z.get(G[0]), K.getWidth()), ee = parsePercent(Z.get(G[1]), K.getHeight());
  if (!isNaN(Q) && !isNaN(ee))
    X = [Q, ee];
  else {
    if (U.getMarkerPosition) {
      var te = H.getValues(["x0", "y0"], C), re = H.getValues(["x1", "y1"], C), ne = W.clampData(te), ae = W.clampData(re), ie = [];
      G[0] === "x0" ? ie[0] = ne[0] > ae[0] ? re[0] : te[0] : ie[0] = ne[0] > ae[0] ? te[0] : re[0], G[1] === "y0" ? ie[1] = ne[1] > ae[1] ? re[1] : te[1] : ie[1] = ne[1] > ae[1] ? te[1] : re[1], X = U.getMarkerPosition(ie, G, !0);
    } else {
      var se = H.get(G[0], C), oe = H.get(G[1], C), le = [se, oe];
      W.clampData && W.clampData(le, le), X = W.dataToPoint(le, !0);
    }
    if (isCoordinateSystemType(W, "cartesian2d")) {
      var ue = W.getAxis("x"), ce = W.getAxis("y"), se = H.get(G[0], C), oe = H.get(G[1], C);
      isInfinity(se) ? X[0] = ue.toGlobalCoord(ue.getExtent()[G[0] === "x0" ? 0 : 1]) : isInfinity(oe) && (X[1] = ce.toGlobalCoord(ce.getExtent()[G[1] === "y0" ? 0 : 1]));
    }
    isNaN(Q) || (X[0] = Q), isNaN(ee) || (X[1] = ee);
  }
  return X;
}
var dimPermutations = [["x0", "y0"], ["x1", "y0"], ["x1", "y1"], ["x0", "y1"]], MarkAreaView = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G;
    }
    return C.prototype.updateTransform = function(G, U, K) {
      U.eachSeries(function(W) {
        var Z = MarkerModel$1.getMarkerModelFromSeries(W, "markArea");
        if (Z) {
          var X = Z.getData();
          X.each(function(Q) {
            var ee = map$1(dimPermutations, function(re) {
              return getSingleMarkerEndPoint(X, Q, re, W, K);
            });
            X.setItemLayout(Q, ee);
            var te = X.getItemGraphicEl(Q);
            te.setShape("points", ee);
          });
        }
      }, this);
    }, C.prototype.renderSeries = function(G, U, K, W) {
      var Z = G.coordinateSystem, X = G.id, Q = G.getData(), ee = this.markerGroupMap, te = ee.get(X) || ee.set(X, {
        group: new Group$4()
      });
      this.group.add(te.group), this.markKeep(te);
      var re = createList(Z, G, U);
      U.setData(re), re.each(function(ne) {
        var ae = map$1(dimPermutations, function(pe) {
          return getSingleMarkerEndPoint(re, ne, pe, G, W);
        }), ie = Z.getAxis("x").scale, se = Z.getAxis("y").scale, oe = ie.getExtent(), le = se.getExtent(), ue = [ie.parse(re.get("x0", ne)), ie.parse(re.get("x1", ne))], ce = [se.parse(re.get("y0", ne)), se.parse(re.get("y1", ne))];
        asc$2(ue), asc$2(ce);
        var de = !(oe[0] > ue[1] || oe[1] < ue[0] || le[0] > ce[1] || le[1] < ce[0]), ge = !de;
        re.setItemLayout(ne, {
          points: ae,
          allClipped: ge
        });
        var fe = re.getItemModel(ne).getModel("itemStyle").getItemStyle(), ve = getVisualFromData(Q, "color");
        fe.fill || (fe.fill = ve, isString(fe.fill) && (fe.fill = modifyAlpha(fe.fill, 0.4))), fe.stroke || (fe.stroke = ve), re.setItemVisual(ne, "style", fe);
      }), re.diff(inner$2(te).data).add(function(ne) {
        var ae = re.getItemLayout(ne);
        if (!ae.allClipped) {
          var ie = new Polygon$1({
            shape: {
              points: ae.points
            }
          });
          re.setItemGraphicEl(ne, ie), te.group.add(ie);
        }
      }).update(function(ne, ae) {
        var ie = inner$2(te).data.getItemGraphicEl(ae), se = re.getItemLayout(ne);
        se.allClipped ? ie && te.group.remove(ie) : (ie ? updateProps$1(ie, {
          shape: {
            points: se.points
          }
        }, U, ne) : ie = new Polygon$1({
          shape: {
            points: se.points
          }
        }), re.setItemGraphicEl(ne, ie), te.group.add(ie));
      }).remove(function(ne) {
        var ae = inner$2(te).data.getItemGraphicEl(ne);
        te.group.remove(ae);
      }).execute(), re.eachItemGraphicEl(function(ne, ae) {
        var ie = re.getItemModel(ae), se = re.getItemVisual(ae, "style");
        ne.useStyle(re.getItemVisual(ae, "style")), setLabelStyle(ne, getLabelStatesModels(ie), {
          labelFetcher: U,
          labelDataIndex: ae,
          defaultText: re.getName(ae) || "",
          inheritColor: isString(se.fill) ? modifyAlpha(se.fill, 1) : "#000"
        }), setStatesStylesFromModel(ne, ie), toggleHoverEmphasis(ne, null, null, ie.get(["emphasis", "disabled"])), getECData(ne).dataModel = U;
      }), inner$2(te).data = re, te.group.silent = U.get("silent") || G.get("silent");
    }, C.type = "markArea", C;
  }(MarkerView$1)
);
function createList(H, C, G) {
  var U, K, W = ["x0", "y0", "x1", "y1"];
  if (H) {
    var Z = map$1(H && H.dimensions, function(ee) {
      var te = C.getData(), re = te.getDimensionInfo(te.mapDimension(ee)) || {};
      return extend(extend({}, re), {
        name: ee,
        // DON'T use ordinalMeta to parse and collect ordinal.
        ordinalMeta: null
      });
    });
    K = map$1(W, function(ee, te) {
      return {
        name: ee,
        type: Z[te % 2].type
      };
    }), U = new SeriesData$1(K, G);
  } else
    K = [{
      name: "value",
      type: "float"
    }], U = new SeriesData$1(K, G);
  var X = map$1(G.get("data"), curry$1(markAreaTransform, C, H, G));
  H && (X = filter(X, curry$1(markAreaFilter, H)));
  var Q = H ? function(ee, te, re, ne) {
    var ae = ee.coord[Math.floor(ne / 2)][ne % 2];
    return parseDataValue(ae, K[ne]);
  } : function(ee, te, re, ne) {
    return parseDataValue(ee.value, K[ne]);
  };
  return U.initData(X, null, Q), U.hasItemOption = !0, U;
}
const MarkAreaView$1 = MarkAreaView;
function install$c(H) {
  H.registerComponentModel(MarkAreaModel$1), H.registerComponentView(MarkAreaView$1), H.registerPreprocessor(function(C) {
    checkMarkerInSeries(C.series, "markArea") && (C.markArea = C.markArea || {});
  });
}
var getDefaultSelectorOptions = function(H, C) {
  if (C === "all")
    return {
      type: "all",
      title: H.getLocaleModel().get(["legend", "selector", "all"])
    };
  if (C === "inverse")
    return {
      type: "inverse",
      title: H.getLocaleModel().get(["legend", "selector", "inverse"])
    };
}, LegendModel = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G.layoutMode = {
        type: "box",
        // legend.width/height are maxWidth/maxHeight actually,
        // whereas real width/height is calculated by its content.
        // (Setting {left: 10, right: 10} does not make sense).
        // So consider the case:
        // `setOption({legend: {left: 10});`
        // then `setOption({legend: {right: 10});`
        // The previous `left` should be cleared by setting `ignoreSize`.
        ignoreSize: !0
      }, G;
    }
    return C.prototype.init = function(G, U, K) {
      this.mergeDefaultAndTheme(G, K), G.selected = G.selected || {}, this._updateSelector(G);
    }, C.prototype.mergeOption = function(G, U) {
      H.prototype.mergeOption.call(this, G, U), this._updateSelector(G);
    }, C.prototype._updateSelector = function(G) {
      var U = G.selector, K = this.ecModel;
      U === !0 && (U = G.selector = ["all", "inverse"]), isArray$1(U) && each$f(U, function(W, Z) {
        isString(W) && (W = {
          type: W
        }), U[Z] = merge(W, getDefaultSelectorOptions(K, W.type));
      });
    }, C.prototype.optionUpdated = function() {
      this._updateData(this.ecModel);
      var G = this._data;
      if (G[0] && this.get("selectedMode") === "single") {
        for (var U = !1, K = 0; K < G.length; K++) {
          var W = G[K].get("name");
          if (this.isSelected(W)) {
            this.select(W), U = !0;
            break;
          }
        }
        !U && this.select(G[0].get("name"));
      }
    }, C.prototype._updateData = function(G) {
      var U = [], K = [];
      G.eachRawSeries(function(Q) {
        var ee = Q.name;
        K.push(ee);
        var te;
        if (Q.legendVisualProvider) {
          var re = Q.legendVisualProvider, ne = re.getAllNames();
          G.isSeriesFiltered(Q) || (K = K.concat(ne)), ne.length ? U = U.concat(ne) : te = !0;
        } else
          te = !0;
        te && isNameSpecified(Q) && U.push(Q.name);
      }), this._availableNames = K;
      var W = this.get("data") || U, Z = createHashMap(), X = map$1(W, function(Q) {
        return (isString(Q) || isNumber(Q)) && (Q = {
          name: Q
        }), Z.get(Q.name) ? null : (Z.set(Q.name, !0), new Model$1(Q, this, this.ecModel));
      }, this);
      this._data = filter(X, function(Q) {
        return !!Q;
      });
    }, C.prototype.getData = function() {
      return this._data;
    }, C.prototype.select = function(G) {
      var U = this.option.selected, K = this.get("selectedMode");
      if (K === "single") {
        var W = this._data;
        each$f(W, function(Z) {
          U[Z.get("name")] = !1;
        });
      }
      U[G] = !0;
    }, C.prototype.unSelect = function(G) {
      this.get("selectedMode") !== "single" && (this.option.selected[G] = !1);
    }, C.prototype.toggleSelected = function(G) {
      var U = this.option.selected;
      U.hasOwnProperty(G) || (U[G] = !0), this[U[G] ? "unSelect" : "select"](G);
    }, C.prototype.allSelect = function() {
      var G = this._data, U = this.option.selected;
      each$f(G, function(K) {
        U[K.get("name", !0)] = !0;
      });
    }, C.prototype.inverseSelect = function() {
      var G = this._data, U = this.option.selected;
      each$f(G, function(K) {
        var W = K.get("name", !0);
        U.hasOwnProperty(W) || (U[W] = !0), U[W] = !U[W];
      });
    }, C.prototype.isSelected = function(G) {
      var U = this.option.selected;
      return !(U.hasOwnProperty(G) && !U[G]) && indexOf(this._availableNames, G) >= 0;
    }, C.prototype.getOrient = function() {
      return this.get("orient") === "vertical" ? {
        index: 1,
        name: "vertical"
      } : {
        index: 0,
        name: "horizontal"
      };
    }, C.type = "legend.plain", C.dependencies = ["series"], C.defaultOption = {
      // zlevel: 0,
      z: 4,
      show: !0,
      orient: "horizontal",
      left: "center",
      // right: 'center',
      top: 0,
      // bottom: null,
      align: "auto",
      backgroundColor: "rgba(0,0,0,0)",
      borderColor: "#ccc",
      borderRadius: 0,
      borderWidth: 0,
      padding: 5,
      itemGap: 10,
      itemWidth: 25,
      itemHeight: 14,
      symbolRotate: "inherit",
      symbolKeepAspect: !0,
      inactiveColor: "#ccc",
      inactiveBorderColor: "#ccc",
      inactiveBorderWidth: "auto",
      itemStyle: {
        color: "inherit",
        opacity: "inherit",
        borderColor: "inherit",
        borderWidth: "auto",
        borderCap: "inherit",
        borderJoin: "inherit",
        borderDashOffset: "inherit",
        borderMiterLimit: "inherit"
      },
      lineStyle: {
        width: "auto",
        color: "inherit",
        inactiveColor: "#ccc",
        inactiveWidth: 2,
        opacity: "inherit",
        type: "inherit",
        cap: "inherit",
        join: "inherit",
        dashOffset: "inherit",
        miterLimit: "inherit"
      },
      textStyle: {
        color: "#333"
      },
      selectedMode: !0,
      selector: !1,
      selectorLabel: {
        show: !0,
        borderRadius: 10,
        padding: [3, 5, 3, 5],
        fontSize: 12,
        fontFamily: "sans-serif",
        color: "#666",
        borderWidth: 1,
        borderColor: "#666"
      },
      emphasis: {
        selectorLabel: {
          show: !0,
          color: "#eee",
          backgroundColor: "#666"
        }
      },
      selectorPosition: "auto",
      selectorItemGap: 7,
      selectorButtonGap: 10,
      tooltip: {
        show: !1
      }
    }, C;
  }(ComponentModel$1)
);
const LegendModel$1 = LegendModel;
var curry = curry$1, each$3 = each$f, Group$1 = Group$4, LegendView = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G.newlineDisabled = !1, G;
    }
    return C.prototype.init = function() {
      this.group.add(this._contentGroup = new Group$1()), this.group.add(this._selectorGroup = new Group$1()), this._isFirstRender = !0;
    }, C.prototype.getContentGroup = function() {
      return this._contentGroup;
    }, C.prototype.getSelectorGroup = function() {
      return this._selectorGroup;
    }, C.prototype.render = function(G, U, K) {
      var W = this._isFirstRender;
      if (this._isFirstRender = !1, this.resetInner(), !!G.get("show", !0)) {
        var Z = G.get("align"), X = G.get("orient");
        (!Z || Z === "auto") && (Z = G.get("left") === "right" && X === "vertical" ? "right" : "left");
        var Q = G.get("selector", !0), ee = G.get("selectorPosition", !0);
        Q && (!ee || ee === "auto") && (ee = X === "horizontal" ? "end" : "start"), this.renderInner(Z, G, U, K, Q, X, ee);
        var te = G.getBoxLayoutParams(), re = {
          width: K.getWidth(),
          height: K.getHeight()
        }, ne = G.get("padding"), ae = getLayoutRect(te, re, ne), ie = this.layoutInner(G, Z, ae, W, Q, ee), se = getLayoutRect(defaults({
          width: ie.width,
          height: ie.height
        }, te), re, ne);
        this.group.x = se.x - ie.x, this.group.y = se.y - ie.y, this.group.markRedraw(), this.group.add(this._backgroundEl = makeBackground(ie, G));
      }
    }, C.prototype.resetInner = function() {
      this.getContentGroup().removeAll(), this._backgroundEl && this.group.remove(this._backgroundEl), this.getSelectorGroup().removeAll();
    }, C.prototype.renderInner = function(G, U, K, W, Z, X, Q) {
      var ee = this.getContentGroup(), te = createHashMap(), re = U.get("selectedMode"), ne = [];
      K.eachRawSeries(function(ae) {
        !ae.get("legendHoverLink") && ne.push(ae.id);
      }), each$3(U.getData(), function(ae, ie) {
        var se = ae.get("name");
        if (!this.newlineDisabled && (se === "" || se === `
`)) {
          var oe = new Group$1();
          oe.newline = !0, ee.add(oe);
          return;
        }
        var le = K.getSeriesByName(se)[0];
        if (!te.get(se)) {
          if (le) {
            var ue = le.getData(), ce = ue.getVisual("legendLineStyle") || {}, de = ue.getVisual("legendIcon"), ge = ue.getVisual("style"), fe = this._createItem(le, se, ie, ae, U, G, ce, ge, de, re, W);
            fe.on("click", curry(dispatchSelectAction, se, null, W, ne)).on("mouseover", curry(dispatchHighlightAction, le.name, null, W, ne)).on("mouseout", curry(dispatchDownplayAction, le.name, null, W, ne)), te.set(se, !0);
          } else
            K.eachRawSeries(function(ve) {
              if (!te.get(se) && ve.legendVisualProvider) {
                var pe = ve.legendVisualProvider;
                if (!pe.containName(se))
                  return;
                var he = pe.indexOfName(se), me = pe.getItemVisual(he, "style"), ye = pe.getItemVisual(he, "legendIcon"), Ce = parse(me.fill);
                Ce && Ce[3] === 0 && (Ce[3] = 0.2, me = extend(extend({}, me), {
                  fill: stringify(Ce, "rgba")
                }));
                var Ie = this._createItem(ve, se, ie, ae, U, G, {}, me, ye, re, W);
                Ie.on("click", curry(dispatchSelectAction, null, se, W, ne)).on("mouseover", curry(dispatchHighlightAction, null, se, W, ne)).on("mouseout", curry(dispatchDownplayAction, null, se, W, ne)), te.set(se, !0);
              }
            }, this);
          process.env.NODE_ENV !== "production" && (te.get(se) || console.warn(se + " series not exists. Legend data should be same with series name or data name."));
        }
      }, this), Z && this._createSelector(Z, U, W, X, Q);
    }, C.prototype._createSelector = function(G, U, K, W, Z) {
      var X = this.getSelectorGroup();
      each$3(G, function(ee) {
        var te = ee.type, re = new ZRText$1({
          style: {
            x: 0,
            y: 0,
            align: "center",
            verticalAlign: "middle"
          },
          onclick: function() {
            K.dispatchAction({
              type: te === "all" ? "legendAllSelect" : "legendInverseSelect"
            });
          }
        });
        X.add(re);
        var ne = U.getModel("selectorLabel"), ae = U.getModel(["emphasis", "selectorLabel"]);
        setLabelStyle(re, {
          normal: ne,
          emphasis: ae
        }, {
          defaultText: ee.title
        }), enableHoverEmphasis(re);
      });
    }, C.prototype._createItem = function(G, U, K, W, Z, X, Q, ee, te, re, ne) {
      var ae = G.visualDrawType, ie = Z.get("itemWidth"), se = Z.get("itemHeight"), oe = Z.isSelected(U), le = W.get("symbolRotate"), ue = W.get("symbolKeepAspect"), ce = W.get("icon");
      te = ce || te || "roundRect";
      var de = getLegendStyle(te, W, Q, ee, ae, oe, ne), ge = new Group$1(), fe = W.getModel("textStyle");
      if (isFunction(G.getLegendIcon) && (!ce || ce === "inherit"))
        ge.add(G.getLegendIcon({
          itemWidth: ie,
          itemHeight: se,
          icon: te,
          iconRotate: le,
          itemStyle: de.itemStyle,
          lineStyle: de.lineStyle,
          symbolKeepAspect: ue
        }));
      else {
        var ve = ce === "inherit" && G.getData().getVisual("symbol") ? le === "inherit" ? G.getData().getVisual("symbolRotate") : le : 0;
        ge.add(getDefaultLegendIcon({
          itemWidth: ie,
          itemHeight: se,
          icon: te,
          iconRotate: ve,
          itemStyle: de.itemStyle,
          lineStyle: de.lineStyle,
          symbolKeepAspect: ue
        }));
      }
      var pe = X === "left" ? ie + 5 : -5, he = X, me = Z.get("formatter"), ye = U;
      isString(me) && me ? ye = me.replace("{name}", U ?? "") : isFunction(me) && (ye = me(U));
      var Ce = W.get("inactiveColor");
      ge.add(new ZRText$1({
        style: createTextStyle(fe, {
          text: ye,
          x: pe,
          y: se / 2,
          fill: oe ? fe.getTextColor() : Ce,
          align: he,
          verticalAlign: "middle"
        })
      }));
      var Ie = new Rect$3({
        shape: ge.getBoundingRect(),
        invisible: !0
      }), be = W.getModel("tooltip");
      return be.get("show") && setTooltipConfig({
        el: Ie,
        componentModel: Z,
        itemName: U,
        itemTooltipOption: be.option
      }), ge.add(Ie), ge.eachChild(function(Se) {
        Se.silent = !0;
      }), Ie.silent = !re, this.getContentGroup().add(ge), enableHoverEmphasis(ge), ge.__legendDataIndex = K, ge;
    }, C.prototype.layoutInner = function(G, U, K, W, Z, X) {
      var Q = this.getContentGroup(), ee = this.getSelectorGroup();
      box(G.get("orient"), Q, G.get("itemGap"), K.width, K.height);
      var te = Q.getBoundingRect(), re = [-te.x, -te.y];
      if (ee.markRedraw(), Q.markRedraw(), Z) {
        box(
          // Buttons in selectorGroup always layout horizontally
          "horizontal",
          ee,
          G.get("selectorItemGap", !0)
        );
        var ne = ee.getBoundingRect(), ae = [-ne.x, -ne.y], ie = G.get("selectorButtonGap", !0), se = G.getOrient().index, oe = se === 0 ? "width" : "height", le = se === 0 ? "height" : "width", ue = se === 0 ? "y" : "x";
        X === "end" ? ae[se] += te[oe] + ie : re[se] += ne[oe] + ie, ae[1 - se] += te[le] / 2 - ne[le] / 2, ee.x = ae[0], ee.y = ae[1], Q.x = re[0], Q.y = re[1];
        var ce = {
          x: 0,
          y: 0
        };
        return ce[oe] = te[oe] + ie + ne[oe], ce[le] = Math.max(te[le], ne[le]), ce[ue] = Math.min(0, ne[ue] + ae[1 - se]), ce;
      } else
        return Q.x = re[0], Q.y = re[1], this.group.getBoundingRect();
    }, C.prototype.remove = function() {
      this.getContentGroup().removeAll(), this._isFirstRender = !0;
    }, C.type = "legend.plain", C;
  }(ComponentView$1)
);
function getLegendStyle(H, C, G, U, K, W, Z) {
  function X(oe, le) {
    oe.lineWidth === "auto" && (oe.lineWidth = le.lineWidth > 0 ? 2 : 0), each$3(oe, function(ue, ce) {
      oe[ce] === "inherit" && (oe[ce] = le[ce]);
    });
  }
  var Q = C.getModel("itemStyle"), ee = Q.getItemStyle(), te = H.lastIndexOf("empty", 0) === 0 ? "fill" : "stroke", re = Q.getShallow("decal");
  ee.decal = !re || re === "inherit" ? U.decal : createOrUpdatePatternFromDecal(re, Z), ee.fill === "inherit" && (ee.fill = U[K]), ee.stroke === "inherit" && (ee.stroke = U[te]), ee.opacity === "inherit" && (ee.opacity = (K === "fill" ? U : G).opacity), X(ee, U);
  var ne = C.getModel("lineStyle"), ae = ne.getLineStyle();
  if (X(ae, G), ee.fill === "auto" && (ee.fill = U.fill), ee.stroke === "auto" && (ee.stroke = U.fill), ae.stroke === "auto" && (ae.stroke = U.fill), !W) {
    var ie = C.get("inactiveBorderWidth"), se = ee[te];
    ee.lineWidth = ie === "auto" ? U.lineWidth > 0 && se ? 2 : 0 : ee.lineWidth, ee.fill = C.get("inactiveColor"), ee.stroke = C.get("inactiveBorderColor"), ae.stroke = ne.get("inactiveColor"), ae.lineWidth = ne.get("inactiveWidth");
  }
  return {
    itemStyle: ee,
    lineStyle: ae
  };
}
function getDefaultLegendIcon(H) {
  var C = H.icon || "roundRect", G = createSymbol$1(C, 0, 0, H.itemWidth, H.itemHeight, H.itemStyle.fill, H.symbolKeepAspect);
  return G.setStyle(H.itemStyle), G.rotation = (H.iconRotate || 0) * Math.PI / 180, G.setOrigin([H.itemWidth / 2, H.itemHeight / 2]), C.indexOf("empty") > -1 && (G.style.stroke = G.style.fill, G.style.fill = "#fff", G.style.lineWidth = 2), G;
}
function dispatchSelectAction(H, C, G, U) {
  dispatchDownplayAction(H, C, G, U), G.dispatchAction({
    type: "legendToggleSelect",
    name: H ?? C
  }), dispatchHighlightAction(H, C, G, U);
}
function isUseHoverLayer(H) {
  for (var C = H.getZr().storage.getDisplayList(), G, U = 0, K = C.length; U < K && !(G = C[U].states.emphasis); )
    U++;
  return G && G.hoverLayer;
}
function dispatchHighlightAction(H, C, G, U) {
  isUseHoverLayer(G) || G.dispatchAction({
    type: "highlight",
    seriesName: H,
    name: C,
    excludeSeriesId: U
  });
}
function dispatchDownplayAction(H, C, G, U) {
  isUseHoverLayer(G) || G.dispatchAction({
    type: "downplay",
    seriesName: H,
    name: C,
    excludeSeriesId: U
  });
}
const LegendView$1 = LegendView;
function legendFilter(H) {
  var C = H.findComponents({
    mainType: "legend"
  });
  C && C.length && H.filterSeries(function(G) {
    for (var U = 0; U < C.length; U++)
      if (!C[U].isSelected(G.name))
        return !1;
    return !0;
  });
}
function legendSelectActionHandler(H, C, G) {
  var U = {}, K = H === "toggleSelected", W;
  return G.eachComponent("legend", function(Z) {
    K && W != null ? Z[W ? "select" : "unSelect"](C.name) : H === "allSelect" || H === "inverseSelect" ? Z[H]() : (Z[H](C.name), W = Z.isSelected(C.name));
    var X = Z.getData();
    each$f(X, function(Q) {
      var ee = Q.get("name");
      if (!(ee === `
` || ee === "")) {
        var te = Z.isSelected(ee);
        U.hasOwnProperty(ee) ? U[ee] = U[ee] && te : U[ee] = te;
      }
    });
  }), H === "allSelect" || H === "inverseSelect" ? {
    selected: U
  } : {
    name: C.name,
    selected: U
  };
}
function installLegendAction(H) {
  H.registerAction("legendToggleSelect", "legendselectchanged", curry$1(legendSelectActionHandler, "toggleSelected")), H.registerAction("legendAllSelect", "legendselectall", curry$1(legendSelectActionHandler, "allSelect")), H.registerAction("legendInverseSelect", "legendinverseselect", curry$1(legendSelectActionHandler, "inverseSelect")), H.registerAction("legendSelect", "legendselected", curry$1(legendSelectActionHandler, "select")), H.registerAction("legendUnSelect", "legendunselected", curry$1(legendSelectActionHandler, "unSelect"));
}
function install$b(H) {
  H.registerComponentModel(LegendModel$1), H.registerComponentView(LegendView$1), H.registerProcessor(H.PRIORITY.PROCESSOR.SERIES_FILTER, legendFilter), H.registerSubTypeDefaulter("legend", function() {
    return "plain";
  }), installLegendAction(H);
}
var ScrollableLegendModel = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G;
    }
    return C.prototype.setScrollDataIndex = function(G) {
      this.option.scrollDataIndex = G;
    }, C.prototype.init = function(G, U, K) {
      var W = getLayoutParams(G);
      H.prototype.init.call(this, G, U, K), mergeAndNormalizeLayoutParams(this, G, W);
    }, C.prototype.mergeOption = function(G, U) {
      H.prototype.mergeOption.call(this, G, U), mergeAndNormalizeLayoutParams(this, this.option, G);
    }, C.type = "legend.scroll", C.defaultOption = inheritDefaultOption(LegendModel$1.defaultOption, {
      scrollDataIndex: 0,
      pageButtonItemGap: 5,
      pageButtonGap: null,
      pageButtonPosition: "end",
      pageFormatter: "{current}/{total}",
      pageIcons: {
        horizontal: ["M0,0L12,-10L12,10z", "M0,0L-12,-10L-12,10z"],
        vertical: ["M0,0L20,0L10,-20z", "M0,0L20,0L10,20z"]
      },
      pageIconColor: "#2f4554",
      pageIconInactiveColor: "#aaa",
      pageIconSize: 15,
      pageTextStyle: {
        color: "#333"
      },
      animationDurationUpdate: 800
    }), C;
  }(LegendModel$1)
);
function mergeAndNormalizeLayoutParams(H, C, G) {
  var U = H.getOrient(), K = [1, 1];
  K[U.index] = 0, mergeLayoutParam(C, G, {
    type: "box",
    ignoreSize: !!K
  });
}
const ScrollableLegendModel$1 = ScrollableLegendModel;
var Group = Group$4, WH = ["width", "height"], XY = ["x", "y"], ScrollableLegendView = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G.newlineDisabled = !0, G._currentIndex = 0, G;
    }
    return C.prototype.init = function() {
      H.prototype.init.call(this), this.group.add(this._containerGroup = new Group()), this._containerGroup.add(this.getContentGroup()), this.group.add(this._controllerGroup = new Group());
    }, C.prototype.resetInner = function() {
      H.prototype.resetInner.call(this), this._controllerGroup.removeAll(), this._containerGroup.removeClipPath(), this._containerGroup.__rectSize = null;
    }, C.prototype.renderInner = function(G, U, K, W, Z, X, Q) {
      var ee = this;
      H.prototype.renderInner.call(this, G, U, K, W, Z, X, Q);
      var te = this._controllerGroup, re = U.get("pageIconSize", !0), ne = isArray$1(re) ? re : [re, re];
      ie("pagePrev", 0);
      var ae = U.getModel("pageTextStyle");
      te.add(new ZRText$1({
        name: "pageText",
        style: {
          // Placeholder to calculate a proper layout.
          text: "xx/xx",
          fill: ae.getTextColor(),
          font: ae.getFont(),
          verticalAlign: "middle",
          align: "center"
        },
        silent: !0
      })), ie("pageNext", 1);
      function ie(se, oe) {
        var le = se + "DataIndex", ue = createIcon(U.get("pageIcons", !0)[U.getOrient().name][oe], {
          // Buttons will be created in each render, so we do not need
          // to worry about avoiding using legendModel kept in scope.
          onclick: bind$1(ee._pageGo, ee, le, U, W)
        }, {
          x: -ne[0] / 2,
          y: -ne[1] / 2,
          width: ne[0],
          height: ne[1]
        });
        ue.name = se, te.add(ue);
      }
    }, C.prototype.layoutInner = function(G, U, K, W, Z, X) {
      var Q = this.getSelectorGroup(), ee = G.getOrient().index, te = WH[ee], re = XY[ee], ne = WH[1 - ee], ae = XY[1 - ee];
      Z && box(
        // Buttons in selectorGroup always layout horizontally
        "horizontal",
        Q,
        G.get("selectorItemGap", !0)
      );
      var ie = G.get("selectorButtonGap", !0), se = Q.getBoundingRect(), oe = [-se.x, -se.y], le = clone$4(K);
      Z && (le[te] = K[te] - se[te] - ie);
      var ue = this._layoutContentAndController(G, W, le, ee, te, ne, ae, re);
      if (Z) {
        if (X === "end")
          oe[ee] += ue[te] + ie;
        else {
          var ce = se[te] + ie;
          oe[ee] -= ce, ue[re] -= ce;
        }
        ue[te] += se[te] + ie, oe[1 - ee] += ue[ae] + ue[ne] / 2 - se[ne] / 2, ue[ne] = Math.max(ue[ne], se[ne]), ue[ae] = Math.min(ue[ae], se[ae] + oe[1 - ee]), Q.x = oe[0], Q.y = oe[1], Q.markRedraw();
      }
      return ue;
    }, C.prototype._layoutContentAndController = function(G, U, K, W, Z, X, Q, ee) {
      var te = this.getContentGroup(), re = this._containerGroup, ne = this._controllerGroup;
      box(G.get("orient"), te, G.get("itemGap"), W ? K.width : null, W ? null : K.height), box(
        // Buttons in controller are layout always horizontally.
        "horizontal",
        ne,
        G.get("pageButtonItemGap", !0)
      );
      var ae = te.getBoundingRect(), ie = ne.getBoundingRect(), se = this._showController = ae[Z] > K[Z], oe = [-ae.x, -ae.y];
      U || (oe[W] = te[ee]);
      var le = [0, 0], ue = [-ie.x, -ie.y], ce = retrieve2(G.get("pageButtonGap", !0), G.get("itemGap", !0));
      if (se) {
        var de = G.get("pageButtonPosition", !0);
        de === "end" ? ue[W] += K[Z] - ie[Z] : le[W] += ie[Z] + ce;
      }
      ue[1 - W] += ae[X] / 2 - ie[X] / 2, te.setPosition(oe), re.setPosition(le), ne.setPosition(ue);
      var ge = {
        x: 0,
        y: 0
      };
      if (ge[Z] = se ? K[Z] : ae[Z], ge[X] = Math.max(ae[X], ie[X]), ge[Q] = Math.min(0, ie[Q] + ue[1 - W]), re.__rectSize = K[Z], se) {
        var fe = {
          x: 0,
          y: 0
        };
        fe[Z] = Math.max(K[Z] - ie[Z] - ce, 0), fe[X] = ge[X], re.setClipPath(new Rect$3({
          shape: fe
        })), re.__rectSize = fe[Z];
      } else
        ne.eachChild(function(pe) {
          pe.attr({
            invisible: !0,
            silent: !0
          });
        });
      var ve = this._getPageInfo(G);
      return ve.pageIndex != null && updateProps$1(
        te,
        {
          x: ve.contentPosition[0],
          y: ve.contentPosition[1]
        },
        // When switch from "show controller" to "not show controller", view should be
        // updated immediately without animation, otherwise causes weird effect.
        se ? G : null
      ), this._updatePageInfoView(G, ve), ge;
    }, C.prototype._pageGo = function(G, U, K) {
      var W = this._getPageInfo(U)[G];
      W != null && K.dispatchAction({
        type: "legendScroll",
        scrollDataIndex: W,
        legendId: U.id
      });
    }, C.prototype._updatePageInfoView = function(G, U) {
      var K = this._controllerGroup;
      each$f(["pagePrev", "pageNext"], function(te) {
        var re = te + "DataIndex", ne = U[re] != null, ae = K.childOfName(te);
        ae && (ae.setStyle("fill", ne ? G.get("pageIconColor", !0) : G.get("pageIconInactiveColor", !0)), ae.cursor = ne ? "pointer" : "default");
      });
      var W = K.childOfName("pageText"), Z = G.get("pageFormatter"), X = U.pageIndex, Q = X != null ? X + 1 : 0, ee = U.pageCount;
      W && Z && W.setStyle("text", isString(Z) ? Z.replace("{current}", Q == null ? "" : Q + "").replace("{total}", ee == null ? "" : ee + "") : Z({
        current: Q,
        total: ee
      }));
    }, C.prototype._getPageInfo = function(G) {
      var U = G.get("scrollDataIndex", !0), K = this.getContentGroup(), W = this._containerGroup.__rectSize, Z = G.getOrient().index, X = WH[Z], Q = XY[Z], ee = this._findTargetItemIndex(U), te = K.children(), re = te[ee], ne = te.length, ae = ne ? 1 : 0, ie = {
        contentPosition: [K.x, K.y],
        pageCount: ae,
        pageIndex: ae - 1,
        pagePrevDataIndex: null,
        pageNextDataIndex: null
      };
      if (!re)
        return ie;
      var se = de(re);
      ie.contentPosition[Z] = -se.s;
      for (var oe = ee + 1, le = se, ue = se, ce = null; oe <= ne; ++oe)
        ce = de(te[oe]), // Half of the last item is out of the window.
        (!ce && ue.e > le.s + W || // If the current item does not intersect with the window, the new page
        // can be started at the current item or the last item.
        ce && !ge(ce, le.s)) && (ue.i > le.i ? le = ue : le = ce, le && (ie.pageNextDataIndex == null && (ie.pageNextDataIndex = le.i), ++ie.pageCount)), ue = ce;
      for (var oe = ee - 1, le = se, ue = se, ce = null; oe >= -1; --oe)
        ce = de(te[oe]), (!ce || !ge(ue, ce.s)) && // e.g., when page size is smaller than item size.
        le.i < ue.i && (ue = le, ie.pagePrevDataIndex == null && (ie.pagePrevDataIndex = le.i), ++ie.pageCount, ++ie.pageIndex), le = ce;
      return ie;
      function de(fe) {
        if (fe) {
          var ve = fe.getBoundingRect(), pe = ve[Q] + fe[Q];
          return {
            s: pe,
            e: pe + ve[X],
            i: fe.__legendDataIndex
          };
        }
      }
      function ge(fe, ve) {
        return fe.e >= ve && fe.s <= ve + W;
      }
    }, C.prototype._findTargetItemIndex = function(G) {
      if (!this._showController)
        return 0;
      var U, K = this.getContentGroup(), W;
      return K.eachChild(function(Z, X) {
        var Q = Z.__legendDataIndex;
        W == null && Q != null && (W = X), Q === G && (U = X);
      }), U ?? W;
    }, C.type = "legend.scroll", C;
  }(LegendView$1)
);
const ScrollableLegendView$1 = ScrollableLegendView;
function installScrollableLegendAction(H) {
  H.registerAction("legendScroll", "legendscroll", function(C, G) {
    var U = C.scrollDataIndex;
    U != null && G.eachComponent({
      mainType: "legend",
      subType: "scroll",
      query: C
    }, function(K) {
      K.setScrollDataIndex(U);
    });
  });
}
function install$a(H) {
  use(install$b), H.registerComponentModel(ScrollableLegendModel$1), H.registerComponentView(ScrollableLegendView$1), installScrollableLegendAction(H);
}
function install$9(H) {
  use(install$b), use(install$a);
}
var InsideZoomModel = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G;
    }
    return C.type = "dataZoom.inside", C.defaultOption = inheritDefaultOption(DataZoomModel$1.defaultOption, {
      disabled: !1,
      zoomLock: !1,
      zoomOnMouseWheel: !0,
      moveOnMouseMove: !0,
      moveOnMouseWheel: !1,
      preventDefaultMouseMove: !0
    }), C;
  }(DataZoomModel$1)
);
const InsideZoomModel$1 = InsideZoomModel;
var inner$1 = makeInner();
function setViewInfoToCoordSysRecord(H, C, G) {
  inner$1(H).coordSysRecordMap.each(function(U) {
    var K = U.dataZoomInfoMap.get(C.uid);
    K && (K.getRange = G);
  });
}
function disposeCoordSysRecordIfNeeded(H, C) {
  for (var G = inner$1(H).coordSysRecordMap, U = G.keys(), K = 0; K < U.length; K++) {
    var W = U[K], Z = G.get(W), X = Z.dataZoomInfoMap;
    if (X) {
      var Q = C.uid, ee = X.get(Q);
      ee && (X.removeKey(Q), X.keys().length || disposeCoordSysRecord(G, Z));
    }
  }
}
function disposeCoordSysRecord(H, C) {
  if (C) {
    H.removeKey(C.model.uid);
    var G = C.controller;
    G && G.dispose();
  }
}
function createCoordSysRecord(H, C) {
  var G = {
    model: C,
    containsPoint: curry$1(containsPoint, C),
    dispatchAction: curry$1(dispatchAction, H),
    dataZoomInfoMap: null,
    controller: null
  }, U = G.controller = new RoamController$1(H.getZr());
  return each$f(["pan", "zoom", "scrollMove"], function(K) {
    U.on(K, function(W) {
      var Z = [];
      G.dataZoomInfoMap.each(function(X) {
        if (W.isAvailableBehavior(X.model.option)) {
          var Q = (X.getRange || {})[K], ee = Q && Q(X.dzReferCoordSysInfo, G.model.mainType, G.controller, W);
          !X.model.get("disabled", !0) && ee && Z.push({
            dataZoomId: X.model.id,
            start: ee[0],
            end: ee[1]
          });
        }
      }), Z.length && G.dispatchAction(Z);
    });
  }), G;
}
function dispatchAction(H, C) {
  H.isDisposed() || H.dispatchAction({
    type: "dataZoom",
    animation: {
      easing: "cubicOut",
      duration: 100
    },
    batch: C
  });
}
function containsPoint(H, C, G, U) {
  return H.coordinateSystem.containPoint([G, U]);
}
function mergeControllerParams(H) {
  var C, G = "type_", U = {
    type_true: 2,
    type_move: 1,
    type_false: 0,
    type_undefined: -1
  }, K = !0;
  return H.each(function(W) {
    var Z = W.model, X = Z.get("disabled", !0) ? !1 : Z.get("zoomLock", !0) ? "move" : !0;
    U[G + X] > U[G + C] && (C = X), K = K && Z.get("preventDefaultMouseMove", !0);
  }), {
    controlType: C,
    opt: {
      // RoamController will enable all of these functionalities,
      // and the final behavior is determined by its event listener
      // provided by each inside zoom.
      zoomOnMouseWheel: !0,
      moveOnMouseMove: !0,
      moveOnMouseWheel: !0,
      preventDefaultMouseMove: !!K
    }
  };
}
function installDataZoomRoamProcessor(H) {
  H.registerProcessor(H.PRIORITY.PROCESSOR.FILTER, function(C, G) {
    var U = inner$1(G), K = U.coordSysRecordMap || (U.coordSysRecordMap = createHashMap());
    K.each(function(W) {
      W.dataZoomInfoMap = null;
    }), C.eachComponent({
      mainType: "dataZoom",
      subType: "inside"
    }, function(W) {
      var Z = collectReferCoordSysModelInfo(W);
      each$f(Z.infoList, function(X) {
        var Q = X.model.uid, ee = K.get(Q) || K.set(Q, createCoordSysRecord(G, X.model)), te = ee.dataZoomInfoMap || (ee.dataZoomInfoMap = createHashMap());
        te.set(W.uid, {
          dzReferCoordSysInfo: X,
          model: W,
          getRange: null
        });
      });
    }), K.each(function(W) {
      var Z = W.controller, X, Q = W.dataZoomInfoMap;
      if (Q) {
        var ee = Q.keys()[0];
        ee != null && (X = Q.get(ee));
      }
      if (!X) {
        disposeCoordSysRecord(K, W);
        return;
      }
      var te = mergeControllerParams(Q);
      Z.enable(te.controlType, te.opt), Z.setPointerChecker(W.containsPoint), createOrUpdate(W, "dispatchAction", X.model.get("throttle", !0), "fixRate");
    });
  });
}
var InsideZoomView = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = "dataZoom.inside", G;
    }
    return C.prototype.render = function(G, U, K) {
      if (H.prototype.render.apply(this, arguments), G.noTarget()) {
        this._clear();
        return;
      }
      this.range = G.getPercentRange(), setViewInfoToCoordSysRecord(K, G, {
        pan: bind$1(getRangeHandlers.pan, this),
        zoom: bind$1(getRangeHandlers.zoom, this),
        scrollMove: bind$1(getRangeHandlers.scrollMove, this)
      });
    }, C.prototype.dispose = function() {
      this._clear(), H.prototype.dispose.apply(this, arguments);
    }, C.prototype._clear = function() {
      disposeCoordSysRecordIfNeeded(this.api, this.dataZoomModel), this.range = null;
    }, C.type = "dataZoom.inside", C;
  }(DataZoomView$1)
), getRangeHandlers = {
  zoom: function(H, C, G, U) {
    var K = this.range, W = K.slice(), Z = H.axisModels[0];
    if (Z) {
      var X = getDirectionInfo[C](null, [U.originX, U.originY], Z, G, H), Q = (X.signal > 0 ? X.pixelStart + X.pixelLength - X.pixel : X.pixel - X.pixelStart) / X.pixelLength * (W[1] - W[0]) + W[0], ee = Math.max(1 / U.scale, 0);
      W[0] = (W[0] - Q) * ee + Q, W[1] = (W[1] - Q) * ee + Q;
      var te = this.dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();
      if (sliderMove(0, W, [0, 100], 0, te.minSpan, te.maxSpan), this.range = W, K[0] !== W[0] || K[1] !== W[1])
        return W;
    }
  },
  pan: makeMover(function(H, C, G, U, K, W) {
    var Z = getDirectionInfo[U]([W.oldX, W.oldY], [W.newX, W.newY], C, K, G);
    return Z.signal * (H[1] - H[0]) * Z.pixel / Z.pixelLength;
  }),
  scrollMove: makeMover(function(H, C, G, U, K, W) {
    var Z = getDirectionInfo[U]([0, 0], [W.scrollDelta, W.scrollDelta], C, K, G);
    return Z.signal * (H[1] - H[0]) * W.scrollDelta;
  })
};
function makeMover(H) {
  return function(C, G, U, K) {
    var W = this.range, Z = W.slice(), X = C.axisModels[0];
    if (X) {
      var Q = H(Z, X, C, G, U, K);
      if (sliderMove(Q, Z, [0, 100], "all"), this.range = Z, W[0] !== Z[0] || W[1] !== Z[1])
        return Z;
    }
  };
}
var getDirectionInfo = {
  grid: function(H, C, G, U, K) {
    var W = G.axis, Z = {}, X = K.model.coordinateSystem.getRect();
    return H = H || [0, 0], W.dim === "x" ? (Z.pixel = C[0] - H[0], Z.pixelLength = X.width, Z.pixelStart = X.x, Z.signal = W.inverse ? 1 : -1) : (Z.pixel = C[1] - H[1], Z.pixelLength = X.height, Z.pixelStart = X.y, Z.signal = W.inverse ? -1 : 1), Z;
  },
  polar: function(H, C, G, U, K) {
    var W = G.axis, Z = {}, X = K.model.coordinateSystem, Q = X.getRadiusAxis().getExtent(), ee = X.getAngleAxis().getExtent();
    return H = H ? X.pointToCoord(H) : [0, 0], C = X.pointToCoord(C), G.mainType === "radiusAxis" ? (Z.pixel = C[0] - H[0], Z.pixelLength = Q[1] - Q[0], Z.pixelStart = Q[0], Z.signal = W.inverse ? 1 : -1) : (Z.pixel = C[1] - H[1], Z.pixelLength = ee[1] - ee[0], Z.pixelStart = ee[0], Z.signal = W.inverse ? -1 : 1), Z;
  },
  singleAxis: function(H, C, G, U, K) {
    var W = G.axis, Z = K.model.coordinateSystem.getRect(), X = {};
    return H = H || [0, 0], W.orient === "horizontal" ? (X.pixel = C[0] - H[0], X.pixelLength = Z.width, X.pixelStart = Z.x, X.signal = W.inverse ? 1 : -1) : (X.pixel = C[1] - H[1], X.pixelLength = Z.height, X.pixelStart = Z.y, X.signal = W.inverse ? -1 : 1), X;
  }
};
const InsideZoomView$1 = InsideZoomView;
function install$8(H) {
  installCommon$1(H), H.registerComponentModel(InsideZoomModel$1), H.registerComponentView(InsideZoomView$1), installDataZoomRoamProcessor(H);
}
var SliderZoomModel = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G;
    }
    return C.type = "dataZoom.slider", C.layoutMode = "box", C.defaultOption = inheritDefaultOption(DataZoomModel$1.defaultOption, {
      show: !0,
      // deault value can only be drived in view stage.
      right: "ph",
      top: "ph",
      width: "ph",
      height: "ph",
      left: null,
      bottom: null,
      borderColor: "#d2dbee",
      borderRadius: 3,
      backgroundColor: "rgba(47,69,84,0)",
      // dataBackgroundColor: '#ddd',
      dataBackground: {
        lineStyle: {
          color: "#d2dbee",
          width: 0.5
        },
        areaStyle: {
          color: "#d2dbee",
          opacity: 0.2
        }
      },
      selectedDataBackground: {
        lineStyle: {
          color: "#8fb0f7",
          width: 0.5
        },
        areaStyle: {
          color: "#8fb0f7",
          opacity: 0.2
        }
      },
      // Color of selected window.
      fillerColor: "rgba(135,175,274,0.2)",
      handleIcon: "path://M-9.35,34.56V42m0-40V9.5m-2,0h4a2,2,0,0,1,2,2v21a2,2,0,0,1-2,2h-4a2,2,0,0,1-2-2v-21A2,2,0,0,1-11.35,9.5Z",
      // Percent of the slider height
      handleSize: "100%",
      handleStyle: {
        color: "#fff",
        borderColor: "#ACB8D1"
      },
      moveHandleSize: 7,
      moveHandleIcon: "path://M-320.9-50L-320.9-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-348-41-339-50-320.9-50z M-212.3-50L-212.3-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-239.4-41-230.4-50-212.3-50z M-103.7-50L-103.7-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-130.9-41-121.8-50-103.7-50z",
      moveHandleStyle: {
        color: "#D2DBEE",
        opacity: 0.7
      },
      showDetail: !0,
      showDataShadow: "auto",
      realtime: !0,
      zoomLock: !1,
      textStyle: {
        color: "#6E7079"
      },
      brushSelect: !0,
      brushStyle: {
        color: "rgba(135,175,274,0.15)"
      },
      emphasis: {
        handleStyle: {
          borderColor: "#8FB0F7"
        },
        moveHandleStyle: {
          color: "#8FB0F7"
        }
      }
    }), C;
  }(DataZoomModel$1)
);
const SliderZoomModel$1 = SliderZoomModel;
var Rect = Rect$3, DEFAULT_LOCATION_EDGE_GAP = 7, DEFAULT_FRAME_BORDER_WIDTH = 1, DEFAULT_FILLER_SIZE = 30, DEFAULT_MOVE_HANDLE_SIZE = 7, HORIZONTAL = "horizontal", VERTICAL = "vertical", LABEL_GAP = 5, SHOW_DATA_SHADOW_SERIES_TYPE = ["line", "bar", "candlestick", "scatter"], REALTIME_ANIMATION_CONFIG = {
  easing: "cubicOut",
  duration: 100,
  delay: 0
}, SliderZoomView = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G._displayables = {}, G;
    }
    return C.prototype.init = function(G, U) {
      this.api = U, this._onBrush = bind$1(this._onBrush, this), this._onBrushEnd = bind$1(this._onBrushEnd, this);
    }, C.prototype.render = function(G, U, K, W) {
      if (H.prototype.render.apply(this, arguments), createOrUpdate(this, "_dispatchZoomAction", G.get("throttle"), "fixRate"), this._orient = G.getOrient(), G.get("show") === !1) {
        this.group.removeAll();
        return;
      }
      if (G.noTarget()) {
        this._clear(), this.group.removeAll();
        return;
      }
      (!W || W.type !== "dataZoom" || W.from !== this.uid) && this._buildView(), this._updateView();
    }, C.prototype.dispose = function() {
      this._clear(), H.prototype.dispose.apply(this, arguments);
    }, C.prototype._clear = function() {
      clear$1(this, "_dispatchZoomAction");
      var G = this.api.getZr();
      G.off("mousemove", this._onBrush), G.off("mouseup", this._onBrushEnd);
    }, C.prototype._buildView = function() {
      var G = this.group;
      G.removeAll(), this._brushing = !1, this._displayables.brushRect = null, this._resetLocation(), this._resetInterval();
      var U = this._displayables.sliderGroup = new Group$4();
      this._renderBackground(), this._renderHandle(), this._renderDataShadow(), G.add(U), this._positionGroup();
    }, C.prototype._resetLocation = function() {
      var G = this.dataZoomModel, U = this.api, K = G.get("brushSelect"), W = K ? DEFAULT_MOVE_HANDLE_SIZE : 0, Z = this._findCoordRect(), X = {
        width: U.getWidth(),
        height: U.getHeight()
      }, Q = this._orient === HORIZONTAL ? {
        // Why using 'right', because right should be used in vertical,
        // and it is better to be consistent for dealing with position param merge.
        right: X.width - Z.x - Z.width,
        top: X.height - DEFAULT_FILLER_SIZE - DEFAULT_LOCATION_EDGE_GAP - W,
        width: Z.width,
        height: DEFAULT_FILLER_SIZE
      } : {
        right: DEFAULT_LOCATION_EDGE_GAP,
        top: Z.y,
        width: DEFAULT_FILLER_SIZE,
        height: Z.height
      }, ee = getLayoutParams(G.option);
      each$f(["right", "top", "width", "height"], function(re) {
        ee[re] === "ph" && (ee[re] = Q[re]);
      });
      var te = getLayoutRect(ee, X);
      this._location = {
        x: te.x,
        y: te.y
      }, this._size = [te.width, te.height], this._orient === VERTICAL && this._size.reverse();
    }, C.prototype._positionGroup = function() {
      var G = this.group, U = this._location, K = this._orient, W = this.dataZoomModel.getFirstTargetAxisModel(), Z = W && W.get("inverse"), X = this._displayables.sliderGroup, Q = (this._dataShadowInfo || {}).otherAxisInverse;
      X.attr(K === HORIZONTAL && !Z ? {
        scaleY: Q ? 1 : -1,
        scaleX: 1
      } : K === HORIZONTAL && Z ? {
        scaleY: Q ? 1 : -1,
        scaleX: -1
      } : K === VERTICAL && !Z ? {
        scaleY: Q ? -1 : 1,
        scaleX: 1,
        rotation: Math.PI / 2
      } : {
        scaleY: Q ? -1 : 1,
        scaleX: -1,
        rotation: Math.PI / 2
      });
      var ee = G.getBoundingRect([X]);
      G.x = U.x - ee.x, G.y = U.y - ee.y, G.markRedraw();
    }, C.prototype._getViewExtent = function() {
      return [0, this._size[0]];
    }, C.prototype._renderBackground = function() {
      var G = this.dataZoomModel, U = this._size, K = this._displayables.sliderGroup, W = G.get("brushSelect");
      K.add(new Rect({
        silent: !0,
        shape: {
          x: 0,
          y: 0,
          width: U[0],
          height: U[1]
        },
        style: {
          fill: G.get("backgroundColor")
        },
        z2: -40
      }));
      var Z = new Rect({
        shape: {
          x: 0,
          y: 0,
          width: U[0],
          height: U[1]
        },
        style: {
          fill: "transparent"
        },
        z2: 0,
        onclick: bind$1(this._onClickPanel, this)
      }), X = this.api.getZr();
      W ? (Z.on("mousedown", this._onBrushStart, this), Z.cursor = "crosshair", X.on("mousemove", this._onBrush), X.on("mouseup", this._onBrushEnd)) : (X.off("mousemove", this._onBrush), X.off("mouseup", this._onBrushEnd)), K.add(Z);
    }, C.prototype._renderDataShadow = function() {
      var G = this._dataShadowInfo = this._prepareDataShadowInfo();
      if (this._displayables.dataShadowSegs = [], !G)
        return;
      var U = this._size, K = this._shadowSize || [], W = G.series, Z = W.getRawData(), X = W.getShadowDim && W.getShadowDim(), Q = X && Z.getDimensionInfo(X) ? W.getShadowDim() : G.otherDim;
      if (Q == null)
        return;
      var ee = this._shadowPolygonPts, te = this._shadowPolylinePts;
      if (Z !== this._shadowData || Q !== this._shadowDim || U[0] !== K[0] || U[1] !== K[1]) {
        var re = Z.getDataExtent(Q), ne = (re[1] - re[0]) * 0.3;
        re = [re[0] - ne, re[1] + ne];
        var ae = [0, U[1]], ie = [0, U[0]], se = [[U[0], 0], [0, 0]], oe = [], le = ie[1] / (Z.count() - 1), ue = 0, ce = Math.round(Z.count() / U[0]), de;
        Z.each([Q], function(he, me) {
          if (ce > 0 && me % ce) {
            ue += le;
            return;
          }
          var ye = he == null || isNaN(he) || he === "", Ce = ye ? 0 : linearMap$2(he, re, ae, !0);
          ye && !de && me ? (se.push([se[se.length - 1][0], 0]), oe.push([oe[oe.length - 1][0], 0])) : !ye && de && (se.push([ue, 0]), oe.push([ue, 0])), se.push([ue, Ce]), oe.push([ue, Ce]), ue += le, de = ye;
        }), ee = this._shadowPolygonPts = se, te = this._shadowPolylinePts = oe;
      }
      this._shadowData = Z, this._shadowDim = Q, this._shadowSize = [U[0], U[1]];
      var ge = this.dataZoomModel;
      function fe(he) {
        var me = ge.getModel(he ? "selectedDataBackground" : "dataBackground"), ye = new Group$4(), Ce = new Polygon$1({
          shape: {
            points: ee
          },
          segmentIgnoreThreshold: 1,
          style: me.getModel("areaStyle").getAreaStyle(),
          silent: !0,
          z2: -20
        }), Ie = new Polyline$3({
          shape: {
            points: te
          },
          segmentIgnoreThreshold: 1,
          style: me.getModel("lineStyle").getLineStyle(),
          silent: !0,
          z2: -19
        });
        return ye.add(Ce), ye.add(Ie), ye;
      }
      for (var ve = 0; ve < 3; ve++) {
        var pe = fe(ve === 1);
        this._displayables.sliderGroup.add(pe), this._displayables.dataShadowSegs.push(pe);
      }
    }, C.prototype._prepareDataShadowInfo = function() {
      var G = this.dataZoomModel, U = G.get("showDataShadow");
      if (U !== !1) {
        var K, W = this.ecModel;
        return G.eachTargetAxis(function(Z, X) {
          var Q = G.getAxisProxy(Z, X).getTargetSeriesModels();
          each$f(Q, function(ee) {
            if (!K && !(U !== !0 && indexOf(SHOW_DATA_SHADOW_SERIES_TYPE, ee.get("type")) < 0)) {
              var te = W.getComponent(getAxisMainType(Z), X).axis, re = getOtherDim(Z), ne, ae = ee.coordinateSystem;
              re != null && ae.getOtherAxis && (ne = ae.getOtherAxis(te).inverse), re = ee.getData().mapDimension(re), K = {
                thisAxis: te,
                series: ee,
                thisDim: Z,
                otherDim: re,
                otherAxisInverse: ne
              };
            }
          }, this);
        }, this), K;
      }
    }, C.prototype._renderHandle = function() {
      var G = this.group, U = this._displayables, K = U.handles = [null, null], W = U.handleLabels = [null, null], Z = this._displayables.sliderGroup, X = this._size, Q = this.dataZoomModel, ee = this.api, te = Q.get("borderRadius") || 0, re = Q.get("brushSelect"), ne = U.filler = new Rect({
        silent: re,
        style: {
          fill: Q.get("fillerColor")
        },
        textConfig: {
          position: "inside"
        }
      });
      Z.add(ne), Z.add(new Rect({
        silent: !0,
        subPixelOptimize: !0,
        shape: {
          x: 0,
          y: 0,
          width: X[0],
          height: X[1],
          r: te
        },
        style: {
          // deprecated option
          stroke: Q.get("dataBackgroundColor") || Q.get("borderColor"),
          lineWidth: DEFAULT_FRAME_BORDER_WIDTH,
          fill: "rgba(0,0,0,0)"
        }
      })), each$f([0, 1], function(ce) {
        var de = Q.get("handleIcon");
        !symbolBuildProxies[de] && de.indexOf("path://") < 0 && de.indexOf("image://") < 0 && (de = "path://" + de, process.env.NODE_ENV !== "production" && deprecateLog("handleIcon now needs 'path://' prefix when using a path string"));
        var ge = createSymbol$1(de, -1, 0, 2, 2, null, !0);
        ge.attr({
          cursor: getCursor$1(this._orient),
          draggable: !0,
          drift: bind$1(this._onDragMove, this, ce),
          ondragend: bind$1(this._onDragEnd, this),
          onmouseover: bind$1(this._showDataInfo, this, !0),
          onmouseout: bind$1(this._showDataInfo, this, !1),
          z2: 5
        });
        var fe = ge.getBoundingRect(), ve = Q.get("handleSize");
        this._handleHeight = parsePercent(ve, this._size[1]), this._handleWidth = fe.width / fe.height * this._handleHeight, ge.setStyle(Q.getModel("handleStyle").getItemStyle()), ge.style.strokeNoScale = !0, ge.rectHover = !0, ge.ensureState("emphasis").style = Q.getModel(["emphasis", "handleStyle"]).getItemStyle(), enableHoverEmphasis(ge);
        var pe = Q.get("handleColor");
        pe != null && (ge.style.fill = pe), Z.add(K[ce] = ge);
        var he = Q.getModel("textStyle");
        G.add(W[ce] = new ZRText$1({
          silent: !0,
          invisible: !0,
          style: createTextStyle(he, {
            x: 0,
            y: 0,
            text: "",
            verticalAlign: "middle",
            align: "center",
            fill: he.getTextColor(),
            font: he.getFont()
          }),
          z2: 10
        }));
      }, this);
      var ae = ne;
      if (re) {
        var ie = parsePercent(Q.get("moveHandleSize"), X[1]), se = U.moveHandle = new Rect$3({
          style: Q.getModel("moveHandleStyle").getItemStyle(),
          silent: !0,
          shape: {
            r: [0, 0, 2, 2],
            y: X[1] - 0.5,
            height: ie
          }
        }), oe = ie * 0.8, le = U.moveHandleIcon = createSymbol$1(Q.get("moveHandleIcon"), -oe / 2, -oe / 2, oe, oe, "#fff", !0);
        le.silent = !0, le.y = X[1] + ie / 2 - 0.5, se.ensureState("emphasis").style = Q.getModel(["emphasis", "moveHandleStyle"]).getItemStyle();
        var ue = Math.min(X[1] / 2, Math.max(ie, 10));
        ae = U.moveZone = new Rect$3({
          invisible: !0,
          shape: {
            y: X[1] - ue,
            height: ie + ue
          }
        }), ae.on("mouseover", function() {
          ee.enterEmphasis(se);
        }).on("mouseout", function() {
          ee.leaveEmphasis(se);
        }), Z.add(se), Z.add(le), Z.add(ae);
      }
      ae.attr({
        draggable: !0,
        cursor: getCursor$1(this._orient),
        drift: bind$1(this._onDragMove, this, "all"),
        ondragstart: bind$1(this._showDataInfo, this, !0),
        ondragend: bind$1(this._onDragEnd, this),
        onmouseover: bind$1(this._showDataInfo, this, !0),
        onmouseout: bind$1(this._showDataInfo, this, !1)
      });
    }, C.prototype._resetInterval = function() {
      var G = this._range = this.dataZoomModel.getPercentRange(), U = this._getViewExtent();
      this._handleEnds = [linearMap$2(G[0], [0, 100], U, !0), linearMap$2(G[1], [0, 100], U, !0)];
    }, C.prototype._updateInterval = function(G, U) {
      var K = this.dataZoomModel, W = this._handleEnds, Z = this._getViewExtent(), X = K.findRepresentativeAxisProxy().getMinMaxSpan(), Q = [0, 100];
      sliderMove(U, W, Z, K.get("zoomLock") ? "all" : G, X.minSpan != null ? linearMap$2(X.minSpan, Q, Z, !0) : null, X.maxSpan != null ? linearMap$2(X.maxSpan, Q, Z, !0) : null);
      var ee = this._range, te = this._range = asc$2([linearMap$2(W[0], Z, Q, !0), linearMap$2(W[1], Z, Q, !0)]);
      return !ee || ee[0] !== te[0] || ee[1] !== te[1];
    }, C.prototype._updateView = function(G) {
      var U = this._displayables, K = this._handleEnds, W = asc$2(K.slice()), Z = this._size;
      each$f([0, 1], function(ae) {
        var ie = U.handles[ae], se = this._handleHeight;
        ie.attr({
          scaleX: se / 2,
          scaleY: se / 2,
          // This is a trick, by adding an extra tiny offset to let the default handle's end point align to the drag window.
          // NOTE: It may affect some custom shapes a bit. But we prefer to have better result by default.
          x: K[ae] + (ae ? -1 : 1),
          y: Z[1] / 2 - se / 2
        });
      }, this), U.filler.setShape({
        x: W[0],
        y: 0,
        width: W[1] - W[0],
        height: Z[1]
      });
      var X = {
        x: W[0],
        width: W[1] - W[0]
      };
      U.moveHandle && (U.moveHandle.setShape(X), U.moveZone.setShape(X), U.moveZone.getBoundingRect(), U.moveHandleIcon && U.moveHandleIcon.attr("x", X.x + X.width / 2));
      for (var Q = U.dataShadowSegs, ee = [0, W[0], W[1], Z[0]], te = 0; te < Q.length; te++) {
        var re = Q[te], ne = re.getClipPath();
        ne || (ne = new Rect$3(), re.setClipPath(ne)), ne.setShape({
          x: ee[te],
          y: 0,
          width: ee[te + 1] - ee[te],
          height: Z[1]
        });
      }
      this._updateDataInfo(G);
    }, C.prototype._updateDataInfo = function(G) {
      var U = this.dataZoomModel, K = this._displayables, W = K.handleLabels, Z = this._orient, X = ["", ""];
      if (U.get("showDetail")) {
        var Q = U.findRepresentativeAxisProxy();
        if (Q) {
          var ee = Q.getAxisModel().axis, te = this._range, re = G ? Q.calculateDataWindow({
            start: te[0],
            end: te[1]
          }).valueWindow : Q.getDataValueWindow();
          X = [this._formatLabel(re[0], ee), this._formatLabel(re[1], ee)];
        }
      }
      var ne = asc$2(this._handleEnds.slice());
      ae.call(this, 0), ae.call(this, 1);
      function ae(ie) {
        var se = getTransform$1(K.handles[ie].parent, this.group), oe = transformDirection(ie === 0 ? "right" : "left", se), le = this._handleWidth / 2 + LABEL_GAP, ue = applyTransform([ne[ie] + (ie === 0 ? -le : le), this._size[1] / 2], se);
        W[ie].setStyle({
          x: ue[0],
          y: ue[1],
          verticalAlign: Z === HORIZONTAL ? "middle" : oe,
          align: Z === HORIZONTAL ? oe : "center",
          text: X[ie]
        });
      }
    }, C.prototype._formatLabel = function(G, U) {
      var K = this.dataZoomModel, W = K.get("labelFormatter"), Z = K.get("labelPrecision");
      (Z == null || Z === "auto") && (Z = U.getPixelPrecision());
      var X = G == null || isNaN(G) ? "" : U.type === "category" || U.type === "time" ? U.scale.getLabel({
        value: Math.round(G)
      }) : G.toFixed(Math.min(Z, 20));
      return isFunction(W) ? W(G, X) : isString(W) ? W.replace("{value}", X) : X;
    }, C.prototype._showDataInfo = function(G) {
      G = this._dragging || G;
      var U = this._displayables, K = U.handleLabels;
      K[0].attr("invisible", !G), K[1].attr("invisible", !G), U.moveHandle && this.api[G ? "enterEmphasis" : "leaveEmphasis"](U.moveHandle, 1);
    }, C.prototype._onDragMove = function(G, U, K, W) {
      this._dragging = !0, stop(W.event);
      var Z = this._displayables.sliderGroup.getLocalTransform(), X = applyTransform([U, K], Z, !0), Q = this._updateInterval(G, X[0]), ee = this.dataZoomModel.get("realtime");
      this._updateView(!ee), Q && ee && this._dispatchZoomAction(!0);
    }, C.prototype._onDragEnd = function() {
      this._dragging = !1, this._showDataInfo(!1);
      var G = this.dataZoomModel.get("realtime");
      !G && this._dispatchZoomAction(!1);
    }, C.prototype._onClickPanel = function(G) {
      var U = this._size, K = this._displayables.sliderGroup.transformCoordToLocal(G.offsetX, G.offsetY);
      if (!(K[0] < 0 || K[0] > U[0] || K[1] < 0 || K[1] > U[1])) {
        var W = this._handleEnds, Z = (W[0] + W[1]) / 2, X = this._updateInterval("all", K[0] - Z);
        this._updateView(), X && this._dispatchZoomAction(!1);
      }
    }, C.prototype._onBrushStart = function(G) {
      var U = G.offsetX, K = G.offsetY;
      this._brushStart = new Point$1(U, K), this._brushing = !0, this._brushStartTime = +new Date();
    }, C.prototype._onBrushEnd = function(G) {
      if (this._brushing) {
        var U = this._displayables.brushRect;
        if (this._brushing = !1, !!U) {
          U.attr("ignore", !0);
          var K = U.shape, W = +new Date();
          if (!(W - this._brushStartTime < 200 && Math.abs(K.width) < 5)) {
            var Z = this._getViewExtent(), X = [0, 100];
            this._range = asc$2([linearMap$2(K.x, Z, X, !0), linearMap$2(K.x + K.width, Z, X, !0)]), this._handleEnds = [K.x, K.x + K.width], this._updateView(), this._dispatchZoomAction(!1);
          }
        }
      }
    }, C.prototype._onBrush = function(G) {
      this._brushing && (stop(G.event), this._updateBrushRect(G.offsetX, G.offsetY));
    }, C.prototype._updateBrushRect = function(G, U) {
      var K = this._displayables, W = this.dataZoomModel, Z = K.brushRect;
      Z || (Z = K.brushRect = new Rect({
        silent: !0,
        style: W.getModel("brushStyle").getItemStyle()
      }), K.sliderGroup.add(Z)), Z.attr("ignore", !1);
      var X = this._brushStart, Q = this._displayables.sliderGroup, ee = Q.transformCoordToLocal(G, U), te = Q.transformCoordToLocal(X.x, X.y), re = this._size;
      ee[0] = Math.max(Math.min(re[0], ee[0]), 0), Z.setShape({
        x: te[0],
        y: 0,
        width: ee[0] - te[0],
        height: re[1]
      });
    }, C.prototype._dispatchZoomAction = function(G) {
      var U = this._range;
      this.api.dispatchAction({
        type: "dataZoom",
        from: this.uid,
        dataZoomId: this.dataZoomModel.id,
        animation: G ? REALTIME_ANIMATION_CONFIG : null,
        start: U[0],
        end: U[1]
      });
    }, C.prototype._findCoordRect = function() {
      var G, U = collectReferCoordSysModelInfo(this.dataZoomModel).infoList;
      if (!G && U.length) {
        var K = U[0].model.coordinateSystem;
        G = K.getRect && K.getRect();
      }
      if (!G) {
        var W = this.api.getWidth(), Z = this.api.getHeight();
        G = {
          x: W * 0.2,
          y: Z * 0.2,
          width: W * 0.6,
          height: Z * 0.6
        };
      }
      return G;
    }, C.type = "dataZoom.slider", C;
  }(DataZoomView$1)
);
function getOtherDim(H) {
  var C = {
    x: "y",
    y: "x",
    radius: "angle",
    angle: "radius"
  };
  return C[H];
}
function getCursor$1(H) {
  return H === "vertical" ? "ns-resize" : "ew-resize";
}
const SliderZoomView$1 = SliderZoomView;
function install$7(H) {
  H.registerComponentModel(SliderZoomModel$1), H.registerComponentView(SliderZoomView$1), installCommon$1(H);
}
function install$6(H) {
  use(install$8), use(install$7);
}
var visualDefault = {
  /**
   * @public
   */
  get: function(H, C, G) {
    var U = clone$4((defaultOption[H] || {})[C]);
    return G && isArray$1(U) ? U[U.length - 1] : U;
  }
}, defaultOption = {
  color: {
    active: ["#006edd", "#e0ffff"],
    inactive: ["rgba(0,0,0,0)"]
  },
  colorHue: {
    active: [0, 360],
    inactive: [0, 0]
  },
  colorSaturation: {
    active: [0.3, 1],
    inactive: [0, 0]
  },
  colorLightness: {
    active: [0.9, 0.5],
    inactive: [0, 0]
  },
  colorAlpha: {
    active: [0.3, 1],
    inactive: [0, 0]
  },
  opacity: {
    active: [0.3, 1],
    inactive: [0, 0]
  },
  symbol: {
    active: ["circle", "roundRect", "diamond"],
    inactive: ["none"]
  },
  symbolSize: {
    active: [10, 50],
    inactive: [0, 0]
  }
};
const visualDefault$1 = visualDefault;
var mapVisual = VisualMapping$1.mapVisual, eachVisual = VisualMapping$1.eachVisual, isArray = isArray$1, each$2 = each$f, asc = asc$2, linearMap$1 = linearMap$2, VisualMapModel = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G.stateList = ["inRange", "outOfRange"], G.replacableOptionKeys = ["inRange", "outOfRange", "target", "controller", "color"], G.layoutMode = {
        type: "box",
        ignoreSize: !0
      }, G.dataBound = [-1 / 0, 1 / 0], G.targetVisuals = {}, G.controllerVisuals = {}, G;
    }
    return C.prototype.init = function(G, U, K) {
      this.mergeDefaultAndTheme(G, K);
    }, C.prototype.optionUpdated = function(G, U) {
      var K = this.option;
      !U && replaceVisualOption(K, G, this.replacableOptionKeys), this.textStyleModel = this.getModel("textStyle"), this.resetItemSize(), this.completeVisualOption();
    }, C.prototype.resetVisual = function(G) {
      var U = this.stateList;
      G = bind$1(G, this), this.controllerVisuals = createVisualMappings(this.option.controller, U, G), this.targetVisuals = createVisualMappings(this.option.target, U, G);
    }, C.prototype.getItemSymbol = function() {
      return null;
    }, C.prototype.getTargetSeriesIndices = function() {
      var G = this.option.seriesIndex, U = [];
      return G == null || G === "all" ? this.ecModel.eachSeries(function(K, W) {
        U.push(W);
      }) : U = normalizeToArray(G), U;
    }, C.prototype.eachTargetSeries = function(G, U) {
      each$f(this.getTargetSeriesIndices(), function(K) {
        var W = this.ecModel.getSeriesByIndex(K);
        W && G.call(U, W);
      }, this);
    }, C.prototype.isTargetSeries = function(G) {
      var U = !1;
      return this.eachTargetSeries(function(K) {
        K === G && (U = !0);
      }), U;
    }, C.prototype.formatValueText = function(G, U, K) {
      var W = this.option, Z = W.precision, X = this.dataBound, Q = W.formatter, ee;
      K = K || ["<", ">"], isArray$1(G) && (G = G.slice(), ee = !0);
      var te = U ? G : ee ? [re(G[0]), re(G[1])] : re(G);
      if (isString(Q))
        return Q.replace("{value}", ee ? te[0] : te).replace("{value2}", ee ? te[1] : te);
      if (isFunction(Q))
        return ee ? Q(G[0], G[1]) : Q(G);
      if (ee)
        return G[0] === X[0] ? K[0] + " " + te[1] : G[1] === X[1] ? K[1] + " " + te[0] : te[0] + " - " + te[1];
      return te;
      function re(ne) {
        return ne === X[0] ? "min" : ne === X[1] ? "max" : (+ne).toFixed(Math.min(Z, 20));
      }
    }, C.prototype.resetExtent = function() {
      var G = this.option, U = asc([G.min, G.max]);
      this._dataExtent = U;
    }, C.prototype.getDataDimensionIndex = function(G) {
      var U = this.option.dimension;
      if (U != null)
        return G.getDimensionIndex(U);
      for (var K = G.dimensions, W = K.length - 1; W >= 0; W--) {
        var Z = K[W], X = G.getDimensionInfo(Z);
        if (!X.isCalculationCoord)
          return X.storeDimIndex;
      }
    }, C.prototype.getExtent = function() {
      return this._dataExtent.slice();
    }, C.prototype.completeVisualOption = function() {
      var G = this.ecModel, U = this.option, K = {
        inRange: U.inRange,
        outOfRange: U.outOfRange
      }, W = U.target || (U.target = {}), Z = U.controller || (U.controller = {});
      merge(W, K), merge(Z, K);
      var X = this.isCategory();
      Q.call(this, W), Q.call(this, Z), ee.call(this, W, "inRange", "outOfRange"), te.call(this, Z);
      function Q(re) {
        isArray(U.color) && !re.inRange && (re.inRange = {
          color: U.color.slice().reverse()
        }), re.inRange = re.inRange || {
          color: G.get("gradientColor")
        };
      }
      function ee(re, ne, ae) {
        var ie = re[ne], se = re[ae];
        ie && !se && (se = re[ae] = {}, each$2(ie, function(oe, le) {
          if (VisualMapping$1.isValidType(le)) {
            var ue = visualDefault$1.get(le, "inactive", X);
            ue != null && (se[le] = ue, le === "color" && !se.hasOwnProperty("opacity") && !se.hasOwnProperty("colorAlpha") && (se.opacity = [0, 0]));
          }
        }));
      }
      function te(re) {
        var ne = (re.inRange || {}).symbol || (re.outOfRange || {}).symbol, ae = (re.inRange || {}).symbolSize || (re.outOfRange || {}).symbolSize, ie = this.get("inactiveColor"), se = this.getItemSymbol(), oe = se || "roundRect";
        each$2(this.stateList, function(le) {
          var ue = this.itemSize, ce = re[le];
          ce || (ce = re[le] = {
            color: X ? ie : [ie]
          }), ce.symbol == null && (ce.symbol = ne && clone$4(ne) || (X ? oe : [oe])), ce.symbolSize == null && (ce.symbolSize = ae && clone$4(ae) || (X ? ue[0] : [ue[0], ue[0]])), ce.symbol = mapVisual(ce.symbol, function(fe) {
            return fe === "none" ? oe : fe;
          });
          var de = ce.symbolSize;
          if (de != null) {
            var ge = -1 / 0;
            eachVisual(de, function(fe) {
              fe > ge && (ge = fe);
            }), ce.symbolSize = mapVisual(de, function(fe) {
              return linearMap$1(fe, [0, ge], [0, ue[0]], !0);
            });
          }
        }, this);
      }
    }, C.prototype.resetItemSize = function() {
      this.itemSize = [parseFloat(this.get("itemWidth")), parseFloat(this.get("itemHeight"))];
    }, C.prototype.isCategory = function() {
      return !!this.option.categories;
    }, C.prototype.setSelected = function(G) {
    }, C.prototype.getSelected = function() {
      return null;
    }, C.prototype.getValueState = function(G) {
      return null;
    }, C.prototype.getVisualMeta = function(G) {
      return null;
    }, C.type = "visualMap", C.dependencies = ["series"], C.defaultOption = {
      show: !0,
      // zlevel: 0,
      z: 4,
      seriesIndex: "all",
      min: 0,
      max: 200,
      left: 0,
      right: null,
      top: null,
      bottom: 0,
      itemWidth: null,
      itemHeight: null,
      inverse: !1,
      orient: "vertical",
      backgroundColor: "rgba(0,0,0,0)",
      borderColor: "#ccc",
      contentColor: "#5793f3",
      inactiveColor: "#aaa",
      borderWidth: 0,
      padding: 5,
      // 接受数组分别设定上右下左边距，同css
      textGap: 10,
      precision: 0,
      textStyle: {
        color: "#333"
        // 值域文字颜色
      }
    }, C;
  }(ComponentModel$1)
);
const VisualMapModel$1 = VisualMapModel;
var DEFAULT_BAR_BOUND = [20, 140], ContinuousModel = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G;
    }
    return C.prototype.optionUpdated = function(G, U) {
      H.prototype.optionUpdated.apply(this, arguments), this.resetExtent(), this.resetVisual(function(K) {
        K.mappingMethod = "linear", K.dataExtent = this.getExtent();
      }), this._resetRange();
    }, C.prototype.resetItemSize = function() {
      H.prototype.resetItemSize.apply(this, arguments);
      var G = this.itemSize;
      (G[0] == null || isNaN(G[0])) && (G[0] = DEFAULT_BAR_BOUND[0]), (G[1] == null || isNaN(G[1])) && (G[1] = DEFAULT_BAR_BOUND[1]);
    }, C.prototype._resetRange = function() {
      var G = this.getExtent(), U = this.option.range;
      !U || U.auto ? (G.auto = 1, this.option.range = G) : isArray$1(U) && (U[0] > U[1] && U.reverse(), U[0] = Math.max(U[0], G[0]), U[1] = Math.min(U[1], G[1]));
    }, C.prototype.completeVisualOption = function() {
      H.prototype.completeVisualOption.apply(this, arguments), each$f(this.stateList, function(G) {
        var U = this.option.controller[G].symbolSize;
        U && U[0] !== U[1] && (U[0] = U[1] / 3);
      }, this);
    }, C.prototype.setSelected = function(G) {
      this.option.range = G.slice(), this._resetRange();
    }, C.prototype.getSelected = function() {
      var G = this.getExtent(), U = asc$2((this.get("range") || []).slice());
      return U[0] > G[1] && (U[0] = G[1]), U[1] > G[1] && (U[1] = G[1]), U[0] < G[0] && (U[0] = G[0]), U[1] < G[0] && (U[1] = G[0]), U;
    }, C.prototype.getValueState = function(G) {
      var U = this.option.range, K = this.getExtent();
      return (U[0] <= K[0] || U[0] <= G) && (U[1] >= K[1] || G <= U[1]) ? "inRange" : "outOfRange";
    }, C.prototype.findTargetDataIndices = function(G) {
      var U = [];
      return this.eachTargetSeries(function(K) {
        var W = [], Z = K.getData();
        Z.each(this.getDataDimensionIndex(Z), function(X, Q) {
          G[0] <= X && X <= G[1] && W.push(Q);
        }, this), U.push({
          seriesId: K.id,
          dataIndex: W
        });
      }, this), U;
    }, C.prototype.getVisualMeta = function(G) {
      var U = getColorStopValues(this, "outOfRange", this.getExtent()), K = getColorStopValues(this, "inRange", this.option.range.slice()), W = [];
      function Z(ae, ie) {
        W.push({
          value: ae,
          color: G(ae, ie)
        });
      }
      for (var X = 0, Q = 0, ee = K.length, te = U.length; Q < te && (!K.length || U[Q] <= K[0]); Q++)
        U[Q] < K[X] && Z(U[Q], "outOfRange");
      for (var re = 1; X < ee; X++, re = 0)
        re && W.length && Z(K[X], "outOfRange"), Z(K[X], "inRange");
      for (var re = 1; Q < te; Q++)
        (!K.length || K[K.length - 1] < U[Q]) && (re && (W.length && Z(W[W.length - 1].value, "outOfRange"), re = 0), Z(U[Q], "outOfRange"));
      var ne = W.length;
      return {
        stops: W,
        outerColors: [ne ? W[0].color : "transparent", ne ? W[ne - 1].color : "transparent"]
      };
    }, C.type = "visualMap.continuous", C.defaultOption = inheritDefaultOption(VisualMapModel$1.defaultOption, {
      align: "auto",
      calculable: !1,
      hoverLink: !0,
      realtime: !0,
      handleIcon: "path://M-11.39,9.77h0a3.5,3.5,0,0,1-3.5,3.5h-22a3.5,3.5,0,0,1-3.5-3.5h0a3.5,3.5,0,0,1,3.5-3.5h22A3.5,3.5,0,0,1-11.39,9.77Z",
      handleSize: "120%",
      handleStyle: {
        borderColor: "#fff",
        borderWidth: 1
      },
      indicatorIcon: "circle",
      indicatorSize: "50%",
      indicatorStyle: {
        borderColor: "#fff",
        borderWidth: 2,
        shadowBlur: 2,
        shadowOffsetX: 1,
        shadowOffsetY: 1,
        shadowColor: "rgba(0,0,0,0.2)"
      }
      // emphasis: {
      //     handleStyle: {
      //         shadowBlur: 3,
      //         shadowOffsetX: 1,
      //         shadowOffsetY: 1,
      //         shadowColor: 'rgba(0,0,0,0.2)'
      //     }
      // }
    }), C;
  }(VisualMapModel$1)
);
function getColorStopValues(H, C, G) {
  if (G[0] === G[1])
    return G.slice();
  for (var U = 200, K = (G[1] - G[0]) / U, W = G[0], Z = [], X = 0; X <= U && W < G[1]; X++)
    Z.push(W), W += K;
  return Z.push(G[1]), Z;
}
const ContinuousModel$1 = ContinuousModel;
var VisualMapView = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G.autoPositionValues = {
        left: 1,
        right: 1,
        top: 1,
        bottom: 1
      }, G;
    }
    return C.prototype.init = function(G, U) {
      this.ecModel = G, this.api = U;
    }, C.prototype.render = function(G, U, K, W) {
      if (this.visualMapModel = G, G.get("show") === !1) {
        this.group.removeAll();
        return;
      }
      this.doRender(G, U, K, W);
    }, C.prototype.renderBackground = function(G) {
      var U = this.visualMapModel, K = normalizeCssArray(U.get("padding") || 0), W = G.getBoundingRect();
      G.add(new Rect$3({
        z2: -1,
        silent: !0,
        shape: {
          x: W.x - K[3],
          y: W.y - K[0],
          width: W.width + K[3] + K[1],
          height: W.height + K[0] + K[2]
        },
        style: {
          fill: U.get("backgroundColor"),
          stroke: U.get("borderColor"),
          lineWidth: U.get("borderWidth")
        }
      }));
    }, C.prototype.getControllerVisual = function(G, U, K) {
      K = K || {};
      var W = K.forceState, Z = this.visualMapModel, X = {};
      if (U === "color") {
        var Q = Z.get("contentColor");
        X.color = Q;
      }
      function ee(ae) {
        return X[ae];
      }
      function te(ae, ie) {
        X[ae] = ie;
      }
      var re = Z.controllerVisuals[W || Z.getValueState(G)], ne = VisualMapping$1.prepareVisualTypes(re);
      return each$f(ne, function(ae) {
        var ie = re[ae];
        K.convertOpacityToAlpha && ae === "opacity" && (ae = "colorAlpha", ie = re.__alphaForOpacity), VisualMapping$1.dependsOn(ae, U) && ie && ie.applyVisual(G, ee, te);
      }), X[U];
    }, C.prototype.positionGroup = function(G) {
      var U = this.visualMapModel, K = this.api;
      positionElement(G, U.getBoxLayoutParams(), {
        width: K.getWidth(),
        height: K.getHeight()
      });
    }, C.prototype.doRender = function(G, U, K, W) {
    }, C.type = "visualMap", C;
  }(ComponentView$1)
);
const VisualMapView$1 = VisualMapView;
var paramsSet = [["left", "right", "width"], ["top", "bottom", "height"]];
function getItemAlign(H, C, G) {
  var U = H.option, K = U.align;
  if (K != null && K !== "auto")
    return K;
  for (var W = {
    width: C.getWidth(),
    height: C.getHeight()
  }, Z = U.orient === "horizontal" ? 1 : 0, X = paramsSet[Z], Q = [0, null, 10], ee = {}, te = 0; te < 3; te++)
    ee[paramsSet[1 - Z][te]] = Q[te], ee[X[te]] = te === 2 ? G[0] : U[X[te]];
  var re = [["x", "width", 3], ["y", "height", 0]][Z], ne = getLayoutRect(ee, W, U.padding);
  return X[(ne.margin[re[2]] || 0) + ne[re[0]] + ne[re[1]] * 0.5 < W[re[1]] * 0.5 ? 0 : 1];
}
function makeHighDownBatch(H, C) {
  return each$f(H || [], function(G) {
    G.dataIndex != null && (G.dataIndexInside = G.dataIndex, G.dataIndex = null), G.highlightKey = "visualMap" + (C ? C.componentIndex : "");
  }), H;
}
var linearMap = linearMap$2, each$1 = each$f, mathMin = Math.min, mathMax = Math.max, HOVER_LINK_SIZE = 12, HOVER_LINK_OUT = 6, ContinuousView = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G._shapes = {}, G._dataInterval = [], G._handleEnds = [], G._hoverLinkDataIndices = [], G;
    }
    return C.prototype.doRender = function(G, U, K, W) {
      this._api = K, (!W || W.type !== "selectDataRange" || W.from !== this.uid) && this._buildView();
    }, C.prototype._buildView = function() {
      this.group.removeAll();
      var G = this.visualMapModel, U = this.group;
      this._orient = G.get("orient"), this._useHandle = G.get("calculable"), this._resetInterval(), this._renderBar(U);
      var K = G.get("text");
      this._renderEndsText(U, K, 0), this._renderEndsText(U, K, 1), this._updateView(!0), this.renderBackground(U), this._updateView(), this._enableHoverLinkToSeries(), this._enableHoverLinkFromSeries(), this.positionGroup(U);
    }, C.prototype._renderEndsText = function(G, U, K) {
      if (U) {
        var W = U[1 - K];
        W = W != null ? W + "" : "";
        var Z = this.visualMapModel, X = Z.get("textGap"), Q = Z.itemSize, ee = this._shapes.mainGroup, te = this._applyTransform([Q[0] / 2, K === 0 ? -X : Q[1] + X], ee), re = this._applyTransform(K === 0 ? "bottom" : "top", ee), ne = this._orient, ae = this.visualMapModel.textStyleModel;
        this.group.add(new ZRText$1({
          style: createTextStyle(ae, {
            x: te[0],
            y: te[1],
            verticalAlign: ne === "horizontal" ? "middle" : re,
            align: ne === "horizontal" ? re : "center",
            text: W
          })
        }));
      }
    }, C.prototype._renderBar = function(G) {
      var U = this.visualMapModel, K = this._shapes, W = U.itemSize, Z = this._orient, X = this._useHandle, Q = getItemAlign(U, this.api, W), ee = K.mainGroup = this._createBarGroup(Q), te = new Group$4();
      ee.add(te), te.add(K.outOfRange = createPolygon()), te.add(K.inRange = createPolygon(null, X ? getCursor(this._orient) : null, bind$1(this._dragHandle, this, "all", !1), bind$1(this._dragHandle, this, "all", !0))), te.setClipPath(new Rect$3({
        shape: {
          x: 0,
          y: 0,
          width: W[0],
          height: W[1],
          r: 3
        }
      }));
      var re = U.textStyleModel.getTextRect("国"), ne = mathMax(re.width, re.height);
      X && (K.handleThumbs = [], K.handleLabels = [], K.handleLabelPoints = [], this._createHandle(U, ee, 0, W, ne, Z), this._createHandle(U, ee, 1, W, ne, Z)), this._createIndicator(U, ee, W, ne, Z), G.add(ee);
    }, C.prototype._createHandle = function(G, U, K, W, Z, X) {
      var Q = bind$1(this._dragHandle, this, K, !1), ee = bind$1(this._dragHandle, this, K, !0), te = parsePercent$1(G.get("handleSize"), W[0]), re = createSymbol$1(G.get("handleIcon"), -te / 2, -te / 2, te, te, null, !0), ne = getCursor(this._orient);
      re.attr({
        cursor: ne,
        draggable: !0,
        drift: Q,
        ondragend: ee,
        onmousemove: function(le) {
          stop(le.event);
        }
      }), re.x = W[0] / 2, re.useStyle(G.getModel("handleStyle").getItemStyle()), re.setStyle({
        strokeNoScale: !0,
        strokeFirst: !0
      }), re.style.lineWidth *= 2, re.ensureState("emphasis").style = G.getModel(["emphasis", "handleStyle"]).getItemStyle(), setAsHighDownDispatcher(re, !0), U.add(re);
      var ae = this.visualMapModel.textStyleModel, ie = new ZRText$1({
        cursor: ne,
        draggable: !0,
        drift: Q,
        onmousemove: function(le) {
          stop(le.event);
        },
        ondragend: ee,
        style: createTextStyle(ae, {
          x: 0,
          y: 0,
          text: ""
        })
      });
      ie.ensureState("blur").style = {
        opacity: 0.1
      }, ie.stateTransition = {
        duration: 200
      }, this.group.add(ie);
      var se = [te, 0], oe = this._shapes;
      oe.handleThumbs[K] = re, oe.handleLabelPoints[K] = se, oe.handleLabels[K] = ie;
    }, C.prototype._createIndicator = function(G, U, K, W, Z) {
      var X = parsePercent$1(G.get("indicatorSize"), K[0]), Q = createSymbol$1(G.get("indicatorIcon"), -X / 2, -X / 2, X, X, null, !0);
      Q.attr({
        cursor: "move",
        invisible: !0,
        silent: !0,
        x: K[0] / 2
      });
      var ee = G.getModel("indicatorStyle").getItemStyle();
      if (Q instanceof ZRImage$1) {
        var te = Q.style;
        Q.useStyle(extend({
          // TODO other properties like x, y ?
          image: te.image,
          x: te.x,
          y: te.y,
          width: te.width,
          height: te.height
        }, ee));
      } else
        Q.useStyle(ee);
      U.add(Q);
      var re = this.visualMapModel.textStyleModel, ne = new ZRText$1({
        silent: !0,
        invisible: !0,
        style: createTextStyle(re, {
          x: 0,
          y: 0,
          text: ""
        })
      });
      this.group.add(ne);
      var ae = [(Z === "horizontal" ? W / 2 : HOVER_LINK_OUT) + K[0] / 2, 0], ie = this._shapes;
      ie.indicator = Q, ie.indicatorLabel = ne, ie.indicatorLabelPoint = ae, this._firstShowIndicator = !0;
    }, C.prototype._dragHandle = function(G, U, K, W) {
      if (this._useHandle) {
        if (this._dragging = !U, !U) {
          var Z = this._applyTransform([K, W], this._shapes.mainGroup, !0);
          this._updateInterval(G, Z[1]), this._hideIndicator(), this._updateView();
        }
        U === !this.visualMapModel.get("realtime") && this.api.dispatchAction({
          type: "selectDataRange",
          from: this.uid,
          visualMapId: this.visualMapModel.id,
          selected: this._dataInterval.slice()
        }), U ? !this._hovering && this._clearHoverLinkToSeries() : useHoverLinkOnHandle(this.visualMapModel) && this._doHoverLinkToSeries(this._handleEnds[G], !1);
      }
    }, C.prototype._resetInterval = function() {
      var G = this.visualMapModel, U = this._dataInterval = G.getSelected(), K = G.getExtent(), W = [0, G.itemSize[1]];
      this._handleEnds = [linearMap(U[0], K, W, !0), linearMap(U[1], K, W, !0)];
    }, C.prototype._updateInterval = function(G, U) {
      U = U || 0;
      var K = this.visualMapModel, W = this._handleEnds, Z = [0, K.itemSize[1]];
      sliderMove(
        U,
        W,
        Z,
        G,
        // cross is forbiden
        0
      );
      var X = K.getExtent();
      this._dataInterval = [linearMap(W[0], Z, X, !0), linearMap(W[1], Z, X, !0)];
    }, C.prototype._updateView = function(G) {
      var U = this.visualMapModel, K = U.getExtent(), W = this._shapes, Z = [0, U.itemSize[1]], X = G ? Z : this._handleEnds, Q = this._createBarVisual(this._dataInterval, K, X, "inRange"), ee = this._createBarVisual(K, K, Z, "outOfRange");
      W.inRange.setStyle({
        fill: Q.barColor
        // opacity: visualInRange.opacity
      }).setShape("points", Q.barPoints), W.outOfRange.setStyle({
        fill: ee.barColor
        // opacity: visualOutOfRange.opacity
      }).setShape("points", ee.barPoints), this._updateHandle(X, Q);
    }, C.prototype._createBarVisual = function(G, U, K, W) {
      var Z = {
        forceState: W,
        convertOpacityToAlpha: !0
      }, X = this._makeColorGradient(G, Z), Q = [this.getControllerVisual(G[0], "symbolSize", Z), this.getControllerVisual(G[1], "symbolSize", Z)], ee = this._createBarPoints(K, Q);
      return {
        barColor: new LinearGradient$1(0, 0, 0, 1, X),
        barPoints: ee,
        handlesColor: [X[0].color, X[X.length - 1].color]
      };
    }, C.prototype._makeColorGradient = function(G, U) {
      var K = 100, W = [], Z = (G[1] - G[0]) / K;
      W.push({
        color: this.getControllerVisual(G[0], "color", U),
        offset: 0
      });
      for (var X = 1; X < K; X++) {
        var Q = G[0] + Z * X;
        if (Q > G[1])
          break;
        W.push({
          color: this.getControllerVisual(Q, "color", U),
          offset: X / K
        });
      }
      return W.push({
        color: this.getControllerVisual(G[1], "color", U),
        offset: 1
      }), W;
    }, C.prototype._createBarPoints = function(G, U) {
      var K = this.visualMapModel.itemSize;
      return [[K[0] - U[0], G[0]], [K[0], G[0]], [K[0], G[1]], [K[0] - U[1], G[1]]];
    }, C.prototype._createBarGroup = function(G) {
      var U = this._orient, K = this.visualMapModel.get("inverse");
      return new Group$4(U === "horizontal" && !K ? {
        scaleX: G === "bottom" ? 1 : -1,
        rotation: Math.PI / 2
      } : U === "horizontal" && K ? {
        scaleX: G === "bottom" ? -1 : 1,
        rotation: -Math.PI / 2
      } : U === "vertical" && !K ? {
        scaleX: G === "left" ? 1 : -1,
        scaleY: -1
      } : {
        scaleX: G === "left" ? 1 : -1
      });
    }, C.prototype._updateHandle = function(G, U) {
      if (this._useHandle) {
        var K = this._shapes, W = this.visualMapModel, Z = K.handleThumbs, X = K.handleLabels, Q = W.itemSize, ee = W.getExtent();
        each$1([0, 1], function(te) {
          var re = Z[te];
          re.setStyle("fill", U.handlesColor[te]), re.y = G[te];
          var ne = linearMap(G[te], [0, Q[1]], ee, !0), ae = this.getControllerVisual(ne, "symbolSize");
          re.scaleX = re.scaleY = ae / Q[0], re.x = Q[0] - ae / 2;
          var ie = applyTransform(K.handleLabelPoints[te], getTransform$1(re, this.group));
          X[te].setStyle({
            x: ie[0],
            y: ie[1],
            text: W.formatValueText(this._dataInterval[te]),
            verticalAlign: "middle",
            align: this._orient === "vertical" ? this._applyTransform("left", K.mainGroup) : "center"
          });
        }, this);
      }
    }, C.prototype._showIndicator = function(G, U, K, W) {
      var Z = this.visualMapModel, X = Z.getExtent(), Q = Z.itemSize, ee = [0, Q[1]], te = this._shapes, re = te.indicator;
      if (re) {
        re.attr("invisible", !1);
        var ne = {
          convertOpacityToAlpha: !0
        }, ae = this.getControllerVisual(G, "color", ne), ie = this.getControllerVisual(G, "symbolSize"), se = linearMap(G, X, ee, !0), oe = Q[0] - ie / 2, le = {
          x: re.x,
          y: re.y
        };
        re.y = se, re.x = oe;
        var ue = applyTransform(te.indicatorLabelPoint, getTransform$1(re, this.group)), ce = te.indicatorLabel;
        ce.attr("invisible", !1);
        var de = this._applyTransform("left", te.mainGroup), ge = this._orient, fe = ge === "horizontal";
        ce.setStyle({
          text: (K || "") + Z.formatValueText(U),
          verticalAlign: fe ? de : "middle",
          align: fe ? "center" : de
        });
        var ve = {
          x: oe,
          y: se,
          style: {
            fill: ae
          }
        }, pe = {
          style: {
            x: ue[0],
            y: ue[1]
          }
        };
        if (Z.ecModel.isAnimationEnabled() && !this._firstShowIndicator) {
          var he = {
            duration: 100,
            easing: "cubicInOut",
            additive: !0
          };
          re.x = le.x, re.y = le.y, re.animateTo(ve, he), ce.animateTo(pe, he);
        } else
          re.attr(ve), ce.attr(pe);
        this._firstShowIndicator = !1;
        var me = this._shapes.handleLabels;
        if (me)
          for (var ye = 0; ye < me.length; ye++)
            this._api.enterBlur(me[ye]);
      }
    }, C.prototype._enableHoverLinkToSeries = function() {
      var G = this;
      this._shapes.mainGroup.on("mousemove", function(U) {
        if (G._hovering = !0, !G._dragging) {
          var K = G.visualMapModel.itemSize, W = G._applyTransform([U.offsetX, U.offsetY], G._shapes.mainGroup, !0, !0);
          W[1] = mathMin(mathMax(0, W[1]), K[1]), G._doHoverLinkToSeries(W[1], 0 <= W[0] && W[0] <= K[0]);
        }
      }).on("mouseout", function() {
        G._hovering = !1, !G._dragging && G._clearHoverLinkToSeries();
      });
    }, C.prototype._enableHoverLinkFromSeries = function() {
      var G = this.api.getZr();
      this.visualMapModel.option.hoverLink ? (G.on("mouseover", this._hoverLinkFromSeriesMouseOver, this), G.on("mouseout", this._hideIndicator, this)) : this._clearHoverLinkFromSeries();
    }, C.prototype._doHoverLinkToSeries = function(G, U) {
      var K = this.visualMapModel, W = K.itemSize;
      if (K.option.hoverLink) {
        var Z = [0, W[1]], X = K.getExtent();
        G = mathMin(mathMax(Z[0], G), Z[1]);
        var Q = getHalfHoverLinkSize(K, X, Z), ee = [G - Q, G + Q], te = linearMap(G, Z, X, !0), re = [linearMap(ee[0], Z, X, !0), linearMap(ee[1], Z, X, !0)];
        ee[0] < Z[0] && (re[0] = -1 / 0), ee[1] > Z[1] && (re[1] = 1 / 0), U && (re[0] === -1 / 0 ? this._showIndicator(te, re[1], "< ", Q) : re[1] === 1 / 0 ? this._showIndicator(te, re[0], "> ", Q) : this._showIndicator(te, te, "≈ ", Q));
        var ne = this._hoverLinkDataIndices, ae = [];
        (U || useHoverLinkOnHandle(K)) && (ae = this._hoverLinkDataIndices = K.findTargetDataIndices(re));
        var ie = compressBatches(ne, ae);
        this._dispatchHighDown("downplay", makeHighDownBatch(ie[0], K)), this._dispatchHighDown("highlight", makeHighDownBatch(ie[1], K));
      }
    }, C.prototype._hoverLinkFromSeriesMouseOver = function(G) {
      var U;
      if (findEventDispatcher(G.target, function(Q) {
        var ee = getECData(Q);
        if (ee.dataIndex != null)
          return U = ee, !0;
      }, !0), !!U) {
        var K = this.ecModel.getSeriesByIndex(U.seriesIndex), W = this.visualMapModel;
        if (W.isTargetSeries(K)) {
          var Z = K.getData(U.dataType), X = Z.getStore().get(W.getDataDimensionIndex(Z), U.dataIndex);
          isNaN(X) || this._showIndicator(X, X);
        }
      }
    }, C.prototype._hideIndicator = function() {
      var G = this._shapes;
      G.indicator && G.indicator.attr("invisible", !0), G.indicatorLabel && G.indicatorLabel.attr("invisible", !0);
      var U = this._shapes.handleLabels;
      if (U)
        for (var K = 0; K < U.length; K++)
          this._api.leaveBlur(U[K]);
    }, C.prototype._clearHoverLinkToSeries = function() {
      this._hideIndicator();
      var G = this._hoverLinkDataIndices;
      this._dispatchHighDown("downplay", makeHighDownBatch(G, this.visualMapModel)), G.length = 0;
    }, C.prototype._clearHoverLinkFromSeries = function() {
      this._hideIndicator();
      var G = this.api.getZr();
      G.off("mouseover", this._hoverLinkFromSeriesMouseOver), G.off("mouseout", this._hideIndicator);
    }, C.prototype._applyTransform = function(G, U, K, W) {
      var Z = getTransform$1(U, W ? null : this.group);
      return isArray$1(G) ? applyTransform(G, Z, K) : transformDirection(G, Z, K);
    }, C.prototype._dispatchHighDown = function(G, U) {
      U && U.length && this.api.dispatchAction({
        type: G,
        batch: U
      });
    }, C.prototype.dispose = function() {
      this._clearHoverLinkFromSeries(), this._clearHoverLinkToSeries();
    }, C.prototype.remove = function() {
      this._clearHoverLinkFromSeries(), this._clearHoverLinkToSeries();
    }, C.type = "visualMap.continuous", C;
  }(VisualMapView$1)
);
function createPolygon(H, C, G, U) {
  return new Polygon$1({
    shape: {
      points: H
    },
    draggable: !!G,
    cursor: C,
    drift: G,
    onmousemove: function(K) {
      stop(K.event);
    },
    ondragend: U
  });
}
function getHalfHoverLinkSize(H, C, G) {
  var U = HOVER_LINK_SIZE / 2, K = H.get("hoverLinkDataSize");
  return K && (U = linearMap(K, C, G, !0) / 2), U;
}
function useHoverLinkOnHandle(H) {
  var C = H.get("hoverLinkOnHandle");
  return !!(C ?? H.get("realtime"));
}
function getCursor(H) {
  return H === "vertical" ? "ns-resize" : "ew-resize";
}
const ContinuousView$1 = ContinuousView;
var visualMapActionInfo = {
  type: "selectDataRange",
  event: "dataRangeSelected",
  // FIXME use updateView appears wrong
  update: "update"
}, visualMapActionHander = function(H, C) {
  C.eachComponent({
    mainType: "visualMap",
    query: H
  }, function(G) {
    G.setSelected(H.selected);
  });
}, visualMapEncodingHandlers = [
  {
    createOnAllSeries: !0,
    reset: function(H, C) {
      var G = [];
      return C.eachComponent("visualMap", function(U) {
        var K = H.pipelineContext;
        !U.isTargetSeries(H) || K && K.large || G.push(incrementalApplyVisual(U.stateList, U.targetVisuals, bind$1(U.getValueState, U), U.getDataDimensionIndex(H.getData())));
      }), G;
    }
  },
  // Only support color.
  {
    createOnAllSeries: !0,
    reset: function(H, C) {
      var G = H.getData(), U = [];
      C.eachComponent("visualMap", function(K) {
        if (K.isTargetSeries(H)) {
          var W = K.getVisualMeta(bind$1(getColorVisual, null, H, K)) || {
            stops: [],
            outerColors: []
          }, Z = K.getDataDimensionIndex(G);
          Z >= 0 && (W.dimension = Z, U.push(W));
        }
      }), H.getData().setVisual("visualMeta", U);
    }
  }
];
function getColorVisual(H, C, G, U) {
  for (var K = C.targetVisuals[U], W = VisualMapping$1.prepareVisualTypes(K), Z = {
    color: getVisualFromData(H.getData(), "color")
    // default color.
  }, X = 0, Q = W.length; X < Q; X++) {
    var ee = W[X], te = K[ee === "opacity" ? "__alphaForOpacity" : ee];
    te && te.applyVisual(G, re, ne);
  }
  return Z.color;
  function re(ae) {
    return Z[ae];
  }
  function ne(ae, ie) {
    Z[ae] = ie;
  }
}
var each = each$f;
function visualMapPreprocessor(H) {
  var C = H && H.visualMap;
  isArray$1(C) || (C = C ? [C] : []), each(C, function(G) {
    if (G) {
      has(G, "splitList") && !has(G, "pieces") && (G.pieces = G.splitList, delete G.splitList);
      var U = G.pieces;
      U && isArray$1(U) && each(U, function(K) {
        isObject$3(K) && (has(K, "start") && !has(K, "min") && (K.min = K.start), has(K, "end") && !has(K, "max") && (K.max = K.end));
      });
    }
  });
}
function has(H, C) {
  return H && H.hasOwnProperty && H.hasOwnProperty(C);
}
var installed = !1;
function installCommon(H) {
  installed || (installed = !0, H.registerSubTypeDefaulter("visualMap", function(C) {
    return !C.categories && (!(C.pieces ? C.pieces.length > 0 : C.splitNumber > 0) || C.calculable) ? "continuous" : "piecewise";
  }), H.registerAction(visualMapActionInfo, visualMapActionHander), each$f(visualMapEncodingHandlers, function(C) {
    H.registerVisual(H.PRIORITY.VISUAL.COMPONENT, C);
  }), H.registerPreprocessor(visualMapPreprocessor));
}
function install$5(H) {
  H.registerComponentModel(ContinuousModel$1), H.registerComponentView(ContinuousView$1), installCommon(H);
}
var PiecewiseModel = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G._pieceList = [], G;
    }
    return C.prototype.optionUpdated = function(G, U) {
      H.prototype.optionUpdated.apply(this, arguments), this.resetExtent();
      var K = this._mode = this._determineMode();
      this._pieceList = [], resetMethods[this._mode].call(this, this._pieceList), this._resetSelected(G, U);
      var W = this.option.categories;
      this.resetVisual(function(Z, X) {
        K === "categories" ? (Z.mappingMethod = "category", Z.categories = clone$4(W)) : (Z.dataExtent = this.getExtent(), Z.mappingMethod = "piecewise", Z.pieceList = map$1(this._pieceList, function(Q) {
          return Q = clone$4(Q), X !== "inRange" && (Q.visual = null), Q;
        }));
      });
    }, C.prototype.completeVisualOption = function() {
      var G = this.option, U = {}, K = VisualMapping$1.listVisualTypes(), W = this.isCategory();
      each$f(G.pieces, function(X) {
        each$f(K, function(Q) {
          X.hasOwnProperty(Q) && (U[Q] = 1);
        });
      }), each$f(U, function(X, Q) {
        var ee = !1;
        each$f(this.stateList, function(te) {
          ee = ee || Z(G, te, Q) || Z(G.target, te, Q);
        }, this), !ee && each$f(this.stateList, function(te) {
          (G[te] || (G[te] = {}))[Q] = visualDefault$1.get(Q, te === "inRange" ? "active" : "inactive", W);
        });
      }, this);
      function Z(X, Q, ee) {
        return X && X[Q] && X[Q].hasOwnProperty(ee);
      }
      H.prototype.completeVisualOption.apply(this, arguments);
    }, C.prototype._resetSelected = function(G, U) {
      var K = this.option, W = this._pieceList, Z = (U ? K : G).selected || {};
      if (K.selected = Z, each$f(W, function(Q, ee) {
        var te = this.getSelectedMapKey(Q);
        Z.hasOwnProperty(te) || (Z[te] = !0);
      }, this), K.selectedMode === "single") {
        var X = !1;
        each$f(W, function(Q, ee) {
          var te = this.getSelectedMapKey(Q);
          Z[te] && (X ? Z[te] = !1 : X = !0);
        }, this);
      }
    }, C.prototype.getItemSymbol = function() {
      return this.get("itemSymbol");
    }, C.prototype.getSelectedMapKey = function(G) {
      return this._mode === "categories" ? G.value + "" : G.index + "";
    }, C.prototype.getPieceList = function() {
      return this._pieceList;
    }, C.prototype._determineMode = function() {
      var G = this.option;
      return G.pieces && G.pieces.length > 0 ? "pieces" : this.option.categories ? "categories" : "splitNumber";
    }, C.prototype.setSelected = function(G) {
      this.option.selected = clone$4(G);
    }, C.prototype.getValueState = function(G) {
      var U = VisualMapping$1.findPieceIndex(G, this._pieceList);
      return U != null && this.option.selected[this.getSelectedMapKey(this._pieceList[U])] ? "inRange" : "outOfRange";
    }, C.prototype.findTargetDataIndices = function(G) {
      var U = [], K = this._pieceList;
      return this.eachTargetSeries(function(W) {
        var Z = [], X = W.getData();
        X.each(this.getDataDimensionIndex(X), function(Q, ee) {
          var te = VisualMapping$1.findPieceIndex(Q, K);
          te === G && Z.push(ee);
        }, this), U.push({
          seriesId: W.id,
          dataIndex: Z
        });
      }, this), U;
    }, C.prototype.getRepresentValue = function(G) {
      var U;
      if (this.isCategory())
        U = G.value;
      else if (G.value != null)
        U = G.value;
      else {
        var K = G.interval || [];
        U = K[0] === -1 / 0 && K[1] === 1 / 0 ? 0 : (K[0] + K[1]) / 2;
      }
      return U;
    }, C.prototype.getVisualMeta = function(G) {
      if (this.isCategory())
        return;
      var U = [], K = ["", ""], W = this;
      function Z(te, re) {
        var ne = W.getRepresentValue({
          interval: te
        });
        re || (re = W.getValueState(ne));
        var ae = G(ne, re);
        te[0] === -1 / 0 ? K[0] = ae : te[1] === 1 / 0 ? K[1] = ae : U.push({
          value: te[0],
          color: ae
        }, {
          value: te[1],
          color: ae
        });
      }
      var X = this._pieceList.slice();
      if (!X.length)
        X.push({
          interval: [-1 / 0, 1 / 0]
        });
      else {
        var Q = X[0].interval[0];
        Q !== -1 / 0 && X.unshift({
          interval: [-1 / 0, Q]
        }), Q = X[X.length - 1].interval[1], Q !== 1 / 0 && X.push({
          interval: [Q, 1 / 0]
        });
      }
      var ee = -1 / 0;
      return each$f(X, function(te) {
        var re = te.interval;
        re && (re[0] > ee && Z([ee, re[0]], "outOfRange"), Z(re.slice()), ee = re[1]);
      }, this), {
        stops: U,
        outerColors: K
      };
    }, C.type = "visualMap.piecewise", C.defaultOption = inheritDefaultOption(VisualMapModel$1.defaultOption, {
      selected: null,
      minOpen: !1,
      maxOpen: !1,
      align: "auto",
      itemWidth: 20,
      itemHeight: 14,
      itemSymbol: "roundRect",
      pieces: null,
      categories: null,
      splitNumber: 5,
      selectedMode: "multiple",
      itemGap: 10,
      hoverLink: !0
      // Enable hover highlight.
    }), C;
  }(VisualMapModel$1)
), resetMethods = {
  splitNumber: function(H) {
    var C = this.option, G = Math.min(C.precision, 20), U = this.getExtent(), K = C.splitNumber;
    K = Math.max(parseInt(K, 10), 1), C.splitNumber = K;
    for (var W = (U[1] - U[0]) / K; +W.toFixed(G) !== W && G < 5; )
      G++;
    C.precision = G, W = +W.toFixed(G), C.minOpen && H.push({
      interval: [-1 / 0, U[0]],
      close: [0, 0]
    });
    for (var Z = 0, X = U[0]; Z < K; X += W, Z++) {
      var Q = Z === K - 1 ? U[1] : X + W;
      H.push({
        interval: [X, Q],
        close: [1, 1]
      });
    }
    C.maxOpen && H.push({
      interval: [U[1], 1 / 0],
      close: [0, 0]
    }), reformIntervals(H), each$f(H, function(ee, te) {
      ee.index = te, ee.text = this.formatValueText(ee.interval);
    }, this);
  },
  categories: function(H) {
    var C = this.option;
    each$f(C.categories, function(G) {
      H.push({
        text: this.formatValueText(G, !0),
        value: G
      });
    }, this), normalizeReverse(C, H);
  },
  pieces: function(H) {
    var C = this.option;
    each$f(C.pieces, function(G, U) {
      isObject$3(G) || (G = {
        value: G
      });
      var K = {
        text: "",
        index: U
      };
      if (G.label != null && (K.text = G.label), G.hasOwnProperty("value")) {
        var W = K.value = G.value;
        K.interval = [W, W], K.close = [1, 1];
      } else {
        for (var Z = K.interval = [], X = K.close = [0, 0], Q = [1, 0, 1], ee = [-1 / 0, 1 / 0], te = [], re = 0; re < 2; re++) {
          for (var ne = [["gte", "gt", "min"], ["lte", "lt", "max"]][re], ae = 0; ae < 3 && Z[re] == null; ae++)
            Z[re] = G[ne[ae]], X[re] = Q[ae], te[re] = ae === 2;
          Z[re] == null && (Z[re] = ee[re]);
        }
        te[0] && Z[1] === 1 / 0 && (X[0] = 0), te[1] && Z[0] === -1 / 0 && (X[1] = 0), process.env.NODE_ENV !== "production" && Z[0] > Z[1] && console.warn("Piece " + U + "is illegal: " + Z + " lower bound should not greater then uppper bound."), Z[0] === Z[1] && X[0] && X[1] && (K.value = Z[0]);
      }
      K.visual = VisualMapping$1.retrieveVisuals(G), H.push(K);
    }, this), normalizeReverse(C, H), reformIntervals(H), each$f(H, function(G) {
      var U = G.close, K = [["<", "≤"][U[1]], [">", "≥"][U[0]]];
      G.text = G.text || this.formatValueText(G.value != null ? G.value : G.interval, !1, K);
    }, this);
  }
};
function normalizeReverse(H, C) {
  var G = H.inverse;
  (H.orient === "vertical" ? !G : G) && C.reverse();
}
const PiecewiseModel$1 = PiecewiseModel;
var PiecewiseVisualMapView = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = C.type, G;
    }
    return C.prototype.doRender = function() {
      var G = this.group;
      G.removeAll();
      var U = this.visualMapModel, K = U.get("textGap"), W = U.textStyleModel, Z = W.getFont(), X = W.getTextColor(), Q = this._getItemAlign(), ee = U.itemSize, te = this._getViewData(), re = te.endsText, ne = retrieve(U.get("showLabel", !0), !re);
      re && this._renderEndsText(G, re[0], ee, ne, Q), each$f(te.viewPieceList, function(ae) {
        var ie = ae.piece, se = new Group$4();
        se.onclick = bind$1(this._onItemClick, this, ie), this._enableHoverLink(se, ae.indexInModelPieceList);
        var oe = U.getRepresentValue(ie);
        if (this._createItemSymbol(se, oe, [0, 0, ee[0], ee[1]]), ne) {
          var le = this.visualMapModel.getValueState(oe);
          se.add(new ZRText$1({
            style: {
              x: Q === "right" ? -K : ee[0] + K,
              y: ee[1] / 2,
              text: ie.text,
              verticalAlign: "middle",
              align: Q,
              font: Z,
              fill: X,
              opacity: le === "outOfRange" ? 0.5 : 1
            }
          }));
        }
        G.add(se);
      }, this), re && this._renderEndsText(G, re[1], ee, ne, Q), box(U.get("orient"), G, U.get("itemGap")), this.renderBackground(G), this.positionGroup(G);
    }, C.prototype._enableHoverLink = function(G, U) {
      var K = this;
      G.on("mouseover", function() {
        return W("highlight");
      }).on("mouseout", function() {
        return W("downplay");
      });
      var W = function(Z) {
        var X = K.visualMapModel;
        X.option.hoverLink && K.api.dispatchAction({
          type: Z,
          batch: makeHighDownBatch(X.findTargetDataIndices(U), X)
        });
      };
    }, C.prototype._getItemAlign = function() {
      var G = this.visualMapModel, U = G.option;
      if (U.orient === "vertical")
        return getItemAlign(G, this.api, G.itemSize);
      var K = U.align;
      return (!K || K === "auto") && (K = "left"), K;
    }, C.prototype._renderEndsText = function(G, U, K, W, Z) {
      if (U) {
        var X = new Group$4(), Q = this.visualMapModel.textStyleModel;
        X.add(new ZRText$1({
          style: createTextStyle(Q, {
            x: W ? Z === "right" ? K[0] : 0 : K[0] / 2,
            y: K[1] / 2,
            verticalAlign: "middle",
            align: W ? Z : "center",
            text: U
          })
        })), G.add(X);
      }
    }, C.prototype._getViewData = function() {
      var G = this.visualMapModel, U = map$1(G.getPieceList(), function(X, Q) {
        return {
          piece: X,
          indexInModelPieceList: Q
        };
      }), K = G.get("text"), W = G.get("orient"), Z = G.get("inverse");
      return (W === "horizontal" ? Z : !Z) ? U.reverse() : K && (K = K.slice().reverse()), {
        viewPieceList: U,
        endsText: K
      };
    }, C.prototype._createItemSymbol = function(G, U, K) {
      G.add(createSymbol$1(
        // symbol will be string
        this.getControllerVisual(U, "symbol"),
        K[0],
        K[1],
        K[2],
        K[3],
        // color will be string
        this.getControllerVisual(U, "color")
      ));
    }, C.prototype._onItemClick = function(G) {
      var U = this.visualMapModel, K = U.option, W = K.selectedMode;
      if (W) {
        var Z = clone$4(K.selected), X = U.getSelectedMapKey(G);
        W === "single" || W === !0 ? (Z[X] = !0, each$f(Z, function(Q, ee) {
          Z[ee] = ee === X;
        })) : Z[X] = !Z[X], this.api.dispatchAction({
          type: "selectDataRange",
          from: this.uid,
          visualMapId: this.visualMapModel.id,
          selected: Z
        });
      }
    }, C.type = "visualMap.piecewise", C;
  }(VisualMapView$1)
);
const PiecewiseView = PiecewiseVisualMapView;
function install$4(H) {
  H.registerComponentModel(PiecewiseModel$1), H.registerComponentView(PiecewiseView), installCommon(H);
}
function install$3(H) {
  use(install$5), use(install$4);
}
var DEFAULT_OPTION = {
  label: {
    enabled: !0
  },
  decal: {
    show: !1
  }
}, inner = makeInner(), decalPaletteScope = {};
function ariaVisual(H, C) {
  var G = H.getModel("aria");
  if (!G.get("enabled"))
    return;
  var U = clone$4(DEFAULT_OPTION);
  merge(U.label, H.getLocaleModel().get("aria"), !1), merge(G.option, U, !1), K(), W();
  function K() {
    var ee = G.getModel("decal"), te = ee.get("show");
    if (te) {
      var re = createHashMap();
      H.eachSeries(function(ne) {
        if (!ne.isColorBySeries()) {
          var ae = re.get(ne.type);
          ae || (ae = {}, re.set(ne.type, ae)), inner(ne).scope = ae;
        }
      }), H.eachRawSeries(function(ne) {
        if (H.isSeriesFiltered(ne))
          return;
        if (isFunction(ne.enableAriaDecal)) {
          ne.enableAriaDecal();
          return;
        }
        var ae = ne.getData();
        if (ne.isColorBySeries()) {
          var ue = getDecalFromPalette(ne.ecModel, ne.name, decalPaletteScope, H.getSeriesCount()), ce = ae.getVisual("decal");
          ae.setVisual("decal", de(ce, ue));
        } else {
          var ie = ne.getRawData(), se = {}, oe = inner(ne).scope;
          ae.each(function(ge) {
            var fe = ae.getRawIndex(ge);
            se[fe] = ge;
          });
          var le = ie.count();
          ie.each(function(ge) {
            var fe = se[ge], ve = ie.getName(ge) || ge + "", pe = getDecalFromPalette(ne.ecModel, ve, oe, le), he = ae.getItemVisual(fe, "decal");
            ae.setItemVisual(fe, "decal", de(he, pe));
          });
        }
        function de(ge, fe) {
          var ve = ge ? extend(extend({}, fe), ge) : fe;
          return ve.dirty = !0, ve;
        }
      });
    }
  }
  function W() {
    var ee = H.getLocaleModel().get("aria"), te = G.getModel("label");
    if (te.option = defaults(te.option, ee), !!te.get("enabled")) {
      var re = C.getZr().dom;
      if (te.get("description")) {
        re.setAttribute("aria-label", te.get("description"));
        return;
      }
      var ne = H.getSeriesCount(), ae = te.get(["data", "maxCount"]) || 10, ie = te.get(["series", "maxCount"]) || 10, se = Math.min(ne, ie), oe;
      if (!(ne < 1)) {
        var le = X();
        if (le) {
          var ue = te.get(["general", "withTitle"]);
          oe = Z(ue, {
            title: le
          });
        } else
          oe = te.get(["general", "withoutTitle"]);
        var ce = [], de = ne > 1 ? te.get(["series", "multiple", "prefix"]) : te.get(["series", "single", "prefix"]);
        oe += Z(de, {
          seriesCount: ne
        }), H.eachSeries(function(pe, he) {
          if (he < se) {
            var me = void 0, ye = pe.get("name"), Ce = ye ? "withName" : "withoutName";
            me = ne > 1 ? te.get(["series", "multiple", Ce]) : te.get(["series", "single", Ce]), me = Z(me, {
              seriesId: pe.seriesIndex,
              seriesName: pe.get("name"),
              seriesType: Q(pe.subType)
            });
            var Ie = pe.getData();
            if (Ie.count() > ae) {
              var be = te.get(["data", "partialData"]);
              me += Z(be, {
                displayCnt: ae
              });
            } else
              me += te.get(["data", "allData"]);
            for (var Se = te.get(["data", "separator", "middle"]), Ae = te.get(["data", "separator", "end"]), _e = [], xe = 0; xe < Ie.count(); xe++)
              if (xe < ae) {
                var Te = Ie.getName(xe), Pe = Ie.getValues(xe), $e = te.get(["data", Te ? "withName" : "withoutName"]);
                _e.push(Z($e, {
                  name: Te,
                  value: Pe.join(Se)
                }));
              }
            me += _e.join(Se) + Ae, ce.push(me);
          }
        });
        var ge = te.getModel(["series", "multiple", "separator"]), fe = ge.get("middle"), ve = ge.get("end");
        oe += ce.join(fe) + ve, re.setAttribute("aria-label", oe);
      }
    }
  }
  function Z(ee, te) {
    if (!isString(ee))
      return ee;
    var re = ee;
    return each$f(te, function(ne, ae) {
      re = re.replace(new RegExp("\\{\\s*" + ae + "\\s*\\}", "g"), ne);
    }), re;
  }
  function X() {
    var ee = H.get("title");
    return ee && ee.length && (ee = ee[0]), ee && ee.text;
  }
  function Q(ee) {
    return H.getLocaleModel().get(["series", "typeNames"])[ee] || "自定义图";
  }
}
function ariaPreprocessor(H) {
  if (!(!H || !H.aria)) {
    var C = H.aria;
    C.show != null && (C.enabled = C.show), C.label = C.label || {}, each$f(["description", "general", "series", "data"], function(G) {
      C[G] != null && (C.label[G] = C[G]);
    });
  }
}
function install$2(H) {
  H.registerPreprocessor(ariaPreprocessor), H.registerVisual(H.PRIORITY.VISUAL.ARIA, ariaVisual);
}
var RELATIONAL_EXPRESSION_OP_ALIAS_MAP = {
  value: "eq",
  // PENDING: not good for literal semantic?
  "<": "lt",
  "<=": "lte",
  ">": "gt",
  ">=": "gte",
  "=": "eq",
  "!=": "ne",
  "<>": "ne"
  // Might be misleading for sake of the difference between '==' and '===',
  // so don't support them.
  // '==': 'eq',
  // '===': 'seq',
  // '!==': 'sne'
  // PENDING: Whether support some common alias "ge", "le", "neq"?
  // ge: 'gte',
  // le: 'lte',
  // neq: 'ne',
}, RegExpEvaluator = (
  /** @class */
  function() {
    function H(C) {
      var G = this._condVal = isString(C) ? new RegExp(C) : isRegExp(C) ? C : null;
      if (G == null) {
        var U = "";
        process.env.NODE_ENV !== "production" && (U = makePrintable("Illegal regexp", C, "in")), throwError(U);
      }
    }
    return H.prototype.evaluate = function(C) {
      var G = typeof C;
      return isString(G) ? this._condVal.test(C) : isNumber(G) ? this._condVal.test(C + "") : !1;
    }, H;
  }()
), ConstConditionInternal = (
  /** @class */
  function() {
    function H() {
    }
    return H.prototype.evaluate = function() {
      return this.value;
    }, H;
  }()
), AndConditionInternal = (
  /** @class */
  function() {
    function H() {
    }
    return H.prototype.evaluate = function() {
      for (var C = this.children, G = 0; G < C.length; G++)
        if (!C[G].evaluate())
          return !1;
      return !0;
    }, H;
  }()
), OrConditionInternal = (
  /** @class */
  function() {
    function H() {
    }
    return H.prototype.evaluate = function() {
      for (var C = this.children, G = 0; G < C.length; G++)
        if (C[G].evaluate())
          return !0;
      return !1;
    }, H;
  }()
), NotConditionInternal = (
  /** @class */
  function() {
    function H() {
    }
    return H.prototype.evaluate = function() {
      return !this.child.evaluate();
    }, H;
  }()
), RelationalConditionInternal = (
  /** @class */
  function() {
    function H() {
    }
    return H.prototype.evaluate = function() {
      for (var C = !!this.valueParser, G = this.getValue, U = G(this.valueGetterParam), K = C ? this.valueParser(U) : null, W = 0; W < this.subCondList.length; W++)
        if (!this.subCondList[W].evaluate(C ? K : U))
          return !1;
      return !0;
    }, H;
  }()
);
function parseOption(H, C) {
  if (H === !0 || H === !1) {
    var G = new ConstConditionInternal();
    return G.value = H, G;
  }
  var U = "";
  return isObjectNotArray(H) || (process.env.NODE_ENV !== "production" && (U = makePrintable("Illegal config. Expect a plain object but actually", H)), throwError(U)), H.and ? parseAndOrOption("and", H, C) : H.or ? parseAndOrOption("or", H, C) : H.not ? parseNotOption(H, C) : parseRelationalOption(H, C);
}
function parseAndOrOption(H, C, G) {
  var U = C[H], K = "";
  process.env.NODE_ENV !== "production" && (K = makePrintable('"and"/"or" condition should only be `' + H + ": [...]` and must not be empty array.", "Illegal condition:", C)), isArray$1(U) || throwError(K), U.length || throwError(K);
  var W = H === "and" ? new AndConditionInternal() : new OrConditionInternal();
  return W.children = map$1(U, function(Z) {
    return parseOption(Z, G);
  }), W.children.length || throwError(K), W;
}
function parseNotOption(H, C) {
  var G = H.not, U = "";
  process.env.NODE_ENV !== "production" && (U = makePrintable('"not" condition should only be `not: {}`.', "Illegal condition:", H)), isObjectNotArray(G) || throwError(U);
  var K = new NotConditionInternal();
  return K.child = parseOption(G, C), K.child || throwError(U), K;
}
function parseRelationalOption(H, C) {
  for (var G = "", U = C.prepareGetValue(H), K = [], W = keys(H), Z = H.parser, X = Z ? getRawValueParser(Z) : null, Q = 0; Q < W.length; Q++) {
    var ee = W[Q];
    if (!(ee === "parser" || C.valueGetterAttrMap.get(ee))) {
      var te = hasOwn(RELATIONAL_EXPRESSION_OP_ALIAS_MAP, ee) ? RELATIONAL_EXPRESSION_OP_ALIAS_MAP[ee] : ee, re = H[ee], ne = X ? X(re) : re, ae = createFilterComparator(te, ne) || te === "reg" && new RegExpEvaluator(ne);
      ae || (process.env.NODE_ENV !== "production" && (G = makePrintable('Illegal relational operation: "' + ee + '" in condition:', H)), throwError(G)), K.push(ae);
    }
  }
  K.length || (process.env.NODE_ENV !== "production" && (G = makePrintable("Relational condition must have at least one operator.", "Illegal condition:", H)), throwError(G));
  var ie = new RelationalConditionInternal();
  return ie.valueGetterParam = U, ie.valueParser = X, ie.getValue = C.getValue, ie.subCondList = K, ie;
}
function isObjectNotArray(H) {
  return isObject$3(H) && !isArrayLike(H);
}
var ConditionalExpressionParsed = (
  /** @class */
  function() {
    function H(C, G) {
      this._cond = parseOption(C, G);
    }
    return H.prototype.evaluate = function() {
      return this._cond.evaluate();
    }, H;
  }()
);
function parseConditionalExpression(H, C) {
  return new ConditionalExpressionParsed(H, C);
}
var filterTransform = {
  type: "echarts:filter",
  // PEDING: enhance to filter by index rather than create new data
  transform: function(H) {
    for (var C = H.upstream, G, U = parseConditionalExpression(H.config, {
      valueGetterAttrMap: createHashMap({
        dimension: !0
      }),
      prepareGetValue: function(X) {
        var Q = "", ee = X.dimension;
        hasOwn(X, "dimension") || (process.env.NODE_ENV !== "production" && (Q = makePrintable('Relation condition must has prop "dimension" specified.', "Illegal condition:", X)), throwError(Q));
        var te = C.getDimensionInfo(ee);
        return te || (process.env.NODE_ENV !== "production" && (Q = makePrintable("Can not find dimension info via: " + ee + `.
`, "Existing dimensions: ", C.cloneAllDimensionInfo(), `.
`, "Illegal condition:", X, `.
`)), throwError(Q)), {
          dimIdx: te.index
        };
      },
      getValue: function(X) {
        return C.retrieveValueFromItem(G, X.dimIdx);
      }
    }), K = [], W = 0, Z = C.count(); W < Z; W++)
      G = C.getRawDataItem(W), U.evaluate() && K.push(G);
    return {
      data: K
    };
  }
}, sampleLog = "";
process.env.NODE_ENV !== "production" && (sampleLog = ["Valid config is like:", '{ dimension: "age", order: "asc" }', 'or [{ dimension: "age", order: "asc"], { dimension: "date", order: "desc" }]'].join(" "));
var sortTransform = {
  type: "echarts:sort",
  transform: function(H) {
    var C = H.upstream, G = H.config, U = "", K = normalizeToArray(G);
    K.length || (process.env.NODE_ENV !== "production" && (U = "Empty `config` in sort transform."), throwError(U));
    var W = [];
    each$f(K, function(te) {
      var re = te.dimension, ne = te.order, ae = te.parser, ie = te.incomparable;
      if (re == null && (process.env.NODE_ENV !== "production" && (U = 'Sort transform config must has "dimension" specified.' + sampleLog), throwError(U)), ne !== "asc" && ne !== "desc" && (process.env.NODE_ENV !== "production" && (U = 'Sort transform config must has "order" specified.' + sampleLog), throwError(U)), ie && ie !== "min" && ie !== "max") {
        var se = "";
        process.env.NODE_ENV !== "production" && (se = 'incomparable must be "min" or "max" rather than "' + ie + '".'), throwError(se);
      }
      if (ne !== "asc" && ne !== "desc") {
        var oe = "";
        process.env.NODE_ENV !== "production" && (oe = 'order must be "asc" or "desc" rather than "' + ne + '".'), throwError(oe);
      }
      var le = C.getDimensionInfo(re);
      le || (process.env.NODE_ENV !== "production" && (U = makePrintable("Can not find dimension info via: " + re + `.
`, "Existing dimensions: ", C.cloneAllDimensionInfo(), `.
`, "Illegal config:", te, `.
`)), throwError(U));
      var ue = ae ? getRawValueParser(ae) : null;
      ae && !ue && (process.env.NODE_ENV !== "production" && (U = makePrintable("Invalid parser name " + ae + `.
`, "Illegal config:", te, `.
`)), throwError(U)), W.push({
        dimIdx: le.index,
        parser: ue,
        comparator: new SortOrderComparator(ne, ie)
      });
    });
    var Z = C.sourceFormat;
    Z !== SOURCE_FORMAT_ARRAY_ROWS && Z !== SOURCE_FORMAT_OBJECT_ROWS && (process.env.NODE_ENV !== "production" && (U = 'sourceFormat "' + Z + '" is not supported yet'), throwError(U));
    for (var X = [], Q = 0, ee = C.count(); Q < ee; Q++)
      X.push(C.getRawDataItem(Q));
    return X.sort(function(te, re) {
      for (var ne = 0; ne < W.length; ne++) {
        var ae = W[ne], ie = C.retrieveValueFromItem(te, ae.dimIdx), se = C.retrieveValueFromItem(re, ae.dimIdx);
        ae.parser && (ie = ae.parser(ie), se = ae.parser(se));
        var oe = ae.comparator.evaluate(ie, se);
        if (oe !== 0)
          return oe;
      }
      return 0;
    }), {
      data: X
    };
  }
};
function install$1(H) {
  H.registerTransform(filterTransform), H.registerTransform(sortTransform);
}
var DatasetModel = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = "dataset", G;
    }
    return C.prototype.init = function(G, U, K) {
      H.prototype.init.call(this, G, U, K), this._sourceManager = new SourceManager(this), disableTransformOptionMerge(this);
    }, C.prototype.mergeOption = function(G, U) {
      H.prototype.mergeOption.call(this, G, U), disableTransformOptionMerge(this);
    }, C.prototype.optionUpdated = function() {
      this._sourceManager.dirty();
    }, C.prototype.getSourceManager = function() {
      return this._sourceManager;
    }, C.type = "dataset", C.defaultOption = {
      seriesLayoutBy: SERIES_LAYOUT_BY_COLUMN
    }, C;
  }(ComponentModel$1)
), DatasetView = (
  /** @class */
  function(H) {
    __extends$1(C, H);
    function C() {
      var G = H !== null && H.apply(this, arguments) || this;
      return G.type = "dataset", G;
    }
    return C.type = "dataset", C;
  }(ComponentView$1)
);
function install(H) {
  H.registerComponentModel(DatasetModel), H.registerComponentView(DatasetView);
}
var CMD = PathProxy$1.CMD;
function aroundEqual(H, C) {
  return Math.abs(H - C) < 1e-5;
}
function pathToBezierCurves(H) {
  var C = H.data, G = H.len(), U = [], K, W = 0, Z = 0, X = 0, Q = 0;
  function ee(Ie, be) {
    K && K.length > 2 && U.push(K), K = [Ie, be];
  }
  function te(Ie, be, Se, Ae) {
    aroundEqual(Ie, Se) && aroundEqual(be, Ae) || K.push(Ie, be, Se, Ae, Se, Ae);
  }
  function re(Ie, be, Se, Ae, _e, xe) {
    var Te = Math.abs(be - Ie), Pe = Math.tan(Te / 4) * 4 / 3, $e = be < Ie ? -1 : 1, Me = Math.cos(Ie), Ee = Math.sin(Ie), we = Math.cos(be), Oe = Math.sin(be), Ne = Me * _e + Se, ke = Ee * xe + Ae, ze = we * _e + Se, He = Oe * xe + Ae, We = _e * Pe * $e, Re = xe * Pe * $e;
    K.push(Ne - We * Ee, ke + Re * Me, ze + We * Oe, He - Re * we, ze, He);
  }
  for (var ne, ae, ie, se, oe = 0; oe < G; ) {
    var le = C[oe++], ue = oe === 1;
    switch (ue && (W = C[oe], Z = C[oe + 1], X = W, Q = Z, (le === CMD.L || le === CMD.C || le === CMD.Q) && (K = [X, Q])), le) {
      case CMD.M:
        W = X = C[oe++], Z = Q = C[oe++], ee(X, Q);
        break;
      case CMD.L:
        ne = C[oe++], ae = C[oe++], te(W, Z, ne, ae), W = ne, Z = ae;
        break;
      case CMD.C:
        K.push(C[oe++], C[oe++], C[oe++], C[oe++], W = C[oe++], Z = C[oe++]);
        break;
      case CMD.Q:
        ne = C[oe++], ae = C[oe++], ie = C[oe++], se = C[oe++], K.push(W + 2 / 3 * (ne - W), Z + 2 / 3 * (ae - Z), ie + 2 / 3 * (ne - ie), se + 2 / 3 * (ae - se), ie, se), W = ie, Z = se;
        break;
      case CMD.A:
        var ce = C[oe++], de = C[oe++], ge = C[oe++], fe = C[oe++], ve = C[oe++], pe = C[oe++] + ve;
        oe += 1;
        var he = !C[oe++];
        ne = Math.cos(ve) * ge + ce, ae = Math.sin(ve) * fe + de, ue ? (X = ne, Q = ae, ee(X, Q)) : te(W, Z, ne, ae), W = Math.cos(pe) * ge + ce, Z = Math.sin(pe) * fe + de;
        for (var me = (he ? -1 : 1) * Math.PI / 2, ye = ve; he ? ye > pe : ye < pe; ye += me) {
          var Ce = he ? Math.max(ye + me, pe) : Math.min(ye + me, pe);
          re(ye, Ce, ce, de, ge, fe);
        }
        break;
      case CMD.R:
        X = W = C[oe++], Q = Z = C[oe++], ne = X + C[oe++], ae = Q + C[oe++], ee(ne, Q), te(ne, Q, ne, ae), te(ne, ae, X, ae), te(X, ae, X, Q), te(X, Q, ne, Q);
        break;
      case CMD.Z:
        K && te(W, Z, X, Q), W = X, Z = Q;
        break;
    }
  }
  return K && K.length > 2 && U.push(K), U;
}
function adpativeBezier(H, C, G, U, K, W, Z, X, Q, ee) {
  if (aroundEqual(H, G) && aroundEqual(C, U) && aroundEqual(K, Z) && aroundEqual(W, X)) {
    Q.push(Z, X);
    return;
  }
  var te = 2 / ee, re = te * te, ne = Z - H, ae = X - C, ie = Math.sqrt(ne * ne + ae * ae);
  ne /= ie, ae /= ie;
  var se = G - H, oe = U - C, le = K - Z, ue = W - X, ce = se * se + oe * oe, de = le * le + ue * ue;
  if (ce < re && de < re) {
    Q.push(Z, X);
    return;
  }
  var ge = ne * se + ae * oe, fe = -ne * le - ae * ue, ve = ce - ge * ge, pe = de - fe * fe;
  if (ve < re && ge >= 0 && pe < re && fe >= 0) {
    Q.push(Z, X);
    return;
  }
  var he = [], me = [];
  cubicSubdivide(H, G, K, Z, 0.5, he), cubicSubdivide(C, U, W, X, 0.5, me), adpativeBezier(he[0], me[0], he[1], me[1], he[2], me[2], he[3], me[3], Q, ee), adpativeBezier(he[4], me[4], he[5], me[5], he[6], me[6], he[7], me[7], Q, ee);
}
function pathToPolygons(H, C) {
  var G = pathToBezierCurves(H), U = [];
  C = C || 1;
  for (var K = 0; K < G.length; K++) {
    var W = G[K], Z = [], X = W[0], Q = W[1];
    Z.push(X, Q);
    for (var ee = 2; ee < W.length; ) {
      var te = W[ee++], re = W[ee++], ne = W[ee++], ae = W[ee++], ie = W[ee++], se = W[ee++];
      adpativeBezier(X, Q, te, re, ne, ae, ie, se, Z, C), X = ie, Q = se;
    }
    U.push(Z);
  }
  return U;
}
function getDividingGrids(H, C, G) {
  var U = H[C], K = H[1 - C], W = Math.abs(U / K), Z = Math.ceil(Math.sqrt(W * G)), X = Math.floor(G / Z);
  X === 0 && (X = 1, Z = G);
  for (var Q = [], ee = 0; ee < Z; ee++)
    Q.push(X);
  var te = Z * X, re = G - te;
  if (re > 0)
    for (var ee = 0; ee < re; ee++)
      Q[ee % Z] += 1;
  return Q;
}
function divideSector(H, C, G) {
  for (var U = H.r0, K = H.r, W = H.startAngle, Z = H.endAngle, X = Math.abs(Z - W), Q = X * K, ee = K - U, te = Q > Math.abs(ee), re = getDividingGrids([Q, ee], te ? 0 : 1, C), ne = (te ? X : ee) / re.length, ae = 0; ae < re.length; ae++)
    for (var ie = (te ? ee : X) / re[ae], se = 0; se < re[ae]; se++) {
      var oe = {};
      te ? (oe.startAngle = W + ne * ae, oe.endAngle = W + ne * (ae + 1), oe.r0 = U + ie * se, oe.r = U + ie * (se + 1)) : (oe.startAngle = W + ie * se, oe.endAngle = W + ie * (se + 1), oe.r0 = U + ne * ae, oe.r = U + ne * (ae + 1)), oe.clockwise = H.clockwise, oe.cx = H.cx, oe.cy = H.cy, G.push(oe);
    }
}
function divideRect(H, C, G) {
  for (var U = H.width, K = H.height, W = U > K, Z = getDividingGrids([U, K], W ? 0 : 1, C), X = W ? "width" : "height", Q = W ? "height" : "width", ee = W ? "x" : "y", te = W ? "y" : "x", re = H[X] / Z.length, ne = 0; ne < Z.length; ne++)
    for (var ae = H[Q] / Z[ne], ie = 0; ie < Z[ne]; ie++) {
      var se = {};
      se[ee] = ne * re, se[te] = ie * ae, se[X] = re, se[Q] = ae, se.x += H.x, se.y += H.y, G.push(se);
    }
}
function crossProduct2d(H, C, G, U) {
  return H * U - G * C;
}
function lineLineIntersect(H, C, G, U, K, W, Z, X) {
  var Q = G - H, ee = U - C, te = Z - K, re = X - W, ne = crossProduct2d(te, re, Q, ee);
  if (Math.abs(ne) < 1e-6)
    return null;
  var ae = H - K, ie = C - W, se = crossProduct2d(ae, ie, te, re) / ne;
  return se < 0 || se > 1 ? null : new Point$1(se * Q + H, se * ee + C);
}
function projPtOnLine(H, C, G) {
  var U = new Point$1();
  Point$1.sub(U, G, C), U.normalize();
  var K = new Point$1();
  Point$1.sub(K, H, C);
  var W = K.dot(U);
  return W;
}
function addToPoly(H, C) {
  var G = H[H.length - 1];
  G && G[0] === C[0] && G[1] === C[1] || H.push(C);
}
function splitPolygonByLine(H, C, G) {
  for (var U = H.length, K = [], W = 0; W < U; W++) {
    var Z = H[W], X = H[(W + 1) % U], Q = lineLineIntersect(Z[0], Z[1], X[0], X[1], C.x, C.y, G.x, G.y);
    Q && K.push({
      projPt: projPtOnLine(Q, C, G),
      pt: Q,
      idx: W
    });
  }
  if (K.length < 2)
    return [{ points: H }, { points: H }];
  K.sort(function(oe, le) {
    return oe.projPt - le.projPt;
  });
  var ee = K[0], te = K[K.length - 1];
  if (te.idx < ee.idx) {
    var re = ee;
    ee = te, te = re;
  }
  for (var ne = [ee.pt.x, ee.pt.y], ae = [te.pt.x, te.pt.y], ie = [ne], se = [ae], W = ee.idx + 1; W <= te.idx; W++)
    addToPoly(ie, H[W].slice());
  addToPoly(ie, ae), addToPoly(ie, ne);
  for (var W = te.idx + 1; W <= ee.idx + U; W++)
    addToPoly(se, H[W % U].slice());
  return addToPoly(se, ne), addToPoly(se, ae), [{
    points: ie
  }, {
    points: se
  }];
}
function binaryDividePolygon(H) {
  var C = H.points, G = [], U = [];
  fromPoints(C, G, U);
  var K = new BoundingRect$1(G[0], G[1], U[0] - G[0], U[1] - G[1]), W = K.width, Z = K.height, X = K.x, Q = K.y, ee = new Point$1(), te = new Point$1();
  return W > Z ? (ee.x = te.x = X + W / 2, ee.y = Q, te.y = Q + Z) : (ee.y = te.y = Q + Z / 2, ee.x = X, te.x = X + W), splitPolygonByLine(C, ee, te);
}
function binaryDivideRecursive(H, C, G, U) {
  if (G === 1)
    U.push(C);
  else {
    var K = Math.floor(G / 2), W = H(C);
    binaryDivideRecursive(H, W[0], K, U), binaryDivideRecursive(H, W[1], G - K, U);
  }
  return U;
}
function clone(H, C) {
  for (var G = [], U = 0; U < C; U++)
    G.push(clonePath(H));
  return G;
}
function copyPathProps(H, C) {
  C.setStyle(H.style), C.z = H.z, C.z2 = H.z2, C.zlevel = H.zlevel;
}
function polygonConvert(H) {
  for (var C = [], G = 0; G < H.length; )
    C.push([H[G++], H[G++]]);
  return C;
}
function split(H, C) {
  var G = [], U = H.shape, K;
  switch (H.type) {
    case "rect":
      divideRect(U, C, G), K = Rect$3;
      break;
    case "sector":
      divideSector(U, C, G), K = Sector$1;
      break;
    case "circle":
      divideSector({
        r0: 0,
        r: U.r,
        startAngle: 0,
        endAngle: Math.PI * 2,
        cx: U.cx,
        cy: U.cy
      }, C, G), K = Sector$1;
      break;
    default:
      var W = H.getComputedTransform(), Z = W ? Math.sqrt(Math.max(W[0] * W[0] + W[1] * W[1], W[2] * W[2] + W[3] * W[3])) : 1, X = map$1(pathToPolygons(H.getUpdatedPathProxy(), Z), function(le) {
        return polygonConvert(le);
      }), Q = X.length;
      if (Q === 0)
        binaryDivideRecursive(binaryDividePolygon, {
          points: X[0]
        }, C, G);
      else if (Q === C)
        for (var ee = 0; ee < Q; ee++)
          G.push({
            points: X[ee]
          });
      else {
        var te = 0, re = map$1(X, function(le) {
          var ue = [], ce = [];
          fromPoints(le, ue, ce);
          var de = (ce[1] - ue[1]) * (ce[0] - ue[0]);
          return te += de, { poly: le, area: de };
        });
        re.sort(function(le, ue) {
          return ue.area - le.area;
        });
        for (var ne = C, ee = 0; ee < Q; ee++) {
          var ae = re[ee];
          if (ne <= 0)
            break;
          var ie = ee === Q - 1 ? ne : Math.ceil(ae.area / te * C);
          ie < 0 || (binaryDivideRecursive(binaryDividePolygon, {
            points: ae.poly
          }, ie, G), ne -= ie);
        }
      }
      K = Polygon$1;
      break;
  }
  if (!K)
    return clone(H, C);
  for (var se = [], ee = 0; ee < G.length; ee++) {
    var oe = new K();
    oe.setShape(G[ee]), copyPathProps(H, oe), se.push(oe);
  }
  return se;
}
function alignSubpath(H, C) {
  var G = H.length, U = C.length;
  if (G === U)
    return [H, C];
  for (var K = [], W = [], Z = G < U ? H : C, X = Math.min(G, U), Q = Math.abs(U - G) / 6, ee = (X - 2) / 6, te = Math.ceil(Q / ee) + 1, re = [Z[0], Z[1]], ne = Q, ae = 2; ae < X; ) {
    var ie = Z[ae - 2], se = Z[ae - 1], oe = Z[ae++], le = Z[ae++], ue = Z[ae++], ce = Z[ae++], de = Z[ae++], ge = Z[ae++];
    if (ne <= 0) {
      re.push(oe, le, ue, ce, de, ge);
      continue;
    }
    for (var fe = Math.min(ne, te - 1) + 1, ve = 1; ve <= fe; ve++) {
      var pe = ve / fe;
      cubicSubdivide(ie, oe, ue, de, pe, K), cubicSubdivide(se, le, ce, ge, pe, W), ie = K[3], se = W[3], re.push(K[1], W[1], K[2], W[2], ie, se), oe = K[5], le = W[5], ue = K[6], ce = W[6];
    }
    ne -= fe - 1;
  }
  return Z === H ? [re, C] : [H, re];
}
function createSubpath(H, C) {
  for (var G = H.length, U = H[G - 2], K = H[G - 1], W = [], Z = 0; Z < C.length; )
    W[Z++] = U, W[Z++] = K;
  return W;
}
function alignBezierCurves(H, C) {
  for (var G, U, K, W = [], Z = [], X = 0; X < Math.max(H.length, C.length); X++) {
    var Q = H[X], ee = C[X], te = void 0, re = void 0;
    Q ? ee ? (G = alignSubpath(Q, ee), te = G[0], re = G[1], U = te, K = re) : (re = createSubpath(K || Q, Q), te = Q) : (te = createSubpath(U || ee, ee), re = ee), W.push(te), Z.push(re);
  }
  return [W, Z];
}
function centroid(H) {
  for (var C = 0, G = 0, U = 0, K = H.length, W = 0, Z = K - 2; W < K; Z = W, W += 2) {
    var X = H[Z], Q = H[Z + 1], ee = H[W], te = H[W + 1], re = X * te - ee * Q;
    C += re, G += (X + ee) * re, U += (Q + te) * re;
  }
  return C === 0 ? [H[0] || 0, H[1] || 0] : [G / C / 3, U / C / 3, C];
}
function findBestRingOffset(H, C, G, U) {
  for (var K = (H.length - 2) / 6, W = 1 / 0, Z = 0, X = H.length, Q = X - 2, ee = 0; ee < K; ee++) {
    for (var te = ee * 6, re = 0, ne = 0; ne < X; ne += 2) {
      var ae = ne === 0 ? te : (te + ne - 2) % Q + 2, ie = H[ae] - G[0], se = H[ae + 1] - G[1], oe = C[ne] - U[0], le = C[ne + 1] - U[1], ue = oe - ie, ce = le - se;
      re += ue * ue + ce * ce;
    }
    re < W && (W = re, Z = ee);
  }
  return Z;
}
function reverse(H) {
  for (var C = [], G = H.length, U = 0; U < G; U += 2)
    C[U] = H[G - U - 2], C[U + 1] = H[G - U - 1];
  return C;
}
function findBestMorphingRotation(H, C, G, U) {
  for (var K = [], W, Z = 0; Z < H.length; Z++) {
    var X = H[Z], Q = C[Z], ee = centroid(X), te = centroid(Q);
    W == null && (W = ee[2] < 0 != te[2] < 0);
    var re = [], ne = [], ae = 0, ie = 1 / 0, se = [], oe = X.length;
    W && (X = reverse(X));
    for (var le = findBestRingOffset(X, Q, ee, te) * 6, ue = oe - 2, ce = 0; ce < ue; ce += 2) {
      var de = (le + ce) % ue + 2;
      re[ce + 2] = X[de] - ee[0], re[ce + 3] = X[de + 1] - ee[1];
    }
    if (re[0] = X[le] - ee[0], re[1] = X[le + 1] - ee[1], G > 0)
      for (var ge = U / G, fe = -U / 2; fe <= U / 2; fe += ge) {
        for (var ve = Math.sin(fe), pe = Math.cos(fe), he = 0, ce = 0; ce < X.length; ce += 2) {
          var me = re[ce], ye = re[ce + 1], Ce = Q[ce] - te[0], Ie = Q[ce + 1] - te[1], be = Ce * pe - Ie * ve, Se = Ce * ve + Ie * pe;
          se[ce] = be, se[ce + 1] = Se;
          var Ae = be - me, _e = Se - ye;
          he += Ae * Ae + _e * _e;
        }
        if (he < ie) {
          ie = he, ae = fe;
          for (var xe = 0; xe < se.length; xe++)
            ne[xe] = se[xe];
        }
      }
    else
      for (var Te = 0; Te < oe; Te += 2)
        ne[Te] = Q[Te] - te[0], ne[Te + 1] = Q[Te + 1] - te[1];
    K.push({
      from: re,
      to: ne,
      fromCp: ee,
      toCp: te,
      rotation: -ae
    });
  }
  return K;
}
function isCombineMorphing(H) {
  return H.__isCombineMorphing;
}
var SAVED_METHOD_PREFIX = "__mOriginal_";
function saveAndModifyMethod(H, C, G) {
  var U = SAVED_METHOD_PREFIX + C, K = H[U] || H[C];
  H[U] || (H[U] = H[C]);
  var W = G.replace, Z = G.after, X = G.before;
  H[C] = function() {
    var Q = arguments, ee;
    return X && X.apply(this, Q), W ? ee = W.apply(this, Q) : ee = K.apply(this, Q), Z && Z.apply(this, Q), ee;
  };
}
function restoreMethod(H, C) {
  var G = SAVED_METHOD_PREFIX + C;
  H[G] && (H[C] = H[G], H[G] = null);
}
function applyTransformOnBeziers(H, C) {
  for (var G = 0; G < H.length; G++)
    for (var U = H[G], K = 0; K < U.length; ) {
      var W = U[K], Z = U[K + 1];
      U[K++] = C[0] * W + C[2] * Z + C[4], U[K++] = C[1] * W + C[3] * Z + C[5];
    }
}
function prepareMorphPath(H, C) {
  var G = H.getUpdatedPathProxy(), U = C.getUpdatedPathProxy(), K = alignBezierCurves(pathToBezierCurves(G), pathToBezierCurves(U)), W = K[0], Z = K[1], X = H.getComputedTransform(), Q = C.getComputedTransform();
  function ee() {
    this.transform = null;
  }
  X && applyTransformOnBeziers(W, X), Q && applyTransformOnBeziers(Z, Q), saveAndModifyMethod(C, "updateTransform", { replace: ee }), C.transform = null;
  var te = findBestMorphingRotation(W, Z, 10, Math.PI), re = [];
  saveAndModifyMethod(C, "buildPath", { replace: function(ne) {
    for (var ae = C.__morphT, ie = 1 - ae, se = [], oe = 0; oe < te.length; oe++) {
      var le = te[oe], ue = le.from, ce = le.to, de = le.rotation * ae, ge = le.fromCp, fe = le.toCp, ve = Math.sin(de), pe = Math.cos(de);
      lerp$1(se, ge, fe, ae);
      for (var he = 0; he < ue.length; he += 2) {
        var me = ue[he], ye = ue[he + 1], Ce = ce[he], Ie = ce[he + 1], be = me * ie + Ce * ae, Se = ye * ie + Ie * ae;
        re[he] = be * pe - Se * ve + se[0], re[he + 1] = be * ve + Se * pe + se[1];
      }
      var Ae = re[0], _e = re[1];
      ne.moveTo(Ae, _e);
      for (var he = 2; he < ue.length; ) {
        var Ce = re[he++], Ie = re[he++], xe = re[he++], Te = re[he++], Pe = re[he++], $e = re[he++];
        Ae === Ce && _e === Ie && xe === Pe && Te === $e ? ne.lineTo(Pe, $e) : ne.bezierCurveTo(Ce, Ie, xe, Te, Pe, $e), Ae = Pe, _e = $e;
      }
    }
  } });
}
function morphPath(H, C, G) {
  if (!H || !C)
    return C;
  var U = G.done, K = G.during;
  prepareMorphPath(H, C), C.__morphT = 0;
  function W() {
    restoreMethod(C, "buildPath"), restoreMethod(C, "updateTransform"), C.__morphT = -1, C.createPathProxy(), C.dirtyShape();
  }
  return C.animateTo({
    __morphT: 1
  }, defaults({
    during: function(Z) {
      C.dirtyShape(), K && K(Z);
    },
    done: function() {
      W(), U && U();
    }
  }, G)), C;
}
function hilbert(H, C, G, U, K, W) {
  var Z = 16;
  H = K === G ? 0 : Math.round(32767 * (H - G) / (K - G)), C = W === U ? 0 : Math.round(32767 * (C - U) / (W - U));
  for (var X = 0, Q, ee = (1 << Z) / 2; ee > 0; ee /= 2) {
    var te = 0, re = 0;
    (H & ee) > 0 && (te = 1), (C & ee) > 0 && (re = 1), X += ee * ee * (3 * te ^ re), re === 0 && (te === 1 && (H = ee - 1 - H, C = ee - 1 - C), Q = H, H = C, C = Q);
  }
  return X;
}
function sortPaths(H) {
  var C = 1 / 0, G = 1 / 0, U = -1 / 0, K = -1 / 0, W = map$1(H, function(X) {
    var Q = X.getBoundingRect(), ee = X.getComputedTransform(), te = Q.x + Q.width / 2 + (ee ? ee[4] : 0), re = Q.y + Q.height / 2 + (ee ? ee[5] : 0);
    return C = Math.min(te, C), G = Math.min(re, G), U = Math.max(te, U), K = Math.max(re, K), [te, re];
  }), Z = map$1(W, function(X, Q) {
    return {
      cp: X,
      z: hilbert(X[0], X[1], C, G, U, K),
      path: H[Q]
    };
  });
  return Z.sort(function(X, Q) {
    return X.z - Q.z;
  }).map(function(X) {
    return X.path;
  });
}
function defaultDividePath(H) {
  return split(H.path, H.count);
}
function createEmptyReturn() {
  return {
    fromIndividuals: [],
    toIndividuals: [],
    count: 0
  };
}
function combineMorph(H, C, G) {
  var U = [];
  function K(ge) {
    for (var fe = 0; fe < ge.length; fe++) {
      var ve = ge[fe];
      isCombineMorphing(ve) ? K(ve.childrenRef()) : ve instanceof Path$1 && U.push(ve);
    }
  }
  K(H);
  var W = U.length;
  if (!W)
    return createEmptyReturn();
  var Z = G.dividePath || defaultDividePath, X = Z({
    path: C,
    count: W
  });
  if (X.length !== W)
    return console.error("Invalid morphing: unmatched splitted path"), createEmptyReturn();
  U = sortPaths(U), X = sortPaths(X);
  for (var Q = G.done, ee = G.during, te = G.individualDelay, re = new Transformable(), ne = 0; ne < W; ne++) {
    var ae = U[ne], ie = X[ne];
    ie.parent = C, ie.copyTransform(re), te || prepareMorphPath(ae, ie);
  }
  C.__isCombineMorphing = !0, C.childrenRef = function() {
    return X;
  };
  function se(ge) {
    for (var fe = 0; fe < X.length; fe++)
      X[fe].addSelfToZr(ge);
  }
  saveAndModifyMethod(C, "addSelfToZr", {
    after: function(ge) {
      se(ge);
    }
  }), saveAndModifyMethod(C, "removeSelfFromZr", {
    after: function(ge) {
      for (var fe = 0; fe < X.length; fe++)
        X[fe].removeSelfFromZr(ge);
    }
  });
  function oe() {
    C.__isCombineMorphing = !1, C.__morphT = -1, C.childrenRef = null, restoreMethod(C, "addSelfToZr"), restoreMethod(C, "removeSelfFromZr");
  }
  var le = X.length;
  if (te)
    for (var ue = le, ce = function() {
      ue--, ue === 0 && (oe(), Q && Q());
    }, ne = 0; ne < le; ne++) {
      var de = te ? defaults({
        delay: (G.delay || 0) + te(ne, le, U[ne], X[ne]),
        done: ce
      }, G) : G;
      morphPath(U[ne], X[ne], de);
    }
  else
    C.__morphT = 0, C.animateTo({
      __morphT: 1
    }, defaults({
      during: function(ge) {
        for (var fe = 0; fe < le; fe++) {
          var ve = X[fe];
          ve.__morphT = C.__morphT, ve.dirtyShape();
        }
        ee && ee(ge);
      },
      done: function() {
        oe();
        for (var ge = 0; ge < H.length; ge++)
          restoreMethod(H[ge], "updateTransform");
        Q && Q();
      }
    }, G));
  return C.__zr && se(C.__zr), {
    fromIndividuals: U,
    toIndividuals: X,
    count: le
  };
}
function separateMorph(H, C, G) {
  var U = C.length, K = [], W = G.dividePath || defaultDividePath;
  function Z(ae) {
    for (var ie = 0; ie < ae.length; ie++) {
      var se = ae[ie];
      isCombineMorphing(se) ? Z(se.childrenRef()) : se instanceof Path$1 && K.push(se);
    }
  }
  if (isCombineMorphing(H)) {
    Z(H.childrenRef());
    var X = K.length;
    if (X < U)
      for (var Q = 0, ee = X; ee < U; ee++)
        K.push(clonePath(K[Q++ % X]));
    K.length = U;
  } else {
    K = W({ path: H, count: U });
    for (var te = H.getComputedTransform(), ee = 0; ee < K.length; ee++)
      K[ee].setLocalTransform(te);
    if (K.length !== U)
      return console.error("Invalid morphing: unmatched splitted path"), createEmptyReturn();
  }
  K = sortPaths(K), C = sortPaths(C);
  for (var re = G.individualDelay, ee = 0; ee < U; ee++) {
    var ne = re ? defaults({
      delay: (G.delay || 0) + re(ee, U, K[ee], C[ee])
    }, G) : G;
    morphPath(K[ee], C[ee], ne);
  }
  return {
    fromIndividuals: K,
    toIndividuals: C,
    count: C.length
  };
}
function isMultiple(H) {
  return isArray$1(H[0]);
}
function prepareMorphBatches(H, C) {
  for (var G = [], U = H.length, K = 0; K < U; K++)
    G.push({
      one: H[K],
      many: []
    });
  for (var K = 0; K < C.length; K++) {
    var W = C[K].length, Z = void 0;
    for (Z = 0; Z < W; Z++)
      G[Z % U].many.push(C[K][Z]);
  }
  for (var X = 0, K = U - 1; K >= 0; K--)
    if (!G[K].many.length) {
      var Q = G[X].many;
      if (Q.length <= 1)
        if (X)
          X = 0;
        else
          return G;
      var W = Q.length, ee = Math.ceil(W / 2);
      G[K].many = Q.slice(ee, W), G[X].many = Q.slice(0, ee), X++;
    }
  return G;
}
var pathDividers = {
  clone: function(H) {
    for (var C = [], G = 1 - Math.pow(1 - H.path.style.opacity, 1 / H.count), U = 0; U < H.count; U++) {
      var K = clonePath(H.path);
      K.setStyle("opacity", G), C.push(K);
    }
    return C;
  },
  // Use the default divider
  split: null
};
function applyMorphAnimation(H, C, G, U, K, W) {
  if (!H.length || !C.length)
    return;
  var Z = getAnimationConfig("update", U, K);
  if (!(Z && Z.duration > 0))
    return;
  var X = U.getModel("universalTransition").get("delay"), Q = Object.assign({
    // Need to setToFinal so the further calculation based on the style can be correct.
    // Like emphasis color.
    setToFinal: !0
  }, Z), ee, te;
  isMultiple(H) && (ee = H, te = C), isMultiple(C) && (ee = C, te = H);
  function re(le, ue, ce, de, ge) {
    var fe = le.many, ve = le.one;
    if (fe.length === 1 && !ge) {
      var pe = ue ? fe[0] : ve, he = ue ? ve : fe[0];
      if (isCombineMorphing(pe))
        re({
          many: [pe],
          one: he
        }, !0, ce, de, !0);
      else {
        var me = X ? defaults({
          delay: X(ce, de)
        }, Q) : Q;
        morphPath(pe, he, me), W(pe, he, pe, he, me);
      }
    } else
      for (var ye = defaults({
        dividePath: pathDividers[G],
        individualDelay: X && function(_e, xe, Te, Pe) {
          return X(_e + ce, de);
        }
      }, Q), Ce = ue ? combineMorph(fe, ve, ye) : separateMorph(ve, fe, ye), Ie = Ce.fromIndividuals, be = Ce.toIndividuals, Se = Ie.length, Ae = 0; Ae < Se; Ae++) {
        var me = X ? defaults({
          delay: X(Ae, Se)
        }, Q) : Q;
        W(Ie[Ae], be[Ae], ue ? fe[Ae] : le.one, ue ? le.one : fe[Ae], me);
      }
  }
  for (var ne = ee ? ee === H : H.length > C.length, ae = ee ? prepareMorphBatches(te, ee) : prepareMorphBatches(ne ? C : H, [ne ? H : C]), ie = 0, se = 0; se < ae.length; se++)
    ie += ae[se].many.length;
  for (var oe = 0, se = 0; se < ae.length; se++)
    re(ae[se], ne, oe, ie), oe += ae[se].many.length;
}
function getPathList(H) {
  if (!H)
    return [];
  if (isArray$1(H)) {
    for (var C = [], G = 0; G < H.length; G++)
      C.push(getPathList(H[G]));
    return C;
  }
  var U = [];
  return H.traverse(function(K) {
    K instanceof Path$1 && !K.disableMorphing && !K.invisible && !K.ignore && U.push(K);
  }), U;
}
var DATA_COUNT_THRESHOLD = 1e4, getUniversalTransitionGlobalStore = makeInner();
function getGroupIdDimension(H) {
  for (var C = H.dimensions, G = 0; G < C.length; G++) {
    var U = H.getDimensionInfo(C[G]);
    if (U && U.otherDims.itemGroupId === 0)
      return C[G];
  }
}
function flattenDataDiffItems(H) {
  var C = [];
  return each$f(H, function(G) {
    var U = G.data;
    if (U.count() > DATA_COUNT_THRESHOLD) {
      process.env.NODE_ENV !== "production" && warn("Universal transition is disabled on large data > 10k.");
      return;
    }
    for (var K = U.getIndices(), W = getGroupIdDimension(U), Z = 0; Z < K.length; Z++)
      C.push({
        dataGroupId: G.dataGroupId,
        data: U,
        dim: G.dim || W,
        divide: G.divide,
        dataIndex: Z
      });
  }), C;
}
function fadeInElement(H, C, G) {
  H.traverse(function(U) {
    U instanceof Path$1 && initProps(U, {
      style: {
        opacity: 0
      }
    }, C, {
      dataIndex: G,
      isFrom: !0
    });
  });
}
function removeEl(H) {
  if (H.parent) {
    var C = H.getComputedTransform();
    H.setLocalTransform(C), H.parent.remove(H);
  }
}
function stopAnimation(H) {
  H.stopAnimation(), H.isGroup && H.traverse(function(C) {
    C.stopAnimation();
  });
}
function animateElementStyles(H, C, G) {
  var U = getAnimationConfig("update", G, C);
  U && H.traverse(function(K) {
    if (K instanceof Displayable$1) {
      var W = getOldStyle(K);
      W && K.animateFrom({
        style: W
      }, U);
    }
  });
}
function isAllIdSame(H, C) {
  var G = H.length;
  if (G !== C.length)
    return !1;
  for (var U = 0; U < G; U++) {
    var K = H[U], W = C[U];
    if (K.data.getId(K.dataIndex) !== W.data.getId(W.dataIndex))
      return !1;
  }
  return !0;
}
function transitionBetween(H, C, G) {
  var U = flattenDataDiffItems(H), K = flattenDataDiffItems(C);
  function W(le, ue, ce, de, ge) {
    (ce || le) && ue.animateFrom({
      style: ce && ce !== le ? (
        // dividingMethod like clone may override the style(opacity)
        // So extend it to raw style.
        extend(extend({}, ce.style), le.style)
      ) : le.style
    }, ge);
  }
  function Z(le) {
    for (var ue = 0; ue < le.length; ue++)
      if (le[ue].dim)
        return le[ue].dim;
  }
  var X = Z(U), Q = Z(K), ee = !1;
  function te(le, ue) {
    return function(ce) {
      var de = ce.data, ge = ce.dataIndex;
      if (ue)
        return de.getId(ge);
      var fe = ce.dataGroupId, ve = le ? X || Q : Q || X, pe = ve && de.getDimensionInfo(ve), he = pe && pe.ordinalMeta;
      if (pe) {
        var me = de.get(pe.name, ge);
        return he && he.categories[me] || me + "";
      }
      var ye = de.getRawDataItem(ge);
      return ye && ye.groupId ? ye.groupId + "" : fe || de.getId(ge);
    };
  }
  var re = isAllIdSame(U, K), ne = {};
  if (!re)
    for (var ae = 0; ae < K.length; ae++) {
      var ie = K[ae], se = ie.data.getItemGraphicEl(ie.dataIndex);
      se && (ne[se.id] = !0);
    }
  function oe(le, ue) {
    var ce = U[ue], de = K[le], ge = de.data.hostModel, fe = ce.data.getItemGraphicEl(ce.dataIndex), ve = de.data.getItemGraphicEl(de.dataIndex);
    if (fe === ve) {
      ve && animateElementStyles(ve, de.dataIndex, ge);
      return;
    }
    // We can't use the elements that already being morphed
    fe && ne[fe.id] || ve && (stopAnimation(ve), fe ? (stopAnimation(fe), removeEl(fe), ee = !0, applyMorphAnimation(getPathList(fe), getPathList(ve), de.divide, ge, le, W)) : fadeInElement(ve, ge, le));
  }
  new DataDiffer$1(U, K, te(!0, re), te(!1, re), null, "multiple").update(oe).updateManyToOne(function(le, ue) {
    var ce = K[le], de = ce.data, ge = de.hostModel, fe = de.getItemGraphicEl(ce.dataIndex), ve = filter(map$1(ue, function(pe) {
      return U[pe].data.getItemGraphicEl(U[pe].dataIndex);
    }), function(pe) {
      return pe && pe !== fe && !ne[pe.id];
    });
    fe && (stopAnimation(fe), ve.length ? (each$f(ve, function(pe) {
      stopAnimation(pe), removeEl(pe);
    }), ee = !0, applyMorphAnimation(getPathList(ve), getPathList(fe), ce.divide, ge, le, W)) : fadeInElement(fe, ge, ce.dataIndex));
  }).updateOneToMany(function(le, ue) {
    var ce = U[ue], de = ce.data.getItemGraphicEl(ce.dataIndex);
    if (!(de && ne[de.id])) {
      var ge = filter(map$1(le, function(ve) {
        return K[ve].data.getItemGraphicEl(K[ve].dataIndex);
      }), function(ve) {
        return ve && ve !== de;
      }), fe = K[le[0]].data.hostModel;
      ge.length && (each$f(ge, function(ve) {
        return stopAnimation(ve);
      }), de ? (stopAnimation(de), removeEl(de), ee = !0, applyMorphAnimation(
        getPathList(de),
        getPathList(ge),
        ce.divide,
        // Use divide on old.
        fe,
        le[0],
        W
      )) : each$f(ge, function(ve) {
        return fadeInElement(ve, fe, le[0]);
      }));
    }
  }).updateManyToMany(function(le, ue) {
    new DataDiffer$1(ue, le, function(ce) {
      return U[ce].data.getId(U[ce].dataIndex);
    }, function(ce) {
      return K[ce].data.getId(K[ce].dataIndex);
    }).update(function(ce, de) {
      oe(le[ce], ue[de]);
    }).execute();
  }).execute(), ee && each$f(C, function(le) {
    var ue = le.data, ce = ue.hostModel, de = ce && G.getViewOfSeriesModel(ce), ge = getAnimationConfig("update", ce, 0);
    de && ce.isAnimationEnabled() && ge && ge.duration > 0 && de.group.traverse(function(fe) {
      fe instanceof Path$1 && !fe.animators.length && fe.animateFrom({
        style: {
          opacity: 0
        }
      }, ge);
    });
  });
}
function getSeriesTransitionKey(H) {
  var C = H.getModel("universalTransition").get("seriesKey");
  return C || H.id;
}
function convertArraySeriesKeyToString(H) {
  return isArray$1(H) ? H.sort().join(",") : H;
}
function getDivideShapeFromData(H) {
  if (H.hostModel)
    return H.hostModel.getModel("universalTransition").get("divideShape");
}
function findTransitionSeriesBatches(H, C) {
  var G = createHashMap(), U = createHashMap(), K = createHashMap();
  each$f(H.oldSeries, function(Z, X) {
    var Q = H.oldDataGroupIds[X], ee = H.oldData[X], te = getSeriesTransitionKey(Z), re = convertArraySeriesKeyToString(te);
    U.set(re, {
      dataGroupId: Q,
      data: ee
    }), isArray$1(te) && each$f(te, function(ne) {
      K.set(ne, {
        key: re,
        dataGroupId: Q,
        data: ee
      });
    });
  });
  function W(Z) {
    G.get(Z) && warn("Duplicated seriesKey in universalTransition " + Z);
  }
  return each$f(C.updatedSeries, function(Z) {
    if (Z.isUniversalTransitionEnabled() && Z.isAnimationEnabled()) {
      var X = Z.get("dataGroupId"), Q = Z.getData(), ee = getSeriesTransitionKey(Z), te = convertArraySeriesKeyToString(ee), re = U.get(te);
      if (re)
        process.env.NODE_ENV !== "production" && W(te), G.set(te, {
          oldSeries: [{
            dataGroupId: re.dataGroupId,
            divide: getDivideShapeFromData(re.data),
            data: re.data
          }],
          newSeries: [{
            dataGroupId: X,
            divide: getDivideShapeFromData(Q),
            data: Q
          }]
        });
      else if (isArray$1(ee)) {
        process.env.NODE_ENV !== "production" && W(te);
        var ne = [];
        each$f(ee, function(se) {
          var oe = U.get(se);
          oe.data && ne.push({
            dataGroupId: oe.dataGroupId,
            divide: getDivideShapeFromData(oe.data),
            data: oe.data
          });
        }), ne.length && G.set(te, {
          oldSeries: ne,
          newSeries: [{
            dataGroupId: X,
            data: Q,
            divide: getDivideShapeFromData(Q)
          }]
        });
      } else {
        var ae = K.get(ee);
        if (ae) {
          var ie = G.get(ae.key);
          ie || (ie = {
            oldSeries: [{
              dataGroupId: ae.dataGroupId,
              data: ae.data,
              divide: getDivideShapeFromData(ae.data)
            }],
            newSeries: []
          }, G.set(ae.key, ie)), ie.newSeries.push({
            dataGroupId: X,
            data: Q,
            divide: getDivideShapeFromData(Q)
          });
        }
      }
    }
  }), G;
}
function querySeries(H, C) {
  for (var G = 0; G < H.length; G++) {
    var U = C.seriesIndex != null && C.seriesIndex === H[G].seriesIndex || C.seriesId != null && C.seriesId === H[G].id;
    if (U)
      return G;
  }
}
function transitionSeriesFromOpt(H, C, G, U) {
  var K = [], W = [];
  each$f(normalizeToArray(H.from), function(Z) {
    var X = querySeries(C.oldSeries, Z);
    X >= 0 && K.push({
      dataGroupId: C.oldDataGroupIds[X],
      data: C.oldData[X],
      // TODO can specify divideShape in transition.
      divide: getDivideShapeFromData(C.oldData[X]),
      dim: Z.dimension
    });
  }), each$f(normalizeToArray(H.to), function(Z) {
    var X = querySeries(G.updatedSeries, Z);
    if (X >= 0) {
      var Q = G.updatedSeries[X].getData();
      W.push({
        dataGroupId: C.oldDataGroupIds[X],
        data: Q,
        divide: getDivideShapeFromData(Q),
        dim: Z.dimension
      });
    }
  }), K.length > 0 && W.length > 0 && transitionBetween(K, W, U);
}
function installUniversalTransition(H) {
  H.registerUpdateLifecycle("series:beforeupdate", function(C, G, U) {
    each$f(normalizeToArray(U.seriesTransition), function(K) {
      each$f(normalizeToArray(K.to), function(W) {
        for (var Z = U.updatedSeries, X = 0; X < Z.length; X++)
          (W.seriesIndex != null && W.seriesIndex === Z[X].seriesIndex || W.seriesId != null && W.seriesId === Z[X].id) && (Z[X][SERIES_UNIVERSAL_TRANSITION_PROP] = !0);
      });
    });
  }), H.registerUpdateLifecycle("series:transition", function(C, G, U) {
    var K = getUniversalTransitionGlobalStore(G);
    if (K.oldSeries && U.updatedSeries && U.optionChanged) {
      var W = U.seriesTransition;
      if (W)
        each$f(normalizeToArray(W), function(ae) {
          transitionSeriesFromOpt(ae, K, U, G);
        });
      else {
        var Z = findTransitionSeriesBatches(K, U);
        each$f(Z.keys(), function(ae) {
          var ie = Z.get(ae);
          transitionBetween(ie.oldSeries, ie.newSeries, G);
        });
      }
      each$f(U.updatedSeries, function(ae) {
        ae[SERIES_UNIVERSAL_TRANSITION_PROP] && (ae[SERIES_UNIVERSAL_TRANSITION_PROP] = !1);
      });
    }
    for (var X = C.getSeries(), Q = K.oldSeries = [], ee = K.oldDataGroupIds = [], te = K.oldData = [], re = 0; re < X.length; re++) {
      var ne = X[re].getData();
      ne.count() < DATA_COUNT_THRESHOLD && (Q.push(X[re]), ee.push(X[re].get("dataGroupId")), te.push(ne));
    }
  });
}
use([install$R]);
use([install$S]);
use([install$Q, install$P, install$O, install$M, install$K, install$I, install$H, install$G, install$F, install$E, install$D, install$B, install$A, install$z, install$y, install$x, install$w, install$v, install$u, install$t, install$s, install$r]);
use(install$p);
use(install$o);
use(install$J);
use(install$n);
use(install$C);
use(install$m);
use(install$l);
use(install$j);
use(install$i);
use(install$q);
use(install$h);
use(install$g);
use(install$f);
use(install$e);
use(install$d);
use(install$c);
use(install$9);
use(install$6);
use(install$8);
use(install$7);
use(install$3);
use(install$5);
use(install$4);
use(install$2);
use(install$1);
use(install);
use(installUniversalTransition);
use(installLabelLayout);
const toolUtil = {
  // jq extend
  extend(...H) {
    let C, G, U, K, W, Z, X = H[0] || {}, Q = 1;
    const ee = H.length;
    let te = !0;
    for (typeof X == "boolean" && (te = X, X = H[Q] || {}, Q++), typeof X != "object" && !this.isFunction(X) && (X = {}), Q === ee && (X = this, Q--); Q < ee; Q++)
      if ((C = H[Q]) != null)
        for (G in C)
          K = C[G], !(G === "__proto__" || X === K) && (te && K && (this.isPlainObject(K) || (W = Array.isArray(K))) ? (U = X[G], W && !Array.isArray(U) ? Z = [] : !W && !this.isPlainObject(U) ? Z = {} : Z = U, W = !1, X[G] = this.extend(te, Z, K)) : K !== void 0 && (X[G] = K));
    return X;
  },
  commafy(H, C) {
    if (H === void 0 || H === "--" || H === "-")
      return "--";
    try {
      if (H != null) {
        C || C === 0 ? H = `${parseFloat(H).toFixed(C)}` : H += "";
        const G = /(-?\d+)(\d{3})/;
        for (; G.test(H); )
          H = H.replace(G, "$1,$2");
      }
    } catch (G) {
      throw G;
    } finally {
      return H;
    }
  },
  merge(H, C, G) {
    const U = this;
    if (!U.isObject(C) || !U.isObject(H))
      return G ? U.clone(C) : H;
    for (const K in C)
      if (C.hasOwnProperty(K)) {
        const W = H[K], Z = C[K];
        U.isObject(Z) && U.isObject(W) && !U.isArray(Z) && !U.isArray(W) && !U.isDom(Z) && !U.isDom(W) && !U.isBuiltInObject(Z) && !U.isBuiltInObject(W) && !U.isPrimitive(Z) && !U.isPrimitive(W) ? U.merge(W, Z, G) : (G || !(K in H)) && (H[K] = U.clone(C[K]));
      }
    return H;
  },
  formatCharts: function(C, G) {
    const U = window.outerWidth;
    let K = "", W = 0, Z = 0;
    U < 1440 ? G += 0 : U >= 1440 && U < 1540 ? G += 2 : U >= 1540 && U < 1640 ? G += 4 : U >= 1640 && U < 1740 ? G += 6 : U >= 1740 && U < 1840 ? G += 8 : G += 10;
    for (let X = 0, Q = C.length; X < Q; X++)
      /.*[\u4e00-\u9fa5]+.*$/.test(C[X]) ? (Z += 2, X < Q - 1 && Z % G === 0 && X !== 0 ? (K += C[X], K += `
`, W++) : X < Q - 1 && Math.floor(Z / G) > W && X !== 0 ? (K = `${K}
${C[X]}`, W++) : K += C[X]) : (Z += 1, K += C[X], X < Q - 1 && Z % G === 0 && X !== 0 && (K += `
`, W++));
    return K;
  },
  /*
  echarts数据单位“万”“亿”
  type    判断转换数据格式   flowUnity  流量（单位统一），flowDisunity  流量（单位不统一） countBillionUnity  亿万格式（单位统一），countBillionDisunity  亿万格式（单位不统一）
  unit    最小单位：如“条”、“个”
  val     需要加单位的数据
  max     判断出最大的值，流量时不用传
  digit   保留小数的位数 (默认为2位)     //author  heyong
  retainedDecimal   数据过万过亿(正好整数)是否保留小数true/false     //author  renjinhong
  */
  dataUnit(H, C, G, U, K, W) {
    if (G === void 0 || G === "--" || G === "-")
      return "--";
    let Z = null;
    switch (H) {
      case "FLOW_UNITY":
        return Z = Math.abs(G), U < 1024 ? (Z = this.commafy(Z, 2), Z += `K${C}`) : U < 1024 * 1024 && U >= 1024 ? (Z = this.commafy(Z / 1024, 2), Z += `M${C}`) : U < 1024 * 1024 * 1024 && U >= 1024 * 1024 ? (Z = this.commafy(Z / (1024 * 1024), 2), Z += `G${C}`) : U < 1024 * 1024 * 1024 * 1024 && U >= 1024 * 1024 * 1024 ? (Z = this.commafy(Z / (1024 * 1024 * 1024), 2), Z += `T${C}`) : (Z = this.commafy(Z / (1024 * 1024 * 1024 * 1024), 2), Z += `P${C}`), G < 0 ? `-${Z}` : Z;
      case "FLOW_DISUNITY":
        return Z = Math.abs(G), Z < 1024 ? (Z % 1 > 0 ? Z = this.commafy(Z, K || 2) : (W && (Z = this.commafy(Z, 2)), Z = this.commafy(Z)), Z += `K${C}`) : Z < 1024 * 1024 && Z >= 1024 ? (Z % 1024 > 0 ? Z = this.commafy(Z / 1024, K || 2) : (W && (Z = this.commafy(Z / 1024, 2)), Z = this.commafy(Z / 1024)), Z += `M${C}`) : Z < 1024 * 1024 * 1024 && Z >= 1024 * 1024 ? (Z % (1024 * 1024) > 0 ? Z = this.commafy(Z / (1024 * 1024), K || 2) : (W && (Z = this.commafy(Z / (1024 * 1024), 2)), Z = this.commafy(Z / (1024 * 1024))), Z += `G${C}`) : Z < 1024 * 1024 * 1024 * 1024 && Z >= 1024 * 1024 * 1024 ? (Z % (1024 * 1024 * 1024) > 0 ? Z = this.commafy(Z / (1024 * 1024 * 1024), K || 2) : (W && (Z = this.commafy(Z / (1024 * 1024 * 1024), 2)), Z = this.commafy(Z / (1024 * 1024 * 1024))), Z += `T${C}`) : (Z % (1024 * 1024 * 1024 * 1024) > 0 ? Z = this.commafy(Z / (1024 * 1024 * 1024 * 1024), K || 2) : (W && (Z = this.commafy(Z / (1024 * 1024 * 1024 * 1024), 2)), Z = this.commafy(Z / (1024 * 1024 * 1024 * 1024))), Z += `P${C}`), G < 0 ? `-${Z}` : Z;
      case "COUNT_BILLION_UNITY":
        return Z = Math.abs(G), U < 1e4 ? (Z = this.commafy(Z, 2), Z += C) : U < 1e8 && U >= 1e4 ? (Z % 1e4 > 0 ? K === 0 || K ? Z = this.commafy(Z / 1e4, K) : Z = this.commafy(Z / 1e4, 2) : Z = this.commafy(Z / 1e4), Z += `万${C}`) : (Z % 1e8 > 0 ? K === 0 || K ? Z = this.commafy(Z / 1e8, K) : Z = this.commafy(Z / 1e8, 2) : Z = this.commafy(Z / 1e8), Z += `亿${C}`), G < 0 ? `-${Z}` : Z;
      case "COUNT_BILLION_DISUNITY":
        return Z = Math.abs(G), Z < 1e4 ? (Z = this.commafy(Z, K), Z += C) : Z < 1e8 && Z >= 1e4 ? (Z % 1e4 > 0 ? K === 0 || K ? Z = this.commafy(Z / 1e4, K) : Z = this.commafy(Z / 1e4, 2) : (W && (Z = this.commafy(Z / 1e4, 2)), Z = this.commafy(Z / 1e4)), Z += `万${C}`) : (Z % 1e8 > 0 ? K === 0 || K ? Z = this.commafy(Z / 1e8, K) : Z = this.commafy(Z / 1e8, 2) : W ? Z = this.commafy(Z / 1e8, 2) : Z = this.commafy(Z / 1e8), Z += `亿${C}`), G < 0 ? `-${Z}` : Z;
      default:
        return G;
    }
  },
  /*
   对yyyymmddhhmmss格式日期的格式化处理
   v ：值 （String or Array）
   tp ：类型 （year|month|week|day|hour|minute|second）
   op ：格式化字符设置（根据自己的需求设置替换方法内部的默认设置）
   @author hy
   */
  iotDateFormat(H, C, G) {
    if (!H)
      return !1;
    H = H.replace(/-/g, "");
    let U = "month";
    C && (U = C);
    let K = {
      ysp: "年",
      msp: "月",
      dsp: "日",
      dtsp: " ",
      centersp: " - ",
      housp: "时",
      minsp: "分",
      secsp: "秒"
    };
    switch (G && (K = this.extend({}, K, G)), U) {
      case "year":
        return typeof H == "string" ? H + K.ysp : H[0] + K.ysp + K.centersp + H[1] + K.ysp;
      case "month":
        return typeof H == "string" ? H.substr(0, 4) + K.ysp + H.substr(4, 2) + K.msp : H[0].substr(0, 4) + K.ysp + H[0].substr(4, 2) + K.msp + K.centersp + H[1].substr(0, 4) + K.ysp + H[1].substr(4, 2) + K.msp;
      case "week":
        return typeof H == "string" ? H.substr(0, 4) + K.ysp + H.substr(4, 2) + K.msp + H.substr(6, 2) + K.dsp : H[0].substr(0, 4) + K.ysp + H[0].substr(4, 2) + K.msp + H[0].substr(6, 2) + K.dsp + K.centersp + H[1].substr(0, 4) + K.ysp + H[1].substr(4, 2) + K.msp + H[1].substr(6, 2) + K.dsp;
      case "day":
        return typeof H == "string" ? H.substr(0, 4) + K.ysp + H.substr(4, 2) + K.msp + H.substr(6, 2) + K.dsp : H[0].substr(0, 4) + K.ysp + H[0].substr(4, 2) + K.msp + H[0].substr(6, 2) + K.dsp + K.centersp + H[1].substr(0, 4) + K.ysp + H[1].substr(4, 2) + K.msp + H[1].substr(6, 2) + K.dsp;
      case "hour":
        return typeof H == "string" ? H.substr(0, 4) + K.ysp + H.substr(4, 2) + K.msp + H.substr(6, 2) + K.dsp + K.dtsp + H.substr(8, 2) + K.housp : H[0].substr(0, 4) + K.ysp + H[0].substr(4, 2) + K.msp + H[0].substr(6, 2) + K.dsp + K.dtsp + H[0].substr(8, 2) + K.housp + K.centersp + H[1].substr(0, 4) + K.ysp + H[1].substr(4, 2) + K.msp + H[1].substr(6, 2) + K.dsp + K.dtsp + H[1].substr(8, 2) + K.housp;
      case "minute":
        return typeof H == "string" ? H.substr(0, 4) + K.ysp + H.substr(4, 2) + K.msp + H.substr(6, 2) + K.dsp + K.dtsp + H.substr(8, 2) + K.housp + H.substr(10, 2) + K.minsp : H[0].substr(0, 4) + K.ysp + H[0].substr(4, 2) + K.msp + H[0].substr(6, 2) + K.dsp + K.dtsp + H[0].substr(8, 2) + K.housp + H[0].substr(10, 2) + K.minsp + K.centersp + H[1].substr(0, 4) + K.ysp + H[1].substr(4, 2) + K.msp + H[1].substr(6, 2) + K.dsp + K.dtsp + H[1].substr(8, 2) + K.housp + H[1].substr(10, 2) + K.minsp;
      case "second":
        return typeof H == "string" ? H.substr(0, 4) + K.ysp + H.substr(4, 2) + K.msp + H.substr(6, 2) + K.dsp + K.dtsp + H.substr(8, 2) + K.housp + H.substr(10, 2) + K.minsp + H.substr(12, 2) + K.secsp : H[0].substr(0, 4) + K.ysp + H[0].substr(4, 2) + K.msp + H[0].substr(6, 2) + K.dsp + K.dtsp + H[0].substr(8, 2) + K.housp + H[0].substr(10, 2) + K.minsp + H[0].substr(12, 2) + K.secsp + K.centersp + H[1].substr(0, 4) + K.ysp + H[1].substr(4, 2) + K.msp + H[1].substr(6, 2) + K.dsp + K.dtsp + H[1].substr(8, 2) + K.housp + H[1].substr(10, 2) + K.minsp + H[1].substr(12, 2) + K.secsp;
      default:
        return H;
    }
  },
  export(H, C) {
    const G = document.createElement("form");
    G.id = "exportForm", G.name = "exportForm", G.style.display = "none", document.body.appendChild(G);
    const U = document.createElement("input");
    U.name = "obj", U.value = JSON.stringify(C), G.appendChild(U), G.method = "POST", G.action = H, G.submit(), document.body.removeChild(G);
  },
  isFunction(H) {
    return typeof H == "function" && typeof H.nodeType != "number";
  },
  isArray(H) {
    return Object.prototype.toString.call(H) === "[object Array]";
  },
  isDom(H) {
    return typeof H == "object" && typeof H.nodeType == "number" && typeof H.ownerDocument == "object";
  },
  isBuiltInObject(H) {
    return !!{
      "[object Function]": 1,
      "[object RegExp]": 1,
      "[object Date]": 1,
      "[object Error]": 1,
      "[object CanvasGradient]": 1,
      "[object CanvasPattern]": 1,
      // For node-canvas
      "[object Image]": 1,
      "[object Canvas]": 1
    }[Object.prototype.toString.call(H)];
  },
  isPrimitive(H) {
    return H["__ec_primitive__"];
  },
  isObject(H) {
    const C = typeof H;
    return C === "function" || !!H && C === "object";
  },
  isPlainObject(H) {
    const C = {}, G = C.toString, U = C.hasOwnProperty, K = U.toString, W = K.call(Object);
    if (!H || G.call(H) !== "[object Object]")
      return !1;
    const Z = Object.getPrototypeOf(H);
    if (!Z)
      return !0;
    const X = U.call(Z, "constructor") && Z.constructor;
    return typeof X == "function" && K.call(X) === W;
  },
  clone(H) {
    const C = this;
    if (H == null || typeof H != "object")
      return H;
    const G = {
      "[object Int8Array]": 1,
      "[object Uint8Array]": 1,
      "[object Uint8ClampedArray]": 1,
      "[object Int16Array]": 1,
      "[object Uint16Array]": 1,
      "[object Int32Array]": 1,
      "[object Uint32Array]": 1,
      "[object Float32Array]": 1,
      "[object Float64Array]": 1
    }, U = {
      "[object Function]": 1,
      "[object RegExp]": 1,
      "[object Date]": 1,
      "[object Error]": 1,
      "[object CanvasGradient]": 1,
      "[object CanvasPattern]": 1,
      // For node-canvas
      "[object Image]": 1,
      "[object Canvas]": 1
    };
    let K = H;
    const W = Object.prototype.toString.call(H);
    if (W === "[object Array]") {
      K = [];
      for (let Z = 0, X = H.length; Z < X; Z++)
        K[Z] = C.clone(H[Z]);
    } else if (G[W])
      K = H.constructor.from(H);
    else if (!U[W] && !C.isPrimitive(H) && !C.isDom(H)) {
      K = {};
      for (const Z in H)
        H.hasOwnProperty(Z) && (K[Z] = C.clone(H[Z]));
    }
    return K;
  }
}, theme$1 = {
  // blue
  "dark-blue1": "",
  // 滚动条颜色
  "dark-blue2": "#e6e6e6",
  // 滚动条颜色
  // "dark-blue3":"#6d7899",//滚动条颜色
  "dark-blue4": "",
  // 导航字颜色
  "dark-blue5": "#fff",
  // 区域背景色
  "dark-blue6": "#e8e8e8",
  // 区域分割线
  "dark-blue7": "",
  // 导航深色区域
  "dark-blue8": "",
  // 导航子区域
  "dark-blue9": "#f5f5f5",
  // layout背景颜色
  "dark-blue10": "",
  // 弹框背景色
  "dark-blue11": "#3e9dff",
  // 按钮选中高亮颜色
  "dark-blue12": "",
  // 日期插件背景色
  "dark-blue13": "#f0f0f0",
  // 表格插件tr深色背景
  "dark-blue14": "#e5e5e5",
  // 表格hover
  // gray
  "dark-gray1": "#d9d9d9",
  // 按钮、input类边框颜色
  "dark-gray2": "#f5f5f5",
  // 日期插件上月灰色
  "dark-gray3": "rgba(0,0,0,0.25)",
  // 日期插件置灰
  "dark-gray4": "#eae8e8",
  // baseGrid边框灰色
  // body
  "dark-white": "",
  // media
  "media-tag": "#f2497c",
  "chart-label": "#666666",
  // 文字
  "chart-axisLine": "#bbbbbb",
  // 轴线
  "chart-splitLine": "#dddddd"
  // 分割线
}, theme = theme$1, defaultConfig = {
  // theme:dark
  queryInput: {
    queryName: "queryName",
    cnName: "输入框",
    validator: "",
    placeholder: "普通输入框，根据输入内容查询",
    type: "queryInput"
  },
  querySelect: {
    queryName: "selectName",
    cnName: "下拉框",
    validator: "",
    placeholder: "展开后可对选项进行搜索。",
    type: "querySelect",
    dataType: "ajax",
    mode: "-",
    clear: !1,
    dataOption: {
      url: "/json/test.json",
      objName: "chart2",
      method: "get",
      keyName: "key",
      valueName: "value"
    },
    staticData: [
      {
        key: 1,
        value: "test1"
      }
    ]
  },
  queryDate: {
    queryName: "dateName",
    cnName: "日期选择",
    validator: "",
    placeholder: "选择日期，单选天",
    type: "queryDate-date"
  },
  // 时间段默认配置
  queryDateRange: {
    queryName: "dateRangeName",
    queryParam: ["startTime", "endTime"],
    cnName: "日期段选择",
    format: ["YYYY/MM/DD", "gggg第wo", "YYYY/MM"],
    defaultTime: null,
    validator: "",
    placeholder: ["开始日期", "结束日期"],
    type: "queryDateRange-date"
  },
  pageSetting: {
    col: 48,
    pageZoom: "fullPage",
    margin: "[10, 10, 10, 10]",
    avatar: "https://echarts.baidu.com/examples/data/thumb/scatter-life-expectancy-timeline.png",
    pageWidth: "auto",
    pageHeight: "auto"
  },
  industrySelect: {
    queryName: "queryName",
    type: "industrySelect"
  },
  // theme:light
  line: {
    option: {
      theme: "light",
      type: "line",
      data: [],
      // 图表数据
      title: "",
      // 图表名称
      name: "折线图",
      // 线名称
      keyName: "key",
      // 数据展现坐标KEY名称
      valueName: "value",
      // 数据展现值
      gridLeft: "10%",
      // grid 组件离容器左侧的距离
      gridRight: "10%",
      // grid 组件离容器右侧的距离
      gridTop: "20%",
      // grid 组件离容器上侧的距离
      gridBottom: "20%",
      // grid 组件离容器下侧的距离
      yAxisName: "Y轴坐标",
      // y轴名称
      xRotate: 0,
      // x轴标签旋转角度
      xAxisLabelColor: theme["chart-axisLine"],
      // x轴标签颜色
      yRotate: 0,
      // y轴标签旋转角度
      yAxisLabelColor: theme["chart-axisLine"],
      // y轴标签颜色
      nameTextColor: theme["chart-label"],
      // y轴名称颜色
      color: "",
      // 折线颜色
      symbolSize: 6,
      optionLine: {},
      isAreaStyle: !0,
      // 是否为堆积面积图
      colorStops: [
        {
          offset: 0,
          color: "rgba(39,169,244,1)"
        },
        {
          offset: 0.5,
          color: "rgba(39,169,244,0.6)"
        },
        {
          offset: 1,
          color: "rgba(39,169,244,0.4)"
        }
      ],
      resetOrder: !0,
      // 设置是否对数据重排序
      showDataZoom: !1,
      lastDotted: !1,
      toolTipFormatter: null,
      legendFormatter: null,
      xAxisFormatter: null,
      yAxisFormatter: null
    },
    dataOption: {
      url: "/json/test.json",
      objName: "chart1",
      method: "get",
      data: [],
      params: {
        intfcType: "baseProvince",
        intfcTypeName: "测试intfcTypeName"
      }
    },
    exportOption: {
      property: [
        {
          exportName: "{dateName} {tab}",
          exportRiskType: "",
          exportAddress: "riskPlatform/exportJson",
          exportParams: ""
        }
      ],
      exportPermission: !0
    },
    customizeOption: [
      {
        index: 1,
        customizeType: "upload",
        customizeIcon: "download",
        customizeDisable: "(()=>false)()",
        buttonConfig: {
          url: "",
          params: {
            searchParam: !1,
            selectParam: !1,
            configParam: [
              {
                key: "key",
                value: "value"
              }
            ]
          },
          fileType: "",
          fileSize: "100"
        }
      }
    ],
    GridX: 0,
    GridY: 0,
    w: 24,
    h: 24
  },
  lines: {
    option: {
      theme: "light",
      type: "lines",
      data: [],
      // 图表数据
      title: "",
      // 图表名称
      name: "多折线图",
      // 线名称
      keyName: "key",
      // 数据展现坐标KEY名称
      valueName: "value",
      // 数据展现值
      gridLeft: "10%",
      // grid 组件离容器左侧的距离
      gridRight: "10%",
      // grid 组件离容器右侧的距离
      gridTop: "20%",
      // grid 组件离容器上侧的距离
      gridBottom: "20%",
      // grid 组件离容器下侧的距离
      legendShow: !0,
      // 是否显示legend
      orient: "horizontal",
      // 图例布局朝向
      legendLeft: "center",
      // 图例组件离容器左侧的距离
      legendTop: "30px",
      // 图例组件离容器上侧的距离
      xRotate: 0,
      // x轴标签旋转角度
      xAxisLabelColor: theme["chart-label"],
      // x轴标签颜色
      y1Rotate: 0,
      // y1轴标签旋转角度
      y1AxisName: "Y1轴",
      // y1轴名称
      y1AxisLabelColor: theme["chart-label"],
      // y1轴标签颜色
      y2Rotate: 0,
      // y2轴标签旋转角度
      y2AxisName: "Y2轴",
      // y2轴名称
      y2AxisLabelColor: theme["chart-label"],
      // y2轴标签颜色
      names: ["用户总数", "新增用户数"],
      keys: ["key1Value", "key2Value"],
      y1Keys: [],
      y2Keys: [],
      isAreaStyle: !1,
      colorList: [
        "#478ff7",
        "#ff7f4c",
        "#7fa7b8",
        "#f1485b",
        "#26cdcb",
        "#7565c7",
        "#27a9f4",
        "#778efe",
        "#4ccb70",
        "#ffca3a"
      ],
      optionLines: {},
      enableDoubleYAxis: !1,
      // 是否启用双y轴
      resetOrder: !0,
      // 设置是否对数据重排序
      symbolSize: 6,
      showDataZoom: !1,
      lastDotted: !1,
      toolTipFormatter: null,
      legendFormatter: null,
      xAxisFormatter: null,
      yAxisFormatter: null
    },
    dataOption: {
      url: "/json/test.json",
      objName: "linesChart",
      method: "get",
      data: [],
      params: {
        intfcType: "baseProvince",
        intfcTypeName: "测试intfcTypeName"
      }
    },
    exportOption: {
      property: [
        {
          exportName: "{dateName} {tab}",
          exportRiskType: "",
          exportAddress: "riskPlatform/exportJson",
          exportParams: ""
        }
      ],
      exportPermission: !0
    },
    customizeOption: [
      {
        index: 1,
        customizeType: "upload",
        customizeIcon: "download",
        customizeDisable: "(()=>false)()",
        buttonConfig: {
          url: "",
          params: {
            searchParam: !1,
            selectParam: !1,
            configParam: [
              {
                key: "key",
                value: "value"
              }
            ]
          },
          fileType: "",
          fileSize: "100"
        }
      }
    ],
    GridX: 0,
    GridY: 0,
    w: 24,
    h: 24
  },
  bar: {
    option: {
      theme: "light",
      type: "bar",
      keyName: "key",
      valueName: ["value", "value1"],
      barType: "horizontal",
      title: "物联卡总体发展趋势",
      name: ["用户数", "总用户数"],
      barColor: ["#60AAFF", "#7687A1"],
      colorList: ["#60AAFF"],
      gridLeft: "10%",
      gridRight: "10%",
      gridTop: "20%",
      gridBottom: "20%",
      legendShow: !0,
      xAxisLabelColor: theme["chart-label"],
      yAxisLabelColor: theme["chart-label"],
      orient: "horizontal",
      legendLeft: "center",
      legendTop: "30px",
      optionBar: {}
    },
    dataOption: {
      url: "/json/test.json",
      objName: "barChart",
      method: "get",
      data: [],
      params: {
        intfcType: "baseProvince",
        intfcTypeName: "测试intfcTypeName"
      }
    },
    exportOption: {
      property: [
        {
          exportName: "{dateName} {tab}",
          exportRiskType: "",
          exportAddress: "riskPlatform/exportJson",
          exportParams: ""
        }
      ],
      exportPermission: !0
    },
    customizeOption: [
      {
        index: 1,
        customizeType: "upload",
        customizeIcon: "download",
        customizeDisable: "(()=>false)()",
        buttonConfig: {
          url: "",
          params: {
            searchParam: !1,
            selectParam: !1,
            configParam: [
              {
                key: "key",
                value: "value"
              }
            ]
          },
          fileType: "",
          fileSize: "100"
        }
      }
    ],
    GridX: 0,
    GridY: 0,
    w: 24,
    h: 24
  },
  pie: {
    option: {
      theme: "light",
      type: "pie",
      title: "物联卡总体发展趋势",
      keyName: "key",
      valueName: "value",
      orient: "vertical",
      legendAlign: "left",
      legendLeft: "right",
      legendTop: "center",
      showTooltip: !1,
      // 2022/01/14 gqd
      // colorList: ["#478ff7", "#d1476b", "#7565c7", "#6cc6c7", "#f87466", "#ffca3a", "#4ccb70", "#34bbff", "#778efe", "#7fa7b8"],
      colorList: [
        "#f25118",
        "#f4db4e",
        "#32bbe0",
        "#a5ec7f",
        "#4d7fff",
        "#f95d60",
        "#f4ac4e",
        "#a179f1",
        "#f1598d",
        "#0080d9",
        "#d05757",
        "#83d540",
        "#f46d9b",
        "#346ef9",
        "#ffdf33",
        "#84adff",
        "#ff8484",
        "#3cb371"
      ],
      optionPie: {},
      legendShow: !0,
      pieCenter: ["48%", "50%"],
      pieRadius: ["30%", "50%"],
      roseType: "false"
    },
    dataOption: {
      url: "/json/test.json",
      objName: "pieChart",
      method: "get",
      data: [],
      params: {
        intfcType: "baseProvince",
        intfcTypeName: "测试intfcTypeName"
      }
    },
    exportOption: {
      property: [
        {
          exportName: "{dateName} {tab}",
          exportRiskType: "",
          exportAddress: "riskPlatform/exportJson",
          exportParams: ""
        }
      ],
      exportPermission: !0
    },
    customizeOption: [
      {
        index: 1,
        customizeType: "upload",
        customizeIcon: "download",
        customizeDisable: "(()=>false)()",
        buttonConfig: {
          url: "",
          params: {
            searchParam: !1,
            selectParam: !1,
            configParam: [
              {
                key: "key",
                value: "value"
              }
            ]
          },
          fileType: "",
          fileSize: "100"
        }
      }
    ],
    GridX: 0,
    GridY: 0,
    w: 24,
    h: 24
  },
  barLine: {
    option: {
      theme: "light",
      type: "barLine",
      keyName: "key",
      barValueName: ["value", "value2"],
      lineValueName: ["value1"],
      barName: ["总用户数", "停机用户数"],
      lineName: ["活跃用户数"],
      barColor: ["#60AAFF", "#7687A1"],
      lineColor: ["#fac22b"],
      // colorList: ["#f6ca3f", "#32bbe0", "#a974ff", "#fffd5c", "#04dcb1", "#ff8023", "#92d362", "#92aeff", "#ff8a92", "#ff502e"],
      title: "",
      legendAlign: "left",
      optionBarLine: {},
      gridLeft: "10%",
      gridRight: "10%",
      gridTop: "20%",
      gridBottom: "20%",
      legendShow: !0,
      overlap: !1,
      hideMarkPoint: !1,
      xAxisLabelColor: theme["chart-label"],
      xRotate: 0,
      orient: "horizontal",
      legendLeft: "center",
      legendTop: "30px",
      y1AxisName: "",
      y2AxisName: "",
      y1AxisLabelColor: theme["chart-label"],
      y2AxisLabelColor: theme["chart-label"],
      y1Rotate: 0,
      y2Rotate: 0,
      showY2Axis: !0,
      showYAxisName: !0,
      splitYAxis: !1
    },
    dataOption: {
      url: "/json/test.json",
      objName: "barLineChart",
      method: "get",
      data: [],
      params: {
        intfcType: "baseProvince",
        intfcTypeName: "测试intfcTypeName"
      }
    },
    exportOption: {
      property: [
        {
          exportName: "{dateName} {tab}",
          exportRiskType: "",
          exportAddress: "riskPlatform/exportJson",
          exportParams: ""
        }
      ],
      exportPermission: !0
    },
    customizeOption: [
      {
        index: 1,
        customizeType: "upload",
        customizeIcon: "download",
        customizeDisable: "(()=>false)()",
        buttonConfig: {
          url: "",
          params: {
            searchParam: !1,
            selectParam: !1,
            configParam: [
              {
                key: "key",
                value: "value"
              }
            ]
          },
          fileType: "",
          fileSize: "100"
        }
      }
    ],
    GridX: 0,
    GridY: 0,
    w: 24,
    h: 24
  },
  radar: {
    option: {
      theme: "light",
      type: "radar",
      title: "模型雷达评分图",
      dimensionKey: ["value1", "value2", "value3", "value4", "value5"],
      dimensionName: ["用户发展情况", "收入情况", "流量使用", "套餐量发展", "活跃度情况"],
      max: [100, 100, 100, 100, 100],
      lineColor: ["#27a9f4", "#4ccb70"],
      legendShow: !0,
      orient: "vertical",
      legendLeft: "right",
      legendTop: "center",
      legendAlign: "left",
      name: ["客户1", "客户2"],
      center: ["50%", "60%"],
      radius: ["0%", "70%"],
      shape: "polygon",
      splitAreaShow: !0,
      splitAreaColor: ["transparent"],
      splitLineShow: !0,
      splitLineColor: ["#0394e7"],
      fillingStyle: !0,
      fillingStyleColor: ["#3D91F7", "#61BE67"],
      optionRadar: {}
    },
    dataOption: {
      url: "/json/test.json",
      objName: "radarChart",
      method: "get",
      data: []
    },
    exportOption: {
      property: [
        {
          exportName: "{dateName} {tab}",
          exportRiskType: "",
          exportAddress: "riskPlatform/exportJson",
          exportParams: ""
        }
      ],
      exportPermission: !0
    },
    customizeOption: [
      {
        index: 1,
        customizeType: "upload",
        customizeIcon: "download",
        customizeDisable: "(()=>false)()",
        buttonConfig: {
          url: "",
          params: {
            searchParam: !1,
            selectParam: !1,
            configParam: [
              {
                key: "key",
                value: "value"
              }
            ]
          },
          fileType: "",
          fileSize: "100"
        }
      }
    ],
    GridX: 0,
    GridY: 0,
    w: 24,
    h: 24
  },
  threeBar: {
    option: {
      theme: "light",
      type: "threeBar",
      title: "3D柱图",
      keyName: "provincename",
      valueName: "totalcnt",
      keyPosition: "bottom",
      // 标签位置(只针对key对应的标签),top || bottom
      dataLength: 5,
      // 柱体个数
      barSize: 1.2,
      // 柱体的大小(长宽)
      barHeight: [9, 7, 5, 3, 1],
      // 每个柱体对应的高度(PS:高度差距不能过大)
      rotate: 0
      // 底部标签旋转角度
    },
    dataOption: {
      url: "/json/test.json",
      objName: "threeBarChart",
      method: "get",
      data: []
    },
    exportOption: {
      property: [
        {
          exportName: "{dateName} {tab}",
          exportRiskType: "",
          exportAddress: "riskPlatform/exportJson",
          exportParams: ""
        }
      ],
      exportPermission: !0
    },
    customizeOption: [
      {
        index: 1,
        customizeType: "upload",
        customizeIcon: "download",
        customizeDisable: "(()=>false)()",
        buttonConfig: {
          url: "",
          params: {
            searchParam: !1,
            selectParam: !1,
            configParam: [
              {
                key: "key",
                value: "value"
              }
            ]
          },
          fileType: "",
          fileSize: "100"
        }
      }
    ],
    GridX: 0,
    GridY: 0,
    w: 24,
    h: 24
  },
  threeBar2: {
    option: {
      theme: "light",
      type: "threeBar2",
      title: "3D柱图2",
      keyName: "provincename",
      valueName: "totalcnt",
      dataLength: 5,
      // 柱体个数
      barSize: 1.2,
      // 柱体的大小(长宽)
      barHeight: [9, 7, 5, 3, 1]
      // 每个柱体对应的高度(PS:高度差距不能过大)
    },
    dataOption: {
      url: "/json/test.json",
      objName: "threeBarChart",
      method: "get",
      data: []
    },
    exportOption: {
      property: [
        {
          exportName: "{dateName} {tab}",
          exportRiskType: "",
          exportAddress: "riskPlatform/exportJson",
          exportParams: ""
        }
      ],
      exportPermission: !0
    },
    customizeOption: [
      {
        index: 1,
        customizeType: "upload",
        customizeIcon: "download",
        customizeDisable: "(()=>false)()",
        buttonConfig: {
          url: "",
          params: {
            searchParam: !1,
            selectParam: !1,
            configParam: [
              {
                key: "key",
                value: "value"
              }
            ]
          },
          fileType: "",
          fileSize: "100"
        }
      }
    ],
    GridX: 0,
    GridY: 0,
    w: 24,
    h: 24
  },
  threeBar3: {
    option: {
      theme: "light",
      type: "threeBar3",
      title: "3D柱图3",
      keyName: "provincename",
      valueName: "totalcnt",
      dataLength: 5,
      // 柱体个数
      barSize: 1.2,
      // 柱体的大小(长宽)
      barHeight: [9, 7, 5, 3, 1]
      // 每个柱体对应的高度(PS:高度差距不能过大)
    },
    dataOption: {
      url: "/json/test.json",
      objName: "threeBarChart",
      method: "get",
      data: []
    },
    exportOption: {
      property: [
        {
          exportName: "{dateName} {tab}",
          exportRiskType: "",
          exportAddress: "riskPlatform/exportJson",
          exportParams: ""
        }
      ],
      exportPermission: !0
    },
    customizeOption: [
      {
        index: 1,
        customizeType: "upload",
        customizeIcon: "download",
        customizeDisable: "(()=>false)()",
        buttonConfig: {
          url: "",
          params: {
            searchParam: !1,
            selectParam: !1,
            configParam: [
              {
                key: "key",
                value: "value"
              }
            ]
          },
          fileType: "",
          fileSize: "100"
        }
      }
    ],
    GridX: 0,
    GridY: 0,
    w: 24,
    h: 24
  },
  particles: {
    option: {
      theme: "light",
      type: "particles",
      title: "particles",
      keyName: "month_id",
      valueName: "api_cnt",
      lineColor: "rgba(221,31,103,0.6)",
      xAxisLabelColor: theme["chart-label"],
      yAxisLabelColor: theme["chart-label"],
      yAxisName: "Y轴",
      gridLeft: "10%",
      gridRight: "10%",
      gridTop: "20%",
      gridBottom: "20%",
      name: ["API调用量"],
      dataUnit: "COUNT_BILLION_DISUNITY",
      unit: "",
      legendShow: !0,
      orient: "horizontal",
      legendLeft: "center",
      legendTop: "30px",
      circleSize: 45,
      barSize: "20%",
      dataLength: 6,
      style: "style1"
    },
    dataOption: {
      url: "/json/test.json",
      objName: "particlesChart",
      method: "get",
      data: []
    },
    exportOption: {
      property: [
        {
          exportName: "{dateName} {tab}",
          exportRiskType: "",
          exportAddress: "riskPlatform/exportJson",
          exportParams: ""
        }
      ],
      exportPermission: !0
    },
    customizeOption: [
      {
        index: 1,
        customizeType: "upload",
        customizeIcon: "download",
        customizeDisable: "(()=>false)()",
        buttonConfig: {
          url: "",
          params: {
            searchParam: !1,
            selectParam: !1,
            configParam: [
              {
                key: "key",
                value: "value"
              }
            ]
          },
          fileType: "",
          fileSize: "100"
        }
      }
    ],
    GridX: 0,
    GridY: 0,
    w: 24,
    h: 24
  },
  map: {
    option: {
      theme: "light",
      type: "map",
      title: "地图",
      selectName: "全国"
    },
    dataOption: {
      url: "/json/data/ggsnPoit.json",
      objName: "provinceUsedCnt",
      method: "get",
      data: []
    },
    exportOption: {
      property: [
        {
          exportName: "{dateName} {tab}",
          exportRiskType: "",
          exportAddress: "riskPlatform/exportJson",
          exportParams: ""
        }
      ],
      exportPermission: !0
    },
    customizeOption: [
      {
        index: 1,
        customizeType: "upload",
        customizeIcon: "download",
        customizeDisable: "(()=>false)()",
        buttonConfig: {
          url: "",
          params: {
            searchParam: !1,
            selectParam: !1,
            configParam: [
              {
                key: "key",
                value: "value"
              }
            ]
          },
          fileType: "",
          fileSize: "100"
        }
      }
    ],
    GridX: 0,
    GridY: 0,
    w: 24,
    h: 24
  },
  bar3D: {
    option: {
      type: "bar3D",
      title: "Bar3D - Punch Card",
      name: "测试seriesName",
      hours: ["12a", "1a", "2a", "3a", "4a", "5a", "6a", "7a", "8a", "9a", "10a", "11a", "12p", "1p", "2p", "3p", "4p", "5p", "6p", "7p", "8p", "9p", "10p", "11p"],
      days: ["Saturday", "Friday", "Thursday", "Wednesday", "Tuesday", "Monday", "Sunday"],
      data: [
        [0, 0, 5],
        [0, 1, 1],
        [0, 2, 0],
        [0, 3, 0],
        [0, 4, 0],
        [0, 5, 0],
        [0, 6, 0],
        [0, 7, 0],
        [0, 8, 0],
        [0, 9, 0],
        [0, 10, 0],
        [0, 11, 2],
        [0, 12, 4],
        [0, 13, 1],
        [0, 14, 1],
        [0, 15, 3],
        [0, 16, 4],
        [0, 17, 6],
        [0, 18, 4],
        [0, 19, 4],
        [0, 20, 3],
        [0, 21, 3],
        [0, 22, 2],
        [0, 23, 5],
        [1, 0, 7],
        [1, 1, 0],
        [1, 2, 0],
        [1, 3, 0],
        [1, 4, 0],
        [1, 5, 0],
        [1, 6, 0],
        [1, 7, 0],
        [1, 8, 0],
        [1, 9, 0],
        [1, 10, 5],
        [1, 11, 2],
        [1, 12, 2],
        [1, 13, 6],
        [1, 14, 9],
        [1, 15, 11],
        [1, 16, 6],
        [1, 17, 7],
        [1, 18, 8],
        [1, 19, 12],
        [1, 20, 5],
        [1, 21, 5],
        [1, 22, 7],
        [1, 23, 2],
        [2, 0, 1],
        [2, 1, 1],
        [2, 2, 0],
        [2, 3, 0],
        [2, 4, 0],
        [2, 5, 0],
        [2, 6, 0],
        [2, 7, 0],
        [2, 8, 0],
        [2, 9, 0],
        [2, 10, 3],
        [2, 11, 2],
        [2, 12, 1],
        [2, 13, 9],
        [2, 14, 8],
        [2, 15, 10],
        [2, 16, 6],
        [2, 17, 5],
        [2, 18, 5],
        [2, 19, 5],
        [2, 20, 7],
        [2, 21, 4],
        [2, 22, 2],
        [2, 23, 4],
        [3, 0, 7],
        [3, 1, 3],
        [3, 2, 0],
        [3, 3, 0],
        [3, 4, 0],
        [3, 5, 0],
        [3, 6, 0],
        [3, 7, 0],
        [3, 8, 1],
        [3, 9, 0],
        [3, 10, 5],
        [3, 11, 4],
        [3, 12, 7],
        [3, 13, 14],
        [3, 14, 13],
        [3, 15, 12],
        [3, 16, 9],
        [3, 17, 5],
        [3, 18, 5],
        [3, 19, 10],
        [3, 20, 6],
        [3, 21, 4],
        [3, 22, 4],
        [3, 23, 1],
        [4, 0, 1],
        [4, 1, 3],
        [4, 2, 0],
        [4, 3, 0],
        [4, 4, 0],
        [4, 5, 1],
        [4, 6, 0],
        [4, 7, 0],
        [4, 8, 0],
        [4, 9, 2],
        [4, 10, 4],
        [4, 11, 4],
        [4, 12, 2],
        [4, 13, 4],
        [4, 14, 4],
        [4, 15, 14],
        [4, 16, 12],
        [4, 17, 1],
        [4, 18, 8],
        [4, 19, 5],
        [4, 20, 3],
        [4, 21, 7],
        [4, 22, 3],
        [4, 23, 0],
        [5, 0, 2],
        [5, 1, 1],
        [5, 2, 0],
        [5, 3, 3],
        [5, 4, 0],
        [5, 5, 0],
        [5, 6, 0],
        [5, 7, 0],
        [5, 8, 2],
        [5, 9, 0],
        [5, 10, 4],
        [5, 11, 1],
        [5, 12, 5],
        [5, 13, 10],
        [5, 14, 5],
        [5, 15, 7],
        [5, 16, 11],
        [5, 17, 6],
        [5, 18, 0],
        [5, 19, 5],
        [5, 20, 3],
        [5, 21, 4],
        [5, 22, 2],
        [5, 23, 0],
        [6, 0, 1],
        [6, 1, 0],
        [6, 2, 0],
        [6, 3, 0],
        [6, 4, 0],
        [6, 5, 0],
        [6, 6, 0],
        [6, 7, 0],
        [6, 8, 0],
        [6, 9, 0],
        [6, 10, 1],
        [6, 11, 0],
        [6, 12, 2],
        [6, 13, 1],
        [6, 14, 3],
        [6, 15, 4],
        [6, 16, 0],
        [6, 17, 0],
        [6, 18, 0],
        [6, 19, 0],
        [6, 20, 1],
        [6, 21, 2],
        [6, 22, 2],
        [6, 23, 6]
      ]
    },
    dataOption: {
      url: "/json/test.json",
      objName: "bar3D",
      method: "get",
      data: []
    },
    exportOption: {
      property: [
        {
          exportName: "{dateName} {tab}",
          exportRiskType: "",
          exportAddress: "riskPlatform/exportJson",
          exportParams: ""
        }
      ],
      exportPermission: !0
    },
    customizeOption: [
      {
        index: 1,
        customizeType: "upload",
        customizeIcon: "download",
        customizeDisable: "(()=>false)()",
        buttonConfig: {
          url: "",
          params: {
            searchParam: !1,
            selectParam: !1,
            configParam: [
              {
                key: "key",
                value: "value"
              }
            ]
          },
          fileType: "",
          fileSize: "100"
        }
      }
    ],
    GridX: 0,
    GridY: 0,
    w: 24,
    h: 24
  },
  tabLines: {
    option: {
      theme: "light",
      type: "tabLines",
      keyName: "key",
      valueName: "value",
      title: "{time}{province}{tab}",
      name: "用户数",
      y1Keys: ["key1Value", "key2Value", "key3Value"],
      y2Keys: ["key4Value"],
      names: ["用户总数", "新增用户数", "活跃用户数", "活跃度"],
      keys: ["key1Value", "key2Value", "key3Value", "key4Value"],
      y1AxisName: "用户数",
      y2AxisName: "活跃度",
      xAxisLabelColor: theme["chart-label"],
      y1AxisLabelColor: theme["chart-label"],
      y2AxisLabelColor: theme["chart-label"],
      y2AxisFormatter: "(function(value){return (value * 100 + '%')})",
      y1Rotate: 0,
      y2Rotate: 0,
      legendShow: !0,
      orient: "horizontal",
      gridLeft: "10%",
      gridRight: "10%",
      gridTop: "25%",
      gridBottom: "15%",
      legendLeft: "center",
      legendTop: "30px",
      colorList: [
        "#478ff7",
        "#ff7f4c",
        "#7fa7b8",
        "#f1485b",
        "#26cdcb",
        "#7565c7",
        "#27a9f4",
        "#778efe",
        "#4ccb70",
        "#ffca3a"
      ],
      enableDoubleYAxis: !0,
      optionLines: {},
      tabs: [
        {
          id: "highRisk",
          name: "高风险",
          objName: "tabLines1",
          url: "/json/test1.json",
          method: "get"
        },
        {
          id: "middleRisk",
          name: "中风险",
          objName: "tabLines2",
          url: "/json/test.json",
          method: "get"
        },
        {
          id: "lowRisk",
          name: "低风险",
          objName: "tabLines3",
          url: "/json/test.json",
          method: "get"
        },
        {
          id: "safe",
          name: "安全",
          objName: "tabLines4",
          url: "/json/test.json",
          method: "get"
        }
      ]
    },
    dataOption: [
      {
        id: "highRisk",
        url: "/json/test1.json",
        objName: "tabLines1",
        method: "get",
        data: []
      },
      {
        id: "middleRisk",
        url: "/json/test.json",
        objName: "tabLines2",
        method: "get",
        data: []
      },
      {
        id: "lowRisk",
        url: "/json/test.json",
        objName: "tabLines3",
        method: "get",
        data: []
      },
      {
        id: "safe",
        url: "/json/test.json",
        objName: "tabLines4",
        method: "get",
        data: []
      }
    ],
    exportOption: {
      property: [
        {
          exportName: "{dateName} {tab}",
          exportRiskType: "",
          exportAddress: "riskPlatform/exportJson",
          exportParams: ""
        }
      ],
      exportPermission: !0
    },
    customizeOption: [
      {
        index: 1,
        customizeType: "upload",
        customizeIcon: "download",
        customizeDisable: "(()=>false)()",
        buttonConfig: {
          url: "",
          params: {
            searchParam: !1,
            selectParam: !1,
            configParam: [
              {
                key: "key",
                value: "value"
              }
            ]
          },
          fileType: "",
          fileSize: "100"
        }
      }
    ],
    GridX: 0,
    GridY: 0,
    w: 24,
    h: 24
  },
  tabBar: {
    option: {
      theme: "light",
      type: "tabBar",
      keyName: "key",
      valueName: ["key1Value", "key2Value", "key3Value", "key4Value"],
      barType: "horizontal",
      title: "{time}{province}{tab}",
      name: ["用户总数", "新增用户数", "活跃用户数", "活跃度"],
      barColor: ["#27a9f4", "#4ccb70"],
      colorList: ["#27a9f4"],
      gridLeft: "10%",
      gridRight: "10%",
      gridTop: "20%",
      gridBottom: "20%",
      legendShow: !0,
      xAxisLabelColor: theme["chart-label"],
      yAxisLabelColor: theme["chart-label"],
      orient: "horizontal",
      legendLeft: "center",
      legendTop: "20px",
      optionBar: {},
      tabs: [
        {
          id: "highRisk",
          name: "高风险",
          objName: "tabBar1",
          url: "/json/test1.json",
          method: "get"
        },
        {
          id: "middleRisk",
          name: "中风险",
          objName: "tabBar2",
          url: "/json/test.json",
          method: "get"
        },
        {
          id: "lowRisk",
          name: "低风险",
          objName: "tabBar3",
          url: "/json/test.json",
          method: "get"
        },
        {
          id: "safe",
          name: "安全",
          objName: "tabBar4",
          url: "/json/test.json",
          method: "get"
        }
      ]
    },
    dataOption: [
      {
        id: "highRisk",
        url: "/json/test1.json",
        objName: "tabBar1",
        method: "get",
        data: []
      },
      {
        id: "middleRisk",
        url: "/json/test.json",
        objName: "tabBar2",
        method: "get",
        data: []
      },
      {
        id: "lowRisk",
        url: "/json/test.json",
        objName: "tabBar3",
        method: "get",
        data: []
      },
      {
        id: "safe",
        url: "/json/test.json",
        objName: "tabBar4",
        method: "get",
        data: []
      }
    ],
    exportOption: {
      property: [
        {
          exportName: "{dateName} {tab}",
          exportRiskType: "",
          exportAddress: "riskPlatform/exportJson",
          exportParams: ""
        }
      ],
      exportPermission: !0
    },
    customizeOption: [
      {
        index: 1,
        customizeType: "upload",
        customizeIcon: "download",
        customizeDisable: "(()=>false)()",
        buttonConfig: {
          url: "",
          params: {
            searchParam: !1,
            selectParam: !1,
            configParam: [
              {
                key: "key",
                value: "value"
              }
            ]
          },
          fileType: "",
          fileSize: "100"
        }
      }
    ],
    GridX: 0,
    GridY: 0,
    w: 24,
    h: 24
  },
  customCard: {
    option: {},
    dataOption: {},
    GridX: 0,
    GridY: 0,
    w: 24,
    h: 24
  },
  table: {
    option: {},
    dataOption: {
      url: "/json/test.json",
      objName: "chart1",
      method: "get",
      data: [],
      params: {
        intfcType: "baseProvince",
        intfcTypeName: "测试intfcTypeName"
      }
    },
    exportOption: {
      property: [
        {
          exportName: "{dateName} {tab}",
          exportRiskType: "",
          exportAddress: "riskPlatform/exportJson",
          exportParams: ""
        }
      ],
      exportPermission: !0
    },
    customizeOption: [
      {
        index: 1,
        customizeType: "upload",
        customizeIcon: "download",
        customizeDisable: "(()=>false)()",
        buttonConfig: {
          url: "",
          params: {
            searchParam: !1,
            selectParam: !1,
            configParam: [
              {
                key: "key",
                value: "value"
              }
            ]
          },
          fileType: "",
          fileSize: "100"
        }
      }
    ],
    GridX: 0,
    GridY: 0,
    w: 24,
    h: 24
  },
  riskOverviewCeil: {
    option: {
      type: "riskOverviewCeil"
    },
    dataOption: {
      url: "/json/test.json",
      objName: "chart1",
      method: "get",
      data: [],
      params: {
        intfcType: "baseProvince",
        intfcTypeName: "测试intfcTypeName"
      }
    },
    GridX: 0,
    GridY: 0,
    w: 24,
    h: 12
  },
  blackListTable: {
    option: {
      type: "blackList"
    },
    dataOption: {
      url: "/json/test.json",
      objName: "chart1",
      method: "get",
      data: [],
      params: {
        intfcType: "baseProvince",
        intfcTypeName: "测试intfcTypeName"
      }
    },
    exportOption: {
      property: [
        {
          exportName: "{dateName} {tab}",
          exportRiskType: "",
          exportAddress: "riskPlatform/exportJson",
          exportParams: ""
        }
      ],
      exportPermission: !0
    },
    customizeOption: [
      {
        index: 1,
        customizeType: "upload",
        customizeIcon: "download",
        customizeDisable: "(()=>false)()",
        buttonConfig: {
          url: "",
          params: {
            searchParam: !1,
            selectParam: !1,
            configParam: [
              {
                key: "key",
                value: "value"
              }
            ]
          },
          fileType: "",
          fileSize: "100"
        }
      }
    ],
    GridX: 0,
    GridY: 0,
    w: 24,
    h: 24
  },
  tabCard: {
    tabs: [
      {
        id: "1",
        name: "tab1",
        cardOption: [
          {
            option: {
              theme: "light",
              type: "lines",
              data: [],
              // 图表数据
              title: "",
              // 图表名称
              name: "多折线图",
              // 线名称
              keyName: "key",
              // 数据展现坐标KEY名称
              valueName: "value",
              // 数据展现值
              gridLeft: "10%",
              // grid 组件离容器左侧的距离
              gridRight: "10%",
              // grid 组件离容器右侧的距离
              gridTop: "20%",
              // grid 组件离容器上侧的距离
              gridBottom: "20%",
              // grid 组件离容器下侧的距离
              legendShow: !0,
              // 是否显示legend
              orient: "horizontal",
              // 图例布局朝向
              legendLeft: "center",
              // 图例组件离容器左侧的距离
              legendTop: "20px",
              // 图例组件离容器上侧的距离
              xRotate: 0,
              // x轴标签旋转角度
              xAxisLabelColor: theme["chart-label"],
              // x轴标签颜色
              y1Rotate: 0,
              // y1轴标签旋转角度
              y1AxisName: "Y1轴",
              // y1轴名称
              y1AxisLabelColor: theme["chart-label"],
              // y1轴标签颜色
              y2Rotate: 0,
              // y2轴标签旋转角度
              y2AxisName: "Y2轴",
              // y2轴名称
              y2AxisLabelColor: theme["chart-label"],
              // y2轴标签颜色
              names: ["用户总数", "新增用户数"],
              keys: ["key1Value", "key2Value"],
              y1Keys: [],
              y2Keys: [],
              isAreaStyle: !1,
              colorList: [
                "#478ff7",
                "#ff7f4c",
                "#7fa7b8",
                "#f1485b",
                "#26cdcb",
                "#7565c7",
                "#27a9f4",
                "#778efe",
                "#4ccb70",
                "#ffca3a"
              ],
              optionLines: {},
              enableDoubleYAxis: !1,
              // 是否启用双y轴
              resetOrder: !0,
              // 设置是否对数据重排序
              symbolSize: 6,
              showDataZoom: !1,
              lastDotted: !1,
              toolTipFormatter: null,
              legendFormatter: null,
              xAxisFormatter: null,
              yAxisFormatter: null
            },
            dataOption: {
              url: "/json/test.json",
              objName: "linesChart",
              method: "get",
              data: [],
              params: {
                intfcType: "baseProvince",
                intfcTypeName: "测试intfcTypeName"
              }
            },
            exportOption: {
              property: [
                {
                  exportName: "{dateName} {tab}",
                  exportRiskType: "",
                  exportAddress: "riskPlatform/exportJson",
                  exportParams: ""
                }
              ],
              exportPermission: !0
            },
            customizeOption: [
              {
                index: 1,
                customizeType: "upload",
                customizeIcon: "download",
                customizeDisable: "(()=>false)()",
                buttonConfig: {
                  url: "",
                  params: {
                    searchParam: !1,
                    selectParam: !1,
                    configParam: [
                      {
                        key: "key",
                        value: "value"
                      }
                    ]
                  },
                  fileType: "",
                  fileSize: "100"
                }
              }
            ],
            GridX: 0,
            GridY: 0,
            w: 24,
            h: 24,
            key: "tab11"
          }
        ]
      },
      {
        id: "2",
        name: "tab2",
        cardOption: [
          {
            option: {
              theme: "light",
              type: "bar",
              keyName: "key",
              valueName: ["value", "value1"],
              barType: "horizontal",
              title: "物联卡总体发展趋势",
              name: ["用户数", "总用户数"],
              barColor: ["#27a9f4", "#4ccb70"],
              colorList: ["#27a9f4"],
              gridLeft: "10%",
              gridRight: "10%",
              gridTop: "20%",
              gridBottom: "20%",
              legendShow: !0,
              xAxisLabelColor: theme["chart-label"],
              yAxisLabelColor: theme["chart-label"],
              orient: "horizontal",
              legendLeft: "center",
              legendTop: "20px",
              optionBar: {}
            },
            dataOption: {
              url: "/json/test.json",
              objName: "barChart",
              method: "get",
              data: [],
              params: {
                intfcType: "baseProvince",
                intfcTypeName: "测试intfcTypeName"
              }
            },
            exportOption: {
              property: [
                {
                  exportName: "{dateName} {tab}",
                  exportRiskType: "",
                  exportAddress: "riskPlatform/exportJson",
                  exportParams: ""
                }
              ],
              exportPermission: !0
            },
            customizeOption: [
              {
                index: 1,
                customizeType: "upload",
                customizeIcon: "download",
                customizeDisable: "(()=>false)()",
                buttonConfig: {
                  url: "",
                  params: {
                    searchParam: !1,
                    selectParam: !1,
                    configParam: [
                      {
                        key: "key",
                        value: "value"
                      }
                    ]
                  },
                  fileType: "",
                  fileSize: "100"
                }
              }
            ],
            GridX: 0,
            GridY: 0,
            w: 24,
            h: 24,
            key: "tab21"
          }
        ]
      }
    ],
    GridX: 0,
    GridY: 0,
    w: 48,
    h: 24
  },
  treeMap: {
    option: {
      data: null,
      title: "",
      keyName: "",
      valueName: "",
      colorList: [
        "#f25118",
        "#32bbe0",
        "#4d7fff",
        "#f95d60",
        "#f4ac4e",
        "#a179f1",
        "#f1598d",
        "#0080d9",
        "#d05757",
        "#83d540",
        "#f46d9b",
        "#346ef9",
        "#ffdf33",
        "#84adff",
        "#ff8484",
        "#3cb371"
      ]
    }
  }
}, dark = {
  // 标题
  title: {
    textStyle: {
      fontSize: "14",
      color: "#fff"
    }
  },
  legend: {
    textStyle: {
      color: "#fff",
      fontFamily: "SimHei,Arial, Verdana, sans-serif",
      fontSize: 12
    }
  },
  // 网格
  grid: {
    borderWidth: 0
  },
  // 类目轴
  categoryAxis: {
    axisTick: {
      show: !1
    },
    axisLine: {
      // 坐标轴线
      lineStyle: {
        // 属性lineStyle控制线条样式
        color: "black"
      }
    },
    splitLine: {
      // 分隔线
      lineStyle: {
        // 属性lineStyle（详见lineStyle）控制线条样式
        color: "rgb(41,66,84)"
      }
    },
    axisLabel: {
      number: 0,
      textStyle: {
        color: "#ffffff"
      }
    },
    nameTextStyle: {
      color: "#ffffff",
      fontSize: 12
    }
  },
  // 数值型坐标轴默认参数
  valueAxis: {
    axisTick: {
      show: !1
    },
    axisLine: {
      lineStyle: {
        color: "#ffffff"
      }
    },
    axisLabel: {
      textStyle: {
        color: "#ffffff"
      }
    },
    splitLine: {
      lineStyle: {
        color: "rgb(41,66,84)"
      }
    },
    nameTextStyle: {
      color: "#ffffff",
      fontSize: 12
    }
  },
  pie: {
    label: {
      color: "#fff"
    },
    labelLine: {
      lineStyle: {
        color: "#fff"
      }
    }
  },
  radar: {
    name: {
      textStyle: {
        color: "#fff",
        fontSize: 12
      }
    }
  },
  textStyle: {
    fontFamily: "微软雅黑, Arial, Verdana, sans-serif",
    color: "#ffffff"
  }
}, light = {
  // 标题
  title: {
    textStyle: {
      fontSize: "14",
      color: "#333333"
    }
  },
  legend: {
    textStyle: {
      color: "#666666",
      fontFamily: "SimHei,Arial, Verdana, sans-serif",
      fontSize: 12
    }
  },
  tooltip: {
    axisPointer: {
      type: "line",
      lineStyle: {
        width: 0.5
      }
    }
  },
  // 网格
  grid: {
    borderWidth: 0
  },
  // 类目轴
  categoryAxis: {
    // 坐标轴刻度
    axisTick: {
      lineStyle: {
        color: "#bbbbbb"
      }
    },
    // 坐标轴轴线
    axisLine: {
      lineStyle: {
        color: "#bbbbbb"
      }
    },
    // 坐标轴在grid区域中的分割线
    splitLine: {
      lineStyle: {
        color: "#dddddd"
      }
    },
    // 坐标轴刻度标签
    axisLabel: {
      number: 0,
      textStyle: {
        color: "#666666"
      }
    },
    // 坐标轴名称
    nameTextStyle: {
      color: "#666666",
      fontSize: 12
    }
  },
  // 数值型坐标轴默认参数
  valueAxis: {
    axisTick: {
      lineStyle: {
        color: "#bbbbbb"
      }
    },
    axisLine: {
      lineStyle: {
        color: "#bbbbbb"
      }
    },
    axisLabel: {
      textStyle: {
        color: "#666666"
      }
    },
    splitLine: {
      lineStyle: {
        color: "#dddddd"
      }
    },
    nameTextStyle: {
      color: "#666666",
      fontSize: 12
    }
  },
  pie: {
    label: {
      color: "#666666"
    },
    labelLine: {
      lineStyle: {
        color: "#666666"
      }
    }
  },
  radar: {
    name: {
      textStyle: {
        color: "#666666",
        fontSize: 12
      }
    }
  },
  textStyle: {
    fontFamily: "微软雅黑, Arial, Verdana, sans-serif"
  }
};
let barChart = null;
const _sfc_main$8 = defineComponent({
  name: "BarChart",
  props: {
    option: {
      type: Object,
      default: () => {
      }
    }
  },
  data() {
    return {
      flagClickEvent: !1,
      defaultOption: toolUtil.extend({}, defaultConfig.bar.option)
    };
  },
  created() {
  },
  mounted() {
    this.option && (barChart = init$1(
      this.$refs.domChart,
      this.option.theme === "dark" ? dark : light
    ), this.setBarOption(this.option), window.addEventListener("resize", this.onWindowResize));
  },
  updated() {
    this.setBarOption(this.option), barChart.resize();
  },
  beforeUnmount() {
    barChart && (barChart.clear(), barChart.dispose()), window.removeEventListener("resize", this.onWindowResize);
  },
  methods: {
    onWindowResize() {
      barChart.resize();
    },
    setBarOption(option) {
      const self = this, opts = toolUtil.merge(this.defaultOption, option, !0), barOptionV = {
        tooltip: {
          trigger: "axis",
          axisPointer: {
            type: "none"
          },
          formatter(params, ticket, callback) {
            if (option.toolTipFormatter)
              return eval(option.toolTipFormatter).call(
                this,
                params,
                ticket,
                callback
              );
            let res = params[0].name;
            for (let H = 0, C = params.length; H < C; H++)
              res += `<br/>${params[H].seriesName} : ${toolUtil.commafy(
                params[H].value
              )}`;
            return res;
          }
        },
        title: {
          x: "center",
          y: 10,
          /* textStyle: {
                  fontSize: 12,
                  color: '#fff'
              }, */
          text: opts.title
        },
        legend: {
          show: opts.legendShow,
          left: opts.legendLeft,
          top: opts.legendTop,
          orient: opts.orient,
          itemHeight: 8,
          padding: 10,
          itemGap: 10,
          formatter(params) {
            return opts.legendFormatter ? eval(opts.legendFormatter).call(this, params) : toolUtil.formatCharts(params, 22);
          },
          pageIconInactiveColor: "#2f4554",
          pageIconColor: "#aaa",
          pageTextStyle: {
            color: "#aaa"
          },
          /* textStyle: {
            color: "#fff",
            fontFamily: "SimHei,Arial, Verdana, sans-serif",
            fontSize: 12
          }, */
          data: []
        },
        grid: {
          left: opts.gridLeft,
          right: opts.gridRight,
          top: opts.gridTop,
          bottom: opts.gridBottom,
          containLabel: !0
        },
        xAxis: [
          {
            type: "value",
            data: [],
            axisLabel: {
              rotate: opts.xRotate,
              formatter(value, index) {
                return option.xAxisFormatter ? eval(option.xAxisFormatter).call(this, value, index) : toolUtil.commafy(value);
              },
              textStyle: {
                // color: opts.xAxisLabelColor,
                fontSize: 12
              }
            },
            nameTextStyle: {
              // color: '#ffffff',
              fontSize: 12
            }
          }
        ],
        yAxis: [
          {
            type: "category",
            name: opts.yAxisName,
            splitLine: {
              show: !1
            },
            data: [],
            axisLabel: {
              interval: 0,
              rotate: opts.yRotate,
              formatter(value, index) {
                return option.yAxisFormatter ? eval(option.yAxisFormatter).call(this, value, index) : toolUtil.formatCharts(value, 18);
              },
              textStyle: {
                fontSize: 12
              }
            },
            nameTextStyle: {
              fontSize: 12
            }
          }
        ],
        series: [
          {
            name: "柱状图",
            type: "bar",
            barCategoryGap: "50%",
            barMinHeight: 5,
            barMaxWidth: 30,
            itemStyle: {
              normal: {
                color: ""
              }
            },
            label: {
              normal: {
                show: !0,
                position: "right",
                formatter(param) {
                  return option.labelFormatter ? eval(option.labelFormatter).call(this, param) : toolUtil.commafy(param.value);
                },
                textStyle: {
                  fontSize: 12
                  // color: '#fff',
                }
              }
            },
            data: []
          }
        ]
      }, barOptionH = {
        tooltip: {
          show: !0,
          trigger: "axis",
          axisPointer: {
            type: "none"
          },
          formatter: (params, ticket, callback) => {
            if (option.toolTipFormatter)
              return eval(option.toolTipFormatter).call(
                this,
                params,
                ticket,
                callback
              );
            let res = params[0].name;
            for (let H = 0, C = params.length; H < C; H++)
              res += `<br/>${params[H].seriesName} : ${toolUtil.commafy(
                params[H].value
              )}`;
            return res;
          }
        },
        title: {
          x: "center",
          y: 10,
          /* textStyle: {
            fontSize: 14,
            color: '#fff'
          }, */
          text: opts.title
        },
        legend: {
          show: opts.legendShow,
          left: opts.legendLeft,
          top: opts.legendTop,
          orient: opts.orient,
          selected: {},
          itemHeight: 8,
          padding: 10,
          itemGap: 10,
          formatter(params) {
            return opts.legendFormatter ? eval(opts.legendFormatter).call(this, params) : toolUtil.formatCharts(params, 22);
          },
          // pageIconInactiveColor: '#2f4554',
          // pageIconColor: '#aaa',
          pageTextStyle: {
            // color: '#aaa',
          },
          /* textStyle: {
            color: "#fff",
            fontFamily: "SimHei,Arial, Verdana, sans-serif",
            fontSize: 12
          }, */
          data: []
        },
        grid: {
          left: opts.gridLeft,
          right: opts.gridRight,
          top: opts.gridTop,
          bottom: opts.gridBottom
        },
        xAxis: [
          {
            show: !0,
            type: "category",
            data: [],
            axisLabel: {
              rotate: opts.xRotate,
              formatter(value, index) {
                return option.xAxisFormatter ? eval(option.xAxisFormatter).call(this, value, index) : toolUtil.formatCharts(value, 12);
              },
              textStyle: {
                // color: opts.xAxisLabelColor,
                fontSize: 12
              }
            },
            splitLine: {
              show: !1
            },
            nameTextStyle: {
              // color: '#ffffff',
              fontSize: 12
            }
          }
        ],
        yAxis: [
          {
            show: !0,
            type: "value",
            data: [],
            name: opts.yAxisName,
            axisLabel: {
              interval: 0,
              rotate: opts.yRotate,
              formatter(value, index) {
                return option.yAxisFormatter ? eval(option.yAxisFormatter).call(this, value, index) : toolUtil.commafy(value);
              },
              textStyle: {
                // color: opts.yAxisLabelColor,
                fontSize: 12
              }
            },
            nameTextStyle: {
              // color: '#ffffff',
              fontSize: 12
            }
          }
        ],
        series: [
          {
            name: "柱状图",
            type: "bar",
            barGap: "0%",
            barCategoryGap: "50%",
            // barMinHeight: 5,
            barMaxWidth: 30,
            label: {
              normal: {
                show: !0,
                position: "top",
                formatter(param) {
                  return option.labelFormatter ? eval(option.labelFormatter).call(this, param) : toolUtil.commafy(param.value);
                },
                textStyle: {
                  fontSize: 12
                  // color: '#fff',
                }
              }
            },
            itemStyle: {
              normal: {
                // color: '',
              }
            },
            data: []
          }
        ]
      }, barOption = opts.barType === "vertical" ? toolUtil.extend({}, barOptionV, opts.optionBar) : toolUtil.extend({}, barOptionH, opts.optionBar), { data } = opts;
      if (data && data.length > 0) {
        barOption.yAxis[0].data = [], barOption.xAxis[0].data = [], barOption.series[0].data = [], opts.resetOrder && data.sort((C, G) => C[opts.keyName] - G[opts.keyName]);
        const H = opts.valueName;
        if (H.length > 1 && H.forEach((C, G) => {
          barOption.series[G] = toolUtil.extend({}, barOption.series[0]), barOption.series[G].data = [], opts.name.length > 1 && opts.name[G] && (barOption.series[G].name = opts.name[G]);
        }), opts.name.forEach((C, G) => {
          barOption.legend.data.push({
            name: opts.name[G],
            icon: "circle"
          });
        }), barOption.yAxis.length > 1 && barOption.yAxis.forEach((C, G) => {
          barOption.series[G].yAxisIndex = G;
        }), data.forEach((C, G) => {
          const U = C[opts.keyName];
          opts.barType === "vertical" ? barOption.yAxis[0].data.push(U) : barOption.xAxis[0].data.push(U), H.length > 1 ? barOption.series.forEach((K, W) => {
            barOption.series[W].data.push(C[H[W]]);
          }) : opts.lastDotted ? G === data.length - 1 ? barOption.series[0].data.push({
            value: C[H[0]],
            itemStyle: {
              normal: {
                borderColor: opts.colorList.length > 1 ? opts.colorList[G] : opts.colorList[0],
                borderType: "dotted",
                borderWidth: "3",
                color: "rgba(0,0,0,0.07)"
              }
            },
            originalData: C
          }) : barOption.series[0].data.push({
            value: C[H[0]],
            itemStyle: opts.colorList.length > 1 ? {
              normal: {
                color: opts.colorList[G]
              }
            } : {},
            originalData: C
          }) : barOption.series[0].data.push({
            value: C[H[0]],
            symbolFlag: C.symbolFlag || "",
            // 用于区分客户简称相同时，设置toolTip用于区分的标志（该值多为客户ID）
            itemStyle: opts.colorList.length > 1 ? {
              normal: {
                color: opts.colorList[G]
              }
            } : {},
            originalData: C
          });
        }), barOption.series.forEach((C) => {
          opts.overlap && (C.stack = "总量"), opts.label || (C.label.normal.show = !1);
        }), opts.name.length > 1 ? barOption.series.forEach((C, G) => {
          barOption.series[G].name = opts.name[G];
        }) : barOption.series[0].name = opts.name[0], opts.name.length > 1 ? barOption.series.forEach((C, G) => {
          barOption.series[G].itemStyle.normal.color = opts.barColor[G];
        }) : barOption.series[0].itemStyle.normal.color = opts.barColor[0], self.showLabel = barOption.series[0].label.normal.show, opts.defaultLegend instanceof Array && opts.defaultLegend.length > 0)
          opts.defaultLegend.forEach((C) => {
            barOption.legend.selected[C] = !0;
          });
        else
          for (const C in barOption.legend.selected)
            barOption.legend.selected[C] = !0;
      } else
        barOption.xAxis[0].show = !1, barOption.yAxis[0].show = !1, barOption.series = [];
      !this.flagClickEvent && opts.clickEvent && (this.flagClickEvent = !0, barChart.on("click", opts.clickEvent)), toolUtil.extend(barOption, opts.barOption), barChart.setOption(barOption, !0);
    }
  }
}), _hoisted_1$7 = {
  ref: "domChart",
  style: { height: "100%", width: "100%" }
}, _hoisted_2$6 = { style: { display: "none" } };
function _sfc_render$8(H, C, G, U, K, W) {
  return openBlock(), createElementBlock("div", _hoisted_1$7, [
    createElementVNode("span", _hoisted_2$6, toDisplayString(H.option.type), 1)
  ], 512);
}
const BarChart = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["render", _sfc_render$8]]);
let pieChart = null;
const _sfc_main$7 = defineComponent({
  name: "PieChart",
  props: {
    option: {
      type: Object,
      default: () => {
      }
    }
  },
  data() {
    return {
      flagClickEvent: !1,
      defaultOption: toolUtil.extend({}, defaultConfig.pie.option)
    };
  },
  mounted() {
    this.option && (pieChart = init$1(
      this.$refs.domChart,
      this.option.theme === "dark" ? dark : light
    ), this.setPieOption(this.option), window.addEventListener("resize", this.onWindowResize));
  },
  updated() {
    this.setPieOption(this.option), pieChart.resize();
  },
  beforeUnmount() {
    pieChart && (pieChart.clear(), pieChart.dispose()), window.removeEventListener("resize", this.onWindowResize);
  },
  methods: {
    onWindowResize() {
      pieChart.resize();
    },
    setPieOption(option) {
      const opts = toolUtil.merge(this.defaultOption, option, !0), optionPie = {
        tooltip: {
          show: opts.showTooltip || !1,
          formatter(H, C, G) {
            return option.toolTipFormatter.call(this, H, C, G);
          }
        },
        title: {
          text: opts.title,
          x: "center",
          y: 10
          /* textStyle: {
                        fontSize: 14,
                        color: '#fff'
                    } */
        },
        legend: {
          show: opts.legendShow,
          orient: opts.orient,
          left: opts.legendLeft,
          top: opts.legendTop,
          align: opts.legendAlign,
          itemHeight: 8,
          itemWidth: 8,
          // textStyle: {color: '#fff'},
          itemGap: 20,
          data: [],
          // pageIconInactiveColor: '#2f4554',
          // pageIconColor: '#aaa',
          pageTextStyle: {
            // color: '#aaa',
          }
        },
        series: [
          {
            name: "数量占比",
            type: "pie",
            center: opts.pieCenter,
            radius: opts.pieRadius,
            startAngle: 90,
            minAngle: 5,
            selectedMode: "multiple",
            clockWise: !0,
            itemStyle: {
              normal: {}
            },
            roseType: opts.roseType === "false" ? !1 : opts.roseType,
            labelLine: {
              normal: {
                show: !0,
                /* lineStyle: {
                                    color: opts.labelLineColor?opts.labelLineColor:''
                                }, */
                length: 30
              }
            },
            label: {
              normal: {
                show: !0,
                textStyle: {
                  // color: '#000',
                  baseline: "bottom",
                  fontSize: 12,
                  fontFamily: "SimHei,Arial, Verdana, sans-serif"
                },
                formatter(params) {
                  return opts.labelFormatter ? eval(opts.labelFormatter).call(
                    this,
                    params,
                    toolUtil
                  ) : `${params.name}:${toolUtil.commafy(params.value, 2)}(${params.percent}%)`;
                }
              }
            },
            data: []
          }
        ]
      }, { data } = opts;
      if (data && data.length > 0) {
        if (!opts.rewriteOption) {
          optionPie.series[0].data = [];
          const H = [], C = [];
          data.forEach((G, U) => {
            let K = !1;
            U === 0 && (K = !0), H.push({
              value: G[opts.valueName],
              name: G[opts.keyName],
              selected: K,
              itemStyle: {
                normal: {
                  color: opts.colorList[U]
                }
              }
            }), C.push({ name: G[opts.keyName] });
          }), optionPie.legend.data = C, optionPie.series[0].data = H, optionPie.series[0].name = opts.name;
        }
      } else
        optionPie.series = [];
      toolUtil.extend(optionPie, opts.optionPie), pieChart.setOption(optionPie, !0);
    }
  }
}), _hoisted_1$6 = {
  ref: "domChart",
  style: { height: "100%", width: "100%" }
}, _hoisted_2$5 = { style: { display: "none" } };
function _sfc_render$7(H, C, G, U, K, W) {
  return openBlock(), createElementBlock("div", _hoisted_1$6, [
    createElementVNode("span", _hoisted_2$5, toDisplayString(H.option.type), 1)
  ], 512);
}
const PieChart = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["render", _sfc_render$7]]), maxPointImg = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGIAAAA8CAYAAACdIW+JAAAACXBIWXMAAAsTAAALEwEAmpwYAAA7WGlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS41LWMwMjEgNzkuMTU1NzcyLCAyMDE0LzAxLzEzLTE5OjQ0OjAwICAgICAgICAiPgogICA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPgogICAgICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgICAgICAgICB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIgogICAgICAgICAgICB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIKICAgICAgICAgICAgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIKICAgICAgICAgICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICAgICAgICAgICB4bWxuczpwaG90b3Nob3A9Imh0dHA6Ly9ucy5hZG9iZS5jb20vcGhvdG9zaG9wLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOnRpZmY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vdGlmZi8xLjAvIgogICAgICAgICAgICB4bWxuczpleGlmPSJodHRwOi8vbnMuYWRvYmUuY29tL2V4aWYvMS4wLyI+CiAgICAgICAgIDx4bXA6Q3JlYXRvclRvb2w+QWRvYmUgUGhvdG9zaG9wIENDIDIwMTQgKFdpbmRvd3MpPC94bXA6Q3JlYXRvclRvb2w+CiAgICAgICAgIDx4bXA6Q3JlYXRlRGF0ZT4yMDE2LTEwLTA4VDExOjMwOjA3KzA4OjAwPC94bXA6Q3JlYXRlRGF0ZT4KICAgICAgICAgPHhtcDpNb2RpZnlEYXRlPjIwMTYtMTAtMDhUMTE6NDQ6MDcrMDg6MDA8L3htcDpNb2RpZnlEYXRlPgogICAgICAgICA8eG1wOk1ldGFkYXRhRGF0ZT4yMDE2LTEwLTA4VDExOjQ0OjA3KzA4OjAwPC94bXA6TWV0YWRhdGFEYXRlPgogICAgICAgICA8eG1wTU06SW5zdGFuY2VJRD54bXAuaWlkOjQ2NWI3ZGVmLWI0NGUtMjQ0Mi04YzljLWQxNzVlZGI1ZjVjNzwveG1wTU06SW5zdGFuY2VJRD4KICAgICAgICAgPHhtcE1NOkRvY3VtZW50SUQ+eG1wLmRpZDo4MjlBNEZGQzhEMDcxMUU2QjM4MUZGOUU2MDA3QjQ3NzwveG1wTU06RG9jdW1lbnRJRD4KICAgICAgICAgPHhtcE1NOkRlcml2ZWRGcm9tIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgPHN0UmVmOmluc3RhbmNlSUQ+eG1wLmlpZDo4MjlBNEZGOThEMDcxMUU2QjM4MUZGOUU2MDA3QjQ3Nzwvc3RSZWY6aW5zdGFuY2VJRD4KICAgICAgICAgICAgPHN0UmVmOmRvY3VtZW50SUQ+eG1wLmRpZDo4MjlBNEZGQThEMDcxMUU2QjM4MUZGOUU2MDA3QjQ3Nzwvc3RSZWY6ZG9jdW1lbnRJRD4KICAgICAgICAgPC94bXBNTTpEZXJpdmVkRnJvbT4KICAgICAgICAgPHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjgyOUE0RkZDOEQwNzExRTZCMzgxRkY5RTYwMDdCNDc3PC94bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDx4bXBNTTpIaXN0b3J5PgogICAgICAgICAgICA8cmRmOlNlcT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+c2F2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0Omluc3RhbmNlSUQ+eG1wLmlpZDo1YjcyY2ZhOC01N2FlLWU0NDgtYjZkYi03MzU4NzBjNGQyOTc8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTYtMTAtMDhUMTE6Mzk6MTcrMDg6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDQyAyMDE0IChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmNoYW5nZWQ+Lzwvc3RFdnQ6Y2hhbmdlZD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPnNhdmVkPC9zdEV2dDphY3Rpb24+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDppbnN0YW5jZUlEPnhtcC5paWQ6NDY1YjdkZWYtYjQ0ZS0yNDQyLThjOWMtZDE3NWVkYjVmNWM3PC9zdEV2dDppbnN0YW5jZUlEPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6d2hlbj4yMDE2LTEwLTA4VDExOjQ0OjA3KzA4OjAwPC9zdEV2dDp3aGVuPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBQaG90b3Nob3AgQ0MgMjAxNCAoV2luZG93cyk8L3N0RXZ0OnNvZnR3YXJlQWdlbnQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpjaGFuZ2VkPi88L3N0RXZ0OmNoYW5nZWQ+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICA8L3JkZjpTZXE+CiAgICAgICAgIDwveG1wTU06SGlzdG9yeT4KICAgICAgICAgPGRjOmZvcm1hdD5pbWFnZS9wbmc8L2RjOmZvcm1hdD4KICAgICAgICAgPHBob3Rvc2hvcDpDb2xvck1vZGU+MzwvcGhvdG9zaG9wOkNvbG9yTW9kZT4KICAgICAgICAgPHRpZmY6T3JpZW50YXRpb24+MTwvdGlmZjpPcmllbnRhdGlvbj4KICAgICAgICAgPHRpZmY6WFJlc29sdXRpb24+NzIwMDAwLzEwMDAwPC90aWZmOlhSZXNvbHV0aW9uPgogICAgICAgICA8dGlmZjpZUmVzb2x1dGlvbj43MjAwMDAvMTAwMDA8L3RpZmY6WVJlc29sdXRpb24+CiAgICAgICAgIDx0aWZmOlJlc29sdXRpb25Vbml0PjI8L3RpZmY6UmVzb2x1dGlvblVuaXQ+CiAgICAgICAgIDxleGlmOkNvbG9yU3BhY2U+NjU1MzU8L2V4aWY6Q29sb3JTcGFjZT4KICAgICAgICAgPGV4aWY6UGl4ZWxYRGltZW5zaW9uPjk4PC9leGlmOlBpeGVsWERpbWVuc2lvbj4KICAgICAgICAgPGV4aWY6UGl4ZWxZRGltZW5zaW9uPjYwPC9leGlmOlBpeGVsWURpbWVuc2lvbj4KICAgICAgPC9yZGY6RGVzY3JpcHRpb24+CiAgIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgCjw/eHBhY2tldCBlbmQ9InciPz7QBjiVAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAEzSURBVHja7NuxTcNAHEbxd5ZFR0EG8QQsAJUHgBXooGMBWIGOHWCBrIMpjJTyKGJKBIEo9he917mxrP9P1t0VV2rfnQCPwBWwwg7ZO/AM3LbAA3DjTGbpbJr9ptS+e/NPmL2hEWERrRpnsIyEEMKEEMKEEMKEEMKEEMKEEMKEEMKEEMKEEMKEEMKEEMKEMCGEMCGEMCGEMCGEMCGOAWJwDLM3NGxvNdq8PbXAHVCAa7a3HO1wfV3vvS+175b6kafAC3C+p/etgUtgdLHerXEa3PrYERJ2TfvAWDxCyvb1PxgRCEnniL9gxCCkHeh2wYhCSDxZ/wYjDiER4ieMSIRUiO8wYhEA2uBT6QhcAK/TcyxCOgTAx4RRkhEASq0Vc40wIYQwIYQwIYQwIfL6BAAA//8DAI3OPfYMBUsuAAAAAElFTkSuQmCC", minPointImg = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGIAAAA8CAYAAACdIW+JAAAACXBIWXMAAAsTAAALEwEAmpwYAAA7WGlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS41LWMwMjEgNzkuMTU1NzcyLCAyMDE0LzAxLzEzLTE5OjQ0OjAwICAgICAgICAiPgogICA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPgogICAgICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgICAgICAgICB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIgogICAgICAgICAgICB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIKICAgICAgICAgICAgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIKICAgICAgICAgICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICAgICAgICAgICB4bWxuczpwaG90b3Nob3A9Imh0dHA6Ly9ucy5hZG9iZS5jb20vcGhvdG9zaG9wLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOnRpZmY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vdGlmZi8xLjAvIgogICAgICAgICAgICB4bWxuczpleGlmPSJodHRwOi8vbnMuYWRvYmUuY29tL2V4aWYvMS4wLyI+CiAgICAgICAgIDx4bXA6Q3JlYXRvclRvb2w+QWRvYmUgUGhvdG9zaG9wIENDIDIwMTQgKFdpbmRvd3MpPC94bXA6Q3JlYXRvclRvb2w+CiAgICAgICAgIDx4bXA6Q3JlYXRlRGF0ZT4yMDE2LTEwLTA4VDExOjMwOjA2KzA4OjAwPC94bXA6Q3JlYXRlRGF0ZT4KICAgICAgICAgPHhtcDpNb2RpZnlEYXRlPjIwMTYtMTAtMDhUMTE6NDQ6MDYrMDg6MDA8L3htcDpNb2RpZnlEYXRlPgogICAgICAgICA8eG1wOk1ldGFkYXRhRGF0ZT4yMDE2LTEwLTA4VDExOjQ0OjA2KzA4OjAwPC94bXA6TWV0YWRhdGFEYXRlPgogICAgICAgICA8eG1wTU06SW5zdGFuY2VJRD54bXAuaWlkOjM4M2Y1ZGFkLTFjYjgtZGQ0Yi05YTAwLWVlZjJkNjQzZGYwMjwveG1wTU06SW5zdGFuY2VJRD4KICAgICAgICAgPHhtcE1NOkRvY3VtZW50SUQ+eG1wLmRpZDo4MjFEQTQxOThEMDcxMUU2QkMzNkEzQTNDRTgxMURDRDwveG1wTU06RG9jdW1lbnRJRD4KICAgICAgICAgPHhtcE1NOkRlcml2ZWRGcm9tIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgPHN0UmVmOmluc3RhbmNlSUQ+eG1wLmlpZDo4MjFEQTQxNjhEMDcxMUU2QkMzNkEzQTNDRTgxMURDRDwvc3RSZWY6aW5zdGFuY2VJRD4KICAgICAgICAgICAgPHN0UmVmOmRvY3VtZW50SUQ+eG1wLmRpZDo4MjFEQTQxNzhEMDcxMUU2QkMzNkEzQTNDRTgxMURDRDwvc3RSZWY6ZG9jdW1lbnRJRD4KICAgICAgICAgPC94bXBNTTpEZXJpdmVkRnJvbT4KICAgICAgICAgPHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjgyMURBNDE5OEQwNzExRTZCQzM2QTNBM0NFODExRENEPC94bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDx4bXBNTTpIaXN0b3J5PgogICAgICAgICAgICA8cmRmOlNlcT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+c2F2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0Omluc3RhbmNlSUQ+eG1wLmlpZDozZDcwNGYzZS1jYWE0LTY5NDQtOTEwOS0xZWExMTIzODkyM2E8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTYtMTAtMDhUMTE6Mzk6MTkrMDg6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDQyAyMDE0IChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmNoYW5nZWQ+Lzwvc3RFdnQ6Y2hhbmdlZD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPnNhdmVkPC9zdEV2dDphY3Rpb24+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDppbnN0YW5jZUlEPnhtcC5paWQ6MzgzZjVkYWQtMWNiOC1kZDRiLTlhMDAtZWVmMmQ2NDNkZjAyPC9zdEV2dDppbnN0YW5jZUlEPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6d2hlbj4yMDE2LTEwLTA4VDExOjQ0OjA2KzA4OjAwPC9zdEV2dDp3aGVuPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBQaG90b3Nob3AgQ0MgMjAxNCAoV2luZG93cyk8L3N0RXZ0OnNvZnR3YXJlQWdlbnQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpjaGFuZ2VkPi88L3N0RXZ0OmNoYW5nZWQ+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICA8L3JkZjpTZXE+CiAgICAgICAgIDwveG1wTU06SGlzdG9yeT4KICAgICAgICAgPGRjOmZvcm1hdD5pbWFnZS9wbmc8L2RjOmZvcm1hdD4KICAgICAgICAgPHBob3Rvc2hvcDpDb2xvck1vZGU+MzwvcGhvdG9zaG9wOkNvbG9yTW9kZT4KICAgICAgICAgPHRpZmY6T3JpZW50YXRpb24+MTwvdGlmZjpPcmllbnRhdGlvbj4KICAgICAgICAgPHRpZmY6WFJlc29sdXRpb24+NzIwMDAwLzEwMDAwPC90aWZmOlhSZXNvbHV0aW9uPgogICAgICAgICA8dGlmZjpZUmVzb2x1dGlvbj43MjAwMDAvMTAwMDA8L3RpZmY6WVJlc29sdXRpb24+CiAgICAgICAgIDx0aWZmOlJlc29sdXRpb25Vbml0PjI8L3RpZmY6UmVzb2x1dGlvblVuaXQ+CiAgICAgICAgIDxleGlmOkNvbG9yU3BhY2U+NjU1MzU8L2V4aWY6Q29sb3JTcGFjZT4KICAgICAgICAgPGV4aWY6UGl4ZWxYRGltZW5zaW9uPjk4PC9leGlmOlBpeGVsWERpbWVuc2lvbj4KICAgICAgICAgPGV4aWY6UGl4ZWxZRGltZW5zaW9uPjYwPC9leGlmOlBpeGVsWURpbWVuc2lvbj4KICAgICAgPC9yZGY6RGVzY3JpcHRpb24+CiAgIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgCjw/eHBhY2tldCBlbmQ9InciPz6HcNDqAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAE0SURBVHja7NuxTcNAHEbxd5ZFhywyDwvADLACHXQsACvQMYIlWCBjeAVM4UiUpogpEQSi2F/0XufGsv4/WXdXXGm69gR4BK6AFXbI3oFn4LYGHoAbZzJLZ9PsP0rTtW/+CbPXVyIsolXlDJaREEKYEEKYEEKYEEKYEEKYEEKYEEKYEEKYEEKYEEKYEEKYECaEECaEECaEECaEECbEMUD0jmH2+ortrUabt6cauAMKcM32lqMdrq/rvfel6dqlfuQp8AKc7+l9a+ASGFysd2uYBrc+doSEXdM+MBaPkLJ9/Q9GBELSOeIvGDEIaQe6XTCiEBJP1r/BiENIhPgJIxIhFeI7jFgEgDr4VDoAF8Dr9ByLkA4BsJkwSjICQBnHEXONMCGEMCGEMCGEMCHy+gQAAP//AwDZWD5ZNODTpgAAAABJRU5ErkJggg==";
let barLineChart = null;
const _sfc_main$6 = defineComponent({
  name: "BarLineChart",
  props: {
    option: {
      type: Object,
      default: () => {
      }
    }
  },
  data() {
    return {
      flagClickEvent: !1,
      defaultOption: toolUtil.extend({}, defaultConfig.barLine.option)
    };
  },
  created() {
  },
  mounted() {
    this.option && (barLineChart = init$1(
      this.$refs.domChart,
      this.option.theme === "dark" ? dark : light
    ), this.setBarLineOption(this.option), window.addEventListener("resize", this.onWindowResize));
  },
  updated() {
    this.setBarLineOption(this.option), barLineChart.resize();
  },
  beforeUnmount() {
    barLineChart && (barLineChart.clear(), barLineChart.dispose()), window.removeEventListener("resize", this.onWindowResize);
  },
  methods: {
    onWindowResize() {
      barLineChart.resize();
    },
    setBarLineOption(option) {
      const opts = toolUtil.merge(this.defaultOption, option, !0), legendData = opts.barName.concat(opts.lineName), barLineOption = {
        tooltip: {
          trigger: "axis",
          formatter(params) {
            if (opts.toolTipFormatter)
              return eval(opts.toolTipFormatter).call(this, params, toolUtil);
            let res = params[0].name;
            for (let H = 0, C = params.length; H < C; H++)
              res += `<br/>${params[H].seriesName} : ${toolUtil.commafy(
                params[H].value
              )}`;
            return res;
          }
        },
        title: {
          x: "center",
          y: 5,
          /* textStyle: { */
          /* fontSize: 14, */
          /* color: '#fff' */
          /* }, */
          text: opts.title
        },
        legend: {
          show: opts.legendShow,
          left: opts.legendLeft,
          top: opts.legendTop,
          itemHeight: 10,
          itemWidth: 20,
          itemGap: 20,
          /* textStyle: { */
          /* color: '#fff', */
          /* fontFamily: 'SimHei,Arial, Verdana, sans-serif', */
          /* fontSize: 12 */
          /* }, */
          data: legendData
        },
        grid: {
          left: opts.gridLeft,
          right: opts.gridRight,
          top: opts.gridTop,
          bottom: opts.gridBottom
        },
        xAxis: [
          {
            show: !0,
            type: "category",
            data: [],
            axisLabel: {
              // color: opts.xAxisLabelColor,
              rotate: opts.xRotate,
              formatter(value, index) {
                return opts.xAxisFormatter ? eval(opts.xAxisFormatter).call(this, value, index) : toolUtil.formatCharts(value, 12);
              }
            }
          }
        ],
        yAxis: [
          {
            show: !0,
            type: "value",
            nameGap: 20,
            splitNumber: 4,
            name: opts.y1AxisName,
            alignTicks: !0,
            axisLabel: {
              interval: 0,
              // color: opts.y1AxisLabelColor,
              rotate: opts.y1Rotate,
              formatter(value, index) {
                return opts.y1AxisFormatter ? eval(opts.y1AxisFormatter).call(this, value, index) : toolUtil.commafy(value);
              }
            }
          },
          {
            show: opts.showY2Axis,
            type: "value",
            nameGap: 20,
            name: opts.y2AxisName,
            splitNumber: 4,
            alignTicks: !0,
            axisLabel: {
              show: !0,
              interval: 0,
              // color: opts.y2AxisLabelColor,
              rotate: opts.y2Rotate,
              formatter(value, index) {
                return opts.y2AxisFormatter ? eval(opts.y2AxisFormatter).call(this, value, index) : toolUtil.commafy(value);
              }
            }
          }
        ],
        series: [],
        seriesBar: {
          name: "",
          type: "bar",
          barGap: "0%",
          barCategoryGap: "70%",
          barMaxWidth: 30,
          itemStyle: {
            normal: {}
          },
          label: {
            normal: {
              show: !1,
              position: "right",
              formatter(v) {
                return opts.labelFormatter ? eval(opts.labelFormatter).call(this, v, toolUtil) : v;
              },
              textStyle: {
                fontSize: 12,
                color: "#fff"
              }
            }
          },
          data: []
        },
        seriesLine: {
          name: "",
          type: "line",
          symbolSize: 6,
          symbol: "circle",
          smooth: !0,
          itemStyle: {
            normal: {}
          },
          lineStyle: {
            normal: {}
          },
          yAxisIndex: 1,
          data: [],
          markPoint: opts.data && opts.data.length > 0 && !opts.hideMarkPoint ? {
            data: [
              {
                type: "max",
                name: "最大值",
                symbol: `image://${maxPointImg}`,
                symbolSize: [80, 45],
                symbolOffset: [0, -18],
                label: {
                  normal: {
                    offset: [0, -8],
                    textStyle: {
                      // color: '#fff',
                    },
                    formatter(a) {
                      return opts.markPointFormatter ? eval(opts.markPointFormatter).call(
                        this,
                        a.value,
                        toolUtil
                      ) : toolUtil.commafy(a.value);
                    }
                  },
                  emphasis: {
                    offset: [0, -8],
                    textStyle: {
                      // color: '#fff',
                    },
                    formatter(a) {
                      return opts.markPointFormatter ? eval(opts.markPointFormatter).call(
                        this,
                        a.value,
                        toolUtil
                      ) : toolUtil.commafy(a.value);
                    }
                  }
                }
              },
              {
                type: "min",
                name: "最小值",
                symbol: `image://${minPointImg}`,
                symbolSize: [80, 45],
                symbolOffset: [0, -18],
                label: {
                  show: !0,
                  normal: {
                    offset: [0, -8],
                    textStyle: {
                      // color: '#fff',
                      fontSize: 12
                    },
                    formatter(a) {
                      return opts.markPointFormatter ? eval(opts.markPointFormatter).call(
                        this,
                        a.value,
                        toolUtil
                      ) : toolUtil.commafy(a.value);
                    }
                  },
                  emphasis: {
                    offset: [0, -8],
                    textStyle: {
                      // color: '#fff',
                    },
                    formatter(a) {
                      return opts.markPointFormatter ? eval(opts.markPointFormatter).call(
                        this,
                        a.value,
                        toolUtil
                      ) : toolUtil.commafy(a.value);
                    }
                  }
                }
              }
            ]
          } : {}
        }
      };
      opts.optionBarLine.seriesBar && toolUtil.extend(barLineOption.seriesBar, opts.optionBarLine.seriesBar), opts.optionBarLine.seriesLine && toolUtil.extend(
        barLineOption.seriesLine,
        opts.optionBarLine.seriesLine
      );
      const { data } = opts;
      if (data && data.length > 0) {
        barLineOption.xAxis[0].data = [];
        const { keyName: H } = opts, C = opts.lineValueName, G = opts.barValueName;
        if (G.length > 1 ? G.forEach((U, K) => {
          barLineOption.series[K] = toolUtil.extend(
            {},
            barLineOption.seriesBar
          ), barLineOption.series[K].name = opts.barName[K], opts.overlap && (barLineOption.series[K].stack = "总量"), opts.barSeriesLabel && (barLineOption.series[K].label = opts.barSeriesLabel);
        }) : (barLineOption.series[0] = toolUtil.extend(
          {},
          barLineOption.seriesBar
        ), barLineOption.series[0].name = opts.barName[0], opts.overlap && (barLineOption.series[0].stack = "总量"), opts.barSeriesLabel && (barLineOption.series[0].label = opts.barSeriesLabel)), C.length > 1)
          C.forEach((U, K) => {
            let W = K;
            G.length > 1 ? W = K + G.length : W++, barLineOption.series[W] = toolUtil.extend(
              {},
              barLineOption.seriesLine
            ), barLineOption.series[W].name = opts.lineName[K];
          });
        else {
          let U;
          G.length > 1 ? U = G.length : U = 1, barLineOption.series[U] = toolUtil.extend({}, barLineOption.seriesLine), barLineOption.series[U].name = opts.lineName[0];
        }
        if (opts.barName.length >= 1 && opts.barName.forEach((U, K) => {
          barLineOption.series[K].itemStyle.normal.color = opts.barColor[K % opts.barColor.length];
        }), opts.lineName.length >= 1 && opts.lineName.forEach((U, K) => {
          barLineOption.series[opts.barName.length + K].itemStyle.normal.color = opts.lineColor[K % opts.lineColor.length];
        }), data.forEach((U) => {
          const K = U[H];
          G.length > 1 ? G.forEach((W, Z) => {
            barLineOption.series[Z].data.push(U[G[Z]]);
          }) : barLineOption.series[0].data.push(U[G[0]]), C.length > 1 ? G.length > 1 ? C.forEach((W, Z) => {
            barLineOption.series[G.length + Z].data.push(
              U[C[Z]]
            );
          }) : C.forEach((W, Z) => {
            barLineOption.series[Z + 1].data.push(
              U[C[Z]]
            );
          }) : G.length > 1 ? barLineOption.series[G.length].data.push(U[C[0]]) : barLineOption.series[1].data.push(U[C[0]]), barLineOption.xAxis[0].data.push(K);
        }), opts.splitYAxis) {
          let U, K, W, Z;
          barLineOption.series.forEach((ee, te) => {
            ee.data.forEach((re) => {
              te < G.length ? (U = U === void 0 || U > re ? re : U, W = W === void 0 || W < re ? re : W) : (K = K === void 0 || K > re ? re : K, Z = Z === void 0 || Z < re ? re : Z);
            });
          }), barLineOption.yAxis[0].min = U, barLineOption.yAxis[0].max = W;
          const X = (W - U) / 5;
          barLineOption.yAxis[0].interval = X, barLineOption.yAxis[1].min = K, barLineOption.yAxis[1].max = Z;
          const Q = (Z - K) / 5;
          barLineOption.yAxis[1].interval = Q;
        }
        opts.showYAxisName || (barLineOption.yAxis[0].name = "", barLineOption.yAxis[1].name = "");
      } else
        barLineOption.xAxis[0].show = !1, barLineOption.yAxis[0].show = !1, barLineOption.yAxis[1].show = !1, barLineOption.series = [];
      !this.flagClickEvent && opts.clickEvent && (this.flagClickEvent = !0, barLineChart.on("click", opts.clickEvent)), toolUtil.extend(barLineOption, opts.optionBarLine), barLineChart.setOption(barLineOption, !0);
    }
  }
}), _hoisted_1$5 = {
  ref: "domChart",
  style: { height: "100%", width: "100%" }
}, _hoisted_2$4 = { style: { display: "none" } };
function _sfc_render$6(H, C, G, U, K, W) {
  return openBlock(), createElementBlock("div", _hoisted_1$5, [
    createElementVNode("span", _hoisted_2$4, toDisplayString(H.option.type), 1)
  ], 512);
}
const BarLineChart = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["render", _sfc_render$6]]);
let lineChart = null;
const _sfc_main$5 = defineComponent({
  name: "LineChart",
  props: {
    option: {
      type: Object,
      default: () => {
      }
    }
  },
  data() {
    return {
      flagClickEvent: !1,
      defaultOption: toolUtil.extend({}, defaultConfig.line.option)
    };
  },
  created() {
  },
  mounted() {
    this.option && (lineChart = init$1(
      this.$refs.domChart,
      this.option.theme === "dark" ? dark : light
    ), this.setLineOption(this.option), window.addEventListener("resize", this.onWindowResize));
  },
  updated() {
    this.setLineOption(this.option), lineChart.resize();
  },
  beforeUnmount() {
    lineChart && (lineChart.clear(), lineChart.dispose()), window.removeEventListener("resize", this.onWindowResize);
  },
  methods: {
    onWindowResize() {
      lineChart.resize();
    },
    setLineOption(option) {
      const opts = toolUtil.extend({}, this.defaultOption, option), optionLine = {
        tooltip: {
          show: !0,
          trigger: "axis",
          formatter(H, C, G) {
            if (opts.toolTipFormatter)
              return opts.toolTipFormatter.call(this, H, C, G);
            if (opts.lastDotted) {
              let K = "", W = 0;
              return H[0].value !== "_" ? W = H[0].value : W = H[1].value, K = `${H[0].axisValue}</br>${H[0].seriesName}:${toolUtil.commafy(W)}`, K;
            }
            let U = H[0].name;
            for (let K = 0, W = H.length; K < W; K++)
              U += `<br/>${H[K].seriesName} : ${toolUtil.commafy(
                H[K].value
              )}`;
            return U;
          }
        },
        title: {
          text: opts.title,
          left: "center",
          /*  textStyle: {
                         fontSize: '14',
                         color: 'white'
                         }, */
          top: 5
        },
        grid: {
          left: opts.gridLeft,
          right: opts.gridRight,
          top: opts.gridTop,
          bottom: opts.gridBottom
        },
        legend: {
          show: !1,
          x: "right",
          y: "center",
          orient: "vertical",
          itemHeight: 8,
          padding: 20,
          itemGap: 20,
          formatter(H) {
            return opts.legendFormatter ? opts.legendFormatter.call(this, H) : toolUtil.formatCharts(H, 22);
          },
          /* textStyle: {
                         color: '#fff',
                         fontFamily: 'SimHei,Arial, Verdana, sans-serif',
                         fontSize: 12
                         }, */
          data: []
        },
        xAxis: [
          {
            show: !0,
            type: "category",
            boundaryGap: !1,
            data: [],
            axisLabel: {
              // color: opts.xAxisLabelColor,
              rotate: opts.xRotate,
              formatter(value) {
                if (opts.xAxisFormatter) {
                  const xAxisFormatter = eval(opts.xAxisFormatter), tp = xAxisFormatter.call(this, value);
                  return tp;
                }
                return value;
              }
            }
          }
        ],
        yAxis: [
          {
            show: !0,
            type: "value",
            name: opts.yAxisName,
            axisLabel: {
              interval: 0,
              // color: opts.yAxisLabelColor,
              rotate: opts.yRotate,
              formatter(H) {
                return opts.yAxisFormatter ? opts.yAxisFormatter.call(this, H) : toolUtil.commafy(H);
              }
            },
            nameTextStyle: {
              // color: opts.nameTextColor,
              fontSize: 12
            }
          }
        ],
        series: [
          {
            name: opts.name,
            // symbol: '/images/em-c122.png',
            symbol: "emptyCircle",
            symbolSize: opts.symbolSize,
            type: "line",
            lineStyle: opts.isAreaStyle ? { opacity: 1, color: opts.color } : {
              color: opts.color
            },
            itemStyle: {
              color: opts.color
            },
            areaStyle: opts.isAreaStyle ? {
              normal: {
                color: {
                  type: "linear",
                  x: 0,
                  y: 0,
                  x2: 0,
                  y2: 1,
                  colorStops: opts.colorStops,
                  globalCoord: !1
                  // 缺省为 false
                }
              }
            } : null,
            data: []
          }
        ]
      };
      let { data } = opts;
      if (data && data.length > 0) {
        if (optionLine.xAxis[0].data = [], optionLine.series[0].data = [], opts.lastDotted) {
          const H = toolUtil.extend({}, optionLine.series[0]);
          H.lineStyle = {
            normal: {
              width: 3,
              color: opts.colorList ? opts.colorList[0] : "#27a9f4",
              type: "dotted"
            }
          }, optionLine.series.push(H);
        }
        opts.resetOrder && (data = data.sort((H, C) => H[opts.keyName] - C[opts.keyName])), data.forEach((H, C) => {
          const G = H[opts.keyName], U = H[opts.valueName];
          optionLine.xAxis[0].data.push(G), opts.lastDotted ? (C > data.length - 3 ? optionLine.series[1].data.push(U) : optionLine.series[1].data.push("_"), C < data.length - 1 ? optionLine.series[0].data.push(U) : optionLine.series[0].data.push("_")) : optionLine.series[0].data.push(U);
        });
      } else
        optionLine.xAxis[0].show = !1, optionLine.yAxis[0].show = !1, optionLine.series = [];
      toolUtil.extend(optionLine, opts.optionLine), lineChart.setOption(optionLine, !0);
    }
  }
}), _hoisted_1$4 = {
  ref: "domChart",
  style: { height: "100%", width: "100%" }
}, _hoisted_2$3 = { style: { display: "none" } };
function _sfc_render$5(H, C, G, U, K, W) {
  return openBlock(), createElementBlock("div", _hoisted_1$4, [
    createElementVNode("span", _hoisted_2$3, toDisplayString(H.option.type), 1)
  ], 512);
}
const LineChart = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["render", _sfc_render$5]]);
let linesChart = null;
const _sfc_main$4 = defineComponent({
  name: "LinesChart",
  props: {
    option: {
      type: Object,
      default: () => {
      }
    }
  },
  data() {
    return {
      flagClickEvent: !1,
      defaultOption: toolUtil.extend({}, defaultConfig.lines.option)
    };
  },
  created() {
  },
  mounted() {
    this.option && (linesChart = init$1(
      this.$refs.domChart,
      this.option.theme === "dark" ? dark : light
    ), this.setLinesOption(this.option), window.addEventListener("resize", this.onWindowResize));
  },
  updated() {
    this.setLinesOption(this.option), linesChart.resize();
  },
  beforeUnmount() {
    linesChart && (linesChart.clear(), linesChart.dispose()), window.removeEventListener("resize", this.onWindowResize);
  },
  methods: {
    onWindowResize() {
      linesChart.resize();
    },
    setLinesOption(option) {
      const opts = toolUtil.merge(this.defaultOption, option, !0), optionLines = {
        tooltip: {
          trigger: "axis",
          formatter(params, ticket, callback) {
            if (opts.toolTipFormatter)
              return eval(opts.toolTipFormatter).call(
                this,
                params,
                ticket,
                callback
              );
            if (opts.lastDotted) {
              const H = params[0].axisValue;
              return params = params.filter((C) => C.value !== "_"), params = params.sort((C, G) => G.value - C.value), H;
            }
            params = params.sort((H, C) => C.value - H.value);
            let res = params[0].name;
            for (let H = 0, C = params.length; H < C; H++)
              res += `<br/>${params[H].seriesName} : ${toolUtil.commafy(
                params[H].value
              )}`;
            return res;
          }
        },
        title: {
          text: opts.title,
          left: "center",
          /* textStyle: {
                         fontSize: "14",
                         color: "white"
                         }, */
          top: 5
        },
        grid: {
          left: opts.gridLeft,
          right: opts.gridRight,
          top: opts.gridTop,
          bottom: opts.gridBottom
        },
        legend: {
          show: opts.legendShow,
          left: opts.legendLeft,
          top: opts.legendTop,
          orient: opts.orient,
          selected: {},
          itemHeight: 8,
          padding: 10,
          itemGap: 10,
          formatter(params) {
            return opts.legendFormatter ? eval(opts.legendFormatter).call(this, params) : toolUtil.formatCharts(params, 22);
          },
          // pageIconInactiveColor: '#2f4554',
          // pageIconColor: '#aaa',
          pageTextStyle: {
            // color: '#aaa',
          },
          /* textStyle: {
                         color: "#666666",
                         fontFamily: "SimHei,Arial, Verdana, sans-serif",
                         fontSize: 12
                         }, */
          data: []
        },
        xAxis: [
          {
            show: !0,
            type: "category",
            boundaryGap: !1,
            data: [],
            axisLabel: {
              // color: opts.xAxisLabelColor,
              rotate: opts.xRotate,
              formatter(value) {
                return opts.xAxisFormatter ? eval(opts.xAxisFormatter).call(this, value) : `${value.substr(0, 4)}/${value.substr(4, 2)}`;
              }
            }
          }
        ],
        yAxis: [
          {
            show: !0,
            type: "value",
            name: opts.y1AxisName,
            axisLabel: {
              interval: 0,
              // color: opts.y1AxisLabelColor,
              rotate: opts.y1Rotate,
              formatter(value) {
                return opts.yAxisFormatter ? opts.yAxisFormatter(value) : opts.y1AxisFormatter ? eval(opts.y1AxisFormatter).call(this, value) : toolUtil.commafy(value);
              }
            }
            /* nameTextStyle: {
                             color: "#000",
                             fontSize: 12
                             } */
          },
          {
            type: "value",
            name: opts.y2AxisName,
            show: opts.enableDoubleYAxis,
            axisLabel: {
              show: !0,
              interval: 0,
              // color: opts.y2AxisLabelColor,
              rotate: opts.y2Rotate,
              formatter(value) {
                return opts.yAxisFormatter ? opts.yAxisFormatter(value) : opts.y2AxisFormatter ? eval(opts.y2AxisFormatter).call(this, value) : toolUtil.commafy(value);
              }
            },
            /* nameTextStyle: {
                             color: "#ffffff",
                             fontSize: 12
                             }, */
            axisLine: {
              show: opts.enableDoubleYAxis
            }
          }
        ],
        series: [],
        dataZoom: opts.showDataZoom ? toolUtil.extend(
          !0,
          [
            {
              type: "slider",
              show: !0,
              height: 6,
              bottom: 4,
              handleColor: "#2b85ff",
              dataBackgroundColor: "rgba(0,0,0,0)",
              backgroundColor: "#e5e5e5",
              fillerColor: "#2b85ff",
              handleIcon: "image:///images/datazoom-dot.png",
              handleSize: "200%",
              textStyle: {
                color: "#2b85ff"
              },
              start: opts.dataZoomStart || 50,
              end: opts.dataZoomEnd || 100
            }
          ],
          opts.showDataZoom
        ) : [{ type: "slider", show: !1 }]
      };
      opts.enableDoubleYAxis;
      const keyNameMap = {};
      opts.keys.forEach((H, C) => {
        keyNameMap[H] = opts.names[C];
      });
      const tempData = opts.data, seriesData = [], legendData = [], legendSelected = {};
      let xAxisData = [];
      const xAxisSet = /* @__PURE__ */ new Set(), y1Keys = new Set(opts.y1Keys || []), y2Keys = new Set(opts.y2Keys || []), value = {}, data = [];
      if (tempData && tempData.length > 0) {
        for (const H in keyNameMap)
          value[H] = [], tempData.forEach((C) => {
            xAxisSet.add(C[opts.keyName] || C.key), value[H].push(C[H]);
          });
        xAxisData = Array.from(xAxisSet);
        for (const H in value)
          data.push({
            name: keyNameMap[H],
            key: xAxisData,
            value: value[H],
            yName: y1Keys.has(H) ? opts.y1AxisName : y2Keys.has(H) ? opts.y2AxisName : ""
          });
      }
      if (data && data.length > 0) {
        if (opts.resetOrder && (xAxisData = xAxisData.sort()), data.forEach((H, C) => {
          const G = {
            type: "line",
            symbol: "emptyCircle",
            smooth: "true",
            data: [],
            name: H.name,
            yName: H.yName
            // fix bug by rjh:多折线双Y轴，optionLines.doubleYAxis里面的name（用于显示在y轴上面的文字）与data里面name不一致的情况时无法显示双Y轴
          };
          opts.isAreaStyle ? G.itemStyle = {
            normal: {
              color: opts.colorList[C],
              areaStyle: {
                type: "default"
              }
            }
          } : G.itemStyle = {
            normal: {
              color: opts.colorList[C]
            }
          };
          let U = [];
          if (xAxisData.toString() !== H.key.toString()) {
            U.length = xAxisData.length;
            const { value: K } = H;
            H.key.forEach((W, Z) => {
              for (const X in xAxisData)
                xAxisData[X] === W.toString() ? U[X] = K[Z] : U[X] || (U[X] = 0);
            });
          } else
            U = H.value;
          if (opts.enableDoubleYAxis && optionLines.yAxis.forEach((K, W) => K.name === G.name || K.name === G.yName ? (G.yAxisIndex = W, !1) : !0), opts.lastDotted) {
            const K = toolUtil.extend({}, G);
            K.lineStyle = {
              normal: {
                width: 2,
                color: opts.colorList[C],
                type: "dotted"
              }
            }, U.forEach((W, Z) => {
              const X = W.toString();
              Z > U.length - 3 ? K.data.push(X) : K.data.push("_"), Z < U.length - 1 ? G.data.push(X) : G.data.push("_");
            }), seriesData.push(K);
          } else
            G.data = U;
          seriesData.push(G), legendData.push({ name: G.name, icon: "circle" }), legendSelected[G.name] = !1;
        }), seriesData.length > 0 && seriesData[0].data.length <= 1 ? (optionLines.xAxis[0].boundaryGap = !0, seriesData.forEach((H) => {
          H.symbolSize = 2;
        })) : optionLines.xAxis[0].boundaryGap = !1, optionLines.legend.data = legendData, data.length > 0 && (optionLines.xAxis[0].data = xAxisData), optionLines.series = seriesData, opts.defaultLegend instanceof Array && opts.defaultLegend.length > 0)
          opts.defaultLegend.forEach((H) => {
            legendSelected[H] = !0;
          });
        else
          for (const H in legendSelected)
            legendSelected[H] = !0;
        optionLines.legend.selected = legendSelected;
      } else
        optionLines.xAxis[0].show = !1, optionLines.yAxis[0].show = !1, optionLines.dataZoom[0].show = !1, optionLines.series = [];
      !this.flagClickEvent && opts.clickEvent && (this.flagClickEvent = !0, linesChart.on("click", opts.clickEvent)), toolUtil.extend(optionLines, opts.optionLines), linesChart.setOption(optionLines, !0);
    }
  }
}), _hoisted_1$3 = {
  ref: "domChart",
  style: { height: "100%", width: "100%" }
}, _hoisted_2$2 = { style: { display: "none" } };
function _sfc_render$4(H, C, G, U, K, W) {
  return openBlock(), createElementBlock("div", _hoisted_1$3, [
    createElementVNode("span", _hoisted_2$2, toDisplayString(H.option.type), 1)
  ], 512);
}
const LinesChart = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["render", _sfc_render$4]]);
let radarChart = null;
const _sfc_main$3 = defineComponent({
  name: "RadarChart",
  props: {
    option: {
      type: Object,
      default: () => {
      }
    }
  },
  data() {
    return {
      flagClickEvent: !1,
      defaultOption: toolUtil.extend({}, defaultConfig.radar.option)
    };
  },
  mounted() {
    this.option && (radarChart = init$1(
      this.$refs.domChart,
      this.option.theme === "dark" ? dark : light
    ), this.setRadarOption(this.option), window.addEventListener("resize", this.onWindowResize));
  },
  updated() {
    this.setRadarOption(this.option), radarChart.resize();
  },
  beforeUnmount() {
    radarChart && (radarChart.clear(), radarChart.dispose()), window.removeEventListener("resize", this.onWindowResize);
  },
  methods: {
    onWindowResize() {
      radarChart.resize();
    },
    setRadarOption(option) {
      const opts = toolUtil.merge(this.defaultOption, option, !0), optionRadar = {
        tooltip: {
          trigger: "item",
          confine: !0,
          formatter(params) {
            if (opts.toolTipFormatter)
              return eval(opts.toolTipFormatter).call(this, params);
            let res = `${params.name}<br>`;
            for (let H = 0; H < opts.dimensionName.length; H++)
              res += `${opts.dimensionName[H]} : ${params.value[H]}<br>`;
            return res;
          }
        },
        title: {
          left: "center",
          top: 0,
          textStyle: {
            fontSize: 14,
            color: "#fff",
            width: 20
          },
          text: opts.title
        },
        legend: {
          show: opts.legendShow,
          left: opts.legendLeft,
          top: opts.legendTop,
          orient: opts.orient,
          align: opts.legendAlign,
          itemHeight: 10,
          itemWidth: 20,
          itemGap: 20,
          /* textStyle: {
                            color: '#fff',
                            fontFamily: 'SimHei,Arial, Verdana, sans-serif',
                            fontSize: 12
                            }, */
          data: opts.name,
          formatter(params) {
            return opts.legendFormatter ? eval(opts.legendFormatter).call(this, params) : params;
          }
        },
        series: {
          type: "radar",
          data: [
            {
              value: [],
              name: ""
            }
          ]
        },
        color: ["#3D91F7", "#61BE67"],
        radar: {
          nameGap: 10,
          center: opts.center,
          shape: opts.shape,
          radius: opts.radius,
          // 图表区域大小
          name: {
            /* textStyle: {
                                color: '#fff',
                                fontSize: 12
                                } */
          },
          indicator: [],
          axisLine: {
            show: !0
          },
          splitArea: {
            show: opts.splitAreaShow,
            areaStyle: {
              // color: opts.splitAreaColor, // 图表背景网格的颜色
              opacity: 1
            }
          },
          splitLine: {
            show: opts.splitLineShow,
            lineStyle: {
              width: 0.8
              // color: opts.splitLineColor, // 图表背景网格线的颜色
            }
          }
        }
      }, { data } = opts;
      if (data && data.length > 0) {
        const { dimensionName: H } = opts, { dimensionKey: C } = opts;
        if (opts.name)
          for (let G = 0; G < opts.name.length; G++)
            optionRadar.series.data[G] = toolUtil.extend(
              {},
              optionRadar.series.data[0]
            ), optionRadar.series.data[G].name = opts.name[G];
        if (opts.data.forEach((G, U) => {
          for (let K = 0; K < C.length; K++)
            optionRadar.series.data[U].value.push(G[C[K]]), optionRadar.radar.indicator[K] = { name: H[K] }, opts.max && (opts.max instanceof Array ? optionRadar.radar.indicator[K].max = opts.max[K] : optionRadar.radar.indicator[K].max = opts.max), opts.min && (opts.min instanceof Array ? optionRadar.radar.indicator[K].min = opts.min[K] : optionRadar.radar.indicator[K].min = opts.min);
          opts.lineColor.forEach((K, W) => {
            optionRadar.color[W] = opts.lineColor[W];
          });
        }), opts.fillingStyle)
          for (let G = 0; G < opts.data.length; G++)
            optionRadar.series.data[G].areaStyle = {
              normal: {
                color: opts.fillingStyleColor[G % opts.fillingStyleColor.length]
              }
            };
      } else
        optionRadar.series = [], optionRadar.radar = Object();
      toolUtil.extend(optionRadar, opts.optionRadar), radarChart.setOption(optionRadar, !0);
    }
  }
}), _hoisted_1$2 = {
  ref: "domChart",
  style: { height: "100%", width: "100%" }
}, _hoisted_2$1 = { style: { display: "none" } };
function _sfc_render$3(H, C, G, U, K, W) {
  return openBlock(), createElementBlock("div", _hoisted_1$2, [
    createElementVNode("span", _hoisted_2$1, toDisplayString(H.option.type), 1)
  ], 512);
}
const RadarChart = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["render", _sfc_render$3]]), index$2 = "", _sfc_main$2 = defineComponent({
  name: "VueChart",
  components: {
    NoData,
    BarChart,
    BarLineChart,
    PieChart,
    LineChart,
    LinesChart,
    RadarChart
  },
  props: {
    type: {
      type: String,
      default: () => ""
    },
    option: {
      type: Object,
      default: () => {
      }
    }
  },
  mounted() {
  }
}), _hoisted_1$1 = { class: "vue-chart-wrapper" };
function _sfc_render$2(H, C, G, U, K, W) {
  const Z = resolveComponent("bar-chart"), X = resolveComponent("pie-chart"), Q = resolveComponent("bar-line-chart"), ee = resolveComponent("line-chart"), te = resolveComponent("lines-chart"), re = resolveComponent("radar-chart"), ne = resolveComponent("no-data");
  return openBlock(), createElementBlock("div", _hoisted_1$1, [
    H.type === "bar" ? (openBlock(), createBlock(Z, {
      key: 0,
      option: H.option
    }, null, 8, ["option"])) : H.type === "pie" ? (openBlock(), createBlock(X, {
      key: 1,
      option: H.option
    }, null, 8, ["option"])) : H.type === "barLine" ? (openBlock(), createBlock(Q, {
      key: 2,
      option: H.option
    }, null, 8, ["option"])) : H.type === "line" ? (openBlock(), createBlock(ee, {
      key: 3,
      option: H.option
    }, null, 8, ["option"])) : H.type === "lines" ? (openBlock(), createBlock(te, {
      key: 4,
      option: H.option
    }, null, 8, ["option"])) : H.type === "radar" ? (openBlock(), createBlock(re, {
      key: 5,
      option: H.option
    }, null, 8, ["option"])) : (openBlock(), createBlock(ne, { key: 6 }))
  ]);
}
const VueChart = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["render", _sfc_render$2]]), index$1 = "", _sfc_main$1 = defineComponent({
  name: "BaseTable",
  components: {
    ATable: Table
    // NoData,
  },
  props: {
    option: {
      type: Object,
      default: () => ({
        showHeader: !0,
        columns: [],
        dataSource: [],
        pagination: !1,
        scroll: {
          x: void 0,
          y: 100
        },
        showLineNo: !0,
        onChange: () => {
        },
        styleName: "striped",
        padding: 0
      })
    }
  },
  data() {
    return {};
  },
  computed: {
    defaultOptions() {
      var C;
      const H = {
        size: "middle",
        pagination: !1
      };
      return toolUtil.merge(H, this.option, !0), ((C = H.dataSource) == null ? void 0 : C.length) > 0 && H.dataSource.forEach((G, U) => {
        G.key = U;
      }), H;
    }
  }
});
function _sfc_render$1(H, C, G, U, K, W) {
  const Z = resolveComponent("a-table");
  return openBlock(), createBlock(Z, {
    class: normalizeClass(["baseTable", H.defaultOptions.styleName]),
    "show-header": H.defaultOptions.showHeader,
    columns: H.defaultOptions.columns,
    "data-source": H.defaultOptions.dataSource,
    pagination: H.defaultOptions.pagination,
    scroll: H.defaultOptions.scroll,
    "on-change": H.defaultOptions.onChange,
    style: normalizeStyle$1({ height: "100%", padding: H.defaultOptions.padding })
  }, null, 8, ["class", "show-header", "columns", "data-source", "pagination", "scroll", "on-change", "style"]);
}
const BaseTable = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", _sfc_render$1]]), index = "", _sfc_main = defineComponent({
  name: "TableChart",
  components: {
    ASpin: Spin,
    ExportOutlined: ExportOutlined$1,
    BarChartOutlined: BarChartOutlined$1,
    TableOutlined: TableOutlined$1,
    NoData,
    VueChart,
    BaseTable
  },
  props: {
    option: {
      type: Object,
      default: () => ({
        toolBar: !1,
        onTypeChange: () => {
        },
        height: 600,
        padding: 0,
        type: "",
        columns: [],
        data: void 0,
        tableHeight: void 0,
        showLineNo: !0,
        tableClassName: "",
        onTableChange: () => {
        },
        tableData: void 0,
        scrollX: void 0,
        loading: !1,
        theme: "light"
      })
    },
    loading: {
      type: Boolean,
      default: () => !1
    }
  },
  data() {
    return {
      showType: "chart",
      tableHeaderHeight: 50
    };
  },
  computed: {
    config() {
      const H = {
        displaySwitch: !0,
        export: !1,
        exportParams: {
          intfcType: "",
          intfcTypeName: "",
          fileName: "",
          url: ""
        }
      }, {
        toolBar: C
      } = this.option;
      let G = {}, U = [];
      return typeof C == "boolean" ? C ? G = H : G = {} : typeof C == "object" && (G = { ...H, ...C }), G.displaySwitch && (U = U.concat([
        {
          id: "chart"
          // Component: BarChartOutlined,
        },
        {
          id: "table"
          // Component: TableOutlined,
        }
      ])), G.export && (U = U.concat([
        {
          id: "export"
          // Component: ExportOutlined,
        }
      ])), [G, U.reverse()];
    },
    baseChartOption() {
      return toolUtil.extend({ height: 600, data: [], theme: "light" }, this.option);
    },
    baseTableOption() {
      const {
        height: H,
        columns: C,
        data: G,
        tableHeight: U,
        showLineNo: K,
        tableClassName: W,
        onTableChange: Z,
        tableData: X,
        scrollX: Q,
        padding: ee
      } = this.option;
      return {
        showHeader: !0,
        columns: C,
        dataSource: X || G || [],
        pagination: !1,
        scroll: {
          x: Q,
          y: U || H - this.tableHeaderHeight - 10
        },
        showLineNo: K,
        onChange: Z,
        styleName: W || "striped",
        padding: ee
      };
    }
  },
  mounted() {
  },
  methods: {
    /**
      * 切换统计图表显示类型事件
      * @param type String 切换后的显示类型；
      * @return null
      */
    onUIClick(H) {
      const {
        onTypeChange: C = () => {
        }
      } = this.option;
      if (H === "export") {
        if (this.config[0].onExport && typeof this.config[0].onExport == "function")
          this.config[0].onExport();
        else if (this.config[0].exportParams.url) {
          const { url: G, ...U } = this.config[0].exportParams;
          toolUtil.export(G, U);
        }
      } else
        this.showType = H;
      C && typeof C == "function" && C(H);
    }
  }
}), _hoisted_1 = { class: "table-chart-wrapper" }, _hoisted_2 = {
  key: 1,
  class: "table-chart-container"
}, _hoisted_3 = {
  key: 0,
  class: "table-chart-operator-wrapper"
}, _hoisted_4 = ["onClick"], _hoisted_5 = {
  ref: "tableRef",
  class: "table-chart-content-container"
};
function _sfc_render(H, C, G, U, K, W) {
  const Z = resolveComponent("no-data"), X = resolveComponent("bar-chart-outlined"), Q = resolveComponent("table-outlined"), ee = resolveComponent("export-outlined"), te = resolveComponent("vue-chart"), re = resolveComponent("base-table"), ne = resolveComponent("a-spin");
  return openBlock(), createBlock(ne, {
    spinning: H.option.loading || !1
  }, {
    default: withCtx(() => [
      createElementVNode("div", _hoisted_1, [
        H.baseChartOption.data && H.baseChartOption.data.length === 0 ? (openBlock(), createElementBlock("div", {
          key: 0,
          style: normalizeStyle$1({ position: "relative", height: `${H.baseChartOption.height}px` })
        }, [
          createVNode$1(Z, {
            data: H.baseChartOption.data
          }, null, 8, ["data"])
        ], 4)) : (openBlock(), createElementBlock("div", _hoisted_2, [
          H.config[1].length > 0 ? (openBlock(), createElementBlock("div", _hoisted_3, [
            (openBlock(!0), createElementBlock(Fragment, null, renderList(H.config[1], (ae) => (openBlock(), createElementBlock("span", {
              key: ae.id,
              class: normalizeClass(["table-chart-toolbar-icon-wrapper", { active: ae.id === H.showType }]),
              onClick: (ie) => H.onUIClick(ae.id)
            }, [
              ae.id === "chart" ? (openBlock(), createBlock(X, { key: 0 })) : createCommentVNode("", !0),
              ae.id === "table" ? (openBlock(), createBlock(Q, { key: 1 })) : createCommentVNode("", !0),
              ae.id === "export" ? (openBlock(), createBlock(ee, { key: 2 })) : createCommentVNode("", !0)
            ], 10, _hoisted_4))), 128))
          ])) : createCommentVNode("", !0),
          createElementVNode("div", _hoisted_5, [
            H.showType === "chart" || H.showType === "export" ? (openBlock(), createBlock(te, {
              key: 0,
              type: H.baseChartOption.type,
              option: { ...H.baseChartOption },
              style: normalizeStyle$1({ height: `${H.baseChartOption.height - 25}px` })
            }, null, 8, ["type", "option", "style"])) : H.showType === "table" ? (openBlock(), createBlock(re, {
              key: 1,
              option: H.baseTableOption
            }, null, 8, ["option"])) : createCommentVNode("", !0)
          ], 512)
        ]))
      ])
    ]),
    _: 1
  }, 8, ["spinning"]);
}
const TableChart = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]), TableChartPlugin = {
  install(H) {
    H.component("act-table-chart", TableChart);
  }
}, AntdvChartsTablePlugin = {
  install(H) {
    var C;
    (C = TableChartPlugin.install) == null || C.call(TableChartPlugin, H);
  }
};
export {
  TableChart,
  TableChartPlugin,
  AntdvChartsTablePlugin as default
};
